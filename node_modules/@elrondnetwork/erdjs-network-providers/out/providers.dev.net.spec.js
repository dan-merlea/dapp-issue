"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const transactionStatus_1 = require("./transactionStatus");
const primitives_1 = require("./primitives");
const dummyQuery_1 = require("./testscommon/dummyQuery");
const apiNetworkProvider_1 = require("./apiNetworkProvider");
const proxyNetworkProvider_1 = require("./proxyNetworkProvider");
describe("test network providers on devnet: Proxy and API", function () {
    let alice = new primitives_1.Address("erd1qyu5wthldzr8wx5c9ucg8kjagg0jfs53s8nr3zpz3hypefsdd8ssycr6th");
    let bob = new primitives_1.Address("erd1spyavw0956vq68xj8y4tenjpq2wd5a9p2c6j8gsz7ztyrnpxrruqzu66jx");
    let carol = new primitives_1.Address("erd1k2s324ww2g0yj38qn2ch2jwctdy8mnfxep94q9arncc6xecg3xaq6mjse8");
    let dan = new primitives_1.Address("erd1kyaqzaprcdnv4luvanah0gfxzzsnpaygsy6pytrexll2urtd05ts9vegu7");
    let apiProvider = new apiNetworkProvider_1.ApiNetworkProvider("https://devnet-api.elrond.com", { timeout: 10000 });
    let proxyProvider = new proxyNetworkProvider_1.ProxyNetworkProvider("https://devnet-gateway.elrond.com", { timeout: 10000 });
    it("should have same response for getNetworkConfig()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            let apiResponse = yield apiProvider.getNetworkConfig();
            let proxyResponse = yield proxyProvider.getNetworkConfig();
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
        });
    });
    it("should have same response for getNetworkStatus()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            let apiResponse = yield apiProvider.getNetworkStatus();
            let proxyResponse = yield proxyProvider.getNetworkStatus();
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
        });
    });
    // TODO: Enable test after implementing ProxyNetworkProvider.getNetworkStakeStatistics().
    it.skip("should have same response for getNetworkStakeStatistics()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            let apiResponse = yield apiProvider.getNetworkStakeStatistics();
            let proxyResponse = yield proxyProvider.getNetworkStakeStatistics();
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
        });
    });
    // TODO: Enable test after implementing ProxyNetworkProvider.getNetworkGeneralStatistics().
    it.skip("should have same response for getNetworkGeneralStatistics()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            let apiResponse = yield apiProvider.getNetworkGeneralStatistics();
            let proxyResponse = yield proxyProvider.getNetworkGeneralStatistics();
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
        });
    });
    it("should have same response for getAccount()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            for (const user of [bob, carol, dan]) {
                let apiResponse = yield apiProvider.getAccount(user);
                let proxyResponse = yield proxyProvider.getAccount(user);
                chai_1.assert.deepEqual(apiResponse, proxyResponse);
            }
        });
    });
    it("should have same response for getFungibleTokensOfAccount(), getFungibleTokenOfAccount()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(30000);
            for (const user of [carol, dan]) {
                let apiResponse = yield apiProvider.getFungibleTokensOfAccount(user);
                let proxyResponse = yield proxyProvider.getFungibleTokensOfAccount(user);
                chai_1.assert.deepEqual(apiResponse.slice(0, 100), proxyResponse.slice(0, 100));
                for (const item of apiResponse.slice(0, 5)) {
                    let apiResponse = yield apiProvider.getFungibleTokenOfAccount(user, item.identifier);
                    let proxyResponse = yield proxyProvider.getFungibleTokenOfAccount(user, item.identifier);
                    chai_1.assert.deepEqual(apiResponse, proxyResponse, `user: ${user.bech32()}, token: ${item.identifier}`);
                }
            }
        });
    });
    it("should have same response for getNonFungibleTokensOfAccount(), getNonFungibleTokenOfAccount", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(30000);
            for (const user of [alice, bob, carol, dan]) {
                let apiResponse = yield apiProvider.getNonFungibleTokensOfAccount(user);
                let proxyResponse = yield proxyProvider.getNonFungibleTokensOfAccount(user);
                for (const item of apiResponse) {
                    // Gateway does not provide "type".
                    item.type = "";
                }
                chai_1.assert.deepEqual(apiResponse.slice(0, 100), proxyResponse.slice(0, 100));
                for (const item of apiResponse.slice(0, 5)) {
                    let apiResponse = yield apiProvider.getNonFungibleTokenOfAccount(user, item.collection, item.nonce);
                    let proxyResponse = yield proxyProvider.getNonFungibleTokenOfAccount(user, item.collection, item.nonce);
                    // Gateway does not provide "type".
                    apiResponse.type = "";
                    chai_1.assert.deepEqual(apiResponse, proxyResponse, `user: ${user.bech32()}, token: ${item.identifier}`);
                }
            }
        });
    });
    it("should have same response for getTransaction()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(20000);
            let hashes = [
                "a069c663831002651fd542479869cc61103465f3284dace772e7480f81429fa8",
                "de3bc87f3e057e28ea6a625acd6d6d332e24f35ea73e820462b71256c8ecffb7",
                "dbefa0299fe6b2336eb0bc3123fa623845c276e5c6e2a175adf1a562d5e77718",
                "2a8ccbd91b7d9460a86174b5a8d4e6aa073b38674d1ee8107e728980a66f0676",
            ];
            for (const hash of hashes) {
                let apiResponse = yield apiProvider.getTransaction(hash);
                let proxyResponse = yield proxyProvider.getTransaction(hash);
                ignoreKnownTransactionDifferencesBetweenProviders(apiResponse, proxyResponse);
                chai_1.assert.deepEqual(apiResponse, proxyResponse, `transaction: ${hash}`);
                // Also assert completion
                chai_1.assert.isTrue(apiResponse.isCompleted);
                chai_1.assert.isTrue(proxyResponse.isCompleted);
            }
        });
    });
    // TODO: Strive to have as little differences as possible between Proxy and API.
    function ignoreKnownTransactionDifferencesBetweenProviders(apiResponse, proxyResponse) {
        // TODO: Remove this once "tx.status" is uniformized.
        apiResponse.status = proxyResponse.status = new transactionStatus_1.TransactionStatus("ignore");
        // Ignore fields which are not present on API response:
        proxyResponse.type = "";
        proxyResponse.epoch = 0;
        proxyResponse.blockNonce = 0;
        proxyResponse.hyperblockNonce = 0;
        proxyResponse.hyperblockHash = "";
    }
    // TODO: Fix differences of "tx.status", then enable this test.
    it.skip("should have same response for getTransactionStatus()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(20000);
            let hashes = [
                "a069c663831002651fd542479869cc61103465f3284dace772e7480f81429fa8",
                "de3bc87f3e057e28ea6a625acd6d6d332e24f35ea73e820462b71256c8ecffb7",
                "dbefa0299fe6b2336eb0bc3123fa623845c276e5c6e2a175adf1a562d5e77718",
                "2a8ccbd91b7d9460a86174b5a8d4e6aa073b38674d1ee8107e728980a66f0676",
                "be7914b1eb4c6bd352ba1d86991959b443e446e0ad49fb796be3495c287b2472"
            ];
            for (const hash of hashes) {
                let apiResponse = yield apiProvider.getTransactionStatus(hash);
                let proxyResponse = yield proxyProvider.getTransactionStatus(hash);
                chai_1.assert.deepEqual(apiResponse, proxyResponse, `transaction: ${hash}`);
            }
        });
    });
    it("should have same response for getDefinitionOfFungibleToken()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(10000);
            let identifiers = ["FOO-b6f543", "BAR-c80d29", "COUNTER-b7401d"];
            for (const identifier of identifiers) {
                let apiResponse = yield apiProvider.getDefinitionOfFungibleToken(identifier);
                let proxyResponse = yield proxyProvider.getDefinitionOfFungibleToken(identifier);
                chai_1.assert.equal(apiResponse.identifier, identifier);
                chai_1.assert.deepEqual(apiResponse, proxyResponse);
            }
        });
    });
    it("should have same response for getDefinitionOfTokenCollection()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(10000);
            let collections = ["ERDJS-38f249"];
            for (const collection of collections) {
                let apiResponse = yield apiProvider.getDefinitionOfTokenCollection(collection);
                let proxyResponse = yield proxyProvider.getDefinitionOfTokenCollection(collection);
                chai_1.assert.equal(apiResponse.collection, collection);
                chai_1.assert.deepEqual(apiResponse, proxyResponse);
            }
        });
    });
    it("should have same response for getNonFungibleToken()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(10000);
            let tokens = [{ id: "ERDJS-38f249", nonce: 1 }];
            for (const token of tokens) {
                let apiResponse = yield apiProvider.getNonFungibleToken(token.id, token.nonce);
                chai_1.assert.equal(apiResponse.collection, token.id);
                // TODO: Uncomment after implementing the function in the proxy provider.
                // let proxyResponse = await proxyProvider.getNonFungibleToken(token.id, token.nonce);
                // assert.deepEqual(apiResponse, proxyResponse);
            }
        });
    });
    it("should have same response for queryContract()", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(10000);
            // Query: get sum (of adder contract)
            let query = new dummyQuery_1.MockQuery({
                address: new primitives_1.Address("erd1qqqqqqqqqqqqqpgquykqja5c4v33zdmnwglj3jphqwrelzdn396qlc9g33"),
                func: "getSum"
            });
            let apiResponse = yield apiProvider.queryContract(query);
            let proxyResponse = yield proxyProvider.queryContract(query);
            // Ignore "gasUsed" due to numerical imprecision (API).
            apiResponse.gasUsed = 0;
            proxyResponse.gasUsed = 0;
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
            chai_1.assert.deepEqual(apiResponse.getReturnDataParts(), proxyResponse.getReturnDataParts());
            // Query: increment counter
            query = new dummyQuery_1.MockQuery({
                address: new primitives_1.Address("erd1qqqqqqqqqqqqqpgqzeq07xvhs5g7cg4ama85upaqarrcgu49396q0gz4yf"),
                func: "increment",
                args: []
            });
            apiResponse = yield apiProvider.queryContract(query);
            proxyResponse = yield proxyProvider.queryContract(query);
            // Ignore "gasUsed" due to numerical imprecision (API).
            apiResponse.gasUsed = 0;
            proxyResponse.gasUsed = 0;
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
            chai_1.assert.deepEqual(apiResponse.getReturnDataParts(), proxyResponse.getReturnDataParts());
        });
    });
    it.skip("should have same response for queryContract() (2)", function () {
        return __awaiter(this, void 0, void 0, function* () {
            this.timeout(10000);
            // Query: issue ESDT
            let query = new dummyQuery_1.MockQuery({
                address: new primitives_1.Address("erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u"),
                func: "issue",
                value: "50000000000000000",
                args: [
                    Buffer.from("HELLO").toString("hex"),
                    Buffer.from("WORLD").toString("hex"),
                    "0A",
                    "03" // Decimals
                ]
            });
            let apiResponse = yield apiProvider.queryContract(query);
            let proxyResponse = yield proxyProvider.queryContract(query);
            chai_1.assert.deepEqual(apiResponse, proxyResponse);
            chai_1.assert.deepEqual(apiResponse.getReturnDataParts(), proxyResponse.getReturnDataParts());
        });
    });
});
//# sourceMappingURL=providers.dev.net.spec.js.map