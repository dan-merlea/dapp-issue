"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;
const primitives_1 = require("./primitives");
const WellKnownCompletionEvents = ["completedTxEvent", "SCDeploy", "signalError"];
/**
 * Algorithm for detecting transaction completion.
 * Based on some heuristics (a bit imprecise therefore, at this moment).
 */
class TransactionCompletionStrategyOnProxy {
    isCompleted(transaction) {
        if (transaction.status.isPending()) {
            // Certainly not completed.
            return false;
        }
        // Handle gateway mechanics:
        for (const completionEvent of WellKnownCompletionEvents) {
            if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {
                // Certainly completed.
                console.debug("TransactionCompletionStrategy.isCompleted(), found event:", completionEvent);
                return true;
            }
        }
        if (this.isCertainlyMoveBalance(transaction.data)) {
            return transaction.status.isExecuted();
        }
        let hyperblockNonce = transaction.hyperblockNonce;
        // Imprecise condition, uncertain completion (usually sufficient, though).
        // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the "completedTxEvent" occurs).
        if (hyperblockNonce > 0) {
            console.debug("TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:", hyperblockNonce);
            return true;
        }
        return false;
    }
    isCertainlyMoveBalance(transactionData) {
        let parts = transactionData.toString().split("@");
        let prefix = parts[0];
        let otherParts = parts.slice(1);
        let emptyPrefix = !prefix;
        let somePartsAreNotValidArguments = !otherParts.every(part => this.looksLikeValidArgument(part));
        return emptyPrefix || somePartsAreNotValidArguments;
    }
    looksLikeValidArgument(arg) {
        return primitives_1.isPaddedHex(arg);
    }
}
exports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;
class TransactionCompletionStrategyOnAPI {
    isCompleted(transaction) {
        return !transaction.status.isPending();
    }
}
exports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;
//# sourceMappingURL=transactionCompletionStrategy.js.map