"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletConnectV2Provider = void 0;
const sign_client_1 = __importDefault(require("@walletconnect/sign-client"));
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("./constants");
const operation_1 = require("./operation");
const logger_1 = require("./logger");
const primitives_1 = require("./primitives");
const userAddress_1 = require("./userAddress");
class WalletConnectV2Provider {
    constructor(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId) {
        this.chainId = "";
        this.address = "";
        this.signature = "";
        this.isInitializing = false;
        this.events = [];
        this.methods = [];
        this.onClientConnect = onClientConnect;
        this.chainId = chainId;
        this.walletConnectV2Relay = walletConnectV2Relay;
        this.walletConnectV2ProjectId = walletConnectV2ProjectId;
    }
    /**
     * Initiates WalletConnect client.
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const client = yield sign_client_1.default.init({
                    relayUrl: this.walletConnectV2Relay,
                    projectId: this.walletConnectV2ProjectId,
                });
                this.walletConnector = client;
                yield this.subscribeToEvents(client);
                yield this.checkPersistedState(client);
            }
            catch (error) {
                throw new Error("connect: WalletConnect is unable to init");
            }
            finally {
                this.isInitializing = false;
            }
            return true;
        });
    }
    /**
     * Returns true if init() was previously called successfully
     */
    isInitialized() {
        return !!this.walletConnector;
    }
    /**
     * Returns true if provider is initialized and a valid session is set
     */
    isConnected() {
        return new Promise((resolve, _) => resolve(Boolean(this.isInitialized() && typeof this.session !== "undefined")));
    }
    connect(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                yield this.init();
            }
            if (typeof this.walletConnector === "undefined") {
                throw new Error("WalletConnect is not initialized");
            }
            const methods = [...Object.values(operation_1.Operation), ...((_a = options === null || options === void 0 ? void 0 : options.methods) !== null && _a !== void 0 ? _a : [])];
            const chains = [`${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`];
            const events = (_b = options === null || options === void 0 ? void 0 : options.events) !== null && _b !== void 0 ? _b : [];
            try {
                const response = yield this.walletConnector.connect({
                    pairingTopic: options === null || options === void 0 ? void 0 : options.topic,
                    requiredNamespaces: {
                        [constants_1.WALLETCONNECT_ELROND_NAMESPACE]: {
                            methods,
                            chains,
                            events,
                        },
                    },
                });
                this.events = events;
                this.methods = methods;
                return response;
            }
            catch (error) {
                if (options === null || options === void 0 ? void 0 : options.topic) {
                    yield this.logout({ topic: options.topic });
                    logger_1.Logger.error("connect: WalletConnect is unable to connect to existing pairing");
                    throw new Error("connect: WalletConnect is unable to connect to existing pairing");
                }
                else {
                    logger_1.Logger.error("connect: WalletConnect is unable to connect");
                    throw new Error("connect: WalletConnect is unable to connect");
                }
            }
        });
    }
    login(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isInitializing = true;
            if (typeof this.walletConnector === "undefined") {
                yield this.connect();
            }
            if (typeof this.walletConnector === "undefined") {
                throw new Error("WalletConnect is not initialized");
            }
            if (typeof this.session !== "undefined") {
                yield this.logout();
            }
            try {
                if (options && options.approval) {
                    const session = yield options.approval();
                    if (options.token) {
                        const address = this.getAddressFromSession(session);
                        const { signature } = yield this.walletConnector.request({
                            chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,
                            topic: session.topic,
                            request: {
                                method: operation_1.Operation.SIGN_LOGIN_TOKEN,
                                params: {
                                    token: options.token,
                                    address,
                                },
                            },
                        });
                        if (!signature) {
                            logger_1.Logger.error("login: WalletConnect could not sign login token");
                            throw new Error("WalletConnect could not sign login token");
                        }
                        return yield this.onSessionConnected({
                            session,
                            signature,
                        });
                    }
                    return yield this.onSessionConnected({
                        session,
                        signature: "",
                    });
                }
            }
            catch (error) {
                logger_1.Logger.error("login: WalletConnect is unable to login");
                throw new Error("login: WalletConnect is unable to login");
            }
            finally {
                this.isInitializing = false;
            }
            return "";
        });
    }
    /**
     * Mocks a logout request by returning true
     */
    logout(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("logout: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            try {
                const topic = (_a = options === null || options === void 0 ? void 0 : options.topic) !== null && _a !== void 0 ? _a : (_b = this.session) === null || _b === void 0 ? void 0 : _b.topic;
                if (topic) {
                    yield this.walletConnector.disconnect({
                        topic,
                        reason: utils_1.getSdkError("USER_DISCONNECTED"),
                    });
                    const newPairings = this.walletConnector.pairing
                        .getAll({ active: true })
                        .filter((pairing) => pairing.topic !== topic);
                    this.pairings = newPairings;
                }
            }
            catch (_c) {
                logger_1.Logger.error("logout: WalletConnect was unable to logout");
            }
            this.session = undefined;
            return true;
        });
    }
    /**
     * Fetches the WalletConnect address
     */
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("getAddress: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            return this.address;
        });
    }
    /**
     * Fetches the WalletConnect signature
     */
    getSignature() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("getSignature: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            return this.signature;
        });
    }
    /**
     * Fetches the WalletConnect pairings
     */
    getPairings() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("getPairings: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            return ((_a = this.pairings) !== null && _a !== void 0 ? _a : this.walletConnector.pairing.getAll({ active: true }));
        });
    }
    /**
     * Signs a message and returns it signed
     * @param message
     */
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("signMessage: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error("signMessage: Session is not connected");
                throw new Error("Session is not connected");
            }
            const address = yield this.getAddress();
            const { signature } = yield this.walletConnector.request({
                chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,
                topic: this.session.topic,
                request: {
                    method: operation_1.Operation.SIGN_MESSAGE,
                    params: {
                        address,
                        message: message.message.toString(),
                    },
                },
            });
            if (!signature) {
                logger_1.Logger.error("signMessage: WalletConnect could not sign the message");
                throw new Error("WalletConnect could not sign the message");
            }
            message.applySignature(new primitives_1.Signature(signature), userAddress_1.UserAddress.fromBech32(address));
            return message;
        });
    }
    /**
     * Signs a transaction and returns it signed
     * @param transaction
     */
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("signTransaction: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error("signTransaction: Session is not connected");
                throw new Error("Session is not connected");
            }
            const address = yield this.getAddress();
            const sender = new primitives_1.Address(address);
            const wcTransaction = transaction.toPlainObject(sender);
            if (this.chainId !== transaction.getChainID().valueOf()) {
                logger_1.Logger.error("signTransaction: Transaction Chain Id different than Connection Chain Id");
                throw new Error("Transaction Chain Id different than Connection Chain Id");
            }
            const { signature } = yield this.walletConnector.request({
                chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,
                topic: this.session.topic,
                request: {
                    method: operation_1.Operation.SIGN_TRANSACTION,
                    params: {
                        transaction: wcTransaction,
                    },
                },
            });
            if (!signature) {
                logger_1.Logger.error("signTransaction: WalletConnect could not sign the transaction");
                throw new Error("WalletConnect could not sign the transaction");
            }
            transaction.applySignature(primitives_1.Signature.fromHex(signature), userAddress_1.UserAddress.fromBech32(address));
            return transaction;
        });
    }
    /**
     * Signs an array of transactions and returns it signed
     * @param transactions
     */
    signTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("signTransactions: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error("signTransactions: Session is not connected");
                throw new Error("Session is not connected");
            }
            const address = yield this.getAddress();
            const sender = new primitives_1.Address(address);
            const wcTransactions = transactions.map((transaction) => {
                if (this.chainId !== transaction.getChainID().valueOf()) {
                    logger_1.Logger.error("signTransactions: Transaction Chain Id different than Connection Chain Id");
                    throw new Error("Transactions Chain Id different than Connection Chain Id");
                }
                return transaction.toPlainObject(sender);
            });
            const { signatures } = yield this.walletConnector.request({
                chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,
                topic: this.session.topic,
                request: {
                    method: operation_1.Operation.SIGN_TRANSACTIONS,
                    params: {
                        transactions: wcTransactions,
                    },
                },
            });
            if (!signatures || !Array.isArray(signatures)) {
                logger_1.Logger.error("signTransactions: WalletConnect could not sign the transactions");
                throw new Error("WalletConnect could not sign the transactions");
            }
            if (transactions.length !== signatures.length) {
                logger_1.Logger.error("signTransactions: WalletConnect could not sign the transactions. Invalid signatures.");
                throw new Error("WalletConnect could not sign the transactions. Invalid signatures.");
            }
            for (const [index, transaction] of transactions.entries()) {
                transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));
            }
            return transactions;
        });
    }
    /**
     * Sends a custom request
     * @param request
     */
    sendCustomRequest(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("sendCustomRequest: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error("sendCustomRequest: Session is not connected");
                throw new Error("Session is not connected");
            }
            if (options === null || options === void 0 ? void 0 : options.request) {
                const { response } = yield this.walletConnector.request({
                    chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,
                    topic: this.session.topic,
                    request: options.request,
                });
                if (!response) {
                    logger_1.Logger.error("sendCustomRequest: WalletConnect could not send the custom request");
                    throw new Error("WalletConnect could not send the custom request");
                }
                return response;
            }
        });
    }
    /**
     * Ping helper
     */
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                logger_1.Logger.error("ping: WalletConnect not initialised, call init() first");
                throw new Error("WalletConnect not initialised, call init() first");
            }
            if (typeof this.session === "undefined") {
                logger_1.Logger.error("ping: Session is not connected");
                throw new Error("Session is not connected");
            }
            try {
                yield this.walletConnector.ping({ topic: this.session.topic });
                return true;
            }
            catch (error) {
                logger_1.Logger.error("ping: Ping failed");
                return false;
            }
        });
    }
    loginAccount(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                return;
            }
            if (this.addressIsValid(options.address)) {
                this.address = options.address;
                if (options.signature) {
                    this.signature = options.signature;
                }
                this.onClientConnect.onClientLogin();
                return;
            }
            logger_1.Logger.error(`WalletConnect invalid address ${options.address}`);
            if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) && this.walletConnector) {
                yield this.walletConnector.disconnect({
                    topic: this.session.topic,
                    reason: utils_1.getSdkError("USER_DISCONNECTED"),
                });
                const newPairings = this.walletConnector.pairing.getAll({ active: true });
                this.pairings = newPairings;
            }
        });
    }
    onSessionConnected(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                return "";
            }
            this.session = options.session;
            const address = this.getAddressFromSession(options.session);
            if (address) {
                yield this.loginAccount({ address, signature: options.signature });
            }
            return "";
        });
    }
    handleTopicUpdateEvent({ topic, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                throw new Error("WalletConnect is not initialized");
            }
            this.pairings = this.walletConnector.pairing.getAll({ active: true });
            if (this.address &&
                !this.isInitializing &&
                (((_a = this === null || this === void 0 ? void 0 : this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic || this.pairings.length === 0)) {
                this.onClientConnect.onClientLogout();
            }
        });
    }
    handleSessionEvents({ topic, params, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.walletConnector === "undefined") {
                throw new Error("WalletConnect is not initialized");
            }
            const { event } = params;
            if ((event === null || event === void 0 ? void 0 : event.name) && ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {
                const eventData = event.data;
                this.onClientConnect.onClientEvent(eventData);
            }
        });
    }
    subscribeToEvents(client) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof client === "undefined") {
                throw new Error("WalletConnect is not initialized");
            }
            client.on("session_update", ({ topic, params }) => {
                const { namespaces } = params;
                const _session = client.session.get(topic);
                const updatedSession = Object.assign(Object.assign({}, _session), { namespaces });
                this.onSessionConnected({ session: updatedSession });
            });
            client.on("session_event", this.handleSessionEvents.bind(this));
            client.on("session_delete", this.handleTopicUpdateEvent.bind(this));
            client.on("session_expire", this.handleTopicUpdateEvent.bind(this));
        });
    }
    checkPersistedState(client) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof client === "undefined") {
                throw new Error("WalletConnect is not initialized");
            }
            this.pairings = client.pairing.getAll({ active: true });
            if (typeof this.session !== "undefined") {
                return;
            }
            // Populates existing session to state (assume only the top one)
            if (client.session.length && !this.address && !this.isInitializing) {
                const lastKeyIndex = client.session.keys.length - 1;
                const session = client.session.get(client.session.keys[lastKeyIndex]);
                yield this.onSessionConnected({ session });
                return session;
            }
            return;
        });
    }
    addressIsValid(destinationAddress) {
        try {
            const addr = userAddress_1.UserAddress.fromBech32(destinationAddress);
            return !!addr;
        }
        catch (_a) {
            return false;
        }
    }
    getAddressFromSession(session) {
        const selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_ELROND_NAMESPACE];
        if (selectedNamespace && selectedNamespace.accounts) {
            // Use only the first address in case of multiple provided addresses
            const currentSession = selectedNamespace.accounts[0];
            const [namespace, reference, address] = currentSession.split(":");
            return address;
        }
        return "";
    }
}
exports.WalletConnectV2Provider = WalletConnectV2Provider;
//# sourceMappingURL=walletConnectV2Provider.js.map