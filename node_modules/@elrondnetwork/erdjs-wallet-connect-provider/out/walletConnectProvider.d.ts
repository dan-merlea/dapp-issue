import WalletClient from "@walletconnect/client";
import { ISignableMessage, ITransaction } from "./interface";
interface IClientConnect {
    onClientLogin: () => void;
    onClientLogout(): void;
}
export declare class WalletConnectProvider {
    walletConnectBridge: string;
    address: string;
    signature: string;
    walletConnector: WalletClient | undefined;
    private onClientConnect;
    constructor(walletConnectBridge: string, onClientConnect: IClientConnect);
    /**
     * Initiates wallet connect client.
     */
    init(): Promise<boolean>;
    /**
     * Returns true if init() was previously called successfully
     */
    isInitialized(): boolean;
    /**
     * Returns true if provider is connected and a valid account is set
     */
    isConnected(): Promise<boolean>;
    login(): Promise<string>;
    /**
     * Mocks a logout request by returning true
     */
    logout(): Promise<boolean>;
    /**
     * Fetches the wallet connect address
     */
    getAddress(): Promise<string>;
    /**
     * Fetches the wallet connect signature
     */
    getSignature(): Promise<string>;
    /**
     * Method will be available once the Maiar wallet connect hook is implemented
     * @param _
     */
    signMessage<T extends ISignableMessage>(_: T): Promise<T>;
    /**
     * Signs a transaction and returns it
     * @param transaction
     */
    signTransaction<T extends ITransaction>(transaction: T): Promise<T>;
    /**
     * Signs an array of transactions and returns it
     * @param transactions
     */
    signTransactions<T extends ITransaction>(transactions: T[]): Promise<T[]>;
    /**
     * Sends a custom method and params and returns the response object
     */
    sendCustomMessage({ method, params, }: {
        method: string;
        params: any;
    }): Promise<any>;
    private onConnect;
    private onDisconnect;
    private loginAccount;
    private prepareWalletConnectMessage;
    private addressIsValid;
}
export {};
