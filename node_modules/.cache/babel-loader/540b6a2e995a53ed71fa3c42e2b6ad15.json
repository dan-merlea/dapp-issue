{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interaction = void 0;\nvar query_1 = require(\"./query\");\nvar function_1 = require(\"./function\");\nvar address_1 = require(\"../address\");\nvar typesystem_1 = require(\"./typesystem\");\nvar constants_1 = require(\"../constants\");\nvar interactionChecker_1 = require(\"./interactionChecker\");\n/**\n * Interactions can be seen as mutable transaction & query builders.\n *\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\n * the execution outcome for the objects they've built.\n */\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(contract, func, args) {\n    _classCallCheck(this, Interaction);\n    this.nonce = 0;\n    this.value = \"0\";\n    this.gasLimit = 0;\n    this.gasPrice = undefined;\n    this.chainID = \"\";\n    this.querent = new address_1.Address();\n    this.isWithSingleESDTTransfer = false;\n    this.isWithSingleESDTNFTTransfer = false;\n    this.isWithMultiESDTNFTTransfer = false;\n    this.tokenTransfersSender = new address_1.Address();\n    this.contract = contract;\n    this.function = func;\n    this.args = args;\n    this.tokenTransfers = new TokenTransfersWithinInteraction([], this);\n  }\n  _createClass(Interaction, [{\n    key: \"getContractAddress\",\n    value: function getContractAddress() {\n      return this.contract.getAddress();\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction() {\n      return this.function;\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint() {\n      return this.contract.getEndpoint(this.function);\n    }\n  }, {\n    key: \"getArguments\",\n    value: function getArguments() {\n      return this.args;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.value;\n    }\n  }, {\n    key: \"getTokenTransfers\",\n    value: function getTokenTransfers() {\n      return this.tokenTransfers.getTransfers();\n    }\n  }, {\n    key: \"getGasLimit\",\n    value: function getGasLimit() {\n      return this.gasLimit;\n    }\n  }, {\n    key: \"getExplicitReceiver\",\n    value: function getExplicitReceiver() {\n      return this.explicitReceiver;\n    }\n  }, {\n    key: \"buildTransaction\",\n    value: function buildTransaction() {\n      var receiver = this.explicitReceiver || this.contract.getAddress();\n      var func = this.function;\n      var args = this.args;\n      if (this.isWithSingleESDTTransfer) {\n        func = new function_1.ContractFunction(constants_1.ESDT_TRANSFER_FUNCTION_NAME);\n        args = this.tokenTransfers.buildArgsForSingleESDTTransfer();\n      } else if (this.isWithSingleESDTNFTTransfer) {\n        // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.\n        receiver = this.tokenTransfersSender;\n        func = new function_1.ContractFunction(constants_1.ESDTNFT_TRANSFER_FUNCTION_NAME);\n        args = this.tokenTransfers.buildArgsForSingleESDTNFTTransfer();\n      } else if (this.isWithMultiESDTNFTTransfer) {\n        // For NFT, SFT and MetaESDT, transaction.sender == transaction.receiver.\n        receiver = this.tokenTransfersSender;\n        func = new function_1.ContractFunction(constants_1.MULTI_ESDTNFT_TRANSFER_FUNCTION_NAME);\n        args = this.tokenTransfers.buildArgsForMultiESDTNFTTransfer();\n      }\n      var transaction = this.contract.call({\n        func: func,\n        // GasLimit will be set using \"withGasLimit()\".\n        gasLimit: this.gasLimit,\n        gasPrice: this.gasPrice,\n        args: args,\n        // Value will be set using \"withValue()\".\n        value: this.value,\n        receiver: receiver,\n        chainID: this.chainID\n      });\n      transaction.setNonce(this.nonce);\n      return transaction;\n    }\n  }, {\n    key: \"buildQuery\",\n    value: function buildQuery() {\n      return new query_1.Query({\n        address: this.contract.getAddress(),\n        func: this.function,\n        args: this.args,\n        // Value will be set using \"withValue()\".\n        value: this.value,\n        caller: this.querent\n      });\n    }\n  }, {\n    key: \"withValue\",\n    value: function withValue(value) {\n      this.value = value;\n      return this;\n    }\n  }, {\n    key: \"withSingleESDTTransfer\",\n    value: function withSingleESDTTransfer(transfer) {\n      this.isWithSingleESDTTransfer = true;\n      this.tokenTransfers = new TokenTransfersWithinInteraction([transfer], this);\n      return this;\n    }\n  }, {\n    key: \"withSingleESDTNFTTransfer\",\n    value: function withSingleESDTNFTTransfer(transfer, sender) {\n      this.isWithSingleESDTNFTTransfer = true;\n      this.tokenTransfers = new TokenTransfersWithinInteraction([transfer], this);\n      this.tokenTransfersSender = sender;\n      return this;\n    }\n  }, {\n    key: \"withMultiESDTNFTTransfer\",\n    value: function withMultiESDTNFTTransfer(transfers, sender) {\n      this.isWithMultiESDTNFTTransfer = true;\n      this.tokenTransfers = new TokenTransfersWithinInteraction(transfers, this);\n      this.tokenTransfersSender = sender;\n      return this;\n    }\n  }, {\n    key: \"withGasLimit\",\n    value: function withGasLimit(gasLimit) {\n      this.gasLimit = gasLimit;\n      return this;\n    }\n  }, {\n    key: \"withGasPrice\",\n    value: function withGasPrice(gasPrice) {\n      this.gasPrice = gasPrice;\n      return this;\n    }\n  }, {\n    key: \"withNonce\",\n    value: function withNonce(nonce) {\n      this.nonce = nonce;\n      return this;\n    }\n  }, {\n    key: \"useThenIncrementNonceOf\",\n    value: function useThenIncrementNonceOf(account) {\n      return this.withNonce(account.getNonceThenIncrement());\n    }\n  }, {\n    key: \"withChainID\",\n    value: function withChainID(chainID) {\n      this.chainID = chainID;\n      return this;\n    }\n    /**\n     * Sets the \"caller\" field on contract queries.\n     */\n  }, {\n    key: \"withQuerent\",\n    value: function withQuerent(querent) {\n      this.querent = querent;\n      return this;\n    }\n  }, {\n    key: \"withExplicitReceiver\",\n    value: function withExplicitReceiver(receiver) {\n      this.explicitReceiver = receiver;\n      return this;\n    }\n    /**\n     * To perform custom checking, extend {@link Interaction} and override this method.\n     */\n  }, {\n    key: \"check\",\n    value: function check() {\n      new interactionChecker_1.InteractionChecker().checkInteraction(this, this.getEndpoint());\n      return this;\n    }\n  }]);\n  return Interaction;\n}();\nexports.Interaction = Interaction;\nvar TokenTransfersWithinInteraction = /*#__PURE__*/function () {\n  function TokenTransfersWithinInteraction(transfers, interaction) {\n    _classCallCheck(this, TokenTransfersWithinInteraction);\n    this.transfers = transfers;\n    this.interaction = interaction;\n  }\n  _createClass(TokenTransfersWithinInteraction, [{\n    key: \"getTransfers\",\n    value: function getTransfers() {\n      return this.transfers;\n    }\n  }, {\n    key: \"buildArgsForSingleESDTTransfer\",\n    value: function buildArgsForSingleESDTTransfer() {\n      var singleTransfer = this.transfers[0];\n      return [this.getTypedTokenIdentifier(singleTransfer), this.getTypedTokenQuantity(singleTransfer), this.getTypedInteractionFunction()].concat(_toConsumableArray(this.getInteractionArguments()));\n    }\n  }, {\n    key: \"buildArgsForSingleESDTNFTTransfer\",\n    value: function buildArgsForSingleESDTNFTTransfer() {\n      var singleTransfer = this.transfers[0];\n      return [this.getTypedTokenIdentifier(singleTransfer), this.getTypedTokenNonce(singleTransfer), this.getTypedTokenQuantity(singleTransfer), this.getTypedTokensReceiver(), this.getTypedInteractionFunction()].concat(_toConsumableArray(this.getInteractionArguments()));\n    }\n  }, {\n    key: \"buildArgsForMultiESDTNFTTransfer\",\n    value: function buildArgsForMultiESDTNFTTransfer() {\n      var result = [];\n      result.push(this.getTypedTokensReceiver());\n      result.push(this.getTypedNumberOfTransfers());\n      var _iterator = _createForOfIteratorHelper(this.transfers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var transfer = _step.value;\n          result.push(this.getTypedTokenIdentifier(transfer));\n          result.push(this.getTypedTokenNonce(transfer));\n          result.push(this.getTypedTokenQuantity(transfer));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      result.push(this.getTypedInteractionFunction());\n      result.push.apply(result, _toConsumableArray(this.getInteractionArguments()));\n      return result;\n    }\n  }, {\n    key: \"getTypedNumberOfTransfers\",\n    value: function getTypedNumberOfTransfers() {\n      return new typesystem_1.U8Value(this.transfers.length);\n    }\n  }, {\n    key: \"getTypedTokenIdentifier\",\n    value: function getTypedTokenIdentifier(transfer) {\n      // Important: for NFTs, this has to be the \"collection\" name, actually.\n      // We will reconsider adding the field \"collection\" on \"Token\" upon merging \"ApiProvider\" and \"ProxyProvider\".\n      return typesystem_1.BytesValue.fromUTF8(transfer.tokenIdentifier);\n    }\n  }, {\n    key: \"getTypedTokenNonce\",\n    value: function getTypedTokenNonce(transfer) {\n      // The token nonce (creation nonce)\n      return new typesystem_1.U64Value(transfer.nonce);\n    }\n  }, {\n    key: \"getTypedTokenQuantity\",\n    value: function getTypedTokenQuantity(transfer) {\n      // For NFTs, this will be 1.\n      return new typesystem_1.BigUIntValue(transfer.amountAsBigInteger);\n    }\n  }, {\n    key: \"getTypedTokensReceiver\",\n    value: function getTypedTokensReceiver() {\n      // The actual receiver of the token(s): the contract\n      return new typesystem_1.AddressValue(this.interaction.getContractAddress());\n    }\n  }, {\n    key: \"getTypedInteractionFunction\",\n    value: function getTypedInteractionFunction() {\n      return typesystem_1.BytesValue.fromUTF8(this.interaction.getFunction().valueOf());\n    }\n  }, {\n    key: \"getInteractionArguments\",\n    value: function getInteractionArguments() {\n      return this.interaction.getArguments();\n    }\n  }]);\n  return TokenTransfersWithinInteraction;\n}();","map":null,"metadata":{},"sourceType":"script"}