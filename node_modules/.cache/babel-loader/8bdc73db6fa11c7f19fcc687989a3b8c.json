{"ast":null,"code":"import _toConsumableArray from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\nvar Resolver = /*#__PURE__*/function () {\n  function Resolver() {\n    _classCallCheck(this, Resolver);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  _createClass(Resolver, [{\n    key: \"prefer\",\n    value: function prefer() {\n      var _this = this;\n      for (var _len = arguments.length, preferOrders = new Array(_len), _key = 0; _key < _len; _key++) {\n        preferOrders[_key] = arguments[_key];\n      }\n      preferOrders.forEach(function (prefer) {\n        _this._preferredOrder.push(prefer);\n        if (!prefer.priority) {\n          prefer.priority = Object.keys(prefer.params);\n        }\n      });\n      this._resolverHash = {};\n    }\n  }, {\n    key: \"basePath\",\n    get: function get() {\n      return this._basePath;\n    },\n    set: function set(basePath) {\n      this._basePath = basePath;\n    }\n  }, {\n    key: \"rootPath\",\n    get: function get() {\n      return this._rootPath;\n    },\n    set: function set(rootPath) {\n      this._rootPath = rootPath;\n    }\n  }, {\n    key: \"parsers\",\n    get: function get() {\n      return this._parsers;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._preferredOrder = [];\n      this._resolverHash = {};\n      this._assetMap = {};\n      this._rootPath = null;\n      this._basePath = null;\n      this._manifest = null;\n    }\n  }, {\n    key: \"addManifest\",\n    value: function addManifest(manifest) {\n      var _this2 = this;\n      if (this._manifest) {}\n      this._manifest = manifest;\n      manifest.bundles.forEach(function (bundle) {\n        _this2.addBundle(bundle.name, bundle.assets);\n      });\n    }\n  }, {\n    key: \"addBundle\",\n    value: function addBundle(bundleId, assets) {\n      var _this3 = this;\n      var assetNames = [];\n      if (Array.isArray(assets)) {\n        assets.forEach(function (asset) {\n          if (typeof asset.name === \"string\") {\n            assetNames.push(asset.name);\n          } else {\n            assetNames.push.apply(assetNames, _toConsumableArray(asset.name));\n          }\n          _this3.add(asset.name, asset.srcs);\n        });\n      } else {\n        Object.keys(assets).forEach(function (key) {\n          assetNames.push(key);\n          _this3.add(key, assets[key]);\n        });\n      }\n      this._bundles[bundleId] = assetNames;\n    }\n  }, {\n    key: \"add\",\n    value: function add(keysIn, assetsIn, data) {\n      var _this4 = this;\n      var keys = convertToList(keysIn);\n      keys.forEach(function (key) {\n        if (_this4._assetMap[key]) {}\n      });\n      if (!Array.isArray(assetsIn)) {\n        if (typeof assetsIn === \"string\") {\n          assetsIn = createStringVariations(assetsIn);\n        } else {\n          assetsIn = [assetsIn];\n        }\n      }\n      var assetMap = assetsIn.map(function (asset) {\n        var _formattedAsset$data;\n        var formattedAsset = asset;\n        if (typeof asset === \"string\") {\n          var parsed = false;\n          for (var i = 0; i < _this4._parsers.length; i++) {\n            var parser = _this4._parsers[i];\n            if (parser.test(asset)) {\n              formattedAsset = parser.parse(asset);\n              parsed = true;\n              break;\n            }\n          }\n          if (!parsed) {\n            formattedAsset = {\n              src: asset\n            };\n          }\n        }\n        if (!formattedAsset.format) {\n          formattedAsset.format = formattedAsset.src.split(\".\").pop();\n        }\n        if (!formattedAsset.alias) {\n          formattedAsset.alias = keys;\n        }\n        if (_this4._basePath || _this4._rootPath) {\n          formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, _this4._basePath, _this4._rootPath);\n        }\n        formattedAsset.data = (_formattedAsset$data = formattedAsset.data) !== null && _formattedAsset$data !== void 0 ? _formattedAsset$data : data;\n        return formattedAsset;\n      });\n      keys.forEach(function (key) {\n        _this4._assetMap[key] = assetMap;\n      });\n    }\n  }, {\n    key: \"resolveBundle\",\n    value: function resolveBundle(bundleIds) {\n      var _this5 = this;\n      var singleAsset = isSingleItem(bundleIds);\n      bundleIds = convertToList(bundleIds);\n      var out = {};\n      bundleIds.forEach(function (bundleId) {\n        var assetNames = _this5._bundles[bundleId];\n        if (assetNames) {\n          out[bundleId] = _this5.resolve(assetNames);\n        }\n      });\n      return singleAsset ? out[bundleIds[0]] : out;\n    }\n  }, {\n    key: \"resolveUrl\",\n    value: function resolveUrl(key) {\n      var result = this.resolve(key);\n      if (typeof key !== \"string\") {\n        var out = {};\n        for (var i in result) {\n          out[i] = result[i].src;\n        }\n        return out;\n      }\n      return result.src;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(keys) {\n      var _this6 = this;\n      var singleAsset = isSingleItem(keys);\n      keys = convertToList(keys);\n      var result = {};\n      keys.forEach(function (key) {\n        if (!_this6._resolverHash[key]) {\n          if (_this6._assetMap[key]) {\n            var _assets$;\n            var assets = _this6._assetMap[key];\n            var preferredOrder = _this6._getPreferredOrder(assets);\n            var bestAsset = assets[0];\n            preferredOrder === null || preferredOrder === void 0 ? void 0 : preferredOrder.priority.forEach(function (priorityKey) {\n              preferredOrder.params[priorityKey].forEach(function (value) {\n                var filteredAssets = assets.filter(function (asset) {\n                  if (asset[priorityKey]) {\n                    return asset[priorityKey] === value;\n                  }\n                  return false;\n                });\n                if (filteredAssets.length) {\n                  assets = filteredAssets;\n                }\n              });\n            });\n            _this6._resolverHash[key] = (_assets$ = assets[0]) !== null && _assets$ !== void 0 ? _assets$ : bestAsset;\n          } else {\n            var src = key;\n            if (_this6._basePath || _this6._rootPath) {\n              src = utils.path.toAbsolute(src, _this6._basePath, _this6._rootPath);\n            }\n            _this6._resolverHash[key] = {\n              src: src\n            };\n          }\n        }\n        result[key] = _this6._resolverHash[key];\n      });\n      return singleAsset ? result[keys[0]] : result;\n    }\n  }, {\n    key: \"_getPreferredOrder\",\n    value: function _getPreferredOrder(assets) {\n      var _this7 = this;\n      var _loop = function _loop(i) {\n        var asset = assets[0];\n        var preferred = _this7._preferredOrder.find(function (preference) {\n          return preference.params.format.includes(asset.format);\n        });\n        if (preferred) {\n          return {\n            v: preferred\n          };\n        }\n      };\n      for (var i = 0; i < assets.length; i++) {\n        var _ret = _loop(i);\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n      return this._preferredOrder[0];\n    }\n  }]);\n  return Resolver;\n}();\nexport { Resolver };","map":{"version":3,"sources":["../../src/resolver/Resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { utils } from '@pixi/core';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\nimport type { ResolveAsset, PreferOrder, ResolveURLParser, ResolverManifest, ResolverBundle } from './types';\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof PIXI\n */\nexport class Resolver\n{\n    private _assetMap: Record<string, ResolveAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolveAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: ResolverManifest;\n    private _bundles: Record<string, string[]> = {};\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(settings.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this._preferredOrder = [];\n\n        this._resolverHash = {};\n        this._assetMap = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: ResolverManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            console.warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n\n        if (Array.isArray(assets))\n        {\n            assets.forEach((asset) =>\n            {\n                if (typeof asset.name === 'string')\n                {\n                    assetNames.push(asset.name);\n                }\n                else\n                {\n                    assetNames.push(...asset.name);\n                }\n\n                this.add(asset.name, asset.srcs);\n            });\n        }\n        else\n        {\n            Object.keys(assets).forEach((key) =>\n            {\n                assetNames.push(key);\n                this.add(key, assets[key]);\n            });\n        }\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add('foo', 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add(['foo', 'boo'], 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add(['foo', 'boo'], ['bar.png', 'bar.webp']);\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * );\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param keysIn - The keys to map, can be an array or a single key\n     * @param assetsIn - The assets to associate with the key(s)\n     * @param data - The data that will be attached to the object that resolved object.\n     */\n    public add(keysIn: string | string[], assetsIn: string | ResolveAsset | (ResolveAsset | string)[], data?: unknown): void\n    {\n        const keys: string[] = convertToList<string>(keysIn);\n\n        keys.forEach((key) =>\n        {\n            if (this._assetMap[key])\n            {\n                // #if _DEBUG\n                console.warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        });\n\n        if (!Array.isArray(assetsIn))\n        {\n            if (typeof assetsIn === 'string')\n            {\n                assetsIn = createStringVariations(assetsIn);\n            }\n            else\n            {\n                assetsIn = [assetsIn];\n            }\n        }\n\n        const assetMap: ResolveAsset[] = assetsIn.map((asset): ResolveAsset =>\n        {\n            let formattedAsset = asset as ResolveAsset;\n\n            // check if is a string\n            if (typeof asset === 'string')\n            {\n                // first see if it contains any {} tags...\n\n                let parsed = false;\n\n                for (let i = 0; i < this._parsers.length; i++)\n                {\n                    const parser = this._parsers[i];\n\n                    if (parser.test(asset))\n                    {\n                        formattedAsset = parser.parse(asset);\n                        parsed = true;\n                        break;\n                    }\n                }\n\n                if (!parsed)\n                {\n                    formattedAsset = {\n                        src: asset,\n                    };\n                }\n            }\n\n            if (!formattedAsset.format)\n            {\n                formattedAsset.format = formattedAsset.src.split('.').pop();\n            }\n\n            if (!formattedAsset.alias)\n            {\n                formattedAsset.alias = keys;\n            }\n\n            if (this._basePath || this._rootPath)\n            {\n                formattedAsset.src = utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n            }\n\n            formattedAsset.data = formattedAsset.data ?? data;\n\n            return formattedAsset;\n        });\n\n        keys.forEach((key) =>\n        {\n            this._assetMap[key] = assetMap;\n        });\n    }\n\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'background',\n     *                     srcs: 'sunset.png',\n     *                 },\n     *                 {\n     *                     name: 'bar',\n     *                     srcs: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'character',\n     *                     srcs: 'robot.png',\n     *                 },\n     *                 {\n     *                     name: 'enemy',\n     *                     srcs: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: string | string[]):\n    Record<string, ResolveAsset> | Record<string, Record<string, ResolveAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolveAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                out[bundleId] = this.resolve(assetNames) as Record<string, ResolveAsset>;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: string | string[]): string | Record<string, string>\n    {\n        const result = this.resolve(key);\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolveAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolveAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string | string[]): ResolveAsset | Record<string, ResolveAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolveAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    const bestAsset = assets[0];\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey])\n                                {\n                                    return asset[priorityKey] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = (assets[0] ?? bestAsset);\n                }\n                else\n                {\n                    let src = key;\n\n                    if (this._basePath || this._rootPath)\n                    {\n                        src = utils.path.toAbsolute(src, this._basePath, this._rootPath);\n                    }\n\n                    // if the resolver fails we just pass back the key assuming its a url\n                    this._resolverHash[key] = {\n                        src,\n                    };\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolveAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred =  this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n}\n"]},"metadata":{},"sourceType":"module"}