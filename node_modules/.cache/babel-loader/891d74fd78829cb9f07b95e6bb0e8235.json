{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar utils_1 = require(\"../../utils\");\nvar struct_1 = require(\"./struct\");\nvar contractInterface_1 = require(\"./contractInterface\");\nvar enum_1 = require(\"./enum\");\nvar typeMapper_1 = require(\"./typeMapper\");\nvar endpoint_1 = require(\"./endpoint\");\nvar AbiRegistry = /*#__PURE__*/function () {\n  function AbiRegistry() {\n    _classCallCheck(this, AbiRegistry);\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  _createClass(AbiRegistry, [{\n    key: \"extend\",\n    value: function extend(json) {\n      json.types = json.types || {};\n      // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n      var iface = contractInterface_1.ContractInterface.fromJSON(json);\n      this.interfaces.push(iface);\n      for (var customTypeName in json.types) {\n        var itemJson = json.types[customTypeName];\n        var typeDiscriminant = itemJson.type;\n        // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n        itemJson.name = customTypeName;\n        var customType = this.createCustomType(typeDiscriminant, itemJson);\n        this.customTypes.push(customType);\n      }\n      this.sortCustomTypesByDependencies();\n      return this;\n    }\n  }, {\n    key: \"createCustomType\",\n    value: function createCustomType(typeDiscriminant, json) {\n      if (typeDiscriminant == \"struct\") {\n        return struct_1.StructType.fromJSON(json);\n      }\n      if (typeDiscriminant == \"enum\") {\n        return enum_1.EnumType.fromJSON(json);\n      }\n      throw new errors.ErrTypingSystem(\"Unknown type discriminant: \".concat(typeDiscriminant));\n    }\n  }, {\n    key: \"sortCustomTypesByDependencies\",\n    value: function sortCustomTypesByDependencies() {\n      // TODO: Improve consistency of the sorting function (and make sure the sorting is stable): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n      this.customTypes.sort(function (a, b) {\n        var bDependsOnA = b.getNamesOfDependencies().indexOf(a.getName()) > -1;\n        if (bDependsOnA) {\n          // Sort \"a\" before \"b\".\n          return -1;\n        }\n        // Sort \"b\" before \"a\".\n        return 1;\n      });\n    }\n  }, {\n    key: \"getInterface\",\n    value: function getInterface(name) {\n      var result = this.interfaces.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSetWithMessage(\"interface [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getInterfaces\",\n    value: function getInterfaces(names) {\n      var _this = this;\n      return names.map(function (name) {\n        return _this.getInterface(name);\n      });\n    }\n  }, {\n    key: \"getStruct\",\n    value: function getStruct(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"struct [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getStructs\",\n    value: function getStructs(names) {\n      var _this2 = this;\n      return names.map(function (name) {\n        return _this2.getStruct(name);\n      });\n    }\n  }, {\n    key: \"getEnum\",\n    value: function getEnum(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"enum [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getEnums\",\n    value: function getEnums(names) {\n      var _this3 = this;\n      return names.map(function (name) {\n        return _this3.getEnum(name);\n      });\n    }\n    /**\n     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n  }, {\n    key: \"remapToKnownTypes\",\n    value: function remapToKnownTypes() {\n      var _newRegistry$customTy, _newRegistry$interfac;\n      var mapper = new typeMapper_1.TypeMapper([]);\n      var newCustomTypes = [];\n      var newInterfaces = [];\n      // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n      var _iterator = _createForOfIteratorHelper(this.customTypes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          var mappedTyped = mapper.mapType(type);\n          newCustomTypes.push(mappedTyped);\n        }\n        // Then, remap types of all endpoint parameters.\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n      var _iterator2 = _createForOfIteratorHelper(this.interfaces),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var iface = _step2.value;\n          var newEndpoints = [];\n          var _iterator3 = _createForOfIteratorHelper(iface.endpoints),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var endpoint = _step3.value;\n              newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          var newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n          newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var newRegistry = new AbiRegistry();\n      (_newRegistry$customTy = newRegistry.customTypes).push.apply(_newRegistry$customTy, newCustomTypes);\n      (_newRegistry$interfac = newRegistry.interfaces).push.apply(_newRegistry$interfac, newInterfaces);\n      return newRegistry;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(json) {\n      var registry = new AbiRegistry().extend(json);\n      var remappedRegistry = registry.remapToKnownTypes();\n      return remappedRegistry;\n    }\n  }]);\n  return AbiRegistry;\n}();\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n  var newInput = endpoint.input.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  var newOutput = endpoint.output.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbiRegistry = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst utils_1 = require(\"../../utils\");\nconst struct_1 = require(\"./struct\");\nconst contractInterface_1 = require(\"./contractInterface\");\nconst enum_1 = require(\"./enum\");\nconst typeMapper_1 = require(\"./typeMapper\");\nconst endpoint_1 = require(\"./endpoint\");\nclass AbiRegistry {\n    constructor() {\n        this.interfaces = [];\n        this.customTypes = [];\n    }\n    static create(json) {\n        let registry = new AbiRegistry().extend(json);\n        let remappedRegistry = registry.remapToKnownTypes();\n        return remappedRegistry;\n    }\n    extend(json) {\n        json.types = json.types || {};\n        // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n        let iface = contractInterface_1.ContractInterface.fromJSON(json);\n        this.interfaces.push(iface);\n        for (const customTypeName in json.types) {\n            let itemJson = json.types[customTypeName];\n            let typeDiscriminant = itemJson.type;\n            // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n            itemJson.name = customTypeName;\n            let customType = this.createCustomType(typeDiscriminant, itemJson);\n            this.customTypes.push(customType);\n        }\n        this.sortCustomTypesByDependencies();\n        return this;\n    }\n    createCustomType(typeDiscriminant, json) {\n        if (typeDiscriminant == \"struct\") {\n            return struct_1.StructType.fromJSON(json);\n        }\n        if (typeDiscriminant == \"enum\") {\n            return enum_1.EnumType.fromJSON(json);\n        }\n        throw new errors.ErrTypingSystem(`Unknown type discriminant: ${typeDiscriminant}`);\n    }\n    sortCustomTypesByDependencies() {\n        // TODO: Improve consistency of the sorting function (and make sure the sorting is stable): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n        this.customTypes.sort((a, b) => {\n            const bDependsOnA = b.getNamesOfDependencies().indexOf(a.getName()) > -1;\n            if (bDependsOnA) {\n                // Sort \"a\" before \"b\".\n                return -1;\n            }\n            // Sort \"b\" before \"a\".\n            return 1;\n        });\n    }\n    getInterface(name) {\n        let result = this.interfaces.find((e) => e.name == name);\n        utils_1.guardValueIsSetWithMessage(`interface [${name}] not found`, result);\n        return result;\n    }\n    getInterfaces(names) {\n        return names.map((name) => this.getInterface(name));\n    }\n    getStruct(name) {\n        let result = this.customTypes.find((e) => e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName));\n        utils_1.guardValueIsSetWithMessage(`struct [${name}] not found`, result);\n        return result;\n    }\n    getStructs(names) {\n        return names.map((name) => this.getStruct(name));\n    }\n    getEnum(name) {\n        let result = this.customTypes.find((e) => e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName));\n        utils_1.guardValueIsSetWithMessage(`enum [${name}] not found`, result);\n        return result;\n    }\n    getEnums(names) {\n        return names.map((name) => this.getEnum(name));\n    }\n    /**\n     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n    remapToKnownTypes() {\n        let mapper = new typeMapper_1.TypeMapper([]);\n        let newCustomTypes = [];\n        let newInterfaces = [];\n        // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n        for (const type of this.customTypes) {\n            const mappedTyped = mapper.mapType(type);\n            newCustomTypes.push(mappedTyped);\n        }\n        // Then, remap types of all endpoint parameters.\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n        mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n        for (const iface of this.interfaces) {\n            let newEndpoints = [];\n            for (const endpoint of iface.endpoints) {\n                newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n            let newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n            newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n        let newRegistry = new AbiRegistry();\n        newRegistry.customTypes.push(...newCustomTypes);\n        newRegistry.interfaces.push(...newInterfaces);\n        return newRegistry;\n    }\n}\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n    let newInput = endpoint.input.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n    let newOutput = endpoint.output.map((e) => new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type)));\n    return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}\n//# sourceMappingURL=abiRegistry.js.map"]},"metadata":{},"sourceType":"script"}