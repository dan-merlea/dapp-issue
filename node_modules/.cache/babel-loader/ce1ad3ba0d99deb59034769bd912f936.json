{"ast":null,"code":"import { uniformParsers } from './uniformParsers.mjs';\nvar GLSL_TO_SINGLE_SETTERS_CACHED = {\n  float: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n        gl.uniform1f(location, v);\\n    }\",\n  vec2: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2f(location, v[0], v[1])\\n    }\",\n  vec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3f(location, v[0], v[1], v[2])\\n    }\",\n  vec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  int: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1i(location, v);\\n    }\",\n  ivec2: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2i(location, v[0], v[1]);\\n    }\",\n  ivec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3i(location, v[0], v[1], v[2]);\\n    }\",\n  ivec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  uint: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1ui(location, v);\\n    }\",\n  uvec2: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2ui(location, v[0], v[1]);\\n    }\",\n  uvec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3ui(location, v[0], v[1], v[2]);\\n    }\",\n  uvec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  bool: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n        gl.uniform1i(location, v);\\n    }\",\n  bvec2: \"\\n    if (cv[0] != v[0] || cv[1] != v[1])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n\\n        gl.uniform2i(location, v[0], v[1]);\\n    }\",\n  bvec3: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n\\n        gl.uniform3i(location, v[0], v[1], v[2]);\\n    }\",\n  bvec4: \"\\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\\n    {\\n        cv[0] = v[0];\\n        cv[1] = v[1];\\n        cv[2] = v[2];\\n        cv[3] = v[3];\\n\\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\\n    }\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1i(location, v);\\n    }\",\n  samplerCube: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1i(location, v);\\n    }\",\n  sampler2DArray: \"\\n    if (cv !== v)\\n    {\\n        cu.value = v;\\n\\n        gl.uniform1i(location, v);\\n    }\"\n};\nvar GLSL_TO_ARRAY_SETTERS = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction generateUniformsSync(group, uniformData) {\n  var funcFragments = [\"\\n        var v = null;\\n        var cv = null;\\n        var cu = null;\\n        var t = 0;\\n        var gl = renderer.gl;\\n    \"];\n  for (var i in group.uniforms) {\n    var data = uniformData[i];\n    if (!data) {\n      var _group$uniforms$i;\n      if ((_group$uniforms$i = group.uniforms[i]) !== null && _group$uniforms$i !== void 0 && _group$uniforms$i.group) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(\"\\n                        renderer.shader.syncUniformBufferGroup(uv.\".concat(i, \", '\").concat(i, \"');\\n                    \"));\n        } else {\n          funcFragments.push(\"\\n                        renderer.shader.syncUniformGroup(uv.\".concat(i, \", syncData);\\n                    \"));\n        }\n      }\n      continue;\n    }\n    var uniform = group.uniforms[i];\n    var parsed = false;\n    for (var j = 0; j < uniformParsers.length; j++) {\n      if (uniformParsers[j].test(data, uniform)) {\n        funcFragments.push(uniformParsers[j].code(i, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      var templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n      var template = templateType[data.type].replace(\"location\", \"ud[\\\"\".concat(i, \"\\\"].location\"));\n      funcFragments.push(\"\\n            cu = ud[\\\"\".concat(i, \"\\\"];\\n            cv = cu.value;\\n            v = uv[\\\"\").concat(i, \"\\\"];\\n            \").concat(template, \";\"));\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\nexport { generateUniformsSync };","map":{"version":3,"sources":["../../../src/shader/utils/generateUniformsSync.ts"],"names":[],"mappings":";AAaA,IAAM,6BAA8C,GAAA;EAEhD,KAAO,gGAAA;EAOP,IAAM,yJAAA;EASN,IAAM,wMAAA;EAUN,IAAM,wPAAA;EAWN,GAAK,kGAAA;EAOL,KAAO,0JAAA;EAQP,KAAO,yMAAA;EASP,KAAO,wPAAA;EAWP,IAAM,mGAAA;EAON,KAAO,2JAAA;EAQP,KAAO,0MAAA;EASP,KAAO,yPAAA;EAWP,IAAM,gGAAA;EAMN,KAAO,wJAAA;EAQP,KAAO,yMAAA;EASP,KAAO,wPAAA;EAWP,IAAU,EAAA,yCAAA;EACV,IAAU,EAAA,yCAAA;EACV,IAAU,EAAA,yCAAA;EAEV,SAAW,kGAAA;EAOX,WAAa,kGAAA;EAOb,cAAgB;AAOpB,CAAA;AAEA,IAAM,qBAAsC,GAAA;EAExC,KAAU,8BAAA;EAEV,IAAU,8BAAA;EACV,IAAU,8BAAA;EACV,IAAU,EAAA,4BAAA;EAEV,IAAU,EAAA,yCAAA;EACV,IAAU,EAAA,yCAAA;EACV,IAAU,EAAA,yCAAA;EAEV,GAAU,EAAA,4BAAA;EACV,KAAU,EAAA,4BAAA;EACV,KAAU,EAAA,4BAAA;EACV,KAAU,EAAA,4BAAA;EAEV,IAAU,EAAA,6BAAA;EACV,KAAU,EAAA,6BAAA;EACV,KAAU,EAAA,6BAAA;EACV,KAAU,EAAA,6BAAA;EAEV,IAAU,EAAA,4BAAA;EACV,KAAU,EAAA,4BAAA;EACV,KAAU,EAAA,4BAAA;EACV,KAAU,EAAA,4BAAA;EAEV,SAAgB,EAAA,4BAAA;EAChB,WAAgB,EAAA,4BAAA;EAChB,cAAgB,EAAA;AACpB,CAAA;AAEO,SAAA,oBAAA,CAA8B,KAAA,EAAqB,WAC1D,EAAA;EACI,IAAM,aAAA,GAAgB,oIAMrB;EAEU,KAAA,IAAA,CAAA,IAAK,KAAA,CAAM,QACtB,EAAA;IACI,IAAM,IAAA,GAAO,WAAY,CAAA,CAAA,CAAA;IAEzB,IAAI,CAAC,IACL,EAAA;MAAA;MACQ,yBAAA,KAAA,CAAM,QAAS,CAAA,CAAA,CAAA,8CAAf,kBAAmB,KACvB,EAAA;QACQ,IAAA,KAAA,CAAM,QAAS,CAAA,CAAA,CAAA,CAAG,GACtB,EAAA;UACI,aAAA,CAAc,IAAK,+EAC6B,CAAO,gBAAA,CAAA,+BACtD;QAAA,CAGL,MAAA;UACI,aAAA,CAAc,IAAK,yEACuB,CAAA,wCACzC;QAAA;MACL;MAGJ;IAAA;IAGE,IAAA,OAAA,GAAU,KAAA,CAAM,QAAS,CAAA,CAAA,CAAA;IAE/B,IAAI,MAAS,GAAA,KAAA;IAEb,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,cAAA,CAAe,MAAA,EAAQ,CAC3C,EAAA,EAAA;MACI,IAAI,cAAe,CAAA,CAAA,CAAA,CAAG,IAAK,CAAA,IAAA,EAAM,OAAO,CACxC,EAAA;QACI,aAAA,CAAc,IAAA,CAAK,cAAe,CAAA,CAAA,CAAA,CAAG,IAAK,CAAA,CAAA,EAAG,OAAO,CAAC,CAAA;QAC5C,MAAA,GAAA,IAAA;QAET;MAAA;IACJ;IAGJ,IAAI,CAAC,MACL,EAAA;MACI,IAAM,YAAA,GAAe,IAAK,CAAA,IAAA,KAAS,CAAA,IAAK,CAAC,IAAA,CAAK,OAAA,GAAU,6BAAgC,GAAA,qBAAA;MACxF,IAAM,QAAA,GAAW,YAAa,CAAA,IAAA,CAAK,IAAA,CAAA,CAAM,OAAQ,CAAA,UAAA,iBAAmB,CAAc,kBAAA;MAElF,aAAA,CAAc,IAAK,mCACR,CAAA,oEAED,CAAA,+BACR,QAAW,OAAA;IAAA;EACjB;EAUG,OAAA,IAAI,QAAA,CAAS,IAAM,EAAA,IAAA,EAAM,UAAA,EAAY,UAAY,EAAA,aAAA,CAAc,IAAK,CAAA,IAAI,CAAC,CAAA;AACpF","sourcesContent":["import { uniformParsers } from './uniformParsers';\n\nimport type { UniformGroup } from '../UniformGroup';\nimport type { Dict } from '@pixi/utils';\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n\n// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n// l = location\nconst GLSL_TO_SINGLE_SETTERS_CACHED: Dict<string> = {\n\n    float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n\n    vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n\n    vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n\n    vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n    ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n    ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n    ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n    uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n    uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n    uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n    bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n    bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n    bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n\n    mat2:     'gl.uniformMatrix2fv(location, false, v)',\n    mat3:     'gl.uniformMatrix3fv(location, false, v)',\n    mat4:     'gl.uniformMatrix4fv(location, false, v)',\n\n    sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n    samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n    sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n};\n\nconst GLSL_TO_ARRAY_SETTERS: Dict<string> = {\n\n    float:    `gl.uniform1fv(location, v)`,\n\n    vec2:     `gl.uniform2fv(location, v)`,\n    vec3:     `gl.uniform3fv(location, v)`,\n    vec4:     'gl.uniform4fv(location, v)',\n\n    mat4:     'gl.uniformMatrix4fv(location, false, v)',\n    mat3:     'gl.uniformMatrix3fv(location, false, v)',\n    mat2:     'gl.uniformMatrix2fv(location, false, v)',\n\n    int:      'gl.uniform1iv(location, v)',\n    ivec2:    'gl.uniform2iv(location, v)',\n    ivec3:    'gl.uniform3iv(location, v)',\n    ivec4:    'gl.uniform4iv(location, v)',\n\n    uint:     'gl.uniform1uiv(location, v)',\n    uvec2:    'gl.uniform2uiv(location, v)',\n    uvec3:    'gl.uniform3uiv(location, v)',\n    uvec4:    'gl.uniform4uiv(location, v)',\n\n    bool:     'gl.uniform1iv(location, v)',\n    bvec2:    'gl.uniform2iv(location, v)',\n    bvec3:    'gl.uniform3iv(location, v)',\n    bvec4:    'gl.uniform4iv(location, v)',\n\n    sampler2D:      'gl.uniform1iv(location, v)',\n    samplerCube:    'gl.uniform1iv(location, v)',\n    sampler2DArray: 'gl.uniform1iv(location, v)',\n};\n\nexport function generateUniformsSync(group: UniformGroup, uniformData: Dict<any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        const data = uniformData[i];\n\n        if (!data)\n        {\n            if (group.uniforms[i]?.group)\n            {\n                if (group.uniforms[i].ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.syncUniformGroup(uv.${i}, syncData);\n                    `);\n                }\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniforms[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            if (uniformParsers[j].test(data, uniform))\n            {\n                funcFragments.push(uniformParsers[j].code(i, uniform));\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = data.size === 1 && !data.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS;\n            const template = templateType[data.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n"]},"metadata":{},"sourceType":"module"}