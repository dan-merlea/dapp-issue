{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar mesh = require('@pixi/mesh');\nvar BitmapFont = require('./BitmapFont.js');\nrequire('./utils/index.js');\nvar msdf$1 = require('./shader/msdf.js');\nvar msdf = require('./shader/msdf2.js');\nvar core = require('@pixi/core');\nvar display = require('@pixi/display');\nvar splitTextToCharacters = require('./utils/splitTextToCharacters.js');\nvar extractCharCode = require('./utils/extractCharCode.js');\nvar pageMeshDataDefaultPageMeshData = [];\nvar pageMeshDataMSDFPageMeshData = [];\nvar charRenderDataPool = [];\nvar _BitmapText = /*#__PURE__*/function (_display$Container) {\n  _inherits(_BitmapText, _display$Container);\n  var _super = _createSuper(_BitmapText);\n  function _BitmapText(text) {\n    var _this;\n    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _BitmapText);\n    _this = _super.call(this);\n    _this._tint = 16777215;\n    var _Object$assign = Object.assign({}, _BitmapText.styleDefaults, style),\n      align = _Object$assign.align,\n      tint = _Object$assign.tint,\n      maxWidth = _Object$assign.maxWidth,\n      letterSpacing = _Object$assign.letterSpacing,\n      fontName = _Object$assign.fontName,\n      fontSize = _Object$assign.fontSize;\n    if (!BitmapFont.BitmapFont.available[fontName]) {\n      throw new Error(\"Missing BitmapFont \\\"\".concat(fontName, \"\\\"\"));\n    }\n    _this._activePagesMeshData = [];\n    _this._textWidth = 0;\n    _this._textHeight = 0;\n    _this._align = align;\n    _this._tint = tint;\n    _this._font = void 0;\n    _this._fontName = fontName;\n    _this._fontSize = fontSize;\n    _this.text = text;\n    _this._maxWidth = maxWidth;\n    _this._maxLineHeight = 0;\n    _this._letterSpacing = letterSpacing;\n    _this._anchor = new core.ObservablePoint(function () {\n      _this.dirty = true;\n    }, _assertThisInitialized(_this), 0, 0);\n    _this._roundPixels = core.settings.ROUND_PIXELS;\n    _this.dirty = true;\n    _this._resolution = core.settings.RESOLUTION;\n    _this._autoResolution = true;\n    _this._textureCache = {};\n    return _this;\n  }\n  _createClass(_BitmapText, [{\n    key: \"updateText\",\n    value: function updateText() {\n      var data = BitmapFont.BitmapFont.available[this._fontName];\n      var fontSize = this.fontSize;\n      var scale = fontSize / data.size;\n      var pos = new core.Point();\n      var chars = [];\n      var lineWidths = [];\n      var lineSpaces = [];\n      var text = this._text.replace(/(?:\\r\\n|\\r)/g, \"\\n\") || \" \";\n      var charsInput = splitTextToCharacters.splitTextToCharacters(text);\n      var maxWidth = this._maxWidth * data.size / fontSize;\n      var pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n      var prevCharCode = null;\n      var lastLineWidth = 0;\n      var maxLineWidth = 0;\n      var line = 0;\n      var lastBreakPos = -1;\n      var lastBreakWidth = 0;\n      var spacesRemoved = 0;\n      var maxLineHeight = 0;\n      var spaceCount = 0;\n      for (var i = 0; i < charsInput.length; i++) {\n        var char = charsInput[i];\n        var charCode = extractCharCode.extractCharCode(char);\n        if (/(?:\\s)/.test(char)) {\n          lastBreakPos = i;\n          lastBreakWidth = lastLineWidth;\n          spaceCount++;\n        }\n        if (char === \"\\r\" || char === \"\\n\") {\n          lineWidths.push(lastLineWidth);\n          lineSpaces.push(-1);\n          maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n          ++line;\n          ++spacesRemoved;\n          pos.x = 0;\n          pos.y += data.lineHeight;\n          prevCharCode = null;\n          spaceCount = 0;\n          continue;\n        }\n        var charData = data.chars[charCode];\n        if (!charData) {\n          continue;\n        }\n        if (prevCharCode && charData.kerning[prevCharCode]) {\n          pos.x += charData.kerning[prevCharCode];\n        }\n        var charRenderData = charRenderDataPool.pop() || {\n          texture: core.Texture.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new core.Point()\n        };\n        charRenderData.texture = charData.texture;\n        charRenderData.line = line;\n        charRenderData.charCode = charCode;\n        charRenderData.position.x = pos.x + charData.xOffset + this._letterSpacing / 2;\n        charRenderData.position.y = pos.y + charData.yOffset;\n        charRenderData.prevSpaces = spaceCount;\n        chars.push(charRenderData);\n        lastLineWidth = charRenderData.position.x + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n        pos.x += charData.xAdvance + this._letterSpacing;\n        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n        prevCharCode = charCode;\n        if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n          ++spacesRemoved;\n          core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n          i = lastBreakPos;\n          lastBreakPos = -1;\n          lineWidths.push(lastBreakWidth);\n          lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n          maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n          line++;\n          pos.x = 0;\n          pos.y += data.lineHeight;\n          prevCharCode = null;\n          spaceCount = 0;\n        }\n      }\n      var lastChar = charsInput[charsInput.length - 1];\n      if (lastChar !== \"\\r\" && lastChar !== \"\\n\") {\n        if (/(?:\\s)/.test(lastChar)) {\n          lastLineWidth = lastBreakWidth;\n        }\n        lineWidths.push(lastLineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        lineSpaces.push(-1);\n      }\n      var lineAlignOffsets = [];\n      for (var _i = 0; _i <= line; _i++) {\n        var alignOffset = 0;\n        if (this._align === \"right\") {\n          alignOffset = maxLineWidth - lineWidths[_i];\n        } else if (this._align === \"center\") {\n          alignOffset = (maxLineWidth - lineWidths[_i]) / 2;\n        } else if (this._align === \"justify\") {\n          alignOffset = lineSpaces[_i] < 0 ? 0 : (maxLineWidth - lineWidths[_i]) / lineSpaces[_i];\n        }\n        lineAlignOffsets.push(alignOffset);\n      }\n      var lenChars = chars.length;\n      var pagesMeshData = {};\n      var newPagesMeshData = [];\n      var activePagesMeshData = this._activePagesMeshData;\n      pageMeshDataPool.push.apply(pageMeshDataPool, _toConsumableArray(activePagesMeshData));\n      for (var _i2 = 0; _i2 < lenChars; _i2++) {\n        var texture = chars[_i2].texture;\n        var baseTextureUid = texture.baseTexture.uid;\n        if (!pagesMeshData[baseTextureUid]) {\n          var pageMeshData = pageMeshDataPool.pop();\n          if (!pageMeshData) {\n            var geometry = new mesh.MeshGeometry();\n            var material = void 0;\n            var meshBlendMode = void 0;\n            if (data.distanceFieldType === \"none\") {\n              material = new mesh.MeshMaterial(core.Texture.EMPTY);\n              meshBlendMode = core.BLEND_MODES.NORMAL;\n            } else {\n              material = new mesh.MeshMaterial(core.Texture.EMPTY, {\n                program: core.Program.from(msdf[\"default\"], msdf$1[\"default\"]),\n                uniforms: {\n                  uFWidth: 0\n                }\n              });\n              meshBlendMode = core.BLEND_MODES.NORMAL_NPM;\n            }\n            var mesh$1 = new mesh.Mesh(geometry, material);\n            mesh$1.blendMode = meshBlendMode;\n            pageMeshData = {\n              index: 0,\n              indexCount: 0,\n              vertexCount: 0,\n              uvsCount: 0,\n              total: 0,\n              mesh: mesh$1,\n              vertices: null,\n              uvs: null,\n              indices: null\n            };\n          }\n          pageMeshData.index = 0;\n          pageMeshData.indexCount = 0;\n          pageMeshData.vertexCount = 0;\n          pageMeshData.uvsCount = 0;\n          pageMeshData.total = 0;\n          var _textureCache = this._textureCache;\n          _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new core.Texture(texture.baseTexture);\n          pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n          pageMeshData.mesh.tint = this._tint;\n          newPagesMeshData.push(pageMeshData);\n          pagesMeshData[baseTextureUid] = pageMeshData;\n        }\n        pagesMeshData[baseTextureUid].total++;\n      }\n      for (var _i3 = 0; _i3 < activePagesMeshData.length; _i3++) {\n        if (!newPagesMeshData.includes(activePagesMeshData[_i3])) {\n          this.removeChild(activePagesMeshData[_i3].mesh);\n        }\n      }\n      for (var _i4 = 0; _i4 < newPagesMeshData.length; _i4++) {\n        if (newPagesMeshData[_i4].mesh.parent !== this) {\n          this.addChild(newPagesMeshData[_i4].mesh);\n        }\n      }\n      this._activePagesMeshData = newPagesMeshData;\n      for (var _i5 in pagesMeshData) {\n        var _pageMeshData$indices;\n        var _pageMeshData = pagesMeshData[_i5];\n        var total = _pageMeshData.total;\n        if (!(((_pageMeshData$indices = _pageMeshData.indices) === null || _pageMeshData$indices === void 0 ? void 0 : _pageMeshData$indices.length) > 6 * total) || _pageMeshData.vertices.length < mesh.Mesh.BATCHABLE_SIZE * 2) {\n          _pageMeshData.vertices = new Float32Array(4 * 2 * total);\n          _pageMeshData.uvs = new Float32Array(4 * 2 * total);\n          _pageMeshData.indices = new Uint16Array(6 * total);\n        } else {\n          var total2 = _pageMeshData.total;\n          var vertices = _pageMeshData.vertices;\n          for (var i2 = total2 * 4 * 2; i2 < vertices.length; i2++) {\n            vertices[i2] = 0;\n          }\n        }\n        _pageMeshData.mesh.size = 6 * total;\n      }\n      for (var _i6 = 0; _i6 < lenChars; _i6++) {\n        var _char = chars[_i6];\n        var offset = _char.position.x + lineAlignOffsets[_char.line] * (this._align === \"justify\" ? _char.prevSpaces : 1);\n        if (this._roundPixels) {\n          offset = Math.round(offset);\n        }\n        var xPos = offset * scale;\n        var yPos = _char.position.y * scale;\n        var _texture = _char.texture;\n        var pageMesh = pagesMeshData[_texture.baseTexture.uid];\n        var textureFrame = _texture.frame;\n        var textureUvs = _texture._uvs;\n        var index = pageMesh.index++;\n        pageMesh.indices[index * 6 + 0] = 0 + index * 4;\n        pageMesh.indices[index * 6 + 1] = 1 + index * 4;\n        pageMesh.indices[index * 6 + 2] = 2 + index * 4;\n        pageMesh.indices[index * 6 + 3] = 0 + index * 4;\n        pageMesh.indices[index * 6 + 4] = 2 + index * 4;\n        pageMesh.indices[index * 6 + 5] = 3 + index * 4;\n        pageMesh.vertices[index * 8 + 0] = xPos;\n        pageMesh.vertices[index * 8 + 1] = yPos;\n        pageMesh.vertices[index * 8 + 2] = xPos + textureFrame.width * scale;\n        pageMesh.vertices[index * 8 + 3] = yPos;\n        pageMesh.vertices[index * 8 + 4] = xPos + textureFrame.width * scale;\n        pageMesh.vertices[index * 8 + 5] = yPos + textureFrame.height * scale;\n        pageMesh.vertices[index * 8 + 6] = xPos;\n        pageMesh.vertices[index * 8 + 7] = yPos + textureFrame.height * scale;\n        pageMesh.uvs[index * 8 + 0] = textureUvs.x0;\n        pageMesh.uvs[index * 8 + 1] = textureUvs.y0;\n        pageMesh.uvs[index * 8 + 2] = textureUvs.x1;\n        pageMesh.uvs[index * 8 + 3] = textureUvs.y1;\n        pageMesh.uvs[index * 8 + 4] = textureUvs.x2;\n        pageMesh.uvs[index * 8 + 5] = textureUvs.y2;\n        pageMesh.uvs[index * 8 + 6] = textureUvs.x3;\n        pageMesh.uvs[index * 8 + 7] = textureUvs.y3;\n      }\n      this._textWidth = maxLineWidth * scale;\n      this._textHeight = (pos.y + data.lineHeight) * scale;\n      for (var _i7 in pagesMeshData) {\n        var _pageMeshData2 = pagesMeshData[_i7];\n        if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n          var vertexCount = 0;\n          var anchorOffsetX = this._textWidth * this.anchor.x;\n          var anchorOffsetY = this._textHeight * this.anchor.y;\n          for (var _i8 = 0; _i8 < _pageMeshData2.total; _i8++) {\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetX;\n            _pageMeshData2.vertices[vertexCount++] -= anchorOffsetY;\n          }\n        }\n        this._maxLineHeight = maxLineHeight * scale;\n        var vertexBuffer = _pageMeshData2.mesh.geometry.getBuffer(\"aVertexPosition\");\n        var textureBuffer = _pageMeshData2.mesh.geometry.getBuffer(\"aTextureCoord\");\n        var indexBuffer = _pageMeshData2.mesh.geometry.getIndex();\n        vertexBuffer.data = _pageMeshData2.vertices;\n        textureBuffer.data = _pageMeshData2.uvs;\n        indexBuffer.data = _pageMeshData2.indices;\n        vertexBuffer.update();\n        textureBuffer.update();\n        indexBuffer.update();\n      }\n      for (var _i9 = 0; _i9 < chars.length; _i9++) {\n        charRenderDataPool.push(chars[_i9]);\n      }\n      this._font = data;\n      this.dirty = false;\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      this.validate();\n      this.containerUpdateTransform();\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      if (this._autoResolution && this._resolution !== renderer.resolution) {\n        this._resolution = renderer.resolution;\n        this.dirty = true;\n      }\n      var _BitmapFont$BitmapFon = BitmapFont.BitmapFont.available[this._fontName],\n        distanceFieldRange = _BitmapFont$BitmapFon.distanceFieldRange,\n        distanceFieldType = _BitmapFont$BitmapFon.distanceFieldType,\n        size = _BitmapFont$BitmapFon.size;\n      if (distanceFieldType !== \"none\") {\n        var _this$worldTransform = this.worldTransform,\n          a = _this$worldTransform.a,\n          b = _this$worldTransform.b,\n          c = _this$worldTransform.c,\n          d = _this$worldTransform.d;\n        var dx = Math.sqrt(a * a + b * b);\n        var dy = Math.sqrt(c * c + d * d);\n        var worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n        var fontScale = this.fontSize / size;\n        var resolution = renderer._view.resolution;\n        var _iterator = _createForOfIteratorHelper(this._activePagesMeshData),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _mesh = _step.value;\n            _mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      _get(_getPrototypeOf(_BitmapText.prototype), \"_render\", this).call(this, renderer);\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds() {\n      this.validate();\n      return _get(_getPrototypeOf(_BitmapText.prototype), \"getLocalBounds\", this).call(this);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      var font = BitmapFont.BitmapFont.available[this._fontName];\n      if (!font) {\n        throw new Error(\"Missing BitmapFont \\\"\".concat(this._fontName, \"\\\"\"));\n      }\n      if (this._font !== font) {\n        this.dirty = true;\n      }\n      if (this.dirty) {\n        this.updateText();\n      }\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      if (this._tint === value) return;\n      this._tint = value;\n      for (var i = 0; i < this._activePagesMeshData.length; i++) {\n        this._activePagesMeshData[i].mesh.tint = value;\n      }\n    }\n  }, {\n    key: \"align\",\n    get: function get() {\n      return this._align;\n    },\n    set: function set(value) {\n      if (this._align !== value) {\n        this._align = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"fontName\",\n    get: function get() {\n      return this._fontName;\n    },\n    set: function set(value) {\n      if (!BitmapFont.BitmapFont.available[value]) {\n        throw new Error(\"Missing BitmapFont \\\"\".concat(value, \"\\\"\"));\n      }\n      if (this._fontName !== value) {\n        this._fontName = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"fontSize\",\n    get: function get() {\n      var _this$_fontSize;\n      return (_this$_fontSize = this._fontSize) !== null && _this$_fontSize !== void 0 ? _this$_fontSize : BitmapFont.BitmapFont.available[this._fontName].size;\n    },\n    set: function set(value) {\n      if (this._fontSize !== value) {\n        this._fontSize = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      return this._anchor;\n    },\n    set: function set(value) {\n      if (typeof value === \"number\") {\n        this._anchor.set(value);\n      } else {\n        this._anchor.copyFrom(value);\n      }\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) {\n      text = String(text === null || text === void 0 ? \"\" : text);\n      if (this._text === text) {\n        return;\n      }\n      this._text = text;\n      this.dirty = true;\n    }\n  }, {\n    key: \"maxWidth\",\n    get: function get() {\n      return this._maxWidth;\n    },\n    set: function set(value) {\n      if (this._maxWidth === value) {\n        return;\n      }\n      this._maxWidth = value;\n      this.dirty = true;\n    }\n  }, {\n    key: \"maxLineHeight\",\n    get: function get() {\n      this.validate();\n      return this._maxLineHeight;\n    }\n  }, {\n    key: \"textWidth\",\n    get: function get() {\n      this.validate();\n      return this._textWidth;\n    }\n  }, {\n    key: \"letterSpacing\",\n    get: function get() {\n      return this._letterSpacing;\n    },\n    set: function set(value) {\n      if (this._letterSpacing !== value) {\n        this._letterSpacing = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"roundPixels\",\n    get: function get() {\n      return this._roundPixels;\n    },\n    set: function set(value) {\n      if (value !== this._roundPixels) {\n        this._roundPixels = value;\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"textHeight\",\n    get: function get() {\n      this.validate();\n      return this._textHeight;\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this._resolution;\n    },\n    set: function set(value) {\n      this._autoResolution = false;\n      if (this._resolution === value) {\n        return;\n      }\n      this._resolution = value;\n      this.dirty = true;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      var _textureCache = this._textureCache;\n      var data = BitmapFont.BitmapFont.available[this._fontName];\n      var pageMeshDataPool = data.distanceFieldType === \"none\" ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n      pageMeshDataPool.push.apply(pageMeshDataPool, _toConsumableArray(this._activePagesMeshData));\n      var _iterator2 = _createForOfIteratorHelper(this._activePagesMeshData),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var pageMeshData = _step2.value;\n          this.removeChild(pageMeshData.mesh);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this._activePagesMeshData = [];\n      pageMeshDataPool.filter(function (page) {\n        return _textureCache[page.mesh.texture.baseTexture.uid];\n      }).forEach(function (page) {\n        page.mesh.texture = core.Texture.EMPTY;\n      });\n      for (var id in _textureCache) {\n        var texture = _textureCache[id];\n        texture.destroy();\n        delete _textureCache[id];\n      }\n      this._font = null;\n      this._textureCache = null;\n      _get(_getPrototypeOf(_BitmapText.prototype), \"destroy\", this).call(this, options);\n    }\n  }]);\n  return _BitmapText;\n}(display.Container);\nvar BitmapText = _BitmapText;\nBitmapText.styleDefaults = {\n  align: \"left\",\n  tint: 16777215,\n  maxWidth: 0,\n  letterSpacing: 0\n};\nexports.BitmapText = BitmapText;","map":{"version":3,"sources":["../src/BitmapText.ts"],"names":["Container","BitmapFont","ObservablePoint","settings","Point","splitTextToCharacters","extractCharCode","Texture","MeshGeometry","MeshMaterial","BLEND_MODES","Program","msdfVert","mesh","Mesh"],"mappings":"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","sourcesContent":["import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { BitmapFont } from './BitmapFont';\nimport { splitTextToCharacters, extractCharCode } from './utils';\nimport msdfFrag from './shader/msdf.frag';\nimport msdfVert from './shader/msdf.vert';\nimport type { Renderer, Rectangle } from '@pixi/core';\nimport { Program, Texture, BLEND_MODES, settings, utils, ObservablePoint, Point } from '@pixi/core';\nimport type { IBitmapTextStyle } from './BitmapTextStyle';\nimport type { TextStyleAlign } from '@pixi/text';\nimport { Container } from '@pixi/display';\nimport type { IDestroyOptions } from '@pixi/display';\n\ninterface PageMeshData\n{\n    index: number;\n    indexCount: number;\n    vertexCount: number;\n    uvsCount: number;\n    total: number;\n    mesh: Mesh;\n    vertices?: Float32Array;\n    uvs?: Float32Array;\n    indices?: Uint16Array;\n}\ninterface CharRenderData\n{\n    texture: Texture;\n    line: number;\n    charCode: number;\n    position: Point;\n    prevSpaces: number;\n}\n\n// If we ever need more than two pools, please make a Dict or something better.\nconst pageMeshDataDefaultPageMeshData: PageMeshData[] = [];\nconst pageMeshDataMSDFPageMeshData: PageMeshData[] = [];\nconst charRenderDataPool: CharRenderData[] = [];\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font.\n *\n * The primary advantage of this class over Text is that all of your textures are pre-generated and loading,\n * meaning that rendering is fast, and changing text has no performance implications.\n *\n * Supporting character sets other than latin, such as CJK languages, may be impractical due to the number of characters.\n *\n * To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n *\n * PixiJS can auto-generate fonts on-the-fly using BitmapFont or use fnt files provided by:\n * http://www.angelcode.com/products/bmfont/ for Windows or\n * http://www.bmglyph.com/ for Mac.\n *\n * You can also use SDF, MSDF and MTSDF BitmapFonts for vector-like scaling appearance provided by:\n * https://github.com/soimy/msdf-bmfont-xml for SDF and MSDF fnt files or\n * https://github.com/Chlumsky/msdf-atlas-gen for SDF, MSDF and MTSDF json files\n *\n * A BitmapText can only be created when the font is loaded.\n * @example\n * import { BitmapText } from 'pixi.js';\n *\n * // in this case the font is in a file called 'desyrel.fnt'\n * const bitmapText = new BitmapText('text using a fancy font!', {\n *     fontName: 'Desyrel',\n *     fontSize: 35,\n *     align: 'right',\n * });\n * @memberof PIXI\n */\nexport class BitmapText extends Container\n{\n    public static styleDefaults: Partial<IBitmapTextStyle> = {\n        align: 'left',\n        tint: 0xFFFFFF,\n        maxWidth: 0,\n        letterSpacing: 0,\n    };\n\n    /** Set to `true` if the BitmapText needs to be redrawn. */\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the width of the overall text.\n     * @private\n     */\n    protected _textWidth: number;\n\n    /**\n     * Private tracker for the height of the overall text.\n     * @private\n     */\n    protected _textHeight: number;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     * @private\n     */\n    protected _maxWidth: number;\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align. (Internally used)\n     * @private\n     */\n    protected _maxLineHeight: number;\n\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @private\n     */\n    protected _letterSpacing: number;\n\n    /**\n     * Text anchor.\n     * @readonly\n     * @private\n     */\n    protected _anchor: ObservablePoint;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font?: BitmapFont;\n\n    /**\n     * Private tracker for the current font name.\n     * @private\n     */\n    protected _fontName: string;\n\n    /**\n     * Private tracker for the current font size.\n     * @private\n     */\n    protected _fontSize?: number;\n\n    /**\n     * Private tracker for the current text align.\n     * @type {string}\n     * @private\n     */\n    protected _align: TextStyleAlign;\n\n    /** Collection of page mesh data. */\n    protected _activePagesMeshData: PageMeshData[];\n\n    /**\n     * Private tracker for the current tint.\n     * @private\n     */\n    protected _tint = 0xFFFFFF;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering.\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    protected _roundPixels: boolean;\n\n    /** Cached char texture is destroyed when BitmapText is destroyed. */\n    private _textureCache: Record<number, Texture>;\n\n    /**\n     * @param text - A string that you would like the text to display.\n     * @param style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center', 'right' or 'justify'),\n     *      does not affect single line text.\n     * @param {number} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    constructor(text: string, style: Partial<IBitmapTextStyle> = {})\n    {\n        super();\n\n        // Apply the defaults\n        const { align, tint, maxWidth, letterSpacing, fontName, fontSize } = Object.assign(\n            {}, BitmapText.styleDefaults, style);\n\n        if (!BitmapFont.available[fontName])\n        {\n            throw new Error(`Missing BitmapFont \"${fontName}\"`);\n        }\n\n        this._activePagesMeshData = [];\n        this._textWidth = 0;\n        this._textHeight = 0;\n        this._align = align;\n        this._tint = tint;\n        this._font = undefined;\n        this._fontName = fontName;\n        this._fontSize = fontSize;\n        this.text = text;\n        this._maxWidth = maxWidth;\n        this._maxLineHeight = 0;\n        this._letterSpacing = letterSpacing;\n        this._anchor = new ObservablePoint((): void => { this.dirty = true; }, this, 0, 0);\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.dirty = true;\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._textureCache = {};\n    }\n\n    /** Renders text and updates it when needed. This should only be called if the BitmapFont is regenerated. */\n    public updateText(): void\n    {\n        const data = BitmapFont.available[this._fontName];\n        const fontSize = this.fontSize;\n        const scale = fontSize / data.size;\n        const pos = new Point();\n        const chars: CharRenderData[] = [];\n        const lineWidths = [];\n        const lineSpaces = [];\n        const text = this._text.replace(/(?:\\r\\n|\\r)/g, '\\n') || ' ';\n        const charsInput = splitTextToCharacters(text);\n        const maxWidth = this._maxWidth * data.size / fontSize;\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n        let spaceCount = 0;\n\n        for (let i = 0; i < charsInput.length; i++)\n        {\n            const char = charsInput[i];\n            const charCode = extractCharCode(char);\n\n            if ((/(?:\\s)/).test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n                spaceCount++;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                lineSpaces.push(-1);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            const charRenderData: CharRenderData = charRenderDataPool.pop() || {\n                texture: Texture.EMPTY,\n                line: 0,\n                charCode: 0,\n                prevSpaces: 0,\n                position: new Point(),\n            };\n\n            charRenderData.texture = charData.texture;\n            charRenderData.line = line;\n            charRenderData.charCode = charCode;\n            charRenderData.position.x = pos.x + charData.xOffset + (this._letterSpacing / 2);\n            charRenderData.position.y = pos.y + charData.yOffset;\n            charRenderData.prevSpaces = spaceCount;\n\n            chars.push(charRenderData);\n\n            lastLineWidth = charRenderData.position.x\n                + Math.max(charData.xAdvance - charData.xOffset, charData.texture.orig.width);\n            pos.x += charData.xAdvance + this._letterSpacing;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                lineSpaces.push(chars.length > 0 ? chars[chars.length - 1].prevSpaces : 0);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                spaceCount = 0;\n            }\n        }\n\n        const lastChar = charsInput[charsInput.length - 1];\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if ((/(?:\\s)/).test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            lineSpaces.push(-1);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n            else if (this._align === 'justify')\n            {\n                alignOffset = lineSpaces[i] < 0 ? 0 : (maxLineWidth - lineWidths[i]) / lineSpaces[i];\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n\n        const pagesMeshData: Record<number, PageMeshData> = {};\n\n        const newPagesMeshData: PageMeshData[] = [];\n\n        const activePagesMeshData = this._activePagesMeshData;\n\n        pageMeshDataPool.push(...activePagesMeshData);\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const texture = chars[i].texture;\n            const baseTextureUid = texture.baseTexture.uid;\n\n            if (!pagesMeshData[baseTextureUid])\n            {\n                let pageMeshData = pageMeshDataPool.pop();\n\n                if (!pageMeshData)\n                {\n                    const geometry = new MeshGeometry();\n                    let material: MeshMaterial;\n                    let meshBlendMode: BLEND_MODES;\n\n                    if (data.distanceFieldType === 'none')\n                    {\n                        material = new MeshMaterial(Texture.EMPTY);\n                        meshBlendMode = BLEND_MODES.NORMAL;\n                    }\n                    else\n                    {\n                        material = new MeshMaterial(Texture.EMPTY,\n                            { program: Program.from(msdfVert, msdfFrag), uniforms: { uFWidth: 0 } });\n                        meshBlendMode = BLEND_MODES.NORMAL_NPM;\n                    }\n\n                    const mesh = new Mesh(geometry, material);\n\n                    mesh.blendMode = meshBlendMode;\n\n                    pageMeshData = {\n                        index: 0,\n                        indexCount: 0,\n                        vertexCount: 0,\n                        uvsCount: 0,\n                        total: 0,\n                        mesh,\n                        vertices: null,\n                        uvs: null,\n                        indices: null,\n                    };\n                }\n\n                // reset data..\n                pageMeshData.index = 0;\n                pageMeshData.indexCount = 0;\n                pageMeshData.vertexCount = 0;\n                pageMeshData.uvsCount = 0;\n                pageMeshData.total = 0;\n\n                // TODO need to get page texture here somehow..\n                const { _textureCache } = this;\n\n                _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n                pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n\n                pageMeshData.mesh.tint = this._tint;\n\n                newPagesMeshData.push(pageMeshData);\n\n                pagesMeshData[baseTextureUid] = pageMeshData;\n            }\n\n            pagesMeshData[baseTextureUid].total++;\n        }\n\n        // lets find any previously active pageMeshDatas that are no longer required for\n        // the updated text (if any), removed and return them to the pool.\n        for (let i = 0; i < activePagesMeshData.length; i++)\n        {\n            if (!newPagesMeshData.includes(activePagesMeshData[i]))\n            {\n                this.removeChild(activePagesMeshData[i].mesh);\n            }\n        }\n\n        // next lets add any new meshes, that have not yet been added to this BitmapText\n        // we only add if its not already a child of this BitmapObject\n        for (let i = 0; i < newPagesMeshData.length; i++)\n        {\n            if (newPagesMeshData[i].mesh.parent !== this)\n            {\n                this.addChild(newPagesMeshData[i].mesh);\n            }\n        }\n\n        // active page mesh datas are set to be the new pages added.\n        this._activePagesMeshData = newPagesMeshData;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n            const total = pageMeshData.total;\n\n            // lets only allocate new buffers if we can fit the new text in the current ones..\n            // unless that is, we will be batching. Currently batching dose not respect the size property of mesh\n            if (!(pageMeshData.indices?.length > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2)\n            {\n                pageMeshData.vertices = new Float32Array(4 * 2 * total);\n                pageMeshData.uvs = new Float32Array(4 * 2 * total);\n                pageMeshData.indices = new Uint16Array(6 * total);\n            }\n            else\n            {\n                const total = pageMeshData.total;\n                const vertices = pageMeshData.vertices;\n\n                // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.\n                for (let i = total * 4 * 2; i < vertices.length; i++)\n                {\n                    vertices[i] = 0;\n                }\n            }\n\n            // as a buffer maybe bigger than the current word, we set the size of the meshMaterial\n            // to match the number of letters needed\n            pageMeshData.mesh.size = 6 * total;\n        }\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            const char = chars[i];\n            let offset = char.position.x + (lineAlignOffsets[char.line] * (this._align === 'justify' ? char.prevSpaces : 1));\n\n            if (this._roundPixels)\n            {\n                offset = Math.round(offset);\n            }\n\n            const xPos = offset * scale;\n            const yPos = char.position.y * scale;\n            const texture = char.texture;\n\n            const pageMesh = pagesMeshData[texture.baseTexture.uid];\n\n            const textureFrame = texture.frame;\n            const textureUvs = texture._uvs;\n\n            const index = pageMesh.index++;\n\n            pageMesh.indices[(index * 6) + 0] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 1] = 1 + (index * 4);\n            pageMesh.indices[(index * 6) + 2] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 3] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 4] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 5] = 3 + (index * 4);\n\n            pageMesh.vertices[(index * 8) + 0] = xPos;\n            pageMesh.vertices[(index * 8) + 1] = yPos;\n\n            pageMesh.vertices[(index * 8) + 2] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 3] = yPos;\n\n            pageMesh.vertices[(index * 8) + 4] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 5] = yPos + (textureFrame.height * scale);\n\n            pageMesh.vertices[(index * 8) + 6] = xPos;\n            pageMesh.vertices[(index * 8) + 7] = yPos + (textureFrame.height * scale);\n\n            pageMesh.uvs[(index * 8) + 0] = textureUvs.x0;\n            pageMesh.uvs[(index * 8) + 1] = textureUvs.y0;\n\n            pageMesh.uvs[(index * 8) + 2] = textureUvs.x1;\n            pageMesh.uvs[(index * 8) + 3] = textureUvs.y1;\n\n            pageMesh.uvs[(index * 8) + 4] = textureUvs.x2;\n            pageMesh.uvs[(index * 8) + 5] = textureUvs.y2;\n\n            pageMesh.uvs[(index * 8) + 6] = textureUvs.x3;\n            pageMesh.uvs[(index * 8) + 7] = textureUvs.y3;\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        for (const i in pagesMeshData)\n        {\n            const pageMeshData = pagesMeshData[i];\n\n            // apply anchor\n            if (this.anchor.x !== 0 || this.anchor.y !== 0)\n            {\n                let vertexCount = 0;\n\n                const anchorOffsetX = this._textWidth * this.anchor.x;\n                const anchorOffsetY = this._textHeight * this.anchor.y;\n\n                for (let i = 0; i < pageMeshData.total; i++)\n                {\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                }\n            }\n\n            this._maxLineHeight = maxLineHeight * scale;\n\n            const vertexBuffer = pageMeshData.mesh.geometry.getBuffer('aVertexPosition');\n            const textureBuffer = pageMeshData.mesh.geometry.getBuffer('aTextureCoord');\n            const indexBuffer = pageMeshData.mesh.geometry.getIndex();\n\n            vertexBuffer.data = pageMeshData.vertices;\n            textureBuffer.data = pageMeshData.uvs;\n            indexBuffer.data = pageMeshData.indices;\n\n            vertexBuffer.update();\n            textureBuffer.update();\n            indexBuffer.update();\n        }\n\n        for (let i = 0; i < chars.length; i++)\n        {\n            charRenderDataPool.push(chars[i]);\n        }\n\n        this._font = data;\n        this.dirty = false;\n    }\n\n    updateTransform(): void\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        // Update the uniform\n        const { distanceFieldRange, distanceFieldType, size } = BitmapFont.available[this._fontName];\n\n        if (distanceFieldType !== 'none')\n        {\n            // Inject the shader code with the correct value\n            const { a, b, c, d } = this.worldTransform;\n\n            const dx = Math.sqrt((a * a) + (b * b));\n            const dy = Math.sqrt((c * c) + (d * d));\n            const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n            const fontScale = this.fontSize / size;\n\n            const resolution =  renderer._view.resolution;\n\n            for (const mesh of this._activePagesMeshData)\n            {\n                mesh.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;\n            }\n        }\n\n        super._render(renderer);\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     * @returns - The rectangular bounding area\n     */\n    public getLocalBounds(): Rectangle\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     * @private\n     */\n    protected validate(): void\n    {\n        const font = BitmapFont.available[this._fontName];\n\n        if (!font)\n        {\n            throw new Error(`Missing BitmapFont \"${this._fontName}\"`);\n        }\n        if (this._font !== font)\n        {\n            this.dirty = true;\n        }\n\n        if (this.dirty)\n        {\n            this.updateText();\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        if (this._tint === value) return;\n\n        this._tint = value;\n\n        for (let i = 0; i < this._activePagesMeshData.length; i++)\n        {\n            this._activePagesMeshData[i].mesh.tint = value;\n        }\n    }\n\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    public get align(): TextStyleAlign\n    {\n        return this._align;\n    }\n\n    public set align(value: TextStyleAlign)\n    {\n        if (this._align !== value)\n        {\n            this._align = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The name of the BitmapFont. */\n    public get fontName(): string\n    {\n        return this._fontName;\n    }\n\n    public set fontName(value: string)\n    {\n        if (!BitmapFont.available[value])\n        {\n            throw new Error(`Missing BitmapFont \"${value}\"`);\n        }\n\n        if (this._fontName !== value)\n        {\n            this._fontName = value;\n            this.dirty = true;\n        }\n    }\n\n    /** The size of the font to display. */\n    public get fontSize(): number\n    {\n        return this._fontSize ?? BitmapFont.available[this._fontName].size;\n    }\n\n    public set fontSize(value: number | undefined)\n    {\n        if (this._fontSize !== value)\n        {\n            this._fontSize = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    public get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    public set anchor(value: ObservablePoint)\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copyFrom(value);\n        }\n    }\n\n    /** The text of the BitmapText object. */\n    public get text(): string\n    {\n        return this._text;\n    }\n\n    public set text(text: string)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    public get maxWidth(): number\n    {\n        return this._maxWidth;\n    }\n\n    public set maxWidth(value: number)\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    public get maxLineHeight(): number\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textWidth(): number\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /** Additional space between characters. */\n    public get letterSpacing(): number\n    {\n        return this._letterSpacing;\n    }\n\n    public set letterSpacing(value: number)\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    public get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    public set roundPixels(value: boolean)\n    {\n        if (value !== this._roundPixels)\n        {\n            this._roundPixels = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    public get textHeight(): number\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n\n    destroy(options?: boolean | IDestroyOptions): void\n    {\n        const { _textureCache } = this;\n        const data = BitmapFont.available[this._fontName];\n        const pageMeshDataPool = data.distanceFieldType === 'none'\n            ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;\n\n        pageMeshDataPool.push(...this._activePagesMeshData);\n        for (const pageMeshData of this._activePagesMeshData)\n        {\n            this.removeChild(pageMeshData.mesh);\n        }\n        this._activePagesMeshData = [];\n\n        // Release references to any cached textures in page pool\n        pageMeshDataPool\n            .filter((page) => _textureCache[page.mesh.texture.baseTexture.uid])\n            .forEach((page) =>\n            {\n                page.mesh.texture = Texture.EMPTY;\n            });\n\n        for (const id in _textureCache)\n        {\n            const texture = _textureCache[id];\n\n            texture.destroy();\n            delete _textureCache[id];\n        }\n\n        this._font = null;\n        this._textureCache = null;\n\n        super.destroy(options);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}