{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n */\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nvar Transport = /*#__PURE__*/function () {\n  function Transport() {\n    var _this = this;\n    _classCallCheck(this, Transport);\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n    this.send = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cla, ins, p1, p2) {\n        var data,\n          statusList,\n          response,\n          sw,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _args.length > 4 && _args[4] !== undefined ? _args[4] : Buffer.alloc(0);\n                statusList = _args.length > 5 && _args[5] !== undefined ? _args[5] : [StatusCodes.OK];\n                if (!(data.length >= 256)) {\n                  _context.next = 4;\n                  break;\n                }\n                throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n              case 4:\n                _context.next = 6;\n                return _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n              case 6:\n                response = _context.sent;\n                sw = response.readUInt16BE(response.length - 2);\n                if (statusList.some(function (s) {\n                  return s === sw;\n                })) {\n                  _context.next = 10;\n                  break;\n                }\n                throw new TransportStatusError(sw);\n              case 10:\n                return _context.abrupt(\"return\", response);\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this.exchangeBusyPromise = void 0;\n    this.exchangeAtomicImpl = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(f) {\n        var resolveBusy, busyPromise, unresponsiveReached, timeout, res;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!_this.exchangeBusyPromise) {\n                  _context2.next = 2;\n                  break;\n                }\n                throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n              case 2:\n                busyPromise = new Promise(function (r) {\n                  resolveBusy = r;\n                });\n                _this.exchangeBusyPromise = busyPromise;\n                unresponsiveReached = false;\n                timeout = setTimeout(function () {\n                  unresponsiveReached = true;\n                  _this.emit(\"unresponsive\");\n                }, _this.unresponsiveTimeout);\n                _context2.prev = 6;\n                _context2.next = 9;\n                return f();\n              case 9:\n                res = _context2.sent;\n                if (unresponsiveReached) {\n                  _this.emit(\"responsive\");\n                }\n                return _context2.abrupt(\"return\", res);\n              case 12:\n                _context2.prev = 12;\n                clearTimeout(timeout);\n                if (resolveBusy) resolveBusy();\n                _this.exchangeBusyPromise = null;\n                return _context2.finish(12);\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[6,, 12, 17]]);\n      }));\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    this._appAPIlock = null;\n  }\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  _createClass(Transport, [{\n    key: \"exchange\",\n    value: function exchange(_apdu) {\n      throw new Error(\"exchange not implemented\");\n    }\n    /**\n     * set the \"scramble key\" for the next exchanges with the device.\n     * Each App can have a different scramble key and they internally will set it at instanciation.\n     * @param key the scramble key\n     */\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(_key) {}\n    /**\n     * close the exchange with the device.\n     * @return a Promise that ends when the transport is closed.\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n\n    /**\n     * Listen to an event on an instance of transport.\n     * Transport implementation can have specific events. Here is the common events:\n     * * `\"disconnect\"` : triggered if Transport is disconnected\n     */\n  }, {\n    key: \"on\",\n    value: function on(eventName, cb) {\n      this._events.on(eventName, cb);\n    }\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n  }, {\n    key: \"off\",\n    value: function off(eventName, cb) {\n      this._events.removeListener(eventName, cb);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var _this$_events;\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      (_this$_events = this._events).emit.apply(_this$_events, [event].concat(args));\n    }\n    /**\n     * Enable or not logs of the binary exchange\n     */\n  }, {\n    key: \"setDebugMode\",\n    value: function setDebugMode() {\n      console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    }\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n  }, {\n    key: \"setExchangeTimeout\",\n    value: function setExchangeTimeout(exchangeTimeout) {\n      this.exchangeTimeout = exchangeTimeout;\n    }\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n  }, {\n    key: \"setExchangeUnresponsiveTimeout\",\n    value: function setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n      this.unresponsiveTimeout = unresponsiveTimeout;\n    }\n    /**\n     * wrapper on top of exchange to simplify work of the implementation.\n     * @param cla\n     * @param ins\n     * @param p1\n     * @param p2\n     * @param data\n     * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n     * @return a Promise of response buffer\n     */\n\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n  }, {\n    key: \"decorateAppAPIMethods\",\n    value: function decorateAppAPIMethods(self, methods, scrambleKey) {\n      var _iterator = _createForOfIteratorHelper(methods),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var methodName = _step.value;\n          self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"decorateAppAPIMethod\",\n    value: function decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n      var _this2 = this;\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _appAPIlock,\n          _len2,\n          args,\n          _key3,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _appAPIlock = _this2._appAPIlock;\n                if (!_appAPIlock) {\n                  _context3.next = 3;\n                  break;\n                }\n                return _context3.abrupt(\"return\", Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\")));\n              case 3:\n                _context3.prev = 3;\n                _this2._appAPIlock = methodName;\n                _this2.setScrambleKey(scrambleKey);\n                for (_len2 = _args3.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n                  args[_key3] = _args3[_key3];\n                }\n                _context3.next = 9;\n                return f.apply(ctx, args);\n              case 9:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 10:\n                _context3.prev = 10;\n                _this2._appAPIlock = null;\n                return _context3.finish(10);\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[3,, 10, 13]]);\n      }));\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var _this3 = this;\n      var openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;\n      var listenTimeout = arguments.length > 1 ? arguments[1] : undefined;\n      return new Promise(function (resolve, reject) {\n        var found = false;\n        var sub = _this3.listen({\n          next: function next(e) {\n            found = true;\n            if (sub) sub.unsubscribe();\n            if (listenTimeoutId) clearTimeout(listenTimeoutId);\n            _this3.open(e.descriptor, openTimeout).then(resolve, reject);\n          },\n          error: function error(e) {\n            if (listenTimeoutId) clearTimeout(listenTimeoutId);\n            reject(e);\n          },\n          complete: function complete() {\n            if (listenTimeoutId) clearTimeout(listenTimeoutId);\n            if (!found) {\n              reject(new TransportError(_this3.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n            }\n          }\n        });\n        var listenTimeoutId = listenTimeout ? setTimeout(function () {\n          sub.unsubscribe();\n          reject(new TransportError(_this3.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n        }, listenTimeout) : null;\n      });\n    }\n  }]);\n  return Transport;\n}();\nexport { Transport as default };\nTransport.isSupported = void 0;\nTransport.list = void 0;\nTransport.listen = void 0;\nTransport.open = void 0;\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";","map":{"version":3,"sources":["../src/Transport.js"],"names":["EventEmitter","TransportRaceCondition","TransportError","StatusCodes","getAltStatusMessage","TransportStatusError","Transport","exchangeTimeout","unresponsiveTimeout","deviceModel","isSupported","list","listen","open","exchange","_apdu","Error","setScrambleKey","_key","close","Promise","resolve","_events","on","eventName","cb","off","removeListener","emit","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","OK","length","response","concat","from","sw","readUInt16BE","some","s","openTimeout","listenTimeout","reject","found","sub","next","e","unsubscribe","listenTimeoutId","clearTimeout","descriptor","then","error","complete","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout","exchangeBusyPromise","exchangeAtomicImpl","f","busyPromise","r","resolveBusy","unresponsiveReached","timeout","res","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","_appAPIlock","ctx","apply"],"mappings":";;;;;AAEA,OAAOA,YAAP,MAAyB,QAAzB;AAEA,SACEC,sBADF,EAEEC,cAFF,EAGEC,WAHF,EAIEC,mBAJF,EAKEC,oBALF,QAMO,kBANP;AAQA,SACEH,cADF,EAEEG,oBAFF,EAGEF,WAHF,EAIEC,mBAJF;AAOA;AACA;;AA2BA;AACA;AACA;AACA;AACA;AAJA,IAKqBE,SAAN;EAA4B,qBAAA;IAAA;IAAA;IAAA,IAAA,CACzCC,eADyC,GACf,KADe;IAAA,IAAA,CAEzCC,mBAFyC,GAEX,KAFW;IAAA,IAAA,CAGzCC,WAHyC,GAGb,IAHa;IAAA,IAAA,CAiFzCa,OAjFyC,GAiF/B,IAAItB,YAAJ,EAjF+B;IAAA,IAAA,CAwIzCoC,IAxIyC;MAAA,sEAwIlC,iBACLC,GADK,EAELC,GAFK,EAGLC,EAHK,EAILC,EAJK;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBAKLC,IAAY,2DAAGC,MAAM,CAACC,KAAPD,CAAa,CAAbA,CALV;gBAMLE,UAAyB,2DAAG,CAACzC,WAAW,CAAC0C,EAAb,CANvB;gBAAA,MAQDJ,IAAI,CAACK,MAALL,IAAe,GAAnB;kBAAA;kBAAA;gBAAA;gBAAA,MACQ,IAAIvC,cAAJ,CACJ,2CAAA,GAA8CuC,IAAI,CAACK,MAD/C,EAEJ,kBAFI,CAAN;cAAA;gBAAA;gBAAA,OAKqB,KAAA,CAAKhC,QAAL,CACrB4B,MAAM,CAACM,MAAPN,CAAc,CACZA,MAAM,CAACO,IAAPP,CAAY,CAACL,GAAD,EAAMC,GAAN,EAAWC,EAAX,EAAeC,EAAf,CAAZE,CADY,EAEZA,MAAM,CAACO,IAAPP,CAAY,CAACD,IAAI,CAACK,MAAN,CAAZJ,CAFY,EAGZD,IAHY,CAAdC,CADqB,CAAvB;cAAA;gBAAMK,QAAQ;gBAORG,EAAE,GAAGH,QAAQ,CAACI,YAATJ,CAAsBA,QAAQ,CAACD,MAATC,GAAkB,CAAxCA,CAAX;gBAAA,IACKH,UAAU,CAACQ,IAAXR,CAAiBS,UAAAA,CAAD;kBAAA,OAAOA,CAAC,KAAKH,EAA7BN;gBAAAA,EAAL;kBAAA;kBAAA;gBAAA;gBAAA,MACQ,IAAIvC,oBAAJ,CAAyB6C,EAAzB,CAAN;cAAA;gBAAA,iCAEKH,QAAP;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAjKuC;MAAA;QAAA;MAAA;IAAA;IAAA,IAAA,CAsNzCwB,mBAtNyC,GAAA,KAAA,CAAA;IAAA,IAAA,CAyNzCC,kBAzNyC;MAAA,uEAyNpB,kBAAOC,CAAP;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,KACf,KAAA,CAAKF,mBAAT;kBAAA;kBAAA;gBAAA;gBAAA,MACQ,IAAItE,sBAAJ,CACJ,+EADI,CAAN;cAAA;gBAKIyE,WAAW,GAAG,IAAItD,OAAJ,CAAauD,UAAAA,CAAD,EAAO;kBACrCC,WAAW,GAAGD,CAAdC;gBACD,CAFmB,CAApB;gBAGA,KAAA,CAAKL,mBAAL,GAA2BG,WAA3B;gBACIG,mBAAmB,GAAG,KAA1B;gBACMC,OAAO,GAAGT,UAAU,CAAC,YAAM;kBAC/BQ,mBAAmB,GAAG,IAAtBA;kBACA,KAAA,CAAKjD,IAAL,CAAU,cAAV,CAAA;gBACD,CAHyB,EAGvB,KAAA,CAAKpB,mBAHkB,CAA1B;gBAAA;gBAAA;gBAAA,OAKoBiE,CAAC,EAAnB;cAAA;gBAAMM,GAAG;gBACT,IAAIF,mBAAJ,EAAyB;kBACvB,KAAA,CAAKjD,IAAL,CAAU,YAAV,CAAA;gBACD;gBAAA,kCACMmD,GAAP;cAAA;gBAAA;gBAEAhB,YAAY,CAACe,OAAD,CAAZf;gBACA,IAAIa,WAAJ,EAAiBA,WAAW,EAAA;gBAC5B,KAAA,CAAKL,mBAAL,GAA2B,IAA3B;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAlPqC;MAAA;QAAA;MAAA;IAAA;IAAA,IAAA,CAqQzCe,WArQyC,GAqQ3B,IArQ2B;EAAA;;EAuDzC;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAA;IAAA,OAOAxE,kBAASC,KAAD,EAAiC;MACvC,MAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;IACD;IAED;AACF;AACA;AACA;AACA;EAJE;IAAA;IAAA,OAKAC,wBAAeC,IAAD,EAAe,CAAE;IAE/B;AACF;AACA;AACA;EAHE;IAAA;IAAA,OAIAC,iBAAuB;MACrB,OAAOC,OAAO,CAACC,OAARD,EAAP;IACD;;IAID;AACF;AACA;AACA;AACA;EAJE;IAAA;IAAA,OAKAG,YAAGC,SAAD,EAAoBC,EAApB,EAAkC;MAClC,IAAA,CAAKH,OAAL,CAAaC,EAAb,CAAgBC,SAAhB,EAA2BC,EAA3B,CAAA;IACD;IAED;AACF;AACA;EAFE;IAAA;IAAA,OAGAC,aAAIF,SAAD,EAAoBC,EAApB,EAAkC;MACnC,IAAA,CAAKH,OAAL,CAAaK,cAAb,CAA4BH,SAA5B,EAAuCC,EAAvC,CAAA;IACD;EAAA;IAAA;IAAA,OAEDG,cAAKC,KAAD,EAA4B;MAAA;MAAA,kCAATC,IAAnB;QAAmBA,IAAnB;MAAA;MACF,qBAAA,CAAKR,OAAL,EAAaM,IAAb,uBAAkBC,KAAlB,SAA4BC,IAA5B,EAAA;IACD;IAED;AACF;AACA;EAFE;IAAA;IAAA,OAGAC,wBAAe;MACbC,OAAO,CAACC,IAARD,CACE,8FADFA,CAAAA;IAGD;IAED;AACF;AACA;EAFE;IAAA;IAAA,OAGAE,4BAAmB3B,eAAD,EAA0B;MAC1C,IAAA,CAAKA,eAAL,GAAuBA,eAAvB;IACD;IAED;AACF;AACA;EAFE;IAAA;IAAA,OAGA4B,wCAA+B3B,mBAAD,EAA8B;MAC1D,IAAA,CAAKA,mBAAL,GAA2BA,mBAA3B;IACD;IAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IA6BE;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAA;IAAA,OAkFAwE,+BACEC,IADmB,EAEnBC,OAFmB,EAGnBC,WAHmB,EAInB;MAAA,2CACuBD,OAAvB;QAAA;MAAA;QAAA,oDAAgC;UAAA,IAAvBE,UAAT;UACEH,IAAI,CAACG,UAAD,CAAJH,GAAmB,IAAA,CAAKI,oBAAL,CACjBD,UADiB,EAEjBH,IAAI,CAACG,UAAD,CAFa,EAGjBH,IAHiB,EAIjBE,WAJiB,CAAnBF;QAMD;MAAA;QAAA;MAAA;QAAA;MAAA;IACF;EAAA;IAAA;IAAA,OAGDI,8BACED,UADkB,EAElBX,CAFkB,EAGlBc,GAHkB,EAIlBJ,WAJkB,EAKU;MAAA;MAC5B,+EAAO;QAAA;UAAA;UAAA;UAAA;UAAA;QAAA;UAAA;YAAA;cAAA;gBACGG,WAAAA,GAAgB,MAAxB,CAAQA,WAAAA;gBAAAA,KACJA,WAAJ;kBAAA;kBAAA;gBAAA;gBAAA,kCACSlE,OAAO,CAACoC,MAARpC,CACL,IAAIlB,cAAJ,CACE,8BAAA,GAAiCoF,WAAjC,GAA+C,GADjD,EAEE,iBAFF,CADKlE,CAAP;cAAA;gBAAA;gBAQA,MAAA,CAAKkE,WAAL,GAAmBF,UAAnB;gBACA,MAAA,CAAKnE,cAAL,CAAoBkE,WAApB,CAAA;gBAAA,4BAZarD,IAAV;kBAAUA,IAAV;gBAAA;gBAAA;gBAAA,OAaU2C,CAAC,CAACe,KAAFf,CAAQc,GAARd,EAAa3C,IAAb2C,CAAb;cAAA;gBAAA;cAAA;gBAAA;gBAEA,MAAA,CAAKa,WAAL,GAAmB,IAAnB;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAfJ;IAkBD;EAAA;IAAA;IAAA,OAnHD,kBAGkC;MAAA;MAAA,IAFhChC,WAAoB,uEAAG,IADzB;MAAA,IAEEC,aAFF;MAIE,OAAO,IAAInC,OAAJ,CAAY,UAACC,OAAD,EAAUmC,MAAV,EAAqB;QACtC,IAAIC,KAAK,GAAG,KAAZ;QACA,IAAMC,GAAG,GAAG,MAAA,CAAK9C,MAAL,CAAY;UACtB+C,IAAI,EAAGC,cAAAA,CAAD,EAAO;YACXH,KAAK,GAAG,IAARA;YACA,IAAIC,GAAJ,EAASA,GAAG,CAACG,WAAJH,EAAAA;YACT,IAAII,eAAJ,EAAqBC,YAAY,CAACD,eAAD,CAAZC;YACrB,MAAA,CAAKlD,IAAL,CAAU+C,CAAC,CAACI,UAAZ,EAAwBV,WAAxB,CAAA,CAAqCW,IAArC,CAA0C5C,OAA1C,EAAmDmC,MAAnD,CAAA;UACD,CANqB;UAOtBU,KAAK,EAAGN,eAAAA,CAAD,EAAO;YACZ,IAAIE,eAAJ,EAAqBC,YAAY,CAACD,eAAD,CAAZC;YACrBP,MAAM,CAACI,CAAD,CAANJ;UACD,CAVqB;UAWtBW,QAAQ,EAAE,oBAAM;YACd,IAAIL,eAAJ,EAAqBC,YAAY,CAACD,eAAD,CAAZC;YACrB,IAAI,CAACN,KAAL,EAAY;cACVD,MAAM,CACJ,IAAItD,cAAJ,CACE,MAAA,CAAKkE,0BADP,EAEE,eAFF,CADI,CAANZ;YAMD;UACF;QArBqB,CAAZ,CAAZ;QAuBA,IAAMM,eAAe,GAAGP,aAAa,GACjCc,UAAU,CAAC,YAAM;UACfX,GAAG,CAACG,WAAJH,EAAAA;UACAF,MAAM,CACJ,IAAItD,cAAJ,CACE,MAAA,CAAKoE,0BADP,EAEE,eAFF,CADI,CAANd;QAMD,CARS,EAQPD,aARO,CADuB,GAUjC,IAVJ;MAWD,CApCM,CAAP;IAqCD;EAAA;EAAA;AAAA;AAAA,SApNkBjD,SAAN;AAAMA,S,CAQXI,W;AARWJ,S,CAgBXK,I;AAhBWL,S,CAsCXM,M;AAtCWN,S,CAkDXO,I;AAlDWP,S,CAgSZgE,0B,GAA6B,kC;AAhSjBhE,S,CAiSZ8D,0B,GAA6B,wB","sourcesContent":["//@flow\n\nimport EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\n\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage,\n};\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  deviceModel?: ?DeviceModel,\n  device?: Device,\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed,\n}>;\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  exchangeTimeout: number = 30000;\n  unresponsiveTimeout: number = 15000;\n  deviceModel: ?DeviceModel = null;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data,\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some((s) => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: (e) => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: (e) => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: ?Promise<void>;\n\n  // $FlowFixMe\n  exchangeAtomicImpl = async (f) => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\"\n      );\n    }\n    let resolveBusy;\n    const busyPromise = new Promise((r) => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n    try {\n      const res = await f();\n      if (unresponsiveReached) {\n        this.emit(\"responsive\");\n      }\n      return res;\n    } finally {\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"]},"metadata":{},"sourceType":"module"}