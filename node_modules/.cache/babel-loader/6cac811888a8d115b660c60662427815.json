{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar displacement$1 = require('./displacement.js');\nvar displacement = require('./displacement2.js');\nvar DisplacementFilter = /*#__PURE__*/function (_core$Filter) {\n  _inherits(DisplacementFilter, _core$Filter);\n  var _super = _createSuper(DisplacementFilter);\n  function DisplacementFilter(sprite, scale) {\n    var _this;\n    _classCallCheck(this, DisplacementFilter);\n    var maskMatrix = new core.Matrix();\n    sprite.renderable = false;\n    _this = _super.call(this, displacement[\"default\"], displacement$1[\"default\"], {\n      mapSampler: sprite._texture,\n      filterMatrix: maskMatrix,\n      scale: {\n        x: 1,\n        y: 1\n      },\n      rotation: new Float32Array([1, 0, 0, 1])\n    });\n    _this.maskSprite = sprite;\n    _this.maskMatrix = maskMatrix;\n    if (scale === null || scale === void 0) {\n      scale = 20;\n    }\n    _this.scale = new core.Point(scale, scale);\n    return _this;\n  }\n  _createClass(DisplacementFilter, [{\n    key: \"apply\",\n    value: function apply(filterManager, input, output, clearMode) {\n      this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n      this.uniforms.scale.x = this.scale.x;\n      this.uniforms.scale.y = this.scale.y;\n      var wt = this.maskSprite.worldTransform;\n      var lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\n      var lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);\n      if (lenX !== 0 && lenY !== 0) {\n        this.uniforms.rotation[0] = wt.a / lenX;\n        this.uniforms.rotation[1] = wt.b / lenX;\n        this.uniforms.rotation[2] = wt.c / lenY;\n        this.uniforms.rotation[3] = wt.d / lenY;\n      }\n      filterManager.applyFilter(this, input, output, clearMode);\n    }\n  }, {\n    key: \"map\",\n    get: function get() {\n      return this.uniforms.mapSampler;\n    },\n    set: function set(value) {\n      this.uniforms.mapSampler = value;\n    }\n  }]);\n  return DisplacementFilter;\n}(core.Filter);\nexports.DisplacementFilter = DisplacementFilter;","map":{"version":3,"sources":["../src/DisplacementFilter.ts"],"names":["Filter","Matrix","vertex","fragment","Point"],"mappings":";;;;;;;;;;;;IAqBa,kBAAA;EAAA;EAAA;EAUT,4BAAY,MAAA,EAA2B,KACvC,EAAA;IAAA;IAAA;IACU,IAAA,UAAA,GAAa,IAAIC,IAAAA,CAAAA,MAAO,EAAA;IAE9B,MAAA,CAAO,UAAa,GAAA,KAAA;IAEpB,0BAAMC,YAAAA,CAAAA,SAAAA,CAAAA,EAAQC,cAAAA,CAAAA,SAAAA,CAAU,EAAA;MACpB,UAAA,EAAY,MAAO,CAAA,QAAA;MACnB,YAAc,EAAA,UAAA;MACd,KAAO,EAAA;QAAE,CAAG,EAAA,CAAA;QAAG,CAAA,EAAG;MAAE,CAAA;MACpB,QAAA,EAAU,IAAI,YAAa,CAAA,CAAC,CAAA,EAAG,CAAG,EAAA,CAAA,EAAG,CAAC,CAAC;IAAA,CAC1C;IAED,MAAK,UAAa,GAAA,MAAA;IAClB,MAAK,UAAa,GAAA,UAAA;IAEd,IAAA,KAAA,KAAU,IAAQ,IAAA,KAAA,KAAU,KAChC,CAAA,EAAA;MACY,KAAA,GAAA,EAAA;IAAA;IAOZ,MAAK,KAAQ,GAAA,IAAIC,IAAAA,CAAAA,KAAM,CAAA,KAAA,EAAO,KAAK,CAAA;IAAA;EAAA;EACvC;IAAA;IAAA,OASA,eACI,aAA6B,EAAA,KAAA,EAAsB,MAAA,EAAuB,SAE9E,EAAA;MAEI,IAAA,CAAK,QAAA,CAAS,YAAe,GAAA,aAAA,CAAc,qBAAA,CAAsB,IAAK,CAAA,UAAA,EAAY,IAAA,CAAK,UAAU,CAAA;MACjG,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,CAAI,GAAA,IAAA,CAAK,KAAM,CAAA,CAAA;MACnC,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,CAAI,GAAA,IAAA,CAAK,KAAM,CAAA,CAAA;MAG7B,IAAA,EAAA,GAAK,IAAA,CAAK,UAAW,CAAA,cAAA;MACrB,IAAA,IAAA,GAAO,IAAK,CAAA,IAAA,CAAM,EAAG,CAAA,CAAA,GAAI,EAAA,CAAG,CAAM,GAAA,EAAA,CAAG,CAAI,GAAA,EAAA,CAAG,CAAE,CAAA;MAC9C,IAAA,IAAA,GAAO,IAAK,CAAA,IAAA,CAAM,EAAG,CAAA,CAAA,GAAI,EAAA,CAAG,CAAM,GAAA,EAAA,CAAG,CAAI,GAAA,EAAA,CAAG,CAAE,CAAA;MAEhD,IAAA,IAAA,KAAS,CAAK,IAAA,IAAA,KAAS,CAC3B,EAAA;QACI,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA;QACnC,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA;QACnC,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA;QACnC,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,EAAA,CAAG,CAAI,GAAA,IAAA;MAAA;MAIvC,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA;IAAA;EAC5D;IAAA;IAAA,KAGA,eACA;MACI,OAAO,IAAA,CAAK,QAAS,CAAA,UAAA;IAAA,CACzB;IAAA,KAEA,aAAQ,KACR,EAAA;MACI,IAAA,CAAK,QAAA,CAAS,UAAa,GAAA,KAAA;IAAA;EAC/B;EAAA;AAAA,EAhFoCJ,IAAAA,CAAAA,MACxC","sourcesContent":["import { Matrix, Point, Filter } from '@pixi/core';\nimport fragment from './displacement.frag';\nimport vertex from './displacement.vert';\n\nimport type { CLEAR_MODES, FilterSystem, RenderTexture, Texture, ISpriteMaskTarget } from '@pixi/core';\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object.\n *\n * You can use this filter to apply all manor of crazy warping effects.\n * Currently the `r` property of the texture is used to offset the `x`\n * and the `g` property of the texture is used to offset the `y`.\n *\n * The way it works is it uses the values of the displacement map to look up the\n * correct pixels to output. This means it's not technically moving the original.\n * Instead, it's starting at the output and asking \"which pixel from the original goes here\".\n * For example, if a displacement map pixel has `red = 1` and the filter scale is `20`,\n * this filter will output the pixel approximately 20 pixels to the right of the original.\n * @memberof PIXI.filters\n */\nexport class DisplacementFilter extends Filter\n{\n    public maskSprite: ISpriteMaskTarget;\n    public maskMatrix: Matrix;\n    public scale: Point;\n\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param scale - The scale of the displacement\n     */\n    constructor(sprite: ISpriteMaskTarget, scale?: number)\n    {\n        const maskMatrix = new Matrix();\n\n        sprite.renderable = false;\n\n        super(vertex, fragment, {\n            mapSampler: sprite._texture,\n            filterMatrix: maskMatrix,\n            scale: { x: 1, y: 1 },\n            rotation: new Float32Array([1, 0, 0, 1]),\n        });\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n\n        if (scale === null || scale === undefined)\n        {\n            scale = 20;\n        }\n\n        /**\n         * scaleX, scaleY for displacements\n         * @member {PIXI.Point}\n         */\n        this.scale = new Point(scale, scale);\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - clearMode.\n     */\n    public apply(\n        filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode: CLEAR_MODES\n    ): void\n    {\n        // fill maskMatrix with _normalized sprite texture coords_\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n        // Extract rotation from world transform\n        const wt = this.maskSprite.worldTransform;\n        const lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));\n        const lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));\n\n        if (lenX !== 0 && lenY !== 0)\n        {\n            this.uniforms.rotation[0] = wt.a / lenX;\n            this.uniforms.rotation[1] = wt.b / lenX;\n            this.uniforms.rotation[2] = wt.c / lenY;\n            this.uniforms.rotation[3] = wt.d / lenY;\n        }\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /** The texture used for the displacement map. Must be power of 2 sized texture. */\n    get map(): Texture\n    {\n        return this.uniforms.mapSampler;\n    }\n\n    set map(value: Texture)\n    {\n        this.uniforms.mapSampler = value;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}