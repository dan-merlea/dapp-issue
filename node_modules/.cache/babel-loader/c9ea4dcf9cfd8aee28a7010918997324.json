{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prependByteToBuffer = exports.flipBufferBitsInPlace = exports.getHexMagnitudeOfBigInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.cloneBuffer = exports.isMsbZero = exports.isMsbOne = void 0;\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar utils_codec_1 = require(\"../../utils.codec\");\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 1.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\nfunction isMsbOne(buffer) {\n  var byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var byte = buffer[byteIndex];\n  var bit = byte >> 7;\n  var isSet = bit == 1;\n  return isSet;\n}\nexports.isMsbOne = isMsbOne;\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 0.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\nfunction isMsbZero(buffer) {\n  var byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return !isMsbOne(buffer, byteIndex);\n}\nexports.isMsbZero = isMsbZero;\nfunction cloneBuffer(buffer) {\n  var clone = Buffer.alloc(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\nfunction bufferToBigInt(buffer) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.\n  var hex = buffer.toString(\"hex\");\n  return new bignumber_js_1.default(\"0x\".concat(hex), 16);\n}\nexports.bufferToBigInt = bufferToBigInt;\nfunction bigIntToBuffer(value) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.\n  var hex = getHexMagnitudeOfBigInt(value);\n  return Buffer.from(hex, \"hex\");\n}\nexports.bigIntToBuffer = bigIntToBuffer;\nfunction getHexMagnitudeOfBigInt(value) {\n  if (!value) {\n    return \"\";\n  }\n  if (value.isNegative()) {\n    value = value.multipliedBy(new bignumber_js_1.default(-1));\n  }\n  return utils_codec_1.numberToPaddedHex(value);\n}\nexports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;\nfunction flipBufferBitsInPlace(buffer) {\n  for (var i = 0; i < buffer.length; i++) {\n    buffer[i] = ~buffer[i];\n  }\n}\nexports.flipBufferBitsInPlace = flipBufferBitsInPlace;\nfunction prependByteToBuffer(buffer, byte) {\n  return Buffer.concat([Buffer.from([byte]), buffer]);\n}\nexports.prependByteToBuffer = prependByteToBuffer;","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;AACA;AAEA;;;;;AAKA,SAAgBA,QAAQ,CAACC,MAAc,EAAuB;EAAA,IAArBC,gFAAoB,CAAC;EAC1D,IAAIC,IAAI,GAAGF,MAAM,CAACC,SAAS,CAAC;EAC5B,IAAIE,GAAG,GAAGD,IAAI,IAAI,CAAC;EACnB,IAAIE,KAAK,GAAGD,GAAG,IAAI,CAAC;EACpB,OAAOC,KAAK;AAChB;AALAC;AAOA;;;;;AAKA,SAAgBC,SAAS,CAACN,MAAc,EAAuB;EAAA,IAArBC,gFAAoB,CAAC;EAC3D,OAAO,CAACF,QAAQ,CAACC,MAAM,EAAEC,SAAS,CAAC;AACvC;AAFAI;AAIA,SAAgBE,WAAW,CAACP,MAAc;EACtC,IAAIQ,KAAK,GAAGC,MAAM,CAACC,KAAK,CAACV,MAAM,CAACW,MAAM,CAAC;EACvCX,MAAM,CAACY,IAAI,CAACJ,KAAK,CAAC;EAClB,OAAOA,KAAK;AAChB;AAJAH;AAMA,SAAgBQ,cAAc,CAACb,MAAc;EACzC;EACA,IAAIc,GAAG,GAAGd,MAAM,CAACe,QAAQ,CAAC,KAAK,CAAC;EAChC,OAAO,IAAIC,sBAAS,aAAMF,GAAG,GAAI,EAAE,CAAC;AACxC;AAJAT;AAMA,SAAgBY,cAAc,CAACC,KAAgB;EAC3C;EACA,IAAIJ,GAAG,GAAGK,uBAAuB,CAACD,KAAK,CAAC;EACxC,OAAOT,MAAM,CAACW,IAAI,CAACN,GAAG,EAAE,KAAK,CAAC;AAClC;AAJAT;AAMA,SAAgBc,uBAAuB,CAACD,KAAgB;EACpD,IAAI,CAACA,KAAK,EAAE;IACR,OAAO,EAAE;;EAGb,IAAIA,KAAK,CAACG,UAAU,EAAE,EAAE;IACpBH,KAAK,GAAGA,KAAK,CAACI,YAAY,CAAC,IAAIN,sBAAS,CAAC,CAAC,CAAC,CAAC,CAAC;;EAGjD,OAAOO,+BAAiB,CAACL,KAAK,CAAC;AACnC;AAVAb;AAYA,SAAgBmB,qBAAqB,CAACxB,MAAc;EAChD,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,MAAM,CAACW,MAAM,EAAEc,CAAC,EAAE,EAAE;IACpCzB,MAAM,CAACyB,CAAC,CAAC,GAAG,CAACzB,MAAM,CAACyB,CAAC,CAAC;;AAE9B;AAJApB;AAMA,SAAgBqB,mBAAmB,CAAC1B,MAAc,EAAEE,IAAY;EAC5D,OAAOO,MAAM,CAACkB,MAAM,CAAC,CAAClB,MAAM,CAACW,IAAI,CAAC,CAAClB,IAAI,CAAC,CAAC,EAAEF,MAAM,CAAC,CAAC;AACvD;AAFAK","names":["isMsbOne","buffer","byteIndex","byte","bit","isSet","exports","isMsbZero","cloneBuffer","clone","Buffer","alloc","length","copy","bufferToBigInt","hex","toString","bignumber_js_1","bigIntToBuffer","value","getHexMagnitudeOfBigInt","from","isNegative","multipliedBy","utils_codec_1","flipBufferBitsInPlace","i","prependByteToBuffer","concat"],"sourceRoot":"","sources":["../../../src/smartcontracts/codec/utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}