{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nvar ImageResource = /*#__PURE__*/function (_BaseImageResource) {\n  _inherits(ImageResource, _BaseImageResource);\n  var _super = _createSuper(ImageResource);\n  function ImageResource(source, options) {\n    var _options$createBitmap;\n    var _this;\n    _classCallCheck(this, ImageResource);\n    options = options || {};\n    if (typeof source === \"string\") {\n      var imageElement = new Image();\n      BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n      imageElement.src = source;\n      source = imageElement;\n    }\n    _this = _super.call(this, source);\n    if (!source.complete && !!_this._width && !!_this._height) {\n      _this._width = 0;\n      _this._height = 0;\n    }\n    _this.url = source.src;\n    _this._process = null;\n    _this.preserveBitmap = false;\n    _this.createBitmap = ((_options$createBitmap = options.createBitmap) !== null && _options$createBitmap !== void 0 ? _options$createBitmap : settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n    _this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    _this.bitmap = null;\n    _this._load = null;\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  _createClass(ImageResource, [{\n    key: \"load\",\n    value: function load(createBitmap) {\n      var _this2 = this;\n      if (this._load) {\n        return this._load;\n      }\n      if (createBitmap !== void 0) {\n        this.createBitmap = createBitmap;\n      }\n      this._load = new Promise(function (resolve, reject) {\n        var source = _this2.source;\n        _this2.url = source.src;\n        var completed = function completed() {\n          if (_this2.destroyed) {\n            return;\n          }\n          source.onload = null;\n          source.onerror = null;\n          _this2.resize(source.width, source.height);\n          _this2._load = null;\n          if (_this2.createBitmap) {\n            resolve(_this2.process());\n          } else {\n            resolve(_this2);\n          }\n        };\n        if (source.complete && source.src) {\n          completed();\n        } else {\n          source.onload = completed;\n          source.onerror = function (event) {\n            reject(event);\n            _this2.onError.emit(event);\n          };\n        }\n      });\n      return this._load;\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this3 = this;\n      var source = this.source;\n      if (this._process !== null) {\n        return this._process;\n      }\n      if (this.bitmap !== null || !globalThis.createImageBitmap) {\n        return Promise.resolve(this);\n      }\n      var createImageBitmap = globalThis.createImageBitmap;\n      var cors = !source.crossOrigin || source.crossOrigin === \"anonymous\";\n      this._process = fetch(source.src, {\n        mode: cors ? \"cors\" : \"no-cors\"\n      }).then(function (r) {\n        return r.blob();\n      }).then(function (blob) {\n        return createImageBitmap(blob, 0, 0, source.width, source.height, {\n          premultiplyAlpha: _this3.alphaMode === null || _this3.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n        });\n      }).then(function (bitmap) {\n        if (_this3.destroyed) {\n          return Promise.reject();\n        }\n        _this3.bitmap = bitmap;\n        _this3.update();\n        _this3._process = null;\n        return Promise.resolve(_this3);\n      });\n      return this._process;\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(renderer, baseTexture, glTexture) {\n      if (typeof this.alphaMode === \"number\") {\n        baseTexture.alphaMode = this.alphaMode;\n      }\n      if (!this.createBitmap) {\n        return _get(_getPrototypeOf(ImageResource.prototype), \"upload\", this).call(this, renderer, baseTexture, glTexture);\n      }\n      if (!this.bitmap) {\n        this.process();\n        if (!this.bitmap) {\n          return false;\n        }\n      }\n      _get(_getPrototypeOf(ImageResource.prototype), \"upload\", this).call(this, renderer, baseTexture, glTexture, this.bitmap);\n      if (!this.preserveBitmap) {\n        var flag = true;\n        var glTextures = baseTexture._glTextures;\n        for (var key in glTextures) {\n          var otherTex = glTextures[key];\n          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {\n            flag = false;\n            break;\n          }\n        }\n        if (flag) {\n          if (this.bitmap.close) {\n            this.bitmap.close();\n          }\n          this.bitmap = null;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.source.onload = null;\n      this.source.onerror = null;\n      _get(_getPrototypeOf(ImageResource.prototype), \"dispose\", this).call(this);\n      if (this.bitmap) {\n        this.bitmap.close();\n        this.bitmap = null;\n      }\n      this._process = null;\n      this._load = null;\n    }\n  }], [{\n    key: \"test\",\n    value: function test(source) {\n      return typeof HTMLImageElement !== \"undefined\" && (typeof source === \"string\" || source instanceof HTMLImageElement);\n    }\n  }]);\n  return ImageResource;\n}(BaseImageResource);\nexport { ImageResource };","map":{"version":3,"sources":["../../../src/textures/resources/ImageResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Whether its required to create a bitmap before upload. */\n    createBitmap?: boolean;\n\n    /** Load image using cross origin. */\n    crossorigin?: boolean | string;\n\n    /** Premultiply image alpha in bitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for HTMLImageElement.\n * @memberof PIXI\n */\nexport class ImageResource extends BaseImageResource\n{\n    /** URL of the image source */\n    url: string;\n\n    /**\n     * If the image should be disposed after upload\n     * @default false\n     */\n    preserveBitmap: boolean;\n\n    /**\n     * If capable, convert the image using createImageBitmap API.\n     * @default PIXI.settings.CREATE_IMAGE_BITMAP\n     */\n    createBitmap: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES;\n\n    /**\n     * The ImageBitmap element created for a {@code HTMLImageElement}.\n     * @default null\n     */\n    bitmap: ImageBitmap;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<ImageResource>;\n\n    /** When process is completed */\n    private _process: Promise<ImageResource>;\n\n    /**\n     * @param source - image source or URL\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - start loading process\n     * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - whether its required to create\n     *        a bitmap before upload\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Premultiply image alpha in bitmap\n     */\n    constructor(source: HTMLImageElement | string, options?: IImageResourceOptions)\n    {\n        options = options || {};\n\n        if (typeof source === 'string')\n        {\n            const imageElement = new Image();\n\n            BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);\n\n            imageElement.src = source;\n            source = imageElement;\n        }\n\n        super(source);\n\n        // FireFox 68, and possibly other versions, seems like setting the HTMLImageElement#width and #height\n        // to non-zero values before its loading completes if images are in a cache.\n        // Because of this, need to set the `_width` and the `_height` to zero to avoid uploading incomplete images.\n        // Please refer to the issue #5968 (https://github.com/pixijs/pixi.js/issues/5968).\n        if (!source.complete && !!this._width && !!this._height)\n        {\n            this._width = 0;\n            this._height = 0;\n        }\n\n        this.url = source.src;\n\n        this._process = null;\n\n        this.preserveBitmap = false;\n        this.createBitmap = (options.createBitmap ?? settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n        this.bitmap = null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Returns a promise when image will be loaded and processed.\n     * @param createBitmap - whether process image into bitmap\n     */\n    load(createBitmap?: boolean): Promise<ImageResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        if (createBitmap !== undefined)\n        {\n            this.createBitmap = createBitmap;\n        }\n\n        this._load = new Promise((resolve, reject): void =>\n        {\n            const source = this.source as HTMLImageElement;\n\n            this.url = source.src;\n\n            const completed = (): void =>\n            {\n                if (this.destroyed)\n                {\n                    return;\n                }\n                source.onload = null;\n                source.onerror = null;\n\n                this.resize(source.width, source.height);\n                this._load = null;\n\n                if (this.createBitmap)\n                {\n                    resolve(this.process());\n                }\n                else\n                {\n                    resolve(this);\n                }\n            };\n\n            if (source.complete && source.src)\n            {\n                completed();\n            }\n            else\n            {\n                source.onload = completed;\n                source.onerror = (event): void =>\n                {\n                    // Avoids Promise freezing when resource broken\n                    reject(event);\n                    this.onError.emit(event);\n                };\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Called when we need to convert image into BitmapImage.\n     * Can be called multiple times, real promise is cached inside.\n     * @returns - Cached promise to fill that bitmap\n     */\n    process(): Promise<ImageResource>\n    {\n        const source = this.source as HTMLImageElement;\n\n        if (this._process !== null)\n        {\n            return this._process;\n        }\n        if (this.bitmap !== null || !globalThis.createImageBitmap)\n        {\n            return Promise.resolve(this);\n        }\n\n        const createImageBitmap = globalThis.createImageBitmap as any;\n        const cors = !source.crossOrigin || source.crossOrigin === 'anonymous';\n\n        this._process = fetch(source.src,\n            {\n                mode: cors ? 'cors' : 'no-cors'\n            })\n            .then((r) => r.blob())\n            .then((blob) => createImageBitmap(blob,\n                0, 0, source.width, source.height,\n                {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                }))\n            .then((bitmap: ImageBitmap) =>\n            {\n                if (this.destroyed)\n                {\n                    return Promise.reject();\n                }\n                this.bitmap = bitmap;\n                this.update();\n                this._process = null;\n\n                return Promise.resolve(this);\n            });\n\n        return this._process;\n    }\n\n    /**\n     * Upload the image resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (typeof this.alphaMode === 'number')\n        {\n            // bitmap stores unpack premultiply flag, we dont have to notify texImage2D about it\n\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        if (!this.createBitmap)\n        {\n            return super.upload(renderer, baseTexture, glTexture);\n        }\n        if (!this.bitmap)\n        {\n            // yeah, ignore the output\n            this.process();\n            if (!this.bitmap)\n            {\n                return false;\n            }\n        }\n\n        super.upload(renderer, baseTexture, glTexture, this.bitmap);\n\n        if (!this.preserveBitmap)\n        {\n            // checks if there are other renderers that possibly need this bitmap\n\n            let flag = true;\n\n            const glTextures = baseTexture._glTextures;\n\n            for (const key in glTextures)\n            {\n                const otherTex = glTextures[key];\n\n                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId)\n                {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag)\n            {\n                if (this.bitmap.close)\n                {\n                    this.bitmap.close();\n                }\n\n                this.bitmap = null;\n            }\n        }\n\n        return true;\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        (this.source as HTMLImageElement).onload = null;\n        (this.source as HTMLImageElement).onerror = null;\n\n        super.dispose();\n\n        if (this.bitmap)\n        {\n            this.bitmap.close();\n            this.bitmap = null;\n        }\n        this._process = null;\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support HTMLImageElement, and source is string or HTMLImageElement\n     */\n    static override test(source: unknown): source is string | HTMLImageElement\n    {\n        return typeof HTMLImageElement !== 'undefined' && (typeof source === 'string' || source instanceof HTMLImageElement);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}