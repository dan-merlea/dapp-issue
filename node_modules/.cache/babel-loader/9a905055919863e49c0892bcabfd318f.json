{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar utils_1 = require(\"../../utils\");\nvar struct_1 = require(\"./struct\");\nvar contractInterface_1 = require(\"./contractInterface\");\nvar enum_1 = require(\"./enum\");\nvar typeMapper_1 = require(\"./typeMapper\");\nvar endpoint_1 = require(\"./endpoint\");\nvar AbiRegistry = /*#__PURE__*/function () {\n  function AbiRegistry() {\n    _classCallCheck(this, AbiRegistry);\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  _createClass(AbiRegistry, [{\n    key: \"extend\",\n    value: function extend(json) {\n      json.types = json.types || {};\n      // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n      var iface = contractInterface_1.ContractInterface.fromJSON(json);\n      this.interfaces.push(iface);\n      for (var customTypeName in json.types) {\n        var itemJson = json.types[customTypeName];\n        var typeDiscriminant = itemJson.type;\n        // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n        itemJson.name = customTypeName;\n        var customType = this.createCustomType(typeDiscriminant, itemJson);\n        this.customTypes.push(customType);\n      }\n      this.sortCustomTypesByDependencies();\n      return this;\n    }\n  }, {\n    key: \"createCustomType\",\n    value: function createCustomType(typeDiscriminant, json) {\n      if (typeDiscriminant == \"struct\") {\n        return struct_1.StructType.fromJSON(json);\n      }\n      if (typeDiscriminant == \"enum\") {\n        return enum_1.EnumType.fromJSON(json);\n      }\n      throw new errors.ErrTypingSystem(\"Unknown type discriminant: \".concat(typeDiscriminant));\n    }\n  }, {\n    key: \"sortCustomTypesByDependencies\",\n    value: function sortCustomTypesByDependencies() {\n      // TODO: Improve consistency of the sorting function (and make sure the sorting is stable): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n      this.customTypes.sort(function (a, b) {\n        var bDependsOnA = b.getNamesOfDependencies().indexOf(a.getName()) > -1;\n        if (bDependsOnA) {\n          // Sort \"a\" before \"b\".\n          return -1;\n        }\n        // Sort \"b\" before \"a\".\n        return 1;\n      });\n    }\n  }, {\n    key: \"getInterface\",\n    value: function getInterface(name) {\n      var result = this.interfaces.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSetWithMessage(\"interface [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getInterfaces\",\n    value: function getInterfaces(names) {\n      var _this = this;\n      return names.map(function (name) {\n        return _this.getInterface(name);\n      });\n    }\n  }, {\n    key: \"getStruct\",\n    value: function getStruct(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"struct [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getStructs\",\n    value: function getStructs(names) {\n      var _this2 = this;\n      return names.map(function (name) {\n        return _this2.getStruct(name);\n      });\n    }\n  }, {\n    key: \"getEnum\",\n    value: function getEnum(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"enum [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getEnums\",\n    value: function getEnums(names) {\n      var _this3 = this;\n      return names.map(function (name) {\n        return _this3.getEnum(name);\n      });\n    }\n    /**\n     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n  }, {\n    key: \"remapToKnownTypes\",\n    value: function remapToKnownTypes() {\n      var _newRegistry$customTy, _newRegistry$interfac;\n      var mapper = new typeMapper_1.TypeMapper([]);\n      var newCustomTypes = [];\n      var newInterfaces = [];\n      // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n      var _iterator = _createForOfIteratorHelper(this.customTypes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          var mappedTyped = mapper.mapType(type);\n          newCustomTypes.push(mappedTyped);\n        }\n        // Then, remap types of all endpoint parameters.\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n      var _iterator2 = _createForOfIteratorHelper(this.interfaces),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var iface = _step2.value;\n          var newEndpoints = [];\n          var _iterator3 = _createForOfIteratorHelper(iface.endpoints),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var endpoint = _step3.value;\n              newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          var newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n          newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var newRegistry = new AbiRegistry();\n      (_newRegistry$customTy = newRegistry.customTypes).push.apply(_newRegistry$customTy, newCustomTypes);\n      (_newRegistry$interfac = newRegistry.interfaces).push.apply(_newRegistry$interfac, newInterfaces);\n      return newRegistry;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(json) {\n      var registry = new AbiRegistry().extend(json);\n      var remappedRegistry = registry.remapToKnownTypes();\n      return remappedRegistry;\n    }\n  }]);\n  return AbiRegistry;\n}();\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n  var newInput = endpoint.input.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  var newOutput = endpoint.output.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":{"version":3,"mappings":"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","names":["AbiRegistry","json","types","iface","contractInterface_1","fromJSON","interfaces","push","customTypeName","itemJson","typeDiscriminant","type","name","customType","createCustomType","customTypes","sortCustomTypesByDependencies","struct_1","enum_1","errors","ErrTypingSystem","sort","a","b","bDependsOnA","getNamesOfDependencies","indexOf","getName","result","find","e","utils_1","names","map","getInterface","hasExactClass","ClassName","getStruct","getEnum","mapper","typeMapper_1","newCustomTypes","newInterfaces","mappedTyped","mapType","newEndpoints","endpoints","endpoint","mapEndpoint","newConstructor","constructorDefinition","newRegistry","registry","extend","remappedRegistry","remapToKnownTypes","exports","newInput","input","endpoint_1","description","newOutput","output","modifiers"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/abiRegistry.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}