{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeExpressionParser = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar types_1 = require(\"./types\");\nvar jsonHandler = require(\"json-duplicate-key-handle\");\nvar TypeExpressionParser = /*#__PURE__*/function () {\n  function TypeExpressionParser() {\n    _classCallCheck(this, TypeExpressionParser);\n  }\n  _createClass(TypeExpressionParser, [{\n    key: \"parse\",\n    value: function parse(expression) {\n      var root = this.doParse(expression);\n      var rootKeys = Object.keys(root);\n      if (rootKeys.length != 1) {\n        throw new errors.ErrTypingSystem(\"bad type expression: \".concat(expression));\n      }\n      var name = rootKeys[0];\n      var type = this.nodeToType(name, root[name]);\n      return type;\n    }\n  }, {\n    key: \"doParse\",\n    value: function doParse(expression) {\n      var jsoned = this.getJsonedString(expression);\n      try {\n        return jsonHandler.parse(jsoned);\n      } catch (error) {\n        throw new errors.ErrTypingSystem(\"cannot parse type expression: \".concat(expression, \". internal json: \").concat(jsoned, \".\"));\n      }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n  }, {\n    key: \"getJsonedString\",\n    value: function getJsonedString(expression) {\n      var jsoned = \"\";\n      for (var i = 0; i < expression.length; i++) {\n        var char = expression.charAt(i);\n        var previousChar = expression.charAt(i - 1);\n        var nextChar = expression.charAt(i + 1);\n        if (char == \"<\") {\n          jsoned += \": {\";\n        } else if (char == \">\") {\n          if (previousChar != \">\") {\n            jsoned += \": {} }\";\n          } else {\n            jsoned += \"}\";\n          }\n        } else if (char == \",\") {\n          if (nextChar == \">\") {\n            // Skip superfluous comma\n          } else {\n            jsoned += \": {},\";\n          }\n        } else {\n          jsoned += char;\n        }\n      }\n      // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n      var symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n      var tokens = jsoned\n      // Hack for Safari compatibility, where we can't use negative lookbehind\n      .replace(/utf\\-8\\sstring/ig, \"utf-8-string\").split(symbolsRegex).filter(function (token) {\n        return token;\n      });\n      jsoned = tokens.map(function (token) {\n        return symbolsRegex.test(token) ? token : \"\\\"\".concat(token, \"\\\"\");\n      }).map(function (token) {\n        return token.replace(/utf\\-8\\-string/ig, \"utf-8 string\");\n      }).join(\"\");\n      if (tokens.length == 1) {\n        // Workaround for simple, non-generic types.\n        return \"{\".concat(jsoned, \": {}}\");\n      }\n      return \"{\".concat(jsoned, \"}\");\n    }\n  }, {\n    key: \"nodeToType\",\n    value: function nodeToType(name, node) {\n      var _this = this;\n      if (name.charAt(name.length - 1) === \"1\") {\n        name = name.slice(0, -1);\n      }\n      var typeParameters = Object.keys(node).map(function (key) {\n        return _this.nodeToType(key, node[key]);\n      });\n      return new types_1.Type(name, typeParameters);\n    }\n  }]);\n  return TypeExpressionParser;\n}();\nexports.TypeExpressionParser = TypeExpressionParser;","map":{"version":3,"mappings":"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","names":["jsonHandler","require","TypeExpressionParser","expression","root","doParse","rootKeys","Object","keys","length","errors","ErrTypingSystem","name","type","nodeToType","jsoned","getJsonedString","parse","error","i","char","charAt","previousChar","nextChar","symbolsRegex","tokens","replace","split","filter","token","map","test","join","node","slice","typeParameters","key","types_1","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/typeExpressionParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}