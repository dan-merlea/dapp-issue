{"ast":null,"code":"/*!\n * @pixi/mesh - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { State, Program, TextureMatrix, Shader, Buffer, Geometry } from '@pixi/core';\nimport { Point, Polygon, Matrix } from '@pixi/math';\nimport { DRAW_MODES, TYPES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\nimport { settings } from '@pixi/settings';\nimport { premultiplyTintToRgba } from '@pixi/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.\n * @memberof PIXI\n */\nvar MeshBatchUvs = /** @class */function () {\n  /**\n   * @param uvBuffer - Buffer with normalized uv's\n   * @param uvMatrix - Material UV matrix\n   */\n  function MeshBatchUvs(uvBuffer, uvMatrix) {\n    this.uvBuffer = uvBuffer;\n    this.uvMatrix = uvMatrix;\n    this.data = null;\n    this._bufferUpdateId = -1;\n    this._textureUpdateId = -1;\n    this._updateID = 0;\n  }\n  /**\n   * Updates\n   * @param forceUpdate - force the update\n   */\n  MeshBatchUvs.prototype.update = function (forceUpdate) {\n    if (!forceUpdate && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) {\n      return;\n    }\n    this._bufferUpdateId = this.uvBuffer._updateID;\n    this._textureUpdateId = this.uvMatrix._updateID;\n    var data = this.uvBuffer.data;\n    if (!this.data || this.data.length !== data.length) {\n      this.data = new Float32Array(data.length);\n    }\n    this.uvMatrix.multiplyUvs(data, this.data);\n    this._updateID++;\n  };\n  return MeshBatchUvs;\n}();\nvar tempPoint = new Point();\nvar tempPolygon = new Polygon();\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.\n * This class assumes a certain level of WebGL knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof PIXI\n */\nvar Mesh = /** @class */function (_super) {\n  __extends(Mesh, _super);\n  /**\n   * @param geometry - The geometry the mesh will use.\n   * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n   * @param state - The state that the WebGL context is required to be in to render the mesh\n   *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n   * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n   */\n  function Mesh(geometry, shader, state, drawMode) {\n    if (drawMode === void 0) {\n      drawMode = DRAW_MODES.TRIANGLES;\n    }\n    var _this = _super.call(this) || this;\n    _this.geometry = geometry;\n    _this.shader = shader;\n    _this.state = state || State.for2d();\n    _this.drawMode = drawMode;\n    _this.start = 0;\n    _this.size = 0;\n    _this.uvs = null;\n    _this.indices = null;\n    _this.vertexData = new Float32Array(1);\n    _this.vertexDirty = -1;\n    _this._transformID = -1;\n    _this._roundPixels = settings.ROUND_PIXELS;\n    _this.batchUvs = null;\n    return _this;\n  }\n  Object.defineProperty(Mesh.prototype, \"geometry\", {\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get: function get() {\n      return this._geometry;\n    },\n    set: function set(value) {\n      if (this._geometry === value) {\n        return;\n      }\n      if (this._geometry) {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0) {\n          this._geometry.dispose();\n        }\n      }\n      this._geometry = value;\n      if (this._geometry) {\n        this._geometry.refCount++;\n      }\n      this.vertexDirty = -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"uvBuffer\", {\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get: function get() {\n      return this.geometry.buffers[1];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"verticesBuffer\", {\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get: function get() {\n      return this.geometry.buffers[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"material\", {\n    get: function get() {\n      return this.shader;\n    },\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set: function set(value) {\n      this.shader = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"blendMode\", {\n    get: function get() {\n      return this.state.blendMode;\n    },\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set: function set(value) {\n      this.state.blendMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"roundPixels\", {\n    get: function get() {\n      return this._roundPixels;\n    },\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set: function set(value) {\n      if (this._roundPixels !== value) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"tint\", {\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get: function get() {\n      return 'tint' in this.shader ? this.shader.tint : null;\n    },\n    set: function set(value) {\n      this.shader.tint = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Mesh.prototype, \"texture\", {\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get: function get() {\n      return 'texture' in this.shader ? this.shader.texture : null;\n    },\n    set: function set(value) {\n      this.shader.texture = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Standard renderer draw.\n   * @param renderer - Instance to renderer.\n   */\n  Mesh.prototype._render = function (renderer) {\n    // set properties for batching..\n    // TODO could use a different way to grab verts?\n    var vertices = this.geometry.buffers[0].data;\n    var shader = this.shader;\n    // TODO benchmark check for attribute size..\n    if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < Mesh.BATCHABLE_SIZE * 2) {\n      this._renderToBatch(renderer);\n    } else {\n      this._renderDefault(renderer);\n    }\n  };\n  /**\n   * Standard non-batching way of rendering.\n   * @param renderer - Instance to renderer.\n   */\n  Mesh.prototype._renderDefault = function (renderer) {\n    var shader = this.shader;\n    shader.alpha = this.worldAlpha;\n    if (shader.update) {\n      shader.update();\n    }\n    renderer.batch.flush();\n    // bind and sync uniforms..\n    shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n    renderer.shader.bind(shader);\n    // set state..\n    renderer.state.set(this.state);\n    // bind the geometry...\n    renderer.geometry.bind(this.geometry, shader);\n    // then render it\n    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n  };\n  /**\n   * Rendering by using the Batch system.\n   * @param renderer - Instance to renderer.\n   */\n  Mesh.prototype._renderToBatch = function (renderer) {\n    var geometry = this.geometry;\n    var shader = this.shader;\n    if (shader.uvMatrix) {\n      shader.uvMatrix.update();\n      this.calculateUvs();\n    }\n    // set properties for batching..\n    this.calculateVertices();\n    this.indices = geometry.indexBuffer.data;\n    this._tintRGB = shader._tintRGB;\n    this._texture = shader.texture;\n    var pluginName = this.material.pluginName;\n    renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n    renderer.plugins[pluginName].render(this);\n  };\n  /** Updates vertexData field based on transform and vertices. */\n  Mesh.prototype.calculateVertices = function () {\n    var geometry = this.geometry;\n    var verticesBuffer = geometry.buffers[0];\n    var vertices = verticesBuffer.data;\n    var vertexDirtyId = verticesBuffer._updateID;\n    if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {\n      return;\n    }\n    this._transformID = this.transform._worldID;\n    if (this.vertexData.length !== vertices.length) {\n      this.vertexData = new Float32Array(vertices.length);\n    }\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var vertexData = this.vertexData;\n    for (var i = 0; i < vertexData.length / 2; i++) {\n      var x = vertices[i * 2];\n      var y = vertices[i * 2 + 1];\n      vertexData[i * 2] = a * x + c * y + tx;\n      vertexData[i * 2 + 1] = b * x + d * y + ty;\n    }\n    if (this._roundPixels) {\n      var resolution = settings.RESOLUTION;\n      for (var i = 0; i < vertexData.length; ++i) {\n        vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);\n      }\n    }\n    this.vertexDirty = vertexDirtyId;\n  };\n  /** Updates uv field based on from geometry uv's or batchUvs. */\n  Mesh.prototype.calculateUvs = function () {\n    var geomUvs = this.geometry.buffers[1];\n    var shader = this.shader;\n    if (!shader.uvMatrix.isSimple) {\n      if (!this.batchUvs) {\n        this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n      }\n      this.batchUvs.update();\n      this.uvs = this.batchUvs.data;\n    } else {\n      this.uvs = geomUvs.data;\n    }\n  };\n  /**\n   * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n   * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n   */\n  Mesh.prototype._calculateBounds = function () {\n    this.calculateVertices();\n    this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n  };\n  /**\n   * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n   * @param point - The point to test.\n   * @returns - The result of the test.\n   */\n  Mesh.prototype.containsPoint = function (point) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n      return false;\n    }\n    this.worldTransform.applyInverse(point, tempPoint);\n    var vertices = this.geometry.getBuffer('aVertexPosition').data;\n    var points = tempPolygon.points;\n    var indices = this.geometry.getIndex().data;\n    var len = indices.length;\n    var step = this.drawMode === 4 ? 3 : 1;\n    for (var i = 0; i + 2 < len; i += step) {\n      var ind0 = indices[i] * 2;\n      var ind1 = indices[i + 1] * 2;\n      var ind2 = indices[i + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Mesh.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this, options);\n    if (this._cachedTexture) {\n      this._cachedTexture.destroy();\n      this._cachedTexture = null;\n    }\n    this.geometry = null;\n    this.shader = null;\n    this.state = null;\n    this.uvs = null;\n    this.indices = null;\n    this.vertexData = null;\n  };\n  /** The maximum number of vertices to consider batchable. Generally, the complexity of the geometry. */\n  Mesh.BATCHABLE_SIZE = 100;\n  return Mesh;\n}(Container);\nvar fragment = \"varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n\";\nvar vertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTextureMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\n\n/**\n * Slightly opinionated default shader for PixiJS 2D objects.\n * @memberof PIXI\n */\nvar MeshMaterial = /** @class */function (_super) {\n  __extends(MeshMaterial, _super);\n  /**\n   * @param uSampler - Texture that material uses to render.\n   * @param options - Additional options\n   * @param {number} [options.alpha=1] - Default alpha.\n   * @param {number} [options.tint=0xFFFFFF] - Default tint.\n   * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.\n   * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.\n   * @param {object} [options.uniforms] - Custom uniforms.\n   */\n  function MeshMaterial(uSampler, options) {\n    var _this = this;\n    var uniforms = {\n      uSampler: uSampler,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    // Set defaults\n    options = Object.assign({\n      tint: 0xFFFFFF,\n      alpha: 1,\n      pluginName: 'batch'\n    }, options);\n    if (options.uniforms) {\n      Object.assign(uniforms, options.uniforms);\n    }\n    _this = _super.call(this, options.program || Program.from(vertex, fragment), uniforms) || this;\n    _this._colorDirty = false;\n    _this.uvMatrix = new TextureMatrix(uSampler);\n    _this.batchable = options.program === undefined;\n    _this.pluginName = options.pluginName;\n    _this.tint = options.tint;\n    _this.alpha = options.alpha;\n    return _this;\n  }\n  Object.defineProperty(MeshMaterial.prototype, \"texture\", {\n    /** Reference to the texture being rendered. */\n    get: function get() {\n      return this.uniforms.uSampler;\n    },\n    set: function set(value) {\n      if (this.uniforms.uSampler !== value) {\n        if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {\n          this._colorDirty = true;\n        }\n        this.uniforms.uSampler = value;\n        this.uvMatrix.texture = value;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MeshMaterial.prototype, \"alpha\", {\n    get: function get() {\n      return this._alpha;\n    },\n    /**\n     * This gets automatically set by the object using this.\n     * @default 1\n     */\n    set: function set(value) {\n      if (value === this._alpha) {\n        return;\n      }\n      this._alpha = value;\n      this._colorDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MeshMaterial.prototype, \"tint\", {\n    get: function get() {\n      return this._tint;\n    },\n    /**\n     * Multiply tint for the material.\n     * @default 0xFFFFFF\n     */\n    set: function set(value) {\n      if (value === this._tint) {\n        return;\n      }\n      this._tint = value;\n      this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n      this._colorDirty = true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link MeshMaterial} objects. */\n  MeshMaterial.prototype.update = function () {\n    if (this._colorDirty) {\n      this._colorDirty = false;\n      var baseTexture = this.texture.baseTexture;\n      premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);\n    }\n    if (this.uvMatrix.update()) {\n      this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n    }\n  };\n  return MeshMaterial;\n}(Shader);\n\n/**\n * Standard 2D geometry used in PixiJS.\n *\n * Geometry can be defined without passing in a style or data if required.\n *\n * ```js\n * const geometry = new PIXI.Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0,0,1,0,1,1,0,1], 2);\n * geometry.addIndex([0,1,2,1,3,2]);\n *\n * ```\n * @memberof PIXI\n */\nvar MeshGeometry = /** @class */function (_super) {\n  __extends(MeshGeometry, _super);\n  /**\n   * @param {Float32Array|number[]} [vertices] - Positional data on geometry.\n   * @param {Float32Array|number[]} [uvs] - Texture UVs.\n   * @param {Uint16Array|number[]} [index] - IndexBuffer\n   */\n  function MeshGeometry(vertices, uvs, index) {\n    var _this = _super.call(this) || this;\n    var verticesBuffer = new Buffer(vertices);\n    var uvsBuffer = new Buffer(uvs, true);\n    var indexBuffer = new Buffer(index, true, true);\n    _this.addAttribute('aVertexPosition', verticesBuffer, 2, false, TYPES.FLOAT).addAttribute('aTextureCoord', uvsBuffer, 2, false, TYPES.FLOAT).addIndex(indexBuffer);\n    _this._updateId = -1;\n    return _this;\n  }\n  Object.defineProperty(MeshGeometry.prototype, \"vertexDirtyId\", {\n    /**\n     * If the vertex position is updated.\n     * @readonly\n     * @private\n     */\n    get: function get() {\n      return this.buffers[0]._updateID;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return MeshGeometry;\n}(Geometry);\nexport { Mesh, MeshBatchUvs, MeshGeometry, MeshMaterial };","map":{"version":3,"mappings":"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","names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","MeshBatchUvs","uvMatrix","uvBuffer","data","_bufferUpdateId","_textureUpdateId","_updateID","forceUpdate","length","Float32Array","multiplyUvs","tempPoint","Point","tempPolygon","Polygon","geometry","shader","state","drawMode","DRAW_MODES","TRIANGLES","_super","_this","State","for2d","start","size","uvs","indices","vertexData","vertexDirty","_transformID","_roundPixels","settings","ROUND_PIXELS","batchUvs","Mesh","get","_geometry","set","value","refCount","dispose","buffers","blendMode","tint","texture","renderer","vertices","batchable","BATCHABLE_SIZE","_renderToBatch","_renderDefault","alpha","worldAlpha","update","batch","flush","uniforms","translationMatrix","transform","worldTransform","toArray","bind","draw","instanceCount","calculateUvs","calculateVertices","indexBuffer","_tintRGB","_texture","pluginName","material","setObjectRenderer","plugins","render","verticesBuffer","vertexDirtyId","_worldID","wt","a","c","tx","ty","i","x","y","resolution","RESOLUTION","Math","round","geomUvs","isSimple","_bounds","addVertexData","point","getBounds","contains","applyInverse","getBuffer","points","getIndex","len","step","ind0","ind1","ind2","options","destroy","_cachedTexture","Container","MeshMaterial","uSampler","uTextureMatrix","Matrix","IDENTITY","uColor","assign","program","Program","from","vertex","fragment","_colorDirty","TextureMatrix","undefined","baseTexture","alphaMode","_alpha","_tint","premultiplyTintToRgba","mapCoord","Shader","index","Buffer","uvsBuffer","addAttribute","TYPES","FLOAT","addIndex","_updateId","MeshGeometry","Geometry"],"sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/MeshBatchUvs.ts","../../src/Mesh.ts","../../src/MeshMaterial.ts","../../src/MeshGeometry.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import type { TextureMatrix, Buffer } from '@pixi/core';\n\n/**\n * Class controls cache for UV mapping from Texture normal space to BaseTexture normal space.\n * @memberof PIXI\n */\nexport class MeshBatchUvs\n{\n    /** UV Buffer data. */\n    public readonly data: Float32Array;\n\n    /** Buffer with normalized UV's. */\n    public uvBuffer: Buffer;\n\n    /** Material UV matrix. */\n    public uvMatrix: TextureMatrix;\n\n    private _bufferUpdateId: number;\n    private _textureUpdateId: number;\n\n    // Internal-only properties\n    _updateID: number;\n\n    /**\n     * @param uvBuffer - Buffer with normalized uv's\n     * @param uvMatrix - Material UV matrix\n     */\n    constructor(uvBuffer: Buffer, uvMatrix: TextureMatrix)\n    {\n        this.uvBuffer = uvBuffer;\n        this.uvMatrix = uvMatrix;\n        this.data = null;\n\n        this._bufferUpdateId = -1;\n        this._textureUpdateId = -1;\n        this._updateID = 0;\n    }\n\n    /**\n     * Updates\n     * @param forceUpdate - force the update\n     */\n    public update(forceUpdate?: boolean): void\n    {\n        if (!forceUpdate\n            && this._bufferUpdateId === this.uvBuffer._updateID\n            && this._textureUpdateId === this.uvMatrix._updateID\n        )\n        {\n            return;\n        }\n\n        this._bufferUpdateId = this.uvBuffer._updateID;\n        this._textureUpdateId = this.uvMatrix._updateID;\n\n        const data = this.uvBuffer.data as Float32Array;\n\n        if (!this.data || this.data.length !== data.length)\n        {\n            (this.data as any) = new Float32Array(data.length);\n        }\n\n        this.uvMatrix.multiplyUvs(data, this.data);\n\n        this._updateID++;\n    }\n}\n","import { State } from '@pixi/core';\nimport { Point, Polygon } from '@pixi/math';\nimport type { BLEND_MODES } from '@pixi/constants';\nimport { DRAW_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\nimport { settings } from '@pixi/settings';\nimport { MeshBatchUvs } from './MeshBatchUvs';\nimport type { MeshMaterial } from './MeshMaterial';\n\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { Texture, Renderer, Geometry, Buffer, Shader } from '@pixi/core';\nimport type { IPointData } from '@pixi/math';\n\nconst tempPoint = new Point();\nconst tempPolygon = new Polygon();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Mesh extends GlobalMixins.Mesh {}\n\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.\n * This class assumes a certain level of WebGL knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof PIXI\n */\nexport class Mesh<T extends Shader = MeshMaterial> extends Container\n{\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     * @type {PIXI.Shader|PIXI.MeshMaterial}\n     */\n    public shader: T;\n\n    /**\n     * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    public state: State;\n\n    /** The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants. */\n    public drawMode: DRAW_MODES;\n\n    /**\n     * Typically the index of the IndexBuffer where to start drawing.\n     * @default 0\n     */\n    public start: number;\n\n    /**\n     * How much of the geometry to draw, by default `0` renders everything.\n     * @default 0\n     */\n    public size: number;\n\n    private _geometry: Geometry;\n\n    /** This is the caching layer used by the batcher. */\n    private vertexData: Float32Array;\n\n    /** If geometry is changed used to decide to re-transform the vertexData. */\n    private vertexDirty: number;\n    private _transformID: number;\n\n    /** Internal roundPixels field. */\n    private _roundPixels: boolean;\n\n    /** Batched UV's are cached for atlas textures. */\n    private batchUvs: MeshBatchUvs;\n\n    // Internal-only properties\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    uvs: Float32Array;\n\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    indices: Uint16Array;\n    _tintRGB: number;\n    _texture: Texture;\n\n    /**\n     * @param geometry - The geometry the mesh will use.\n     * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n     * @param state - The state that the WebGL context is required to be in to render the mesh\n     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n     * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n     */\n    constructor(geometry: Geometry, shader: T, state?: State, drawMode: DRAW_MODES = DRAW_MODES.TRIANGLES)\n    {\n        super();\n\n        this.geometry = geometry;\n        this.shader = shader;\n        this.state = state || State.for2d();\n        this.drawMode = drawMode;\n        this.start = 0;\n        this.size = 0;\n\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = new Float32Array(1);\n        this.vertexDirty = -1;\n\n        this._transformID = -1;\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.batchUvs = null;\n    }\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get geometry(): Geometry\n    {\n        return this._geometry;\n    }\n\n    set geometry(value: Geometry)\n    {\n        if (this._geometry === value)\n        {\n            return;\n        }\n\n        if (this._geometry)\n        {\n            this._geometry.refCount--;\n\n            if (this._geometry.refCount === 0)\n            {\n                this._geometry.dispose();\n            }\n        }\n\n        this._geometry = value;\n\n        if (this._geometry)\n        {\n            this._geometry.refCount++;\n        }\n\n        this.vertexDirty = -1;\n    }\n\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get uvBuffer(): Buffer\n    {\n        return this.geometry.buffers[1];\n    }\n\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get verticesBuffer(): Buffer\n    {\n        return this.geometry.buffers[0];\n    }\n\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set material(value: T)\n    {\n        this.shader = value;\n    }\n\n    get material(): T\n    {\n        return this.shader;\n    }\n\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        return 'tint' in this.shader ? (this.shader as unknown as MeshMaterial).tint : null;\n    }\n\n    set tint(value: number)\n    {\n        (this.shader as unknown as MeshMaterial).tint = value;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get texture(): Texture\n    {\n        return 'texture' in this.shader ? (this.shader as unknown as MeshMaterial).texture : null;\n    }\n\n    set texture(value: Texture)\n    {\n        (this.shader as unknown as MeshMaterial).texture = value;\n    }\n\n    /**\n     * Standard renderer draw.\n     * @param renderer - Instance to renderer.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // set properties for batching..\n        // TODO could use a different way to grab verts?\n        const vertices = this.geometry.buffers[0].data;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        // TODO benchmark check for attribute size..\n        if (\n            shader.batchable\n            && this.drawMode === DRAW_MODES.TRIANGLES\n            && vertices.length < Mesh.BATCHABLE_SIZE * 2\n        )\n        {\n            this._renderToBatch(renderer);\n        }\n        else\n        {\n            this._renderDefault(renderer);\n        }\n    }\n\n    /**\n     * Standard non-batching way of rendering.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderDefault(renderer: Renderer): void\n    {\n        const shader = this.shader as unknown as MeshMaterial;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        // bind and sync uniforms..\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n        renderer.shader.bind(shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // bind the geometry...\n        renderer.geometry.bind(this.geometry, shader);\n\n        // then render it\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n\n    /**\n     * Rendering by using the Batch system.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderToBatch(renderer: Renderer): void\n    {\n        const geometry = this.geometry;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (shader.uvMatrix)\n        {\n            shader.uvMatrix.update();\n            this.calculateUvs();\n        }\n\n        // set properties for batching..\n        this.calculateVertices();\n        this.indices = geometry.indexBuffer.data as Uint16Array;\n        this._tintRGB = shader._tintRGB;\n        this._texture = shader.texture;\n\n        const pluginName = (this.material as unknown as MeshMaterial).pluginName;\n\n        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n        renderer.plugins[pluginName].render(this);\n    }\n\n    /** Updates vertexData field based on transform and vertices. */\n    public calculateVertices(): void\n    {\n        const geometry = this.geometry;\n        const verticesBuffer = geometry.buffers[0];\n        const vertices = verticesBuffer.data;\n        const vertexDirtyId = verticesBuffer._updateID;\n\n        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        if (this.vertexData.length !== vertices.length)\n        {\n            this.vertexData = new Float32Array(vertices.length);\n        }\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const vertexData = this.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            vertexData[(i * 2)] = (a * x) + (c * y) + tx;\n            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;\n        }\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);\n            }\n        }\n\n        this.vertexDirty = vertexDirtyId;\n    }\n\n    /** Updates uv field based on from geometry uv's or batchUvs. */\n    public calculateUvs(): void\n    {\n        const geomUvs = this.geometry.buffers[1];\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (!shader.uvMatrix.isSimple)\n        {\n            if (!this.batchUvs)\n            {\n                this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n            }\n            this.batchUvs.update();\n            this.uvs = this.batchUvs.data;\n        }\n        else\n        {\n            this.uvs = geomUvs.data as Float32Array;\n        }\n    }\n\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n     */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n\n        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n     * @param point - The point to test.\n     * @returns - The result of the test.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.geometry.getBuffer('aVertexPosition').data;\n\n        const points = tempPolygon.points;\n        const indices =  this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.drawMode === 4 ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        if (this._cachedTexture)\n        {\n            this._cachedTexture.destroy();\n            this._cachedTexture = null;\n        }\n\n        this.geometry = null;\n        this.shader = null;\n        this.state = null;\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = null;\n    }\n\n    /** The maximum number of vertices to consider batchable. Generally, the complexity of the geometry. */\n    public static BATCHABLE_SIZE = 100;\n}\n","import { Program, Shader, TextureMatrix } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\nimport { premultiplyTintToRgba } from '@pixi/utils';\nimport fragment from './shader/mesh.frag';\nimport vertex from './shader/mesh.vert';\n\nimport type { Texture } from '@pixi/core';\nimport type { Dict } from '@pixi/utils';\n\nexport interface IMeshMaterialOptions\n{\n    alpha?: number;\n    tint?: number;\n    pluginName?: string;\n    program?: Program;\n    uniforms?: Dict<unknown>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MeshMaterial extends GlobalMixins.MeshMaterial {}\n\n/**\n * Slightly opinionated default shader for PixiJS 2D objects.\n * @memberof PIXI\n */\nexport class MeshMaterial extends Shader\n{\n    /**\n     * TextureMatrix instance for this Mesh, used to track Texture changes.\n     * @readonly\n     */\n    public readonly uvMatrix: TextureMatrix;\n\n    /**\n     * `true` if shader can be batch with the renderer's batch system.\n     * @default true\n     */\n    public batchable: boolean;\n\n    /**\n     * Renderer plugin for batching.\n     * @default 'batch'\n     */\n    public pluginName: string;\n\n    // Internal-only properties\n    _tintRGB: number;\n\n    /**\n     * Only do update if tint or alpha changes.\n     * @private\n     * @default false\n     */\n    private _colorDirty: boolean;\n    private _alpha: number;\n    private _tint: number;\n\n    /**\n     * @param uSampler - Texture that material uses to render.\n     * @param options - Additional options\n     * @param {number} [options.alpha=1] - Default alpha.\n     * @param {number} [options.tint=0xFFFFFF] - Default tint.\n     * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.\n     * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.\n     * @param {object} [options.uniforms] - Custom uniforms.\n     */\n    constructor(uSampler: Texture, options?: IMeshMaterialOptions)\n    {\n        const uniforms = {\n            uSampler,\n            alpha: 1,\n            uTextureMatrix: Matrix.IDENTITY,\n            uColor: new Float32Array([1, 1, 1, 1]),\n        };\n\n        // Set defaults\n        options = Object.assign({\n            tint: 0xFFFFFF,\n            alpha: 1,\n            pluginName: 'batch',\n        }, options);\n\n        if (options.uniforms)\n        {\n            Object.assign(uniforms, options.uniforms);\n        }\n\n        super(options.program || Program.from(vertex, fragment), uniforms);\n\n        this._colorDirty = false;\n\n        this.uvMatrix = new TextureMatrix(uSampler);\n        this.batchable = options.program === undefined;\n        this.pluginName = options.pluginName;\n\n        this.tint = options.tint;\n        this.alpha = options.alpha;\n    }\n\n    /** Reference to the texture being rendered. */\n    get texture(): Texture\n    {\n        return this.uniforms.uSampler;\n    }\n    set texture(value: Texture)\n    {\n        if (this.uniforms.uSampler !== value)\n        {\n            if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode)\n            {\n                this._colorDirty = true;\n            }\n\n            this.uniforms.uSampler = value;\n            this.uvMatrix.texture = value;\n        }\n    }\n\n    /**\n     * This gets automatically set by the object using this.\n     * @default 1\n     */\n    set alpha(value: number)\n    {\n        if (value === this._alpha) return;\n\n        this._alpha = value;\n        this._colorDirty = true;\n    }\n    get alpha(): number\n    {\n        return this._alpha;\n    }\n\n    /**\n     * Multiply tint for the material.\n     * @default 0xFFFFFF\n     */\n    set tint(value: number)\n    {\n        if (value === this._tint) return;\n\n        this._tint = value;\n        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n        this._colorDirty = true;\n    }\n    get tint(): number\n    {\n        return this._tint;\n    }\n\n    /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link MeshMaterial} objects. */\n    public update(): void\n    {\n        if (this._colorDirty)\n        {\n            this._colorDirty = false;\n            const baseTexture = this.texture.baseTexture;\n\n            premultiplyTintToRgba(\n                this._tint, this._alpha, this.uniforms.uColor, (baseTexture.alphaMode as unknown as boolean)\n            );\n        }\n        if (this.uvMatrix.update())\n        {\n            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n        }\n    }\n}\n","import { TYPES } from '@pixi/constants';\nimport { Buffer, Geometry } from '@pixi/core';\n\nimport type { IArrayBuffer } from '@pixi/core';\n\n/**\n * Standard 2D geometry used in PixiJS.\n *\n * Geometry can be defined without passing in a style or data if required.\n *\n * ```js\n * const geometry = new PIXI.Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0,0,1,0,1,1,0,1], 2);\n * geometry.addIndex([0,1,2,1,3,2]);\n *\n * ```\n * @memberof PIXI\n */\nexport class MeshGeometry extends Geometry\n{\n    // Internal-only properties\n    /**\n     * Dirty flag to limit update calls on Mesh. For example,\n     * limiting updates on a single Mesh instance with a shared Geometry\n     * within the render loop.\n     * @private\n     * @default -1\n     */\n    _updateId: number;\n\n    /**\n     * @param {Float32Array|number[]} [vertices] - Positional data on geometry.\n     * @param {Float32Array|number[]} [uvs] - Texture UVs.\n     * @param {Uint16Array|number[]} [index] - IndexBuffer\n     */\n    constructor(vertices?: IArrayBuffer, uvs?: IArrayBuffer, index?: IArrayBuffer)\n    {\n        super();\n\n        const verticesBuffer = new Buffer(vertices);\n        const uvsBuffer = new Buffer(uvs, true);\n        const indexBuffer = new Buffer(index, true, true);\n\n        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTextureCoord', uvsBuffer, 2, false, TYPES.FLOAT)\n            .addIndex(indexBuffer);\n\n        this._updateId = -1;\n    }\n\n    /**\n     * If the vertex position is updated.\n     * @readonly\n     * @private\n     */\n    get vertexDirtyId(): number\n    {\n        return this.buffers[0]._updateID;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}