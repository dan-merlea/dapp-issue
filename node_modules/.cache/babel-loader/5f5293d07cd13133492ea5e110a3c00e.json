{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _construct = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/construct.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeMapper = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar address_1 = require(\"./address\");\nvar boolean_1 = require(\"./boolean\");\nvar bytes_1 = require(\"./bytes\");\nvar composite_1 = require(\"./composite\");\nvar enum_1 = require(\"./enum\");\nvar generic_1 = require(\"./generic\");\nvar h256_1 = require(\"./h256\");\nvar numerical_1 = require(\"./numerical\");\nvar struct_1 = require(\"./struct\");\nvar fields_1 = require(\"./fields\");\nvar tokenIdentifier_1 = require(\"./tokenIdentifier\");\nvar variadic_1 = require(\"./variadic\");\nvar algebraic_1 = require(\"./algebraic\");\nvar genericArray_1 = require(\"./genericArray\");\nvar string_1 = require(\"./string\");\nvar tuple_1 = require(\"./tuple\");\nvar codeMetadata_1 = require(\"./codeMetadata\");\nvar nothing_1 = require(\"./nothing\");\nvar TypeMapper = /*#__PURE__*/function () {\n  function TypeMapper() {\n    var learnedTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, TypeMapper);\n    this.openTypesFactories = new Map([[\"Option\", function () {\n      return new generic_1.OptionType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"List\", function () {\n      return new generic_1.ListType(arguments.length <= 0 ? undefined : arguments[0]);\n    }],\n    // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n    [\"VarArgs\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"MultiResultVec\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"variadic\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalArg\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"optional\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalResult\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"multi\", function () {\n      for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n        typeParameters[_key] = arguments[_key];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"MultiArg\", function () {\n      for (var _len2 = arguments.length, typeParameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeParameters[_key2] = arguments[_key2];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"MultiResult\", function () {\n      for (var _len3 = arguments.length, typeParameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeParameters[_key3] = arguments[_key3];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"multi\", function () {\n      for (var _len4 = arguments.length, typeParameters = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeParameters[_key4] = arguments[_key4];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }],\n    // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n    [\"tuple\", function () {\n      for (var _len5 = arguments.length, typeParameters = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeParameters[_key5] = arguments[_key5];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple2\", function () {\n      for (var _len6 = arguments.length, typeParameters = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeParameters[_key6] = arguments[_key6];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple3\", function () {\n      for (var _len7 = arguments.length, typeParameters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        typeParameters[_key7] = arguments[_key7];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple4\", function () {\n      for (var _len8 = arguments.length, typeParameters = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        typeParameters[_key8] = arguments[_key8];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple5\", function () {\n      for (var _len9 = arguments.length, typeParameters = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        typeParameters[_key9] = arguments[_key9];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple6\", function () {\n      for (var _len10 = arguments.length, typeParameters = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        typeParameters[_key10] = arguments[_key10];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple7\", function () {\n      for (var _len11 = arguments.length, typeParameters = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        typeParameters[_key11] = arguments[_key11];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple8\", function () {\n      for (var _len12 = arguments.length, typeParameters = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        typeParameters[_key12] = arguments[_key12];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }],\n    // Known-length arrays.\n    // TODO: Handle these in typeExpressionParser!\n    [\"array20\", function () {\n      return new genericArray_1.ArrayVecType(20, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array32\", function () {\n      return new genericArray_1.ArrayVecType(32, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array46\", function () {\n      return new genericArray_1.ArrayVecType(46, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array64\", function () {\n      return new genericArray_1.ArrayVecType(64, arguments.length <= 0 ? undefined : arguments[0]);\n    }]]);\n    // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).\n    this.closedTypesMap = new Map([[\"u8\", new numerical_1.U8Type()], [\"u16\", new numerical_1.U16Type()], [\"u32\", new numerical_1.U32Type()], [\"u64\", new numerical_1.U64Type()], [\"U64\", new numerical_1.U64Type()], [\"BigUint\", new numerical_1.BigUIntType()], [\"i8\", new numerical_1.I8Type()], [\"i16\", new numerical_1.I16Type()], [\"i32\", new numerical_1.I32Type()], [\"i64\", new numerical_1.I64Type()], [\"Bigint\", new numerical_1.BigIntType()], [\"BigInt\", new numerical_1.BigIntType()], [\"bool\", new boolean_1.BooleanType()], [\"bytes\", new bytes_1.BytesType()], [\"Address\", new address_1.AddressType()], [\"H256\", new h256_1.H256Type()], [\"utf-8 string\", new string_1.StringType()], [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()], [\"EgldOrEsdtTokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()], [\"CodeMetadata\", new codeMetadata_1.CodeMetadataType()], [\"nothing\", new nothing_1.NothingType()], [\"AsyncCall\", new nothing_1.NothingType()]]);\n    this.learnedTypesMap = new Map();\n    // Boostrap from previously learned types, if any.\n    var _iterator = _createForOfIteratorHelper(learnedTypes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        this.learnedTypesMap.set(type.getName(), type);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  _createClass(TypeMapper, [{\n    key: \"mapType\",\n    value: function mapType(type) {\n      var mappedType = this.mapRecursiveType(type);\n      if (mappedType) {\n        // We do not learn generic types (that also have type parameters)\n        if (!mappedType.isGenericType()) {\n          this.learnType(mappedType);\n        }\n        return mappedType;\n      }\n      throw new errors.ErrTypingSystem(\"Cannot map the type \\\"\".concat(type.getName(), \"\\\" to a known type\"));\n    }\n  }, {\n    key: \"mapRecursiveType\",\n    value: function mapRecursiveType(type) {\n      var isGeneric = type.isGenericType();\n      var previouslyLearnedType = this.learnedTypesMap.get(type.getName());\n      if (previouslyLearnedType) {\n        return previouslyLearnedType;\n      }\n      var knownClosedType = this.closedTypesMap.get(type.getName());\n      if (knownClosedType) {\n        return knownClosedType;\n      }\n      if (type.hasExactClass(enum_1.EnumType.ClassName)) {\n        // This will call mapType() recursively, for all the enum variant fields.\n        return this.mapEnumType(type);\n      }\n      if (type.hasExactClass(struct_1.StructType.ClassName)) {\n        // This will call mapType() recursively, for all the struct's fields.\n        return this.mapStructType(type);\n      }\n      if (isGeneric) {\n        // This will call mapType() recursively, for all the type parameters.\n        return this.mapGenericType(type);\n      }\n      return null;\n    }\n  }, {\n    key: \"learnType\",\n    value: function learnType(type) {\n      this.learnedTypesMap.delete(type.getName());\n      this.learnedTypesMap.set(type.getName(), type);\n    }\n  }, {\n    key: \"mapStructType\",\n    value: function mapStructType(type) {\n      var mappedFields = this.mappedFields(type.getFieldsDefinitions());\n      var mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n      return mappedStruct;\n    }\n  }, {\n    key: \"mapEnumType\",\n    value: function mapEnumType(type) {\n      var _this = this;\n      var variants = type.variants.map(function (variant) {\n        return new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, _this.mappedFields(variant.getFieldsDefinitions()));\n      });\n      var mappedEnum = new enum_1.EnumType(type.getName(), variants);\n      return mappedEnum;\n    }\n  }, {\n    key: \"mappedFields\",\n    value: function mappedFields(definitions) {\n      var _this2 = this;\n      return definitions.map(function (definition) {\n        return new fields_1.FieldDefinition(definition.name, definition.description, _this2.mapType(definition.type));\n      });\n    }\n  }, {\n    key: \"mapGenericType\",\n    value: function mapGenericType(type) {\n      var _this3 = this;\n      var typeParameters = type.getTypeParameters();\n      var mappedTypeParameters = typeParameters.map(function (item) {\n        return _this3.mapType(item);\n      });\n      var factory = this.openTypesFactories.get(type.getName());\n      if (!factory) {\n        throw new errors.ErrTypingSystem(\"Cannot map the generic type \\\"\".concat(type.getName(), \"\\\" to a known type\"));\n      }\n      return factory.apply(void 0, _toConsumableArray(mappedTypeParameters));\n    }\n  }]);\n  return TypeMapper;\n}();\nexports.TypeMapper = TypeMapper;","map":{"version":3,"mappings":"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","names":["TypeMapper","learnedTypes","openTypesFactories","Map","generic_1","variadic_1","algebraic_1","typeParameters","composite_1","tuple_1","genericArray_1","closedTypesMap","numerical_1","boolean_1","bytes_1","address_1","h256_1","string_1","tokenIdentifier_1","codeMetadata_1","nothing_1","learnedTypesMap","type","set","getName","mappedType","mapRecursiveType","isGenericType","learnType","errors","ErrTypingSystem","isGeneric","previouslyLearnedType","get","knownClosedType","hasExactClass","enum_1","ClassName","mapEnumType","struct_1","mapStructType","mapGenericType","delete","mappedFields","getFieldsDefinitions","mappedStruct","variants","map","variant","name","discriminant","mappedEnum","definitions","definition","fields_1","description","mapType","getTypeParameters","mappedTypeParameters","item","factory","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/typeMapper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}