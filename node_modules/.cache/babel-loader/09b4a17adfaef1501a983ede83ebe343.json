{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { AbstractMultiResource } from './AbstractMultiResource.mjs';\nimport { TARGETS } from '@pixi/constants';\nvar _CubeResource = /*#__PURE__*/function (_AbstractMultiResourc) {\n  _inherits(_CubeResource, _AbstractMultiResourc);\n  var _super = _createSuper(_CubeResource);\n  function _CubeResource(source, options) {\n    var _this;\n    _classCallCheck(this, _CubeResource);\n    var _ref = options || {},\n      width = _ref.width,\n      height = _ref.height,\n      autoLoad = _ref.autoLoad,\n      linkBaseTexture = _ref.linkBaseTexture;\n    if (source && source.length !== _CubeResource.SIDES) {\n      throw new Error(\"Invalid length. Got \".concat(source.length, \", expected 6\"));\n    }\n    _this = _super.call(this, 6, {\n      width: width,\n      height: height\n    });\n    for (var i = 0; i < _CubeResource.SIDES; i++) {\n      _this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n    }\n    _this.linkBaseTexture = linkBaseTexture !== false;\n    if (source) {\n      _this.initFromArray(source, options);\n    }\n    if (autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  _createClass(_CubeResource, [{\n    key: \"bind\",\n    value: function bind(baseTexture) {\n      _get(_getPrototypeOf(_CubeResource.prototype), \"bind\", this).call(this, baseTexture);\n      baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n    }\n  }, {\n    key: \"addBaseTextureAt\",\n    value: function addBaseTextureAt(baseTexture, index, linkBaseTexture) {\n      if (linkBaseTexture === void 0) {\n        linkBaseTexture = this.linkBaseTexture;\n      }\n      if (!this.items[index]) {\n        throw new Error(\"Index \".concat(index, \" is out of bounds\"));\n      }\n      if (!this.linkBaseTexture || baseTexture.parentTextureArray || Object.keys(baseTexture._glTextures).length > 0) {\n        if (baseTexture.resource) {\n          this.addResourceAt(baseTexture.resource, index);\n        } else {\n          throw new Error(\"CubeResource does not support copying of renderTexture.\");\n        }\n      } else {\n        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n        baseTexture.parentTextureArray = this.baseTexture;\n        this.items[index] = baseTexture;\n      }\n      if (baseTexture.valid && !this.valid) {\n        this.resize(baseTexture.realWidth, baseTexture.realHeight);\n      }\n      this.items[index] = baseTexture;\n      return this;\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(renderer, _baseTexture, glTexture) {\n      var dirty = this.itemDirtyIds;\n      for (var i = 0; i < _CubeResource.SIDES; i++) {\n        var side = this.items[i];\n        if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) {\n          if (side.valid && side.resource) {\n            side.resource.upload(renderer, side, glTexture);\n            dirty[i] = side.dirtyId;\n          } else if (dirty[i] < -1) {\n            renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null);\n            dirty[i] = -1;\n          }\n        }\n      }\n      return true;\n    }\n  }], [{\n    key: \"test\",\n    value: function test(source) {\n      return Array.isArray(source) && source.length === _CubeResource.SIDES;\n    }\n  }]);\n  return _CubeResource;\n}(AbstractMultiResource);\nvar CubeResource = _CubeResource;\nCubeResource.SIDES = 6;\nexport { CubeResource };","map":{"version":3,"sources":["../../../src/textures/resources/CubeResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractMultiResource } from './AbstractMultiResource';\nimport { TARGETS } from '@pixi/constants';\n\nimport type { Resource } from './Resource';\nimport type { ISize } from '@pixi/math';\nimport type { ArrayFixed } from '@pixi/utils';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { Renderer } from '../../Renderer';\nimport type { GLTexture } from '../GLTexture';\n\n/** Constructor options for CubeResource */\nexport interface ICubeResourceOptions extends ISize\n{\n    /** Whether to auto-load resources */\n    autoLoad?: boolean;\n\n    /** In case BaseTextures are supplied, whether to copy them or use. */\n    linkBaseTexture?: boolean;\n}\n\n/**\n * Resource for a CubeTexture which contains six resources.\n * @memberof PIXI\n */\nexport class CubeResource extends AbstractMultiResource\n{\n    items: ArrayFixed<BaseTexture, 6>;\n\n    /**\n     * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself.\n     * @protected\n     */\n    linkBaseTexture: boolean;\n\n    /**\n     * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n     *        to use as the sides of the cube.\n     * @param options - ImageResource options\n     * @param {number} [options.width] - Width of resource\n     * @param {number} [options.height] - Height of resource\n     * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n     * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n     *   whether to copy them or use\n     */\n    constructor(source?: ArrayFixed<string | Resource, 6>, options?: ICubeResourceOptions)\n    {\n        const { width, height, autoLoad, linkBaseTexture } = options || {};\n\n        if (source && source.length !== CubeResource.SIDES)\n        {\n            throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n        }\n\n        super(6, { width, height });\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n        }\n\n        this.linkBaseTexture = linkBaseTexture !== false;\n\n        if (source)\n        {\n            this.initFromArray(source, options);\n        }\n\n        if (autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Add binding.\n     * @param baseTexture - parent base texture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n    }\n\n    addBaseTextureAt(baseTexture: BaseTexture, index: number, linkBaseTexture?: boolean): this\n    {\n        if (linkBaseTexture === undefined)\n        {\n            linkBaseTexture = this.linkBaseTexture;\n        }\n\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        if (!this.linkBaseTexture\n            || baseTexture.parentTextureArray\n            || Object.keys(baseTexture._glTextures).length > 0)\n        {\n            // copy mode\n            if (baseTexture.resource)\n            {\n                this.addResourceAt(baseTexture.resource, index);\n            }\n            else\n            {\n                throw new Error(`CubeResource does not support copying of renderTexture.`);\n            }\n        }\n        else\n        {\n            // link mode, the difficult one!\n            baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n            baseTexture.parentTextureArray = this.baseTexture;\n\n            this.items[index] = baseTexture;\n        }\n\n        if (baseTexture.valid && !this.valid)\n        {\n            this.resize(baseTexture.realWidth, baseTexture.realHeight);\n        }\n\n        this.items[index] = baseTexture;\n\n        return this;\n    }\n\n    /**\n     * Upload the resource\n     * @param renderer\n     * @param _baseTexture\n     * @param glTexture\n     * @returns {boolean} true is success\n     */\n    upload(renderer: Renderer, _baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const dirty = this.itemDirtyIds;\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            const side = this.items[i];\n\n            if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId)\n            {\n                if (side.valid && side.resource)\n                {\n                    side.resource.upload(renderer, side, glTexture);\n                    dirty[i] = side.dirtyId;\n                }\n                else if (dirty[i] < -1)\n                {\n                    // either item is not valid yet, either its a renderTexture\n                    // allocate the memory\n                    renderer.gl.texImage2D(side.target, 0,\n                        glTexture.internalFormat,\n                        _baseTexture.realWidth,\n                        _baseTexture.realHeight,\n                        0,\n                        _baseTexture.format,\n                        glTexture.type,\n                        null);\n                    dirty[i] = -1;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** Number of texture sides to store for CubeResources. */\n    static SIDES = 6;\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if source is an array of 6 elements\n     */\n    static test(source: unknown): source is ArrayFixed<string | Resource, 6>\n    {\n        return Array.isArray(source) && source.length === CubeResource.SIDES;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}