{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar assets = require('@pixi/assets');\nrequire('../parsers/index.js');\nvar parseDDS = require('../parsers/parseDDS.js');\nvar loadDDS = {\n  extension: {\n    type: core.ExtensionType.LoadParser,\n    priority: assets.LoaderParserPriority.High\n  },\n  test: function test(url) {\n    return assets.checkExtension(url, \".dds\");\n  },\n  load: function load(url, asset, loader) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var response, arrayBuffer, resources, textures;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return core.settings.ADAPTER.fetch(url);\n            case 2:\n              response = _context.sent;\n              _context.next = 5;\n              return response.arrayBuffer();\n            case 5:\n              arrayBuffer = _context.sent;\n              resources = parseDDS.parseDDS(arrayBuffer);\n              textures = resources.map(function (resource) {\n                var base = new core.BaseTexture(resource, _objectSpread({\n                  mipmap: core.MIPMAP_MODES.OFF,\n                  alphaMode: core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                  resolution: core.utils.getResolutionOfUrl(url)\n                }, asset.data));\n                return assets.createTexture(base, loader, url);\n              });\n              return _context.abrupt(\"return\", textures.length === 1 ? textures[0] : textures);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  unload: function unload(texture) {\n    if (Array.isArray(texture)) {\n      texture.forEach(function (t) {\n        return t.destroy(true);\n      });\n    } else {\n      texture.destroy(true);\n    }\n  }\n};\ncore.extensions.add(loadDDS);\nexports.loadDDS = loadDDS;","map":{"version":3,"sources":["../../src/loaders/loadDDS.ts"],"names":["ExtensionType","LoaderParserPriority","settings","parseDDS","BaseTexture","MIPMAP_MODES","ALPHA_MODES","utils","extensions"],"mappings":";;;;;;;;;;;;AAQO,IAAM,OAAwB,GAAA;EACjC,SAAW,EAAA;IACP,IAAA,EAAMA,IAAAA,CAAAA,aAAc,CAAA,UAAA;IACpB,QAAA,EAAUC,MAAAA,CAAAA,oBAAqB,CAAA;EAAA,CACnC;EAEA,IAAA,gBAAK,GACL,EAAA;IACW,OAAA,MAAA,CAAA,cAAA,CAAe,GAAA,EAAK,MAAM,CAAA;EAAA,CACrC;EAEM,IAAA,gBAAK,GAAa,EAAA,KAAA,EAAkB,MAC1C,EAAA;IAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OAE2BC,IAAAA,CAAAA,QAAS,CAAA,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA;YAAA;cAA3C,QAAW;cAAA;cAAA,OAES,QAAA,CAAS,WAAY,EAAA;YAAA;cAAzC,WAAA;cAEA,SAAA,GAAYC,QAAAA,CAAAA,QAAAA,CAAS,WAAW,CAAA;cAEhC,QAAW,GAAA,SAAA,CAAU,GAAI,CAAA,UAAC,QAChC,EAAA;gBACU,IAAA,IAAA,GAAO,IAAIC,IAAAA,CAAAA,WAAAA,CAAY,QAAU;kBACnC,MAAA,EAAQC,IAAAA,CAAAA,YAAa,CAAA,GAAA;kBACrB,SAAA,EAAWC,IAAAA,CAAAA,WAAY,CAAA,sBAAA;kBACvB,UAAA,EAAYC,IAAAA,CAAAA,KAAM,CAAA,kBAAA,CAAmB,GAAG;gBAAA,GACrC,KAAM,CAAA,IAAA,EACZ;gBAEM,OAAA,MAAA,CAAA,aAAA,CAAc,IAAM,EAAA,MAAA,EAAQ,GAAG,CAAA;cAAA,CACzC,CAAA;cAAA,iCAEM,QAAS,CAAA,MAAA,KAAW,CAAI,GAAA,QAAA,CAAS,CAAK,CAAA,GAAA,QAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EAAA,CACjD;EAEA,MAAA,kBAAO,OACP,EAAA;IACQ,IAAA,KAAA,CAAM,OAAQ,CAAA,OAAO,CACzB,EAAA;MACI,OAAA,CAAQ,OAAA,CAAQ,UAAC,CAAA;QAAA,OAAM,CAAE,CAAA,OAAA,CAAQ,IAAI,CAAC;MAAA,EAAA;IAAA,CAG1C,MAAA;MACI,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA;IAAA;EACxB;AAGR,CAAA;AAEAC,IAAAA,CAAAA,UAAAA,CAAW,GAAA,CAAI,OAAO,CAAA","sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils, ALPHA_MODES, MIPMAP_MODES } from '@pixi/core';\nimport { checkExtension, createTexture, LoaderParserPriority } from '@pixi/assets';\nimport { parseDDS } from '../parsers';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { LoadAsset, Loader, LoaderParser } from '@pixi/assets';\n\n/** Load our DDS textures! */\nexport const loadDDS: LoaderParser = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    test(url: string): boolean\n    {\n        return checkExtension(url, '.dds');\n    },\n\n    async load(url: string, asset: LoadAsset, loader: Loader): Promise<Texture | Texture[]>\n    {\n        // get an array buffer...\n        const response = await settings.ADAPTER.fetch(url);\n\n        const arrayBuffer = await response.arrayBuffer();\n\n        const resources = parseDDS(arrayBuffer);\n\n        const textures = resources.map((resource) =>\n        {\n            const base = new BaseTexture(resource, {\n                mipmap: MIPMAP_MODES.OFF,\n                alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                resolution: utils.getResolutionOfUrl(url),\n                ...asset.data,\n            });\n\n            return createTexture(base, loader, url);\n        });\n\n        return textures.length === 1 ? textures[0] : textures;\n    },\n\n    unload(texture: Texture | Texture[]): void\n    {\n        if (Array.isArray(texture))\n        {\n            texture.forEach((t) => t.destroy(true));\n        }\n        else\n        {\n            texture.destroy(true);\n        }\n    }\n\n} as LoaderParser<Texture | Texture[], IBaseTextureOptions>;\n\nextensions.add(loadDDS);\n"]},"metadata":{},"sourceType":"script"}