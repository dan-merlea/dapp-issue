{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EventBoundary } from './EventBoundary.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\nimport { ExtensionType, extensions } from '@pixi/core';\nvar MOUSE_POINTER_ID = 1;\nvar TOUCH_TO_POINTER = {\n  touchstart: \"pointerdown\",\n  touchend: \"pointerup\",\n  touchendoutside: \"pointerupoutside\",\n  touchmove: \"pointermove\",\n  touchcancel: \"pointercancel\"\n};\nvar EventSystem = /*#__PURE__*/function () {\n  function EventSystem(renderer) {\n    _classCallCheck(this, EventSystem);\n    this.supportsTouchEvents = \"ontouchstart\" in globalThis;\n    this.supportsPointerEvents = !!globalThis.PointerEvent;\n    this.domElement = null;\n    this.resolution = 1;\n    this.renderer = renderer;\n    this.rootBoundary = new EventBoundary(null);\n    this.autoPreventDefault = true;\n    this.eventsAdded = false;\n    this.rootPointerEvent = new FederatedPointerEvent(null);\n    this.rootWheelEvent = new FederatedWheelEvent(null);\n    this.cursorStyles = {\n      default: \"inherit\",\n      pointer: \"pointer\"\n    };\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.onPointerOverOut = this.onPointerOverOut.bind(this);\n    this.onWheel = this.onWheel.bind(this);\n  }\n  _createClass(EventSystem, [{\n    key: \"init\",\n    value: function init() {\n      var _this$renderer = this.renderer,\n        view = _this$renderer.view,\n        resolution = _this$renderer.resolution;\n      this.setTargetElement(view);\n      this.resolution = resolution;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.setTargetElement(null);\n      this.renderer = null;\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(mode) {\n      mode = mode || \"default\";\n      var applyStyles = true;\n      if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {\n        applyStyles = false;\n      }\n      if (this.currentCursor === mode) {\n        return;\n      }\n      this.currentCursor = mode;\n      var style = this.cursorStyles[mode];\n      if (style) {\n        switch (typeof style) {\n          case \"string\":\n            if (applyStyles) {\n              this.domElement.style.cursor = style;\n            }\n            break;\n          case \"function\":\n            style(mode);\n            break;\n          case \"object\":\n            if (applyStyles) {\n              Object.assign(this.domElement.style, style);\n            }\n            break;\n        }\n      } else if (applyStyles && typeof mode === \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        this.domElement.style.cursor = mode;\n      }\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(nativeEvent) {\n      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n      if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n      var events = this.normalizeToPointerData(nativeEvent);\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        var cancelable = nativeEvent.cancelable || !(\"cancelable\" in nativeEvent);\n        if (cancelable) {\n          nativeEvent.preventDefault();\n        }\n      }\n      for (var i = 0, j = events.length; i < j; i++) {\n        var nativeEvent2 = events[i];\n        var federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);\n        this.rootBoundary.mapEvent(federatedEvent);\n      }\n      this.setCursor(this.rootBoundary.cursor);\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(nativeEvent) {\n      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n      if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n      var normalizedEvents = this.normalizeToPointerData(nativeEvent);\n      for (var i = 0, j = normalizedEvents.length; i < j; i++) {\n        var event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n        this.rootBoundary.mapEvent(event);\n      }\n      this.setCursor(this.rootBoundary.cursor);\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(nativeEvent) {\n      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n      if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n      var target = nativeEvent.target;\n      if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {\n        target = nativeEvent.composedPath()[0];\n      }\n      var outside = target !== this.domElement ? \"outside\" : \"\";\n      var normalizedEvents = this.normalizeToPointerData(nativeEvent);\n      for (var i = 0, j = normalizedEvents.length; i < j; i++) {\n        var event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n        event.type += outside;\n        this.rootBoundary.mapEvent(event);\n      }\n      this.setCursor(this.rootBoundary.cursor);\n    }\n  }, {\n    key: \"onPointerOverOut\",\n    value: function onPointerOverOut(nativeEvent) {\n      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n      if (this.supportsTouchEvents && nativeEvent.pointerType === \"touch\") return;\n      var normalizedEvents = this.normalizeToPointerData(nativeEvent);\n      for (var i = 0, j = normalizedEvents.length; i < j; i++) {\n        var event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n        this.rootBoundary.mapEvent(event);\n      }\n      this.setCursor(this.rootBoundary.cursor);\n    }\n  }, {\n    key: \"onWheel\",\n    value: function onWheel(nativeEvent) {\n      var wheelEvent = this.normalizeWheelEvent(nativeEvent);\n      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n      this.rootBoundary.mapEvent(wheelEvent);\n    }\n  }, {\n    key: \"setTargetElement\",\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.domElement = element;\n      this.addEvents();\n    }\n  }, {\n    key: \"addEvents\",\n    value: function addEvents() {\n      if (this.eventsAdded || !this.domElement) {\n        return;\n      }\n      var style = this.domElement.style;\n      if (style) {\n        if (globalThis.navigator.msPointerEnabled) {\n          style.msContentZooming = \"none\";\n          style.msTouchAction = \"none\";\n        } else if (this.supportsPointerEvents) {\n          style.touchAction = \"none\";\n        }\n      }\n      if (this.supportsPointerEvents) {\n        globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, true);\n        this.domElement.addEventListener(\"pointerdown\", this.onPointerDown, true);\n        this.domElement.addEventListener(\"pointerleave\", this.onPointerOverOut, true);\n        this.domElement.addEventListener(\"pointerover\", this.onPointerOverOut, true);\n        globalThis.addEventListener(\"pointerup\", this.onPointerUp, true);\n      } else {\n        globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, true);\n        this.domElement.addEventListener(\"mousedown\", this.onPointerDown, true);\n        this.domElement.addEventListener(\"mouseout\", this.onPointerOverOut, true);\n        this.domElement.addEventListener(\"mouseover\", this.onPointerOverOut, true);\n        globalThis.addEventListener(\"mouseup\", this.onPointerUp, true);\n      }\n      if (this.supportsTouchEvents) {\n        this.domElement.addEventListener(\"touchstart\", this.onPointerDown, true);\n        this.domElement.addEventListener(\"touchend\", this.onPointerUp, true);\n        this.domElement.addEventListener(\"touchmove\", this.onPointerMove, true);\n      }\n      this.domElement.addEventListener(\"wheel\", this.onWheel, {\n        passive: true,\n        capture: true\n      });\n      this.eventsAdded = true;\n    }\n  }, {\n    key: \"removeEvents\",\n    value: function removeEvents() {\n      if (!this.eventsAdded || !this.domElement) {\n        return;\n      }\n      var style = this.domElement.style;\n      if (globalThis.navigator.msPointerEnabled) {\n        style.msContentZooming = \"\";\n        style.msTouchAction = \"\";\n      } else if (this.supportsPointerEvents) {\n        style.touchAction = \"\";\n      }\n      if (this.supportsPointerEvents) {\n        globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, true);\n        this.domElement.removeEventListener(\"pointerdown\", this.onPointerDown, true);\n        this.domElement.removeEventListener(\"pointerleave\", this.onPointerOverOut, true);\n        this.domElement.removeEventListener(\"pointerover\", this.onPointerOverOut, true);\n        globalThis.removeEventListener(\"pointerup\", this.onPointerUp, true);\n      } else {\n        globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, true);\n        this.domElement.removeEventListener(\"mousedown\", this.onPointerDown, true);\n        this.domElement.removeEventListener(\"mouseout\", this.onPointerOverOut, true);\n        this.domElement.removeEventListener(\"mouseover\", this.onPointerOverOut, true);\n        globalThis.removeEventListener(\"mouseup\", this.onPointerUp, true);\n      }\n      if (this.supportsTouchEvents) {\n        this.domElement.removeEventListener(\"touchstart\", this.onPointerDown, true);\n        this.domElement.removeEventListener(\"touchend\", this.onPointerUp, true);\n        this.domElement.removeEventListener(\"touchmove\", this.onPointerMove, true);\n      }\n      this.domElement.removeEventListener(\"wheel\", this.onWheel, true);\n      this.domElement = null;\n      this.eventsAdded = false;\n    }\n  }, {\n    key: \"mapPositionToPoint\",\n    value: function mapPositionToPoint(point, x, y) {\n      var rect;\n      if (!this.domElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          width: this.domElement.width,\n          height: this.domElement.height,\n          left: 0,\n          top: 0\n        };\n      } else {\n        rect = this.domElement.getBoundingClientRect();\n      }\n      var resolutionMultiplier = 1 / this.resolution;\n      point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;\n      point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;\n    }\n  }, {\n    key: \"normalizeToPointerData\",\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === \"undefined\") touch.button = 0;\n          if (typeof touch.buttons === \"undefined\") touch.buttons = 1;\n          if (typeof touch.isPrimary === \"undefined\") {\n            touch.isPrimary = event.touches.length === 1 && event.type === \"touchstart\";\n          }\n          if (typeof touch.width === \"undefined\") touch.width = touch.radiusX || 1;\n          if (typeof touch.height === \"undefined\") touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === \"undefined\") touch.tiltX = 0;\n          if (typeof touch.tiltY === \"undefined\") touch.tiltY = 0;\n          if (typeof touch.pointerType === \"undefined\") touch.pointerType = \"touch\";\n          if (typeof touch.pointerId === \"undefined\") touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === \"undefined\") touch.pressure = touch.force || 0.5;\n          if (typeof touch.twist === \"undefined\") touch.twist = 0;\n          if (typeof touch.tangentialPressure === \"undefined\") touch.tangentialPressure = 0;\n          if (typeof touch.layerX === \"undefined\") touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === \"undefined\") touch.layerY = touch.offsetY = touch.clientY;\n          touch.isNormalized = true;\n          touch.type = event.type;\n          normalizedEvents.push(touch);\n        }\n      } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n        var tempEvent = event;\n        if (typeof tempEvent.isPrimary === \"undefined\") tempEvent.isPrimary = true;\n        if (typeof tempEvent.width === \"undefined\") tempEvent.width = 1;\n        if (typeof tempEvent.height === \"undefined\") tempEvent.height = 1;\n        if (typeof tempEvent.tiltX === \"undefined\") tempEvent.tiltX = 0;\n        if (typeof tempEvent.tiltY === \"undefined\") tempEvent.tiltY = 0;\n        if (typeof tempEvent.pointerType === \"undefined\") tempEvent.pointerType = \"mouse\";\n        if (typeof tempEvent.pointerId === \"undefined\") tempEvent.pointerId = MOUSE_POINTER_ID;\n        if (typeof tempEvent.pressure === \"undefined\") tempEvent.pressure = 0.5;\n        if (typeof tempEvent.twist === \"undefined\") tempEvent.twist = 0;\n        if (typeof tempEvent.tangentialPressure === \"undefined\") tempEvent.tangentialPressure = 0;\n        tempEvent.isNormalized = true;\n        normalizedEvents.push(tempEvent);\n      } else {\n        normalizedEvents.push(event);\n      }\n      return normalizedEvents;\n    }\n  }, {\n    key: \"normalizeWheelEvent\",\n    value: function normalizeWheelEvent(nativeEvent) {\n      var event = this.rootWheelEvent;\n      this.transferMouseData(event, nativeEvent);\n      event.deltaMode = nativeEvent.deltaMode;\n      event.deltaX = nativeEvent.deltaX;\n      event.deltaY = nativeEvent.deltaY;\n      event.deltaZ = nativeEvent.deltaZ;\n      this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n      event.global.copyFrom(event.screen);\n      event.offset.copyFrom(event.screen);\n      event.nativeEvent = nativeEvent;\n      event.type = nativeEvent.type;\n      return event;\n    }\n  }, {\n    key: \"bootstrapEvent\",\n    value: function bootstrapEvent(event, nativeEvent) {\n      event.originalEvent = null;\n      event.nativeEvent = nativeEvent;\n      event.pointerId = nativeEvent.pointerId;\n      event.width = nativeEvent.width;\n      event.height = nativeEvent.height;\n      event.isPrimary = nativeEvent.isPrimary;\n      event.pointerType = nativeEvent.pointerType;\n      event.pressure = nativeEvent.pressure;\n      event.tangentialPressure = nativeEvent.tangentialPressure;\n      event.tiltX = nativeEvent.tiltX;\n      event.tiltY = nativeEvent.tiltY;\n      event.twist = nativeEvent.twist;\n      this.transferMouseData(event, nativeEvent);\n      this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n      event.global.copyFrom(event.screen);\n      event.offset.copyFrom(event.screen);\n      event.isTrusted = nativeEvent.isTrusted;\n      if (event.type === \"pointerleave\") {\n        event.type = \"pointerout\";\n      }\n      if (event.type.startsWith(\"mouse\")) {\n        event.type = event.type.replace(\"mouse\", \"pointer\");\n      }\n      if (event.type.startsWith(\"touch\")) {\n        event.type = TOUCH_TO_POINTER[event.type] || event.type;\n      }\n      return event;\n    }\n  }, {\n    key: \"transferMouseData\",\n    value: function transferMouseData(event, nativeEvent) {\n      event.isTrusted = nativeEvent.isTrusted;\n      event.srcElement = nativeEvent.srcElement;\n      event.timeStamp = performance.now();\n      event.type = nativeEvent.type;\n      event.altKey = nativeEvent.altKey;\n      event.button = nativeEvent.button;\n      event.buttons = nativeEvent.buttons;\n      event.client.x = nativeEvent.clientX;\n      event.client.y = nativeEvent.clientY;\n      event.ctrlKey = nativeEvent.ctrlKey;\n      event.metaKey = nativeEvent.metaKey;\n      event.movement.x = nativeEvent.movementX;\n      event.movement.y = nativeEvent.movementY;\n      event.page.x = nativeEvent.pageX;\n      event.page.y = nativeEvent.pageY;\n      event.relatedTarget = null;\n      event.shiftKey = nativeEvent.shiftKey;\n    }\n  }]);\n  return EventSystem;\n}();\nEventSystem.extension = {\n  name: \"events\",\n  type: [ExtensionType.RendererSystem, ExtensionType.CanvasRendererSystem]\n};\nextensions.add(EventSystem);\nexport { EventSystem };","map":{"version":3,"sources":["../src/EventSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventBoundary } from './EventBoundary';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\nimport { extensions, ExtensionType } from '@pixi/core';\n\nimport type { IRenderableObject, ExtensionMetadata, IPointData } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\nimport type { ICanvas } from '@pixi/settings';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\ninterface Renderer\n{\n    lastObjectRendered: IRenderableObject;\n    view: ICanvas;\n    resolution: number;\n    plugins: Record<string, any>;\n}\n\n/**\n * The system for handling UI events.\n * @memberof PIXI\n */\nexport class EventSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.RendererSystem,\n            ExtensionType.CanvasRendererSystem\n        ],\n    };\n\n    /**\n     * The {@link PIXI.EventBoundary} for the stage.\n     *\n     * The {@link PIXI.EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed DisplayObjects).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link PIXI.Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    private currentCursor: string;\n    private rootPointerEvent: FederatedPointerEvent;\n    private rootWheelEvent: FederatedWheelEvent;\n    private eventsAdded: boolean;\n\n    /**\n     * @param {PIXI.Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n\n        this.autoPreventDefault = true;\n        this.eventsAdded = false;\n\n        this.rootPointerEvent = new FederatedPointerEvent(null);\n        this.rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.onPointerOverOut = this.onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    init(): void\n    {\n        const { view, resolution } = this.renderer;\n\n        this.setTargetElement(view as HTMLCanvasElement);\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this.currentCursor === mode)\n        {\n            return;\n        }\n        this.currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (nativeEvent as PointerEvent).pointerType === 'touch') return;\n\n        const normalizedEvents = this.normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered as DisplayObject;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this.removeEvents();\n        this.domElement = element;\n        this.addEvents();\n    }\n\n    /** Register event listeners on {@link PIXI.Renderer#domElement this.domElement}. */\n    private addEvents(): void\n    {\n        if (this.eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this.onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this.onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this.onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this.onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this.onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this.onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this.onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this.onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        // Always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents)\n        {\n            this.domElement.addEventListener('touchstart', this.onPointerDown, true);\n            // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n            this.domElement.addEventListener('touchend', this.onPointerUp, true);\n            this.domElement.addEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this.eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}. */\n    private removeEvents(): void\n    {\n        if (!this.eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if ((globalThis.navigator as any).msPointerEnabled)\n        {\n            style.msContentZooming = '';\n            style.msTouchAction = '';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            style.touchAction = '';\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this.onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this.onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this.onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this.onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this.onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this.onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this.onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this.onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this.onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this.onPointerUp, true);\n        }\n\n        if (this.supportsTouchEvents)\n        {\n            this.domElement.removeEventListener('touchstart', this.onPointerDown, true);\n            // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n            this.domElement.removeEventListener('touchend', this.onPointerUp, true);\n            this.domElement.removeEventListener('touchmove', this.onPointerMove, true);\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this.eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PIXI.IPointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: IPointData, x: number, y: number): void\n    {\n        let rect;\n\n        // IE 11 fix\n        if (!this.domElement.parentElement)\n        {\n            rect = {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n        }\n        else\n        {\n            rect = this.domElement.getBoundingClientRect();\n        }\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this.rootWheelEvent;\n\n        this.transferMouseData(event, nativeEvent);\n\n        event.deltaMode = nativeEvent.deltaMode;\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the {@code nativeEvent} into a federateed {@code FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this.transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n\ninterface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n    type: string;\n}\n\nextensions.add(EventSystem);\n"]},"metadata":{},"sourceType":"module"}