{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar mapTypeAndFormatToInternalFormat = require('./utils/mapTypeAndFormatToInternalFormat.js');\nvar BaseTexture = require('./BaseTexture.js');\nvar GLTexture = require('./GLTexture.js');\nvar utils = require('@pixi/utils');\nvar constants = require('@pixi/constants');\nvar extensions = require('@pixi/extensions');\nvar TextureSystem = /*#__PURE__*/function () {\n  function TextureSystem(renderer) {\n    _classCallCheck(this, TextureSystem);\n    this.renderer = renderer;\n    this.boundTextures = [];\n    this.currentLocation = -1;\n    this.managedTextures = [];\n    this._unknownBoundTextures = false;\n    this.unknownTexture = new BaseTexture.BaseTexture();\n    this.hasIntegerTextures = false;\n  }\n  _createClass(TextureSystem, [{\n    key: \"contextChange\",\n    value: function contextChange() {\n      var gl = this.gl = this.renderer.gl;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n      this.webGLVersion = this.renderer.context.webGLVersion;\n      this.internalFormats = mapTypeAndFormatToInternalFormat.mapTypeAndFormatToInternalFormat(gl);\n      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n      this.boundTextures.length = maxTextures;\n      for (var i = 0; i < maxTextures; i++) {\n        this.boundTextures[i] = null;\n      }\n      this.emptyTextures = {};\n      var emptyTexture2D = new GLTexture.GLTexture(gl.createTexture());\n      gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n      this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture.GLTexture(gl.createTexture());\n      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n      for (var _i = 0; _i < 6; _i++) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      }\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      for (var _i2 = 0; _i2 < this.boundTextures.length; _i2++) {\n        this.bind(null, _i2);\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(texture) {\n      var _texture, _texture2;\n      var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var gl = this.gl;\n      texture = (_texture = texture) === null || _texture === void 0 ? void 0 : _texture.castToBaseTexture();\n      if ((_texture2 = texture) !== null && _texture2 !== void 0 && _texture2.valid && !texture.parentTextureArray) {\n        texture.touched = this.renderer.textureGC.count;\n        var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n        if (this.boundTextures[location] !== texture) {\n          if (this.currentLocation !== location) {\n            this.currentLocation = location;\n            gl.activeTexture(gl.TEXTURE0 + location);\n          }\n          gl.bindTexture(texture.target, glTexture.texture);\n        }\n        if (glTexture.dirtyId !== texture.dirtyId) {\n          if (this.currentLocation !== location) {\n            this.currentLocation = location;\n            gl.activeTexture(gl.TEXTURE0 + location);\n          }\n          this.updateTexture(texture);\n        } else if (glTexture.dirtyStyleId !== texture.dirtyStyleId) {\n          this.updateTextureStyle(texture);\n        }\n        this.boundTextures[location] = texture;\n      } else {\n        if (this.currentLocation !== location) {\n          this.currentLocation = location;\n          gl.activeTexture(gl.TEXTURE0 + location);\n        }\n        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n        this.boundTextures[location] = null;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._unknownBoundTextures = true;\n      this.hasIntegerTextures = false;\n      this.currentLocation = -1;\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        this.boundTextures[i] = this.unknownTexture;\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(texture) {\n      var gl = this.gl,\n        boundTextures = this.boundTextures;\n      if (this._unknownBoundTextures) {\n        this._unknownBoundTextures = false;\n        for (var i = 0; i < boundTextures.length; i++) {\n          if (boundTextures[i] === this.unknownTexture) {\n            this.bind(null, i);\n          }\n        }\n      }\n      for (var _i3 = 0; _i3 < boundTextures.length; _i3++) {\n        if (boundTextures[_i3] === texture) {\n          if (this.currentLocation !== _i3) {\n            gl.activeTexture(gl.TEXTURE0 + _i3);\n            this.currentLocation = _i3;\n          }\n          gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n          boundTextures[_i3] = null;\n        }\n      }\n    }\n  }, {\n    key: \"ensureSamplerType\",\n    value: function ensureSamplerType(maxTextures) {\n      var boundTextures = this.boundTextures,\n        hasIntegerTextures = this.hasIntegerTextures,\n        CONTEXT_UID = this.CONTEXT_UID;\n      if (!hasIntegerTextures) {\n        return;\n      }\n      for (var i = maxTextures - 1; i >= 0; --i) {\n        var tex = boundTextures[i];\n        if (tex) {\n          var glTexture = tex._glTextures[CONTEXT_UID];\n          if (glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT) {\n            this.renderer.texture.unbind(tex);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"initTexture\",\n    value: function initTexture(texture) {\n      var glTexture = new GLTexture.GLTexture(this.gl.createTexture());\n      glTexture.dirtyId = -1;\n      texture._glTextures[this.CONTEXT_UID] = glTexture;\n      this.managedTextures.push(texture);\n      texture.on(\"dispose\", this.destroyTexture, this);\n      return glTexture;\n    }\n  }, {\n    key: \"initTextureType\",\n    value: function initTextureType(texture, glTexture) {\n      var _this$internalFormats, _this$internalFormats2;\n      glTexture.internalFormat = (_this$internalFormats = (_this$internalFormats2 = this.internalFormats[texture.type]) === null || _this$internalFormats2 === void 0 ? void 0 : _this$internalFormats2[texture.format]) !== null && _this$internalFormats !== void 0 ? _this$internalFormats : texture.format;\n      if (this.webGLVersion === 2 && texture.type === constants.TYPES.HALF_FLOAT) {\n        glTexture.type = this.gl.HALF_FLOAT;\n      } else {\n        glTexture.type = texture.type;\n      }\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture(texture) {\n      var _texture$resource;\n      var glTexture = texture._glTextures[this.CONTEXT_UID];\n      if (!glTexture) {\n        return;\n      }\n      var renderer = this.renderer;\n      this.initTextureType(texture, glTexture);\n      if ((_texture$resource = texture.resource) !== null && _texture$resource !== void 0 && _texture$resource.upload(renderer, texture, glTexture)) {\n        if (glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT) {\n          this.hasIntegerTextures = true;\n        }\n      } else {\n        var width = texture.realWidth;\n        var height = texture.realHeight;\n        var gl = renderer.gl;\n        if (glTexture.width !== width || glTexture.height !== height || glTexture.dirtyId < 0) {\n          glTexture.width = width;\n          glTexture.height = height;\n          gl.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null);\n        }\n      }\n      if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {\n        this.updateTextureStyle(texture);\n      }\n      glTexture.dirtyId = texture.dirtyId;\n    }\n  }, {\n    key: \"destroyTexture\",\n    value: function destroyTexture(texture, skipRemove) {\n      var gl = this.gl;\n      texture = texture.castToBaseTexture();\n      if (texture._glTextures[this.CONTEXT_UID]) {\n        this.unbind(texture);\n        gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n        texture.off(\"dispose\", this.destroyTexture, this);\n        delete texture._glTextures[this.CONTEXT_UID];\n        if (!skipRemove) {\n          var i = this.managedTextures.indexOf(texture);\n          if (i !== -1) {\n            utils.removeItems(this.managedTextures, i, 1);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateTextureStyle\",\n    value: function updateTextureStyle(texture) {\n      var _texture$resource2;\n      var glTexture = texture._glTextures[this.CONTEXT_UID];\n      if (!glTexture) {\n        return;\n      }\n      if ((texture.mipmap === constants.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {\n        glTexture.mipmap = false;\n      } else {\n        glTexture.mipmap = texture.mipmap >= 1;\n      }\n      if (this.webGLVersion !== 2 && !texture.isPowerOfTwo) {\n        glTexture.wrapMode = constants.WRAP_MODES.CLAMP;\n      } else {\n        glTexture.wrapMode = texture.wrapMode;\n      }\n      if ((_texture$resource2 = texture.resource) !== null && _texture$resource2 !== void 0 && _texture$resource2.style(this.renderer, texture, glTexture)) {} else {\n        this.setStyle(texture, glTexture);\n      }\n      glTexture.dirtyStyleId = texture.dirtyStyleId;\n    }\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(texture, glTexture) {\n      var gl = this.gl;\n      if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL) {\n        gl.generateMipmap(texture.target);\n      }\n      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n      gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n      if (glTexture.mipmap) {\n        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n        var anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n        if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === constants.SCALE_MODES.LINEAR) {\n          var level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n          gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n        }\n      } else {\n        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n      }\n      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }]);\n  return TextureSystem;\n}();\nTextureSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"texture\"\n};\nextensions.extensions.add(TextureSystem);\nexports.TextureSystem = TextureSystem;","map":{"version":3,"sources":["../../src/textures/TextureSystem.ts"],"names":["ExtensionType","BaseTexture","mapTypeAndFormatToInternalFormat","GLTexture","TYPES","removeItems","MIPMAP_MODES","WRAP_MODES","SCALE_MODES","extensions"],"mappings":"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","sourcesContent":["import { mapTypeAndFormatToInternalFormat } from './utils/mapTypeAndFormatToInternalFormat';\nimport { BaseTexture } from './BaseTexture';\nimport { GLTexture } from './GLTexture';\nimport { removeItems } from '@pixi/utils';\nimport { MIPMAP_MODES, WRAP_MODES, SCALE_MODES, TYPES, SAMPLER_TYPES } from '@pixi/constants';\n\nimport type { ISystem } from '../system/ISystem';\nimport type { Texture } from './Texture';\n\nimport type { Renderer } from '../Renderer';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\n/**\n * System plugin to the renderer to manage textures.\n * @memberof PIXI\n */\nexport class TextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'texture',\n    };\n\n    /**\n     * Bound textures.\n     * @readonly\n     */\n    public boundTextures: BaseTexture[];\n\n    /**\n     * List of managed textures.\n     * @readonly\n     */\n    public managedTextures: Array<BaseTexture>;\n\n    /** Whether glTexture with int/uint sampler type was uploaded. */\n    protected hasIntegerTextures: boolean;\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected internalFormats: { [type: number]: { [format: number]: number } };\n    protected webGLVersion: number;\n\n    /**\n     * BaseTexture value that shows that we don't know what is bound.\n     * @readonly\n     */\n    protected unknownTexture: BaseTexture;\n\n    /**\n     * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n     * @private\n     */\n    protected _unknownBoundTextures: boolean;\n\n    /**\n     * Current location.\n     * @readonly\n     */\n    currentLocation: number;\n    emptyTextures: {[key: number]: GLTexture};\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this system works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        // TODO set to max textures...\n        this.boundTextures = [];\n        this.currentLocation = -1;\n        this.managedTextures = [];\n\n        this._unknownBoundTextures = false;\n        this.unknownTexture = new BaseTexture();\n\n        this.hasIntegerTextures = false;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    contextChange(): void\n    {\n        const gl = this.gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        this.webGLVersion = this.renderer.context.webGLVersion;\n\n        this.internalFormats = mapTypeAndFormatToInternalFormat(gl);\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this.boundTextures.length = maxTextures;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            this.boundTextures[i] = null;\n        }\n\n        // TODO move this.. to a nice make empty textures class..\n        this.emptyTextures = {};\n\n        const emptyTexture2D = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));\n\n        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;\n        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture(gl.createTexture());\n\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);\n\n        for (let i = 0; i < 6; i++)\n        {\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.bind(null, i);\n        }\n    }\n\n    /**\n     * Bind a texture to a specific location\n     *\n     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`\n     * @param texture - Texture to bind\n     * @param [location=0] - Location to bind at\n     */\n    bind(texture: Texture | BaseTexture, location = 0): void\n    {\n        const { gl } = this;\n\n        texture = texture?.castToBaseTexture();\n\n        // cannot bind partial texture\n        // TODO: report a warning\n        if (texture?.valid && !texture.parentTextureArray)\n        {\n            texture.touched = this.renderer.textureGC.count;\n\n            const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);\n\n            if (this.boundTextures[location] !== texture)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n\n                gl.bindTexture(texture.target, glTexture.texture);\n            }\n\n            if (glTexture.dirtyId !== texture.dirtyId)\n            {\n                if (this.currentLocation !== location)\n                {\n                    this.currentLocation = location;\n                    gl.activeTexture(gl.TEXTURE0 + location);\n                }\n                this.updateTexture(texture);\n            }\n            else if (glTexture.dirtyStyleId !== texture.dirtyStyleId)\n            {\n                this.updateTextureStyle(texture);\n            }\n\n            this.boundTextures[location] = texture;\n        }\n        else\n        {\n            if (this.currentLocation !== location)\n            {\n                this.currentLocation = location;\n                gl.activeTexture(gl.TEXTURE0 + location);\n            }\n\n            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);\n            this.boundTextures[location] = null;\n        }\n    }\n\n    /** Resets texture location and bound textures Actual `bind(null, i)` calls will be performed at next `unbind()` call */\n    reset(): void\n    {\n        this._unknownBoundTextures = true;\n        this.hasIntegerTextures = false;\n        this.currentLocation = -1;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.boundTextures[i] = this.unknownTexture;\n        }\n    }\n\n    /**\n     * Unbind a texture.\n     * @param texture - Texture to bind\n     */\n    unbind(texture?: BaseTexture): void\n    {\n        const { gl, boundTextures } = this;\n\n        if (this._unknownBoundTextures)\n        {\n            this._unknownBoundTextures = false;\n            // someone changed webGL state,\n            // we have to be sure that our texture does not appear in multi-texture renderer samplers\n            for (let i = 0; i < boundTextures.length; i++)\n            {\n                if (boundTextures[i] === this.unknownTexture)\n                {\n                    this.bind(null, i);\n                }\n            }\n        }\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === texture)\n            {\n                if (this.currentLocation !== i)\n                {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    this.currentLocation = i;\n                }\n\n                gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    /**\n     * Ensures that current boundTextures all have FLOAT sampler type,\n     * see {@link PIXI.SAMPLER_TYPES} for explanation.\n     * @param maxTextures - number of locations to check\n     */\n    ensureSamplerType(maxTextures: number): void\n    {\n        const { boundTextures, hasIntegerTextures, CONTEXT_UID } = this;\n\n        if (!hasIntegerTextures)\n        {\n            return;\n        }\n\n        for (let i = maxTextures - 1; i >= 0; --i)\n        {\n            const tex = boundTextures[i];\n\n            if (tex)\n            {\n                const glTexture = tex._glTextures[CONTEXT_UID];\n\n                if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n                {\n                    this.renderer.texture.unbind(tex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Initialize a texture\n     * @private\n     * @param texture - Texture to initialize\n     */\n    initTexture(texture: BaseTexture): GLTexture\n    {\n        const glTexture = new GLTexture(this.gl.createTexture());\n\n        // guarantee an update..\n        glTexture.dirtyId = -1;\n\n        texture._glTextures[this.CONTEXT_UID] = glTexture;\n\n        this.managedTextures.push(texture);\n        texture.on('dispose', this.destroyTexture, this);\n\n        return glTexture;\n    }\n\n    initTextureType(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;\n\n        if (this.webGLVersion === 2 && texture.type === TYPES.HALF_FLOAT)\n        {\n            // TYPES.HALF_FLOAT is WebGL1 HALF_FLOAT_OES\n            // we have to convert it to WebGL HALF_FLOAT\n            glTexture.type = this.gl.HALF_FLOAT;\n        }\n        else\n        {\n            glTexture.type = texture.type;\n        }\n    }\n\n    /**\n     * Update a texture\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to initialize\n     */\n    updateTexture(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n\n        this.initTextureType(texture, glTexture);\n\n        if (texture.resource?.upload(renderer, texture, glTexture))\n        {\n            // texture is uploaded, dont do anything!\n            if (glTexture.samplerType !== SAMPLER_TYPES.FLOAT)\n            {\n                this.hasIntegerTextures = true;\n            }\n        }\n        else\n        {\n            // default, renderTexture-like logic\n            const width = texture.realWidth;\n            const height = texture.realHeight;\n            const gl = renderer.gl;\n\n            if (glTexture.width !== width\n                || glTexture.height !== height\n                || glTexture.dirtyId < 0)\n            {\n                glTexture.width = width;\n                glTexture.height = height;\n\n                gl.texImage2D(texture.target, 0,\n                    glTexture.internalFormat,\n                    width,\n                    height,\n                    0,\n                    texture.format,\n                    glTexture.type,\n                    null);\n            }\n        }\n\n        // lets only update what changes..\n        if (texture.dirtyStyleId !== glTexture.dirtyStyleId)\n        {\n            this.updateTextureStyle(texture);\n        }\n        glTexture.dirtyId = texture.dirtyId;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     * @private\n     * @param texture - the texture to destroy\n     * @param [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture: BaseTexture | Texture, skipRemove?: boolean): void\n    {\n        const { gl } = this;\n\n        texture = texture.castToBaseTexture();\n\n        if (texture._glTextures[this.CONTEXT_UID])\n        {\n            this.unbind(texture);\n\n            gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete texture._glTextures[this.CONTEXT_UID];\n\n            if (!skipRemove)\n            {\n                const i = this.managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this.managedTextures, i, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Update texture style such as mipmap flag\n     * @private\n     * @param {PIXI.BaseTexture} texture - Texture to update\n     */\n    updateTextureStyle(texture: BaseTexture): void\n    {\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            return;\n        }\n\n        if ((texture.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo)\n        {\n            glTexture.mipmap = false;\n        }\n        else\n        {\n            glTexture.mipmap = texture.mipmap >= 1;\n        }\n\n        if (this.webGLVersion !== 2 && !texture.isPowerOfTwo)\n        {\n            glTexture.wrapMode = WRAP_MODES.CLAMP;\n        }\n        else\n        {\n            glTexture.wrapMode = texture.wrapMode;\n        }\n\n        if (texture.resource?.style(this.renderer, texture, glTexture))\n        {\n            // style is set, dont do anything!\n        }\n        else\n        {\n            this.setStyle(texture, glTexture);\n        }\n\n        glTexture.dirtyStyleId = texture.dirtyStyleId;\n    }\n\n    /**\n     * Set style for texture\n     * @private\n     * @param texture - Texture to update\n     * @param glTexture\n     */\n    setStyle(texture: BaseTexture, glTexture: GLTexture): void\n    {\n        const gl = this.gl;\n\n        if (glTexture.mipmap && texture.mipmap !== MIPMAP_MODES.ON_MANUAL)\n        {\n            gl.generateMipmap(texture.target);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);\n        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);\n\n        if (glTexture.mipmap)\n        {\n            /* eslint-disable max-len */\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n            /* eslint-disable max-len */\n\n            const anisotropicExt = this.renderer.context.extensions.anisotropicFiltering;\n\n            if (anisotropicExt && texture.anisotropicLevel > 0 && texture.scaleMode === SCALE_MODES.LINEAR)\n            {\n                const level = Math.min(texture.anisotropicLevel, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n                gl.texParameterf(texture.target, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n            }\n        }\n        else\n        {\n            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n        }\n\n        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(TextureSystem);\n"]},"metadata":{},"sourceType":"script"}