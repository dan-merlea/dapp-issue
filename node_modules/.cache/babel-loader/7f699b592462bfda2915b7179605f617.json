{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar constants = require('@pixi/constants');\nrequire('../settings.js');\nvar extensions = require('@pixi/extensions');\nvar settings = require('@pixi/settings');\nvar byteSizeMap = {\n  5126: 4,\n  5123: 2,\n  5121: 1\n};\nvar GeometrySystem = /*#__PURE__*/function () {\n  function GeometrySystem(renderer) {\n    _classCallCheck(this, GeometrySystem);\n    this.renderer = renderer;\n    this._activeGeometry = null;\n    this._activeVao = null;\n    this.hasVao = true;\n    this.hasInstance = true;\n    this.canUseUInt32ElementIndex = false;\n    this.managedGeometries = {};\n  }\n  _createClass(GeometrySystem, [{\n    key: \"contextChange\",\n    value: function contextChange() {\n      this.disposeAll(true);\n      var gl = this.gl = this.renderer.gl;\n      var context = this.renderer.context;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n      if (context.webGLVersion !== 2) {\n        var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n        if (settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY) {\n          nativeVaoExtension = null;\n        }\n        if (nativeVaoExtension) {\n          gl.createVertexArray = function () {\n            return nativeVaoExtension.createVertexArrayOES();\n          };\n          gl.bindVertexArray = function (vao) {\n            return nativeVaoExtension.bindVertexArrayOES(vao);\n          };\n          gl.deleteVertexArray = function (vao) {\n            return nativeVaoExtension.deleteVertexArrayOES(vao);\n          };\n        } else {\n          this.hasVao = false;\n          gl.createVertexArray = function () {\n            return null;\n          };\n          gl.bindVertexArray = function () {\n            return null;\n          };\n          gl.deleteVertexArray = function () {\n            return null;\n          };\n        }\n      }\n      if (context.webGLVersion !== 2) {\n        var instanceExt = gl.getExtension(\"ANGLE_instanced_arrays\");\n        if (instanceExt) {\n          gl.vertexAttribDivisor = function (a, b) {\n            return instanceExt.vertexAttribDivisorANGLE(a, b);\n          };\n          gl.drawElementsInstanced = function (a, b, c, d, e) {\n            return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n          };\n          gl.drawArraysInstanced = function (a, b, c, d) {\n            return instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n          };\n        } else {\n          this.hasInstance = false;\n        }\n      }\n      this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(geometry, shader) {\n      shader = shader || this.renderer.shader.shader;\n      var gl = this.gl;\n      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n      var incRefCount = false;\n      if (!vaos) {\n        this.managedGeometries[geometry.id] = geometry;\n        geometry.disposeRunner.add(this);\n        geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n        incRefCount = true;\n      }\n      var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n      this._activeGeometry = geometry;\n      if (this._activeVao !== vao) {\n        this._activeVao = vao;\n        if (this.hasVao) {\n          gl.bindVertexArray(vao);\n        } else {\n          this.activateVao(geometry, shader.program);\n        }\n      }\n      this.updateBuffers();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.unbind();\n    }\n  }, {\n    key: \"updateBuffers\",\n    value: function updateBuffers() {\n      var geometry = this._activeGeometry;\n      var bufferSystem = this.renderer.buffer;\n      for (var i = 0; i < geometry.buffers.length; i++) {\n        var buffer = geometry.buffers[i];\n        bufferSystem.update(buffer);\n      }\n    }\n  }, {\n    key: \"checkCompatibility\",\n    value: function checkCompatibility(geometry, program) {\n      var geometryAttributes = geometry.attributes;\n      var shaderAttributes = program.attributeData;\n      for (var j in shaderAttributes) {\n        if (!geometryAttributes[j]) {\n          throw new Error(\"shader and geometry incompatible, geometry missing the \\\"\".concat(j, \"\\\" attribute\"));\n        }\n      }\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature(geometry, program) {\n      var attribs = geometry.attributes;\n      var shaderAttributes = program.attributeData;\n      var strings = [\"g\", geometry.id];\n      for (var i in attribs) {\n        if (shaderAttributes[i]) {\n          strings.push(i, shaderAttributes[i].location);\n        }\n      }\n      return strings.join(\"-\");\n    }\n  }, {\n    key: \"initGeometryVao\",\n    value: function initGeometryVao(geometry, shader) {\n      var incRefCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var gl = this.gl;\n      var CONTEXT_UID = this.CONTEXT_UID;\n      var bufferSystem = this.renderer.buffer;\n      var program = shader.program;\n      if (!program.glPrograms[CONTEXT_UID]) {\n        this.renderer.shader.generateProgram(shader);\n      }\n      this.checkCompatibility(geometry, program);\n      var signature = this.getSignature(geometry, program);\n      var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n      var vao = vaoObjectHash[signature];\n      if (vao) {\n        vaoObjectHash[program.id] = vao;\n        return vao;\n      }\n      var buffers = geometry.buffers;\n      var attributes = geometry.attributes;\n      var tempStride = {};\n      var tempStart = {};\n      for (var j in buffers) {\n        tempStride[j] = 0;\n        tempStart[j] = 0;\n      }\n      for (var _j in attributes) {\n        if (!attributes[_j].size && program.attributeData[_j]) {\n          attributes[_j].size = program.attributeData[_j].size;\n        } else if (!attributes[_j].size) {\n          console.warn(\"PIXI Geometry attribute '\".concat(_j, \"' size cannot be determined (likely the bound shader does not have the attribute)\"));\n        }\n        tempStride[attributes[_j].buffer] += attributes[_j].size * byteSizeMap[attributes[_j].type];\n      }\n      for (var _j2 in attributes) {\n        var attribute = attributes[_j2];\n        var attribSize = attribute.size;\n        if (attribute.stride === void 0) {\n          if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type]) {\n            attribute.stride = 0;\n          } else {\n            attribute.stride = tempStride[attribute.buffer];\n          }\n        }\n        if (attribute.start === void 0) {\n          attribute.start = tempStart[attribute.buffer];\n          tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n        }\n      }\n      vao = gl.createVertexArray();\n      gl.bindVertexArray(vao);\n      for (var i = 0; i < buffers.length; i++) {\n        var buffer = buffers[i];\n        bufferSystem.bind(buffer);\n        if (incRefCount) {\n          buffer._glBuffers[CONTEXT_UID].refCount++;\n        }\n      }\n      this.activateVao(geometry, program);\n      vaoObjectHash[program.id] = vao;\n      vaoObjectHash[signature] = vao;\n      gl.bindVertexArray(null);\n      bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER);\n      return vao;\n    }\n  }, {\n    key: \"disposeGeometry\",\n    value: function disposeGeometry(geometry, contextLost) {\n      var _this$renderer;\n      if (!this.managedGeometries[geometry.id]) {\n        return;\n      }\n      delete this.managedGeometries[geometry.id];\n      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n      var gl = this.gl;\n      var buffers = geometry.buffers;\n      var bufferSystem = (_this$renderer = this.renderer) === null || _this$renderer === void 0 ? void 0 : _this$renderer.buffer;\n      geometry.disposeRunner.remove(this);\n      if (!vaos) {\n        return;\n      }\n      if (bufferSystem) {\n        for (var i = 0; i < buffers.length; i++) {\n          var buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n          if (buf) {\n            buf.refCount--;\n            if (buf.refCount === 0 && !contextLost) {\n              bufferSystem.dispose(buffers[i], contextLost);\n            }\n          }\n        }\n      }\n      if (!contextLost) {\n        for (var vaoId in vaos) {\n          if (vaoId[0] === \"g\") {\n            var vao = vaos[vaoId];\n            if (this._activeVao === vao) {\n              this.unbind();\n            }\n            gl.deleteVertexArray(vao);\n          }\n        }\n      }\n      delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n  }, {\n    key: \"disposeAll\",\n    value: function disposeAll(contextLost) {\n      var all = Object.keys(this.managedGeometries);\n      for (var i = 0; i < all.length; i++) {\n        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n      }\n    }\n  }, {\n    key: \"activateVao\",\n    value: function activateVao(geometry, program) {\n      var gl = this.gl;\n      var CONTEXT_UID = this.CONTEXT_UID;\n      var bufferSystem = this.renderer.buffer;\n      var buffers = geometry.buffers;\n      var attributes = geometry.attributes;\n      if (geometry.indexBuffer) {\n        bufferSystem.bind(geometry.indexBuffer);\n      }\n      var lastBuffer = null;\n      for (var j in attributes) {\n        var attribute = attributes[j];\n        var buffer = buffers[attribute.buffer];\n        var glBuffer = buffer._glBuffers[CONTEXT_UID];\n        if (program.attributeData[j]) {\n          if (lastBuffer !== glBuffer) {\n            bufferSystem.bind(buffer);\n            lastBuffer = glBuffer;\n          }\n          var location = program.attributeData[j].location;\n          gl.enableVertexAttribArray(location);\n          gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);\n          if (attribute.instance) {\n            if (this.hasInstance) {\n              gl.vertexAttribDivisor(location, 1);\n            } else {\n              throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(type, size, start, instanceCount) {\n      var gl = this.gl;\n      var geometry = this._activeGeometry;\n      if (geometry.indexBuffer) {\n        var byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        var glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n        if (byteSize === 2 || byteSize === 4 && this.canUseUInt32ElementIndex) {\n          if (geometry.instanced) {\n            gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n          } else {\n            gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n          }\n        } else {\n          console.warn(\"unsupported index buffer type: uint32\");\n        }\n      } else if (geometry.instanced) {\n        gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n      } else {\n        gl.drawArrays(type, start, size || geometry.getSize());\n      }\n      return this;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.gl.bindVertexArray(null);\n      this._activeVao = null;\n      this._activeGeometry = null;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }]);\n  return GeometrySystem;\n}();\nGeometrySystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"geometry\"\n};\nextensions.extensions.add(GeometrySystem);\nexports.GeometrySystem = GeometrySystem;","map":{"version":3,"sources":["../../src/geometry/GeometrySystem.ts"],"names":["ExtensionType","BUFFER_TYPE","extensions"],"mappings":"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","sourcesContent":["import type { GLBuffer } from './GLBuffer';\nimport { BUFFER_TYPE, ENV } from '@pixi/constants';\nimport { settings } from '../settings';\n\nimport type { ISystem } from '../system/ISystem';\nimport type { DRAW_MODES } from '@pixi/constants';\nimport type { Renderer } from '../Renderer';\nimport type { Geometry } from './Geometry';\nimport type { Shader } from '../shader/Shader';\nimport type { Program } from '../shader/Program';\nimport type { Dict } from '@pixi/utils';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof PIXI\n */\nexport class GeometrySystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'geometry',\n    };\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    /**\n     * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`.\n     * @readonly\n     */\n    public canUseUInt32ElementIndex: boolean;\n\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n    protected _boundBuffer: GLBuffer;\n\n    /** Cache for all geometries by id, used in case renderer gets destroyed or for profiling. */\n    readonly managedGeometries: {[key: number]: Geometry};\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n        this.canUseUInt32ElementIndex = false;\n        this.managedGeometries = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        const gl = this.gl = this.renderer.gl;\n        const context = this.renderer.context;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // webgl2\n        if (context.webGLVersion !== 2)\n        {\n            // webgl 1!\n            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n\n            if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n            {\n                nativeVaoExtension = null;\n            }\n\n            if (nativeVaoExtension)\n            {\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    nativeVaoExtension.createVertexArrayOES();\n\n                gl.bindVertexArray = (vao): void =>\n                    nativeVaoExtension.bindVertexArrayOES(vao);\n\n                gl.deleteVertexArray = (vao): void =>\n                    nativeVaoExtension.deleteVertexArrayOES(vao);\n            }\n            else\n            {\n                this.hasVao = false;\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    null;\n\n                gl.bindVertexArray = (): void =>\n                    null;\n\n                gl.deleteVertexArray = (): void =>\n                    null;\n            }\n        }\n\n        if (context.webGLVersion !== 2)\n        {\n            const instanceExt = gl.getExtension('ANGLE_instanced_arrays');\n\n            if (instanceExt)\n            {\n                gl.vertexAttribDivisor = (a, b): void =>\n                    instanceExt.vertexAttribDivisorANGLE(a, b);\n\n                gl.drawElementsInstanced = (a, b, c, d, e): void =>\n                    instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n\n                gl.drawArraysInstanced = (a, b, c, d): void =>\n                    instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n            }\n            else\n            {\n                this.hasInstance = false;\n            }\n        }\n\n        this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param shader - Instance of shader to use vao for.\n     */\n    bind(geometry?: Geometry, shader?: Shader): void\n    {\n        shader = shader || this.renderer.shader.shader;\n\n        const { gl } = this;\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        let incRefCount = false;\n\n        if (!vaos)\n        {\n            this.managedGeometries[geometry.id] = geometry;\n            geometry.disposeRunner.add(this);\n            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n            incRefCount = true;\n        }\n\n        const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n\n        this._activeGeometry = geometry;\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            if (this.hasVao)\n            {\n                gl.bindVertexArray(vao);\n            }\n            else\n            {\n                this.activateVao(geometry, shader.program);\n            }\n        }\n\n        // TODO - optimise later!\n        // don't need to loop through if nothing changed!\n        // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this.renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.update(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: Program): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: Program): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        const strings = ['g', geometry.id];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param shader - Instance of the shader.\n     * @param incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, shader: Shader, incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const program = shader.program;\n\n        if (!program.glPrograms[CONTEXT_UID])\n        {\n            this.renderer.shader.generateProgram(shader);\n        }\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program.id] = vao;\n\n            return vao;\n        }\n\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n        const tempStride: Dict<number> = {};\n        const tempStart: Dict<number> = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n            else if (!attributes[j].size)\n            {\n                console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);  // eslint-disable-line\n            }\n\n            tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer];\n\n                tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n\n            if (incRefCount)\n            {\n                buffer._glBuffers[CONTEXT_UID].refCount++;\n            }\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program.id] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n        bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    disposeGeometry(geometry: Geometry, contextLost?: boolean): void\n    {\n        if (!this.managedGeometries[geometry.id])\n        {\n            return;\n        }\n\n        delete this.managedGeometries[geometry.id];\n\n        const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        const gl = this.gl;\n        const buffers = geometry.buffers;\n        const bufferSystem = this.renderer?.buffer;\n\n        geometry.disposeRunner.remove(this);\n\n        if (!vaos)\n        {\n            return;\n        }\n\n        // bufferSystem may have already been destroyed..\n        // if this is the case, there is no need to destroy the geometry buffers...\n        // they already have been!\n        if (bufferSystem)\n        {\n            for (let i = 0; i < buffers.length; i++)\n            {\n                const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n\n                // my be null as context may have changed right before the dispose is called\n                if (buf)\n                {\n                    buf.refCount--;\n                    if (buf.refCount === 0 && !contextLost)\n                    {\n                        bufferSystem.dispose(buffers[i], contextLost);\n                    }\n                }\n            }\n        }\n\n        if (!contextLost)\n        {\n            for (const vaoId in vaos)\n            {\n                // delete only signatures, everything else are copies\n                if (vaoId[0] === 'g')\n                {\n                    const vao = vaos[vaoId];\n\n                    if (this._activeVao === vao)\n                    {\n                        this.unbind();\n                    }\n                    gl.deleteVertexArray(vao);\n                }\n            }\n        }\n\n        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedGeometries);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: Program): void\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = buffers[attribute.buffer];\n            const glBuffer = buffer._glBuffers[CONTEXT_UID];\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                gl.vertexAttribPointer(location,\n                    attribute.size,\n                    attribute.type || gl.FLOAT,\n                    attribute.normalized,\n                    attribute.stride,\n                    attribute.start);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param type - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    draw(type: DRAW_MODES, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this;\n        const geometry = this._activeGeometry;\n\n        // TODO.. this should not change so maybe cache the function?\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (byteSize === 2 || (byteSize === 4 && this.canUseUInt32ElementIndex))\n            {\n                if (geometry.instanced)\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n                    /* eslint-enable max-len */\n                }\n                else\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                    /* eslint-enable max-len */\n                }\n            }\n            else\n            {\n                console.warn('unsupported index buffer type: uint32');\n            }\n        }\n        else if (geometry.instanced)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n        }\n        else\n        {\n            gl.drawArrays(type, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(GeometrySystem);\n"]},"metadata":{},"sourceType":"script"}