{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BUFFER_TYPE } from '@pixi/constants';\nimport { Runner } from '@pixi/runner';\nvar UID = 0;\nvar Buffer = /*#__PURE__*/function () {\n  function Buffer(data) {\n    var _static = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classCallCheck(this, Buffer);\n    this.data = data || new Float32Array(1);\n    this._glBuffers = {};\n    this._updateID = 0;\n    this.index = index;\n    this.static = _static;\n    this.id = UID++;\n    this.disposeRunner = new Runner(\"disposeBuffer\");\n  }\n  _createClass(Buffer, [{\n    key: \"update\",\n    value: function update(data) {\n      if (data instanceof Array) {\n        data = new Float32Array(data);\n      }\n      this.data = data || this.data;\n      this._updateID++;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.disposeRunner.emit(this, false);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.dispose();\n      this.data = null;\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    },\n    set: function set(value) {\n      this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(data) {\n      if (data instanceof Array) {\n        data = new Float32Array(data);\n      }\n      return new Buffer(data);\n    }\n  }]);\n  return Buffer;\n}();\nexport { Buffer };","map":{"version":3,"sources":["../../src/geometry/Buffer.ts"],"names":[],"mappings":";;;;AAIA,IAAI,GAAM,GAAA,CAAA;AAAA,IA+BG,MACb;EAgCI,gBAAY,IAAA,EACZ;IAAA,IADiC,OAAU,uEAAA,IAAA;IAAA,IAAM,KAAA,uEAAQ,KACzD;IAAA;IACI,IAAA,CAAK,IAAQ,GAAA,IAAA,IAAQ,IAAI,YAAA,CAAa,CAAC,CAAA;IAEvC,IAAA,CAAK,UAAA,GAAa,CAAA,CAAC;IACnB,IAAA,CAAK,SAAY,GAAA,CAAA;IAEjB,IAAA,CAAK,KAAQ,GAAA,KAAA;IACb,IAAA,CAAK,MAAS,GAAA,OAAA;IACd,IAAA,CAAK,EAAK,GAAA,GAAA,EAAA;IAEL,IAAA,CAAA,aAAA,GAAgB,IAAI,MAAA,CAAO,eAAe,CAAA;EAAA;EACnD;IAAA;IAAA,OAOA,gBAAO,IACP,EAAA;MACI,IAAI,IAAA,YAAgB,KACpB,EAAA;QACW,IAAA,GAAA,IAAI,YAAA,CAAa,IAAI,CAAA;MAAA;MAE3B,IAAA,CAAA,IAAA,GAAQ,IAAA,IAAwB,IAAK,CAAA,IAAA;MACrC,IAAA,CAAA,SAAA,EAAA;IAAA;EACT;IAAA;IAAA,OAGA,mBACA;MACS,IAAA,CAAA,aAAA,CAAc,IAAK,CAAA,IAAA,EAAM,KAAK,CAAA;IAAA;EACvC;IAAA;IAAA,OAGA,mBACA;MACI,IAAA,CAAK,OAAQ,EAAA;MAEb,IAAA,CAAK,IAAO,GAAA,IAAA;IAAA;EAChB;IAAA;IAAA,KAeA,eACA;MACW,OAAA,IAAA,CAAK,IAAA,KAAS,WAAY,CAAA,oBAAA;IAAA,CACrC;IAAA,KARA,aAAU,KACV,EAAA;MACI,IAAA,CAAK,IAAO,GAAA,KAAA,GAAQ,WAAY,CAAA,oBAAA,GAAuB,WAAY,CAAA,YAAA;IAAA;EACvE;IAAA;IAAA,OAYA,cAAY,IACZ,EAAA;MACI,IAAI,IAAA,YAAgB,KACpB,EAAA;QACW,IAAA,GAAA,IAAI,YAAA,CAAa,IAAI,CAAA;MAAA;MAGzB,OAAA,IAAI,MAAA,CAAO,IAAI,CAAA;IAAA;EAC1B;EAAA;AAAA","sourcesContent":["import { BUFFER_TYPE } from '@pixi/constants';\nimport { Runner } from '@pixi/runner';\nimport type { GLBuffer } from './GLBuffer';\n\nlet UID = 0;\n/* eslint-disable max-len */\n\n/**\n * Marks places in PixiJS where you can pass Float32Array, UInt32Array, any typed arrays, and ArrayBuffer\n *\n * Same as ArrayBuffer in typescript lib, defined here just for documentation\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IArrayBuffer extends ArrayBuffer\n{\n}\n\n/**\n * PixiJS classes use this type instead of ArrayBuffer and typed arrays\n * to support expressions like `geometry.buffers[0].data[0] = position.x`.\n *\n * Gives access to indexing and `length` field\n * - @popelyshev: If data is actually ArrayBuffer and throws Exception on indexing - its user problem :)\n */\nexport interface ITypedArray extends IArrayBuffer\n{\n    readonly length: number;\n    [index: number]: number;\n    readonly BYTES_PER_ELEMENT: number;\n}\n\n/**\n * A wrapper for data so that it can be used and uploaded by WebGL\n * @memberof PIXI\n */\nexport class Buffer\n{\n    /**\n     * The data in the buffer, as a typed array\n     * @type {PIXI.IArrayBuffer}\n     */\n    public data: ITypedArray;\n\n    /**\n     * The type of buffer this is, one of:\n     * + ELEMENT_ARRAY_BUFFER - used as an index buffer\n     * + ARRAY_BUFFER - used as an attribute buffer\n     * + UNIFORM_BUFFER - used as a uniform buffer (if available)\n     */\n    public type: BUFFER_TYPE;\n\n    public static: boolean;\n    public id: number;\n    disposeRunner: Runner;\n\n    /**\n     * A map of renderer IDs to webgl buffer\n     * @private\n     * @type {Object<number, GLBuffer>}\n     */\n    _glBuffers: {[key: number]: GLBuffer};\n    _updateID: number;\n\n    /**\n     * @param {PIXI.IArrayBuffer} data - the data to store in the buffer.\n     * @param _static - `true` for static buffer\n     * @param index - `true` for index buffer\n     */\n    constructor(data?: IArrayBuffer, _static = true, index = false)\n    {\n        this.data = (data || new Float32Array(1)) as ITypedArray;\n\n        this._glBuffers = {};\n        this._updateID = 0;\n\n        this.index = index;\n        this.static = _static;\n        this.id = UID++;\n\n        this.disposeRunner = new Runner('disposeBuffer');\n    }\n\n    // TODO could explore flagging only a partial upload?\n    /**\n     * Flags this buffer as requiring an upload to the GPU.\n     * @param {PIXI.IArrayBuffer|number[]} [data] - the data to update in the buffer.\n     */\n    update(data?: IArrayBuffer | Array<number>): void\n    {\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data);\n        }\n        this.data = (data as ITypedArray) || this.data;\n        this._updateID++;\n    }\n\n    /** Disposes WebGL resources that are connected to this geometry. */\n    dispose(): void\n    {\n        this.disposeRunner.emit(this, false);\n    }\n\n    /** Destroys the buffer. */\n    destroy(): void\n    {\n        this.dispose();\n\n        this.data = null;\n    }\n\n    /**\n     * Flags whether this is an index buffer.\n     *\n     * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make\n     * the buffer of type `ARRAY_BUFFER`.\n     *\n     * For backwards compatibility.\n     */\n    set index(value: boolean)\n    {\n        this.type = value ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;\n    }\n\n    get index(): boolean\n    {\n        return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n    }\n\n    /**\n     * Helper function that creates a buffer based on an array or TypedArray\n     * @param {ArrayBufferView | number[]} data - the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.\n     * @returns - A new Buffer based on the data provided.\n     */\n    static from(data: IArrayBuffer | number[]): Buffer\n    {\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data);\n        }\n\n        return new Buffer(data);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}