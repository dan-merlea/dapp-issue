{"ast":null,"code":"import _slicedToArray from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { ExtensionType, extensions } from '@pixi/core';\nvar assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, function (extension) {\n  var ref = extension.ref;\n  Object.entries(assetKeyMap).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1),\n      key = _ref2[0];\n    return !!ref[key];\n  }).forEach(function (_ref3) {\n    var _ref$key$extension;\n    var _ref4 = _slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      type = _ref4[1];\n    return extensions.add(Object.assign(ref[key], {\n      extension: (_ref$key$extension = ref[key].extension) !== null && _ref$key$extension !== void 0 ? _ref$key$extension : type\n    }));\n  });\n}, function (extension) {\n  var ref = extension.ref;\n  Object.keys(assetKeyMap).filter(function (key) {\n    return !!ref[key];\n  }).forEach(function (key) {\n    return extensions.remove(ref[key]);\n  });\n});","map":{"version":3,"sources":["../src/AssetExtension.ts"],"names":[],"mappings":";;AAMA,IAAM,WAAc,GAAA;EAChB,MAAA,EAAQ,aAAc,CAAA,UAAA;EACtB,QAAA,EAAU,aAAc,CAAA,aAAA;EACxB,KAAA,EAAO,aAAc,CAAA,WAAA;EACrB,SAAA,EAAW,aAAc,CAAA;AAC7B,CAAA;AAoBA,UAAA,CAAW,MAAO,CAAA,aAAA,CAAc,KAAO,EAAA,UAAC,SACxC,EAAA;EACI,IAAM,GAAA,GAAM,SAAU,CAAA,GAAA;EAEtB,MAAA,CAAO,OAAQ,CAAA,WAAW,CACrB,CAAA,MAAA,CAAO;IAAA;MAAE,GAAS;IAAA,OAAA,CAAC,CAAC,GAAA,CAAI,GAAiB,CAAA;EAAA,EAAA,CACzC,OAAA,CAAQ;IAAA;IAAA;MAAE,GAAK;MAAA,IAAA;IAAA,OAAU,UAAW,CAAA,GAAA,CAAI,MAAO,CAAA,MAAA,CAC5C,GAAA,CAAI,GAGJ,CAAA,EAAA;MAAE,SAAW,wBAAA,GAAA,CAAI,GAAkB,CAAA,CAAA,SAAA,mEAAa;IAAK,CACzD,CAAC,CAAC;EAAA,EAAA;AACV,CAAA,EAAG,UAAC,SACJ,EAAA;EACI,IAAM,GAAA,GAAM,SAAU,CAAA,GAAA;EAEtB,MAAA,CAAO,IAAA,CAAK,WAAW,CAAA,CAClB,MAAA,CAAO,UAAC,GAAA;IAAA,OAAQ,CAAC,CAAC,GAAA,CAAI,GAAiB,CAAA;EAAA,EAAA,CACvC,OAAA,CAAQ,UAAC,GAAA;IAAA,OAAQ,UAAA,CAAW,MAAO,CAAA,GAAA,CAAI,GAAA,CAAiB,CAAC;EAAA,EAAA;AAClE,CAAC,CAAA","sourcesContent":["import { extensions, ExtensionType } from '@pixi/core';\nimport type { LoaderParser } from './loader';\nimport type { CacheParser } from './cache';\nimport type { FormatDetectionParser } from './detections';\nimport type { ResolveURLParser } from './resolver';\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n/**\n * This developer convenience object allows developers to group\n * together the various asset parsers into a single object.\n * @memberof PIXI\n */\ninterface AssetExtension<ASSET = any, META_DATA = any>\n{\n    extension: ExtensionType.Asset,\n    loader?: Partial<LoaderParser<ASSET, META_DATA>>,\n    resolver?: Partial<ResolveURLParser>,\n    cache?: Partial<CacheParser<ASSET>>,\n    detection?: Partial<FormatDetectionParser>,\n}\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n\nexport type { AssetExtension };\n"]},"metadata":{},"sourceType":"module"}