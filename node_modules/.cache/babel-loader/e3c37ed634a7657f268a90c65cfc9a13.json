{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar sprite = require('@pixi/sprite');\nvar core = require('@pixi/core');\nvar _const = require('./const.js');\nvar TextStyle = require('./TextStyle.js');\nvar TextMetrics = require('./TextMetrics.js');\nvar defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\nvar _Text = /*#__PURE__*/function (_sprite$Sprite) {\n  _inherits(_Text, _sprite$Sprite);\n  var _super = _createSuper(_Text);\n  function _Text(text, style, canvas) {\n    var _this;\n    _classCallCheck(this, _Text);\n    var ownCanvas = false;\n    if (!canvas) {\n      canvas = core.settings.ADAPTER.createCanvas();\n      ownCanvas = true;\n    }\n    canvas.width = 3;\n    canvas.height = 3;\n    var texture = core.Texture.from(canvas);\n    texture.orig = new core.Rectangle();\n    texture.trim = new core.Rectangle();\n    _this = _super.call(this, texture);\n    _this._ownCanvas = ownCanvas;\n    _this.canvas = canvas;\n    _this.context = canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    _this._resolution = core.settings.RESOLUTION;\n    _this._autoResolution = true;\n    _this._text = null;\n    _this._style = null;\n    _this._styleListener = null;\n    _this._font = \"\";\n    _this.text = text;\n    _this.style = style;\n    _this.localStyleID = -1;\n    return _this;\n  }\n  _createClass(_Text, [{\n    key: \"updateText\",\n    value: function updateText(respectDirty) {\n      var style = this._style;\n      if (this.localStyleID !== style.styleID) {\n        this.dirty = true;\n        this.localStyleID = style.styleID;\n      }\n      if (!this.dirty && respectDirty) {\n        return;\n      }\n      this._font = this._style.toFontString();\n      var context = this.context;\n      var measured = TextMetrics.TextMetrics.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas);\n      var width = measured.width;\n      var height = measured.height;\n      var lines = measured.lines;\n      var lineHeight = measured.lineHeight;\n      var lineWidths = measured.lineWidths;\n      var maxLineWidth = measured.maxLineWidth;\n      var fontProperties = measured.fontProperties;\n      this.canvas.width = Math.ceil(Math.ceil(Math.max(1, width) + style.padding * 2) * this._resolution);\n      this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + style.padding * 2) * this._resolution);\n      context.scale(this._resolution, this._resolution);\n      context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      context.font = this._font;\n      context.lineWidth = style.strokeThickness;\n      context.textBaseline = style.textBaseline;\n      context.lineJoin = style.lineJoin;\n      context.miterLimit = style.miterLimit;\n      var linePositionX;\n      var linePositionY;\n      var passesCount = style.dropShadow ? 2 : 1;\n      for (var i = 0; i < passesCount; ++i) {\n        var isShadowPass = style.dropShadow && i === 0;\n        var dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n        var dsOffsetShadow = dsOffsetText * this._resolution;\n        if (isShadowPass) {\n          context.fillStyle = \"black\";\n          context.strokeStyle = \"black\";\n          var dropShadowColor = style.dropShadowColor;\n          var rgb = core.utils.hex2rgb(typeof dropShadowColor === \"number\" ? dropShadowColor : core.utils.string2hex(dropShadowColor));\n          var dropShadowBlur = style.dropShadowBlur * this._resolution;\n          var dropShadowDistance = style.dropShadowDistance * this._resolution;\n          context.shadowColor = \"rgba(\".concat(rgb[0] * 255, \",\").concat(rgb[1] * 255, \",\").concat(rgb[2] * 255, \",\").concat(style.dropShadowAlpha, \")\");\n          context.shadowBlur = dropShadowBlur;\n          context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n          context.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + dsOffsetShadow;\n        } else {\n          context.fillStyle = this._generateFillStyle(style, lines, measured);\n          context.strokeStyle = style.stroke;\n          context.shadowColor = \"black\";\n          context.shadowBlur = 0;\n          context.shadowOffsetX = 0;\n          context.shadowOffsetY = 0;\n        }\n        var linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n        if (lineHeight - fontProperties.fontSize < 0) {\n          linePositionYShift = 0;\n        }\n        for (var i2 = 0; i2 < lines.length; i2++) {\n          linePositionX = style.strokeThickness / 2;\n          linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n          if (style.align === \"right\") {\n            linePositionX += maxLineWidth - lineWidths[i2];\n          } else if (style.align === \"center\") {\n            linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n          }\n          if (style.stroke && style.strokeThickness) {\n            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n          }\n          if (style.fill) {\n            this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n          }\n        }\n      }\n      this.updateTexture();\n    }\n  }, {\n    key: \"drawLetterSpacing\",\n    value: function drawLetterSpacing(text, x, y) {\n      var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var style = this._style;\n      var letterSpacing = style.letterSpacing;\n      var supportLetterSpacing = _Text.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n      if (letterSpacing === 0 || supportLetterSpacing) {\n        if (supportLetterSpacing) {\n          this.context.letterSpacing = letterSpacing;\n          this.context.textLetterSpacing = letterSpacing;\n        }\n        if (isStroke) {\n          this.context.strokeText(text, x, y);\n        } else {\n          this.context.fillText(text, x, y);\n        }\n        return;\n      }\n      var currentPosition = x;\n      var stringArray = Array.from ? Array.from(text) : text.split(\"\");\n      var previousWidth = this.context.measureText(text).width;\n      var currentWidth = 0;\n      for (var i = 0; i < stringArray.length; ++i) {\n        var currentChar = stringArray[i];\n        if (isStroke) {\n          this.context.strokeText(currentChar, currentPosition, y);\n        } else {\n          this.context.fillText(currentChar, currentPosition, y);\n        }\n        var textStr = \"\";\n        for (var j = i + 1; j < stringArray.length; ++j) {\n          textStr += stringArray[j];\n        }\n        currentWidth = this.context.measureText(textStr).width;\n        currentPosition += previousWidth - currentWidth + letterSpacing;\n        previousWidth = currentWidth;\n      }\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture() {\n      var canvas = this.canvas;\n      if (this._style.trim) {\n        var trimmed = core.utils.trimCanvas(canvas);\n        if (trimmed.data) {\n          canvas.width = trimmed.width;\n          canvas.height = trimmed.height;\n          this.context.putImageData(trimmed.data, 0, 0);\n        }\n      }\n      var texture = this._texture;\n      var style = this._style;\n      var padding = style.trim ? 0 : style.padding;\n      var baseTexture = texture.baseTexture;\n      texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n      texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n      texture.trim.x = -padding;\n      texture.trim.y = -padding;\n      texture.orig.width = texture._frame.width - padding * 2;\n      texture.orig.height = texture._frame.height - padding * 2;\n      this._onTextureUpdate();\n      baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n      texture.updateUvs();\n      this.dirty = false;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      if (this._autoResolution && this._resolution !== renderer.resolution) {\n        this._resolution = renderer.resolution;\n        this.dirty = true;\n      }\n      this.updateText(true);\n      _get(_getPrototypeOf(_Text.prototype), \"_render\", this).call(this, renderer);\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      this.updateText(true);\n      _get(_getPrototypeOf(_Text.prototype), \"updateTransform\", this).call(this);\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(skipUpdate, rect) {\n      this.updateText(true);\n      if (this._textureID === -1) {\n        skipUpdate = false;\n      }\n      return _get(_getPrototypeOf(_Text.prototype), \"getBounds\", this).call(this, skipUpdate, rect);\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds(rect) {\n      this.updateText(true);\n      return _get(_getPrototypeOf(_Text.prototype), \"getLocalBounds\", this).call(this, rect);\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      this.calculateVertices();\n      this._bounds.addQuad(this.vertexData);\n    }\n  }, {\n    key: \"_generateFillStyle\",\n    value: function _generateFillStyle(style, lines, metrics) {\n      var fillStyle = style.fill;\n      if (!Array.isArray(fillStyle)) {\n        return fillStyle;\n      } else if (fillStyle.length === 1) {\n        return fillStyle[0];\n      }\n      var gradient;\n      var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0;\n      var padding = style.padding || 0;\n      var width = this.canvas.width / this._resolution - dropShadowCorrection - padding * 2;\n      var height = this.canvas.height / this._resolution - dropShadowCorrection - padding * 2;\n      var fill = fillStyle.slice();\n      var fillGradientStops = style.fillGradientStops.slice();\n      if (!fillGradientStops.length) {\n        var lengthPlus1 = fill.length + 1;\n        for (var i = 1; i < lengthPlus1; ++i) {\n          fillGradientStops.push(i / lengthPlus1);\n        }\n      }\n      fill.unshift(fillStyle[0]);\n      fillGradientStops.unshift(0);\n      fill.push(fillStyle[fillStyle.length - 1]);\n      fillGradientStops.push(1);\n      if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {\n        gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n        for (var _i = 0; _i < lines.length; _i++) {\n          var lastLineBottom = metrics.lineHeight * (_i - 1) + textHeight;\n          var thisLineTop = metrics.lineHeight * _i;\n          var thisLineGradientStart = thisLineTop;\n          if (_i > 0 && lastLineBottom > thisLineTop) {\n            thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n          }\n          var thisLineBottom = thisLineTop + textHeight;\n          var nextLineTop = metrics.lineHeight * (_i + 1);\n          var thisLineGradientEnd = thisLineBottom;\n          if (_i + 1 < lines.length && nextLineTop < thisLineBottom) {\n            thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n          }\n          var gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n          for (var j = 0; j < fill.length; j++) {\n            var lineStop = 0;\n            if (typeof fillGradientStops[j] === \"number\") {\n              lineStop = fillGradientStops[j];\n            } else {\n              lineStop = j / fill.length;\n            }\n            var globalStop = Math.min(1, Math.max(0, thisLineGradientStart / height + lineStop * gradStopLineHeight));\n            globalStop = Number(globalStop.toFixed(5));\n            gradient.addColorStop(globalStop, fill[j]);\n          }\n        }\n      } else {\n        gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n        var totalIterations = fill.length + 1;\n        var currentIteration = 1;\n        for (var _i2 = 0; _i2 < fill.length; _i2++) {\n          var stop = void 0;\n          if (typeof fillGradientStops[_i2] === \"number\") {\n            stop = fillGradientStops[_i2];\n          } else {\n            stop = currentIteration / totalIterations;\n          }\n          gradient.addColorStop(stop, fill[_i2]);\n          currentIteration++;\n        }\n      }\n      return gradient;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      if (typeof options === \"boolean\") {\n        options = {\n          children: options\n        };\n      }\n      options = Object.assign({}, defaultDestroyOptions, options);\n      _get(_getPrototypeOf(_Text.prototype), \"destroy\", this).call(this, options);\n      if (this._ownCanvas) {\n        this.canvas.height = this.canvas.width = 0;\n      }\n      this.context = null;\n      this.canvas = null;\n      this._style = null;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function set(value) {\n      this.updateText(true);\n      var s = core.utils.sign(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width;\n      this._width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function set(value) {\n      this.updateText(true);\n      var s = core.utils.sign(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height;\n      this._height = value;\n    }\n  }, {\n    key: \"style\",\n    get: function get() {\n      return this._style;\n    },\n    set: function set(style) {\n      style = style || {};\n      if (style instanceof TextStyle.TextStyle) {\n        this._style = style;\n      } else {\n        this._style = new TextStyle.TextStyle(style);\n      }\n      this.localStyleID = -1;\n      this.dirty = true;\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) {\n      text = String(text === null || text === void 0 ? \"\" : text);\n      if (this._text === text) {\n        return;\n      }\n      this._text = text;\n      this.dirty = true;\n    }\n  }, {\n    key: \"resolution\",\n    get: function get() {\n      return this._resolution;\n    },\n    set: function set(value) {\n      this._autoResolution = false;\n      if (this._resolution === value) {\n        return;\n      }\n      this._resolution = value;\n      this.dirty = true;\n    }\n  }]);\n  return _Text;\n}(sprite.Sprite);\nvar Text = _Text;\nText.experimentalLetterSpacing = false;\nexports.Text = Text;","map":{"version":3,"sources":["../src/Text.ts"],"names":["Sprite","Texture","Rectangle","settings","utils","TextStyle"],"mappings":"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","sourcesContent":["/* eslint max-depth: [2, 8] */\nimport { Sprite } from '@pixi/sprite';\nimport { Texture, settings, Rectangle, utils } from '@pixi/core';\nimport { TEXT_GRADIENT } from './const';\nimport { TextStyle } from './TextStyle';\nimport { TextMetrics } from './TextMetrics';\n\nimport type { Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { ICanvas, ICanvasRenderingContext2D } from '@pixi/settings';\nimport type { ITextStyle } from './TextStyle';\n\nconst defaultDestroyOptions: IDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\ninterface ModernContext2D extends ICanvasRenderingContext2D\n{\n    // for chrome less 94\n    textLetterSpacing?: number;\n    // for chrome greater 94\n    letterSpacing?: number;\n}\n\n/**\n * A Text Object will create a line or multiple lines of text.\n *\n * The text is created using the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API).\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n * @example\n * import { Text } from 'pixi.js';\n *\n * const text = new Text('This is a PixiJS text', {\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * @memberof PIXI\n */\nexport class Text extends Sprite\n{\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** The canvas element that everything is drawn to. */\n    public canvas: ICanvas;\n    /** The canvas 2d context that everything is drawn with. */\n    public context: ModernContext2D;\n    public localStyleID: number;\n    public dirty: boolean;\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default PIXI.settings.RESOLUTION\n     */\n    _resolution: number;\n    _autoResolution: boolean;\n\n    /**\n     * Private tracker for the current text.\n     * @private\n     */\n    protected _text: string;\n\n    /**\n     * Private tracker for the current font.\n     * @private\n     */\n    protected _font: string;\n\n    /**\n     * Private tracker for the current style.\n     * @private\n     */\n    protected _style: TextStyle;\n\n    /**\n     * Private listener to track style changes.\n     * @private\n     */\n    protected _styleListener: () => void;\n\n    /**\n     * Keep track if this Text object created it's own canvas\n     * element (`true`) or uses the constructor argument (`false`).\n     * Used to workaround a GC issues with Safari < 13 when\n     * destroying Text. See `destroy` for more info.\n     */\n    private _ownCanvas: boolean;\n\n    /**\n     * @param text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param canvas - The canvas element for drawing text\n     */\n    constructor(text?: string | number, style?: Partial<ITextStyle> | TextStyle, canvas?: ICanvas)\n    {\n        let ownCanvas = false;\n\n        if (!canvas)\n        {\n            canvas = settings.ADAPTER.createCanvas();\n            ownCanvas = true;\n        }\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.from(canvas);\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        this._ownCanvas = ownCanvas;\n        this.canvas = canvas;\n        this.context = canvas.getContext('2d', {\n            // required for trimming to work without warnings\n            willReadFrequently: true,\n        });\n\n        this._resolution = settings.RESOLUTION;\n        this._autoResolution = true;\n        this._text = null;\n        this._style = null;\n        this._styleListener = null;\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    public updateText(respectDirty: boolean): void\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil(Math.ceil((Math.max(1, width) + (style.padding * 2))) * this._resolution);\n        this.canvas.height = Math.ceil(Math.ceil((Math.max(1, height) + (style.padding * 2))) * this._resolution);\n\n        context.scale(this._resolution, this._resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * this._resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const dropShadowColor = style.dropShadowColor;\n                const rgb = utils.hex2rgb(typeof dropShadowColor === 'number'\n                    ? dropShadowColor\n                    : utils.string2hex(dropShadowColor));\n                const dropShadowBlur = style.dropShadowBlur * this._resolution;\n                const dropShadowDistance = style.dropShadowDistance * this._resolution;\n\n                context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${style.dropShadowAlpha})`;\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(style.dropShadowAngle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                // set canvas text styles\n                context.fillStyle = this._generateFillStyle(style, lines, measured);\n                // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n                //       the setter converts to string. See this thread for more details:\n                //       https://github.com/microsoft/TypeScript/issues/2521\n                context.strokeStyle = style.stroke as string;\n\n                context.shadowColor = 'black';\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent\n                    + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.stroke && style.strokeThickness)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private drawLetterSpacing(text: string, x: number, y: number, isStroke = false): void\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        // Checking that we can use moddern canvas2D api\n        // https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n        // note: this is unstable API, Chrome less 94 use a `textLetterSpacing`, newest use a letterSpacing\n        // eslint-disable-next-line max-len\n        const supportLetterSpacing = Text.experimentalLetterSpacing\n            && ('letterSpacing' in CanvasRenderingContext2D.prototype\n                || 'textLetterSpacing' in CanvasRenderingContext2D.prototype);\n\n        if (letterSpacing === 0 || supportLetterSpacing)\n        {\n            if (supportLetterSpacing)\n            {\n                this.context.letterSpacing = letterSpacing;\n                this.context.textLetterSpacing = letterSpacing;\n            }\n\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        // Using Array.from correctly splits characters whilst keeping emoji together.\n        // This is not supported on IE as it requires ES6, so regular text splitting occurs.\n        // This also doesn't account for emoji that are multiple emoji put together to make something else.\n        // Handling all of this would require a big library itself.\n        // https://medium.com/@giltayar/iterating-over-emoji-characters-the-es6-way-f06e4589516\n        // https://github.com/orling/grapheme-splitter\n        const stringArray = Array.from ? Array.from(text) : text.split('');\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                this.context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = this.context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /** Updates texture size based on canvas size. */\n    private updateTexture(): void\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = utils.trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        texture.trim.width = texture._frame.width = canvas.width / this._resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this._resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);\n\n        texture.updateUvs();\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        if (this._autoResolution && this._resolution !== renderer.resolution)\n        {\n            this._resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._render(renderer);\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    public updateTransform(): void\n    {\n        this.updateText(true);\n\n        super.updateTransform();\n    }\n\n    public getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        if (this._textureID === -1)\n        {\n            // texture was updated: recalculate transforms\n            skipUpdate = false;\n        }\n\n        return super.getBounds(skipUpdate, rect);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     * @param rect - The output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     * @param style - The style.\n     * @param lines - The lines of text.\n     * @param metrics\n     * @returns The fill style\n     */\n    private _generateFillStyle(\n        style: TextStyle, lines: string[], metrics: TextMetrics\n    ): string | CanvasGradient | CanvasPattern\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n        //       the setter converts to string. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        const fillStyle: string | string[] | CanvasGradient | CanvasPattern = style.fill as any;\n\n        if (!Array.isArray(fillStyle))\n        {\n            return fillStyle;\n        }\n        else if (fillStyle.length === 1)\n        {\n            return fillStyle[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient: string[] | CanvasGradient;\n\n        // a dropshadow will enlarge the canvas and result in the gradient being\n        // generated with the incorrect dimensions\n        const dropShadowCorrection = (style.dropShadow) ? style.dropShadowDistance : 0;\n\n        // should also take padding into account, padding can offset the gradient\n        const padding = style.padding || 0;\n\n        const width = (this.canvas.width / this._resolution) - dropShadowCorrection - (padding * 2);\n        const height = (this.canvas.height / this._resolution) - dropShadowCorrection - (padding * 2);\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = fillStyle.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(fillStyle[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(fillStyle[fillStyle.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n\n            // Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\n            const textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                const lastLineBottom = (metrics.lineHeight * (i - 1)) + textHeight;\n                const thisLineTop = metrics.lineHeight * i;\n                let thisLineGradientStart = thisLineTop;\n\n                // Handle case where last & this line overlap\n                if (i > 0 && lastLineBottom > thisLineTop)\n                {\n                    thisLineGradientStart = (thisLineTop + lastLineBottom) / 2;\n                }\n\n                const thisLineBottom = thisLineTop + textHeight;\n                const nextLineTop = metrics.lineHeight * (i + 1);\n                let thisLineGradientEnd = thisLineBottom;\n\n                // Handle case where this & next line overlap\n                if (i + 1 < lines.length && nextLineTop < thisLineBottom)\n                {\n                    thisLineGradientEnd = (thisLineBottom + nextLineTop) / 2;\n                }\n\n                // textHeight, but as a 0-1 size in global gradient stop space\n                const gradStopLineHeight = (thisLineGradientEnd - thisLineGradientStart) / height;\n\n                for (let j = 0; j < fill.length; j++)\n                {\n                    // 0-1 stop point for the current line, multiplied to global space afterwards\n                    let lineStop = 0;\n\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        lineStop = fillGradientStops[j];\n                    }\n                    else\n                    {\n                        lineStop = j / fill.length;\n                    }\n\n                    let globalStop = Math.min(1, Math.max(0,\n                        (thisLineGradientStart / height) + (lineStop * gradStopLineHeight)));\n\n                    // There's potential for floating point precision issues at the seams between gradient repeats.\n                    globalStop = Number(globalStop.toFixed(5));\n                    gradient.addColorStop(globalStop, fill[j]);\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            const totalIterations = fill.length + 1;\n            let currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                let stop: number;\n\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     *\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // set canvas width and height to 0 to workaround memory leak in Safari < 13\n        // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\n        if (this._ownCanvas)\n        {\n            this.canvas.height = this.canvas.width = 0;\n        }\n\n        // make sure to reset the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value: number)\n    {\n        this.updateText(true);\n\n        const s = utils.sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     */\n    get style(): TextStyle | Partial<ITextStyle>\n    {\n        // TODO: Can't have different types for getter and setter. The getter shouldn't have the ITextStyle\n        //       since the setter creates the TextStyle. See this thread for more details:\n        //       https://github.com/microsoft/TypeScript/issues/2521\n        return this._style;\n    }\n\n    set style(style: TextStyle | Partial<ITextStyle>)\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    get text(): string\n    {\n        return this._text;\n    }\n\n    set text(text: string | number)\n    {\n        text = String(text === null || text === undefined ? '' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this._autoResolution = false;\n\n        if (this._resolution === value)\n        {\n            return;\n        }\n\n        this._resolution = value;\n        this.dirty = true;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}