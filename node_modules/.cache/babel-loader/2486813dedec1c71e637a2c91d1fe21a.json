{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT } from \"./utils\";\nexport function generateKeyPair() {\n  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : randomBytes(KEY_PAIR_SEED_LENGTH);\n  return ed25519.generateKeyPairFromSeed(seed);\n}\nexport function signJWT(_x, _x2, _x3, _x4) {\n  return _signJWT.apply(this, arguments);\n}\nfunction _signJWT() {\n  _signJWT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sub, aud, ttl, keyPair) {\n    var iat,\n      header,\n      iss,\n      exp,\n      payload,\n      data,\n      signature,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            iat = _args.length > 4 && _args[4] !== undefined ? _args[4] : fromMiliseconds(Date.now());\n            header = {\n              alg: JWT_IRIDIUM_ALG,\n              typ: JWT_IRIDIUM_TYP\n            };\n            iss = encodeIss(keyPair.publicKey);\n            exp = iat + ttl;\n            payload = {\n              iss: iss,\n              sub: sub,\n              aud: aud,\n              iat: iat,\n              exp: exp\n            };\n            data = encodeData({\n              header: header,\n              payload: payload\n            });\n            signature = ed25519.sign(keyPair.secretKey, data);\n            return _context.abrupt(\"return\", encodeJWT({\n              header: header,\n              payload: payload,\n              signature: signature\n            }));\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _signJWT.apply(this, arguments);\n}\nexport function verifyJWT(_x5) {\n  return _verifyJWT.apply(this, arguments);\n}\nfunction _verifyJWT() {\n  _verifyJWT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(jwt) {\n    var _decodeJWT, header, payload, signature, publicKey, data;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _decodeJWT = decodeJWT(jwt), header = _decodeJWT.header, payload = _decodeJWT.payload, signature = _decodeJWT.signature;\n            if (!(header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP)) {\n              _context2.next = 3;\n              break;\n            }\n            throw new Error(\"JWT must use EdDSA algorithm\");\n          case 3:\n            publicKey = decodeIss(payload.iss);\n            data = encodeData({\n              header: header,\n              payload: payload\n            });\n            return _context2.abrupt(\"return\", ed25519.verify(publicKey, data, signature));\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifyJWT.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}