{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar TickerListener = /*#__PURE__*/function () {\n  function TickerListener(fn) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, TickerListener);\n    this.next = null;\n    this.previous = null;\n    this._destroyed = false;\n    this.fn = fn;\n    this.context = context;\n    this.priority = priority;\n    this.once = once;\n  }\n  _createClass(TickerListener, [{\n    key: \"match\",\n    value: function match(fn) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this.fn === fn && this.context === context;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(deltaTime) {\n      if (this.fn) {\n        if (this.context) {\n          this.fn.call(this.context, deltaTime);\n        } else {\n          this.fn(deltaTime);\n        }\n      }\n      var redirect = this.next;\n      if (this.once) {\n        this.destroy(true);\n      }\n      if (this._destroyed) {\n        this.next = null;\n      }\n      return redirect;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(previous) {\n      this.previous = previous;\n      if (previous.next) {\n        previous.next.previous = this;\n      }\n      this.next = previous.next;\n      previous.next = this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this._destroyed = true;\n      this.fn = null;\n      this.context = null;\n      if (this.previous) {\n        this.previous.next = this.next;\n      }\n      if (this.next) {\n        this.next.previous = this.previous;\n      }\n      var redirect = this.next;\n      this.next = hard ? null : redirect;\n      this.previous = null;\n      return redirect;\n    }\n  }]);\n  return TickerListener;\n}();\nexport { TickerListener };","map":{"version":3,"sources":["../src/TickerListener.ts"],"names":[],"mappings":";;IAQa,cACb;EAyBI,wBAAY,EAAuB,EACnC;IAAA,IADmC,OAAA,uEAAa,IAAA;IAAA,IAAM,QAAW,uEAAA,CAAA;IAAA,IAAG,IAAA,uEAAO,KAC3E;IAAA;IAtBA,IAAA,CAAO,IAAuB,GAAA,IAAA;IAE9B,IAAA,CAAO,QAA2B,GAAA,IAAA;IASlC,IAAA,CAAQ,UAAa,GAAA,KAAA;IAYjB,IAAA,CAAK,EAAK,GAAA,EAAA;IACV,IAAA,CAAK,OAAU,GAAA,OAAA;IACf,IAAA,CAAK,QAAW,GAAA,QAAA;IAChB,IAAA,CAAK,IAAO,GAAA,IAAA;EAAA;EAChB;IAAA;IAAA,OASA,eAAM,EAAuB,EAC7B;MAAA,IAD6B,OAAA,uEAAe,IAC5C;MACI,OAAO,IAAK,CAAA,EAAA,KAAO,EAAM,IAAA,IAAA,CAAK,OAAY,KAAA,OAAA;IAAA;EAC9C;IAAA;IAAA,OAQA,cAAK,SACL,EAAA;MACI,IAAI,IAAA,CAAK,EACT,EAAA;QACI,IAAI,IAAA,CAAK,OACT,EAAA;UACI,IAAA,CAAK,EAAG,CAAA,IAAA,CAAK,IAAK,CAAA,OAAA,EAAS,SAAS,CAAA;QAAA,CAGxC,MAAA;UACK,IAAA,CAA6B,EAAA,CAAG,SAAS,CAAA;QAAA;MAC9C;MAGJ,IAAM,QAAA,GAAW,IAAK,CAAA,IAAA;MAEtB,IAAI,IAAA,CAAK,IACT,EAAA;QACI,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA;MAAA;MAKrB,IAAI,IAAA,CAAK,UACT,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,IAAA;MAAA;MAGT,OAAA,QAAA;IAAA;EACX;IAAA;IAAA,OAOA,iBAAQ,QACR,EAAA;MACI,IAAA,CAAK,QAAW,GAAA,QAAA;MAChB,IAAI,QAAA,CAAS,IACb,EAAA;QACI,QAAA,CAAS,IAAA,CAAK,QAAW,GAAA,IAAA;MAAA;MAE7B,IAAA,CAAK,IAAA,GAAO,QAAS,CAAA,IAAA;MACrB,QAAA,CAAS,IAAO,GAAA,IAAA;IAAA;EACpB;IAAA;IAAA,OASA,mBACA;MAAA,IADQ,IAAA,uEAAO,KACf;MACI,IAAA,CAAK,UAAa,GAAA,IAAA;MAClB,IAAA,CAAK,EAAK,GAAA,IAAA;MACV,IAAA,CAAK,OAAU,GAAA,IAAA;MAGf,IAAI,IAAA,CAAK,QACT,EAAA;QACS,IAAA,CAAA,QAAA,CAAS,IAAA,GAAO,IAAK,CAAA,IAAA;MAAA;MAG9B,IAAI,IAAA,CAAK,IACT,EAAA;QACS,IAAA,CAAA,IAAA,CAAK,QAAA,GAAW,IAAK,CAAA,QAAA;MAAA;MAI9B,IAAM,QAAA,GAAW,IAAK,CAAA,IAAA;MAGjB,IAAA,CAAA,IAAA,GAAO,IAAA,GAAO,IAAO,GAAA,QAAA;MAC1B,IAAA,CAAK,QAAW,GAAA,IAAA;MAET,OAAA,QAAA;IAAA;EACX;EAAA;AAAA","sourcesContent":["import type { TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n * @memberof PIXI\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private context: T;\n    /** If this should only execute once. */\n    private once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this.fn = fn;\n        this.context = context;\n        this.priority = priority;\n        this.once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this.fn === fn && this.context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @private\n     * @param deltaTime - time since the last emit.\n     * @returns Next ticker\n     */\n    emit(deltaTime: number): TickerListener\n    {\n        if (this.fn)\n        {\n            if (this.context)\n            {\n                this.fn.call(this.context, deltaTime);\n            }\n            else\n            {\n                (this as TickerListener<any>).fn(deltaTime);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this.once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @private\n     * @param previous - Input node, previous listener\n     */\n    connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @private\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this.fn = null;\n        this.context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}