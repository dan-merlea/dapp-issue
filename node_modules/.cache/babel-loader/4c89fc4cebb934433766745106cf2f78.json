{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BytesBinaryCodec = void 0;\nvar bytes_1 = require(\"../typesystem/bytes\");\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"BytesValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nvar BytesBinaryCodec = /*#__PURE__*/function () {\n  function BytesBinaryCodec() {\n    _classCallCheck(this, BytesBinaryCodec);\n  }\n  _createClass(BytesBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer) {\n      var length = buffer.readUInt32BE(0);\n      var payload = buffer.slice(constants_1.SizeOfU32, constants_1.SizeOfU32 + length);\n      var result = new bytes_1.BytesValue(payload);\n      return [result, constants_1.SizeOfU32 + length];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer) {\n      return new bytes_1.BytesValue(buffer);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(bytes) {\n      var lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n      lengthBuffer.writeUInt32BE(bytes.getLength());\n      var buffer = Buffer.concat([lengthBuffer, bytes.valueOf()]);\n      return buffer;\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(bytes) {\n      return bytes.valueOf();\n    }\n  }]);\n  return BytesBinaryCodec;\n}();\nexports.BytesBinaryCodec = BytesBinaryCodec;","map":null,"metadata":{},"sourceType":"script"}