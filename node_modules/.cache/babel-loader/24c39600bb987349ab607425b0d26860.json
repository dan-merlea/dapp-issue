{"ast":null,"code":"/*!\n * @pixi/interaction - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar math = require('@pixi/math');\nvar ticker = require('@pixi/ticker');\nvar display = require('@pixi/display');\nvar utils = require('@pixi/utils');\nvar core = require('@pixi/core');\n\n/**\n * Holds all information related to an Interaction event\n * @memberof PIXI\n */\nvar InteractionData = /** @class */function () {\n  function InteractionData() {\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    this.pressure = 0;\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     */\n    this.rotationAngle = 0;\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    this.twist = 0;\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    this.tangentialPressure = 0;\n    this.global = new math.Point();\n    this.target = null;\n    this.originalEvent = null;\n    this.identifier = null;\n    this.isPrimary = false;\n    this.button = 0;\n    this.buttons = 0;\n    this.width = 0;\n    this.height = 0;\n    this.tiltX = 0;\n    this.tiltY = 0;\n    this.pointerType = null;\n    this.pressure = 0;\n    this.rotationAngle = 0;\n    this.twist = 0;\n    this.tangentialPressure = 0;\n  }\n  Object.defineProperty(InteractionData.prototype, \"pointerId\", {\n    /**\n     * The unique identifier of the pointer. It will be the same as `identifier`.\n     * @readonly\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n     */\n    get: function get() {\n      return this.identifier;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * This will return the local coordinates of the specified displayObject for this InteractionData\n   * @param displayObject - The DisplayObject that you would like the local\n   *  coords off\n   * @param point - A Point object in which to store the value, optional (otherwise\n   *  will create a new point)\n   * @param globalPos - A Point object containing your custom global coords, optional\n   *  (otherwise will use the current global coords)\n   * @returns - A point containing the coordinates of the InteractionData position relative\n   *  to the DisplayObject\n   */\n  InteractionData.prototype.getLocalPosition = function (displayObject, point, globalPos) {\n    return displayObject.worldTransform.applyInverse(globalPos || this.global, point);\n  };\n  /**\n   * Copies properties from normalized event data.\n   * @param {Touch|MouseEvent|PointerEvent} event - The normalized event data\n   */\n  InteractionData.prototype.copyEvent = function (event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if ('isPrimary' in event && event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = 'button' in event && event.button;\n    // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard\n    // event.which property instead, which conveys the same information.\n    var buttons = 'buttons' in event && event.buttons;\n    this.buttons = Number.isInteger(buttons) ? buttons : 'which' in event && event.which;\n    this.width = 'width' in event && event.width;\n    this.height = 'height' in event && event.height;\n    this.tiltX = 'tiltX' in event && event.tiltX;\n    this.tiltY = 'tiltY' in event && event.tiltY;\n    this.pointerType = 'pointerType' in event && event.pointerType;\n    this.pressure = 'pressure' in event && event.pressure;\n    this.rotationAngle = 'rotationAngle' in event && event.rotationAngle;\n    this.twist = 'twist' in event && event.twist || 0;\n    this.tangentialPressure = 'tangentialPressure' in event && event.tangentialPressure || 0;\n  };\n  /** Resets the data for pooling. */\n  InteractionData.prototype.reset = function () {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  };\n  return InteractionData;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * Event class that mimics native DOM events.\n * @memberof PIXI\n */\nvar InteractionEvent = /** @class */function () {\n  function InteractionEvent() {\n    this.stopped = false;\n    this.stopsPropagatingAt = null;\n    this.stopPropagationHint = false;\n    this.target = null;\n    this.currentTarget = null;\n    this.type = null;\n    this.data = null;\n  }\n  /** Prevents event from reaching any objects other than the current object. */\n  InteractionEvent.prototype.stopPropagation = function () {\n    this.stopped = true;\n    this.stopPropagationHint = true;\n    this.stopsPropagatingAt = this.currentTarget;\n  };\n  /** Resets the event. */\n  InteractionEvent.prototype.reset = function () {\n    this.stopped = false;\n    this.stopsPropagatingAt = null;\n    this.stopPropagationHint = false;\n    this.currentTarget = null;\n    this.target = null;\n  };\n  return InteractionEvent;\n}();\n\n/**\n * DisplayObjects with the {@link PIXI.interactiveTarget} mixin use this class to track interactions\n * @class\n * @private\n * @memberof PIXI\n */\nvar InteractionTrackingData = /** @class */function () {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   * @private\n   */\n  function InteractionTrackingData(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  InteractionTrackingData.prototype._doSet = function (flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & ~flag;\n    }\n  };\n  Object.defineProperty(InteractionTrackingData.prototype, \"pointerId\", {\n    /**\n     * Unique pointer id of the event\n     * @readonly\n     * @private\n     * @member {number}\n     */\n    get: function get() {\n      return this._pointerId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData.prototype, \"flags\", {\n    /**\n     * State of the tracking data, expressed as bit flags\n     * @private\n     * @member {number}\n     */\n    get: function get() {\n      return this._flags;\n    },\n    set: function set(flags) {\n      this._flags = flags;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData.prototype, \"none\", {\n    /**\n     * Is the tracked event inactive (not over or down)?\n     * @private\n     * @member {number}\n     */\n    get: function get() {\n      return this._flags === InteractionTrackingData.FLAGS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData.prototype, \"over\", {\n    /**\n     * Is the tracked event over the DisplayObject?\n     * @private\n     * @member {boolean}\n     */\n    get: function get() {\n      return (this._flags & InteractionTrackingData.FLAGS.OVER) !== 0;\n    },\n    set: function set(yn) {\n      this._doSet(InteractionTrackingData.FLAGS.OVER, yn);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData.prototype, \"rightDown\", {\n    /**\n     * Did the right mouse button come down in the DisplayObject?\n     * @private\n     * @member {boolean}\n     */\n    get: function get() {\n      return (this._flags & InteractionTrackingData.FLAGS.RIGHT_DOWN) !== 0;\n    },\n    set: function set(yn) {\n      this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN, yn);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionTrackingData.prototype, \"leftDown\", {\n    /**\n     * Did the left mouse button come down in the DisplayObject?\n     * @private\n     * @member {boolean}\n     */\n    get: function get() {\n      return (this._flags & InteractionTrackingData.FLAGS.LEFT_DOWN) !== 0;\n    },\n    set: function set(yn) {\n      this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN, yn);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  InteractionTrackingData.FLAGS = Object.freeze({\n    NONE: 0,\n    OVER: 1 << 0,\n    LEFT_DOWN: 1 << 1,\n    RIGHT_DOWN: 1 << 2\n  });\n  return InteractionTrackingData;\n}();\n\n/**\n * Strategy how to search through stage tree for interactive objects\n * @memberof PIXI\n */\nvar TreeSearch = /** @class */function () {\n  function TreeSearch() {\n    this._tempPoint = new math.Point();\n  }\n  /**\n   * Recursive implementation for findHit\n   * @private\n   * @param interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param func - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param hitTest - this indicates if the objects inside should be hit test against the point\n   * @param interactive - Whether the displayObject is interactive\n   * @returns - Returns true if the displayObject hit the point\n   */\n  TreeSearch.prototype.recursiveFindHit = function (interactionEvent, displayObject, func, hitTest, interactive) {\n    var _a;\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n    var point = interactionEvent.data.global;\n    // Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimization once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimization is that an object is not hit test directly if a child has already been hit.\n    interactive = displayObject.interactive || interactive;\n    var hit = false;\n    var interactiveParent = interactive;\n    // Flag here can set to false if the event is outside the parents hitArea or mask\n    var hitTestChildren = true;\n    // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea\n    // There is also no longer a need to hitTest children.\n    if (displayObject.hitArea) {\n      if (hitTest) {\n        displayObject.worldTransform.applyInverse(point, this._tempPoint);\n        if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {\n          hitTest = false;\n          hitTestChildren = false;\n        } else {\n          hit = true;\n        }\n      }\n      interactiveParent = false;\n    }\n    // If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.\n    // We still want to hitTestChildren, however, to ensure a mouseout can still be generated.\n    // https://github.com/pixijs/pixi.js/issues/5135\n    else if (displayObject._mask) {\n      if (hitTest) {\n        var maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n        if (maskObject && !((_a = maskObject.containsPoint) === null || _a === void 0 ? void 0 : _a.call(maskObject, point))) {\n          hitTest = false;\n        }\n      }\n    }\n    // ** FREE TIP **! If an object is not interactive or has no buttons in it\n    // (such as a game scene!) set interactiveChildren to false for that displayObject.\n    // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.\n    if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {\n      var children = displayObject.children;\n      for (var i = children.length - 1; i >= 0; i--) {\n        var child = children[i];\n        // time to get recursive.. if this function will return if something is hit..\n        var childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        // already tested against hitArea if it is defined\n        if (!displayObject.hitArea && displayObject.containsPoint) {\n          if (displayObject.containsPoint(point)) {\n            hit = true;\n          }\n        }\n      }\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.target = displayObject;\n        }\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n    return hit;\n  };\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   * @private\n   * @param interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param func - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param hitTest - this indicates if the objects inside should be hit test against the point\n   * @returns - Returns true if the displayObject hit the point\n   */\n  TreeSearch.prototype.findHit = function (interactionEvent, displayObject, func, hitTest) {\n    this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);\n  };\n  return TreeSearch;\n}();\n\n/**\n * Interface for classes that represent a hit area.\n *\n * It is implemented by the following classes:\n * - {@link PIXI.Circle}\n * - {@link PIXI.Ellipse}\n * - {@link PIXI.Polygon}\n * - {@link PIXI.RoundedRectangle}\n * @interface IHitArea\n * @memberof PIXI\n */\n/**\n * Checks whether the x and y coordinates given are contained within this area\n * @method\n * @name contains\n * @memberof PIXI.IHitArea#\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @returns {boolean} Whether the x/y coordinates are within this area\n */\n/**\n * Default property values of interactive objects\n * Used by {@link PIXI.InteractionManager} to automatically give all DisplayObjects these properties\n * @private\n * @name interactiveTarget\n * @type {object}\n * @memberof PIXI\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          DisplayObject.prototype,\n *          PIXI.interactiveTarget\n *      );\n */\nvar interactiveTarget = {\n  interactive: false,\n  interactiveChildren: true,\n  hitArea: null,\n  /**\n   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n   * Setting this changes the 'cursor' property to `'pointer'`.\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.buttonMode = true;\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  get buttonMode() {\n    return this.cursor === 'pointer';\n  },\n  set buttonMode(value) {\n    if (value) {\n      this.cursor = 'pointer';\n    } else if (this.cursor === 'pointer') {\n      this.cursor = null;\n    }\n  },\n  /**\n   * This defines what cursor mode is used when the mouse cursor\n   * is hovered over the displayObject.\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.cursor = 'wait';\n   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  cursor: null,\n  /**\n   * Internal set of all active pointers, by identifier\n   * @member {Map<number, InteractionTrackingData>}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   */\n  get trackedPointers() {\n    if (this._trackedPointers === undefined) {\n      this._trackedPointers = {};\n    }\n    return this._trackedPointers;\n  },\n  /**\n   * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n   * @private\n   * @type {Map<number, InteractionTrackingData>}\n   */\n  _trackedPointers: undefined\n};\n\n// Mix interactiveTarget into DisplayObject.prototype\ndisplay.DisplayObject.mixin(interactiveTarget);\nvar MOUSE_POINTER_ID = 1;\n// helpers for hitTest() - only used inside hitTest()\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events.\n *\n * Any DisplayObject can be interactive if its `interactive` property is set to true.\n *\n * This manager also supports multitouch.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`\n * @memberof PIXI\n */\nvar InteractionManager = /** @class */function (_super) {\n  __extends(InteractionManager, _super);\n  /**\n   * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer\n   * @param options - The options for the manager.\n   * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.\n   * @param {number} [options.interactionFrequency=10] - Maximum frequency (ms) at pointer over/out states will be checked.\n   * @param {number} [options.useSystemTicker=true] - Whether to add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n   */\n  function InteractionManager(renderer, options) {\n    var _this = _super.call(this) || this;\n    options = options || {};\n    _this.renderer = renderer;\n    _this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID;\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    _this.mouse.global.set(-999999);\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;\n    _this.interactionDataPool = [];\n    _this.eventData = new InteractionEvent();\n    _this.interactionDOMElement = null;\n    _this.moveWhenInside = false;\n    _this.eventsAdded = false;\n    _this.tickerAdded = false;\n    _this.mouseOverRenderer = !('PointerEvent' in globalThis);\n    _this.supportsTouchEvents = 'ontouchstart' in globalThis;\n    _this.supportsPointerEvents = !!globalThis.PointerEvent;\n    // this will make it so that you don't have to call bind all the time\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    _this.currentCursorMode = null;\n    _this.cursor = null;\n    _this.resolution = 1;\n    _this.delayedEvents = [];\n    _this.search = new TreeSearch();\n    _this._tempDisplayObject = new display.TemporaryDisplayObject();\n    _this._eventListenerOptions = {\n      capture: true,\n      passive: false\n    };\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     * @event PIXI.InteractionManager#mousedown\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     * @event PIXI.InteractionManager#rightdown\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     * @event PIXI.InteractionManager#mouseup\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     * @event PIXI.InteractionManager#rightup\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     * @event PIXI.InteractionManager#click\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     * @event PIXI.InteractionManager#rightclick\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link PIXI.InteractionManager#event:mousedown}.\n     * @event PIXI.InteractionManager#mouseupoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link PIXI.InteractionManager#event:rightdown}.\n     * @event PIXI.InteractionManager#rightupoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     * @event PIXI.InteractionManager#mousemove\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     * @event PIXI.InteractionManager#mouseover\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     * @event PIXI.InteractionManager#mouseout\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * @event PIXI.InteractionManager#pointerdown\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * Not always fired when some buttons are held down while others are released. In those cases,\n     * use [mousedown]{@link PIXI.InteractionManager#event:mousedown} and\n     * [mouseup]{@link PIXI.InteractionManager#event:mouseup} instead.\n     * @event PIXI.InteractionManager#pointerup\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when the operating system cancels a pointer event\n     * @event PIXI.InteractionManager#pointercancel\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * @event PIXI.InteractionManager#pointertap\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link PIXI.InteractionManager#event:pointerdown}.\n     * @event PIXI.InteractionManager#pointerupoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device is moved while over the display object\n     * @event PIXI.InteractionManager#pointermove\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device is moved onto the display object\n     * @event PIXI.InteractionManager#pointerover\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device is moved off the display object\n     * @event PIXI.InteractionManager#pointerout\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is placed on the display object.\n     * @event PIXI.InteractionManager#touchstart\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is removed from the display object.\n     * @event PIXI.InteractionManager#touchend\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when the operating system cancels a touch\n     * @event PIXI.InteractionManager#touchcancel\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * @event PIXI.InteractionManager#tap\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link PIXI.InteractionManager#event:touchstart}.\n     * @event PIXI.InteractionManager#touchendoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is moved along the display object.\n     * @event PIXI.InteractionManager#touchmove\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#mousedown\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#rightdown\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#mouseup\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#rightup\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#click\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#rightclick\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#mouseupoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#rightupoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#mousemove\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#mouseover\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#mouseout\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointerdown\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointerup\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointercancel\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointertap\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointerupoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointermove\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointerover\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#pointerout\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#touchstart\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#touchend\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#touchcancel\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#tap\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#touchendoutside\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * This comes from the @pixi/interaction package.\n     * @event PIXI.DisplayObject#touchmove\n     * @param {PIXI.InteractionEvent} event - Interaction event\n     */\n    _this._useSystemTicker = options.useSystemTicker !== undefined ? options.useSystemTicker : true;\n    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution);\n    return _this;\n  }\n  Object.defineProperty(InteractionManager.prototype, \"useSystemTicker\", {\n    /**\n     * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n     * @default true\n     */\n    get: function get() {\n      return this._useSystemTicker;\n    },\n    set: function set(useSystemTicker) {\n      this._useSystemTicker = useSystemTicker;\n      if (useSystemTicker) {\n        this.addTickerListener();\n      } else {\n        this.removeTickerListener();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(InteractionManager.prototype, \"lastObjectRendered\", {\n    /**\n     * Last rendered object or temp object.\n     * @readonly\n     * @protected\n     */\n    get: function get() {\n      return this.renderer._lastObjectRendered || this._tempDisplayObject;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   * @param globalPoint - A point to hit test with, in global space.\n   * @param root - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @returns - The hit display object, if any.\n   */\n  InteractionManager.prototype.hitTest = function (globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.lastObjectRendered;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n    return hitTestEvent.target;\n  };\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate\n   * another DOM element to receive those events.\n   * @param element - the DOM element which will receive mouse and touch events.\n   * @param resolution - The resolution / device pixel ratio of the new element (relative to the canvas).\n   */\n  InteractionManager.prototype.setTargetElement = function (element, resolution) {\n    if (resolution === void 0) {\n      resolution = 1;\n    }\n    this.removeTickerListener();\n    this.removeEvents();\n    this.interactionDOMElement = element;\n    this.resolution = resolution;\n    this.addEvents();\n    this.addTickerListener();\n  };\n  /** Adds the ticker listener. */\n  InteractionManager.prototype.addTickerListener = function () {\n    if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker) {\n      return;\n    }\n    ticker.Ticker.system.add(this.tickerUpdate, this, ticker.UPDATE_PRIORITY.INTERACTION);\n    this.tickerAdded = true;\n  };\n  /** Removes the ticker listener. */\n  InteractionManager.prototype.removeTickerListener = function () {\n    if (!this.tickerAdded) {\n      return;\n    }\n    ticker.Ticker.system.remove(this.tickerUpdate, this);\n    this.tickerAdded = false;\n  };\n  /** Registers all the DOM events. */\n  InteractionManager.prototype.addEvents = function () {\n    if (this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n    var style = this.interactionDOMElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = 'none';\n      style.msTouchAction = 'none';\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = 'none';\n    }\n    /*\n     * These events are added first, so that if pointer events are normalized, they are fired\n     * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      globalThis.document.addEventListener('pointermove', this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, this._eventListenerOptions);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, this._eventListenerOptions);\n      globalThis.addEventListener('pointercancel', this.onPointerCancel, this._eventListenerOptions);\n      globalThis.addEventListener('pointerup', this.onPointerUp, this._eventListenerOptions);\n    } else {\n      globalThis.document.addEventListener('mousemove', this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, this._eventListenerOptions);\n      globalThis.addEventListener('mouseup', this.onPointerUp, this._eventListenerOptions);\n    }\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, this._eventListenerOptions);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, this._eventListenerOptions);\n    }\n    this.eventsAdded = true;\n  };\n  /** Removes all the DOM events that were previously registered. */\n  InteractionManager.prototype.removeEvents = function () {\n    if (!this.eventsAdded || !this.interactionDOMElement) {\n      return;\n    }\n    var style = this.interactionDOMElement.style;\n    if (globalThis.navigator.msPointerEnabled) {\n      style.msContentZooming = '';\n      style.msTouchAction = '';\n    } else if (this.supportsPointerEvents) {\n      style.touchAction = '';\n    }\n    if (this.supportsPointerEvents) {\n      globalThis.document.removeEventListener('pointermove', this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, this._eventListenerOptions);\n      globalThis.removeEventListener('pointercancel', this.onPointerCancel, this._eventListenerOptions);\n      globalThis.removeEventListener('pointerup', this.onPointerUp, this._eventListenerOptions);\n    } else {\n      globalThis.document.removeEventListener('mousemove', this.onPointerMove, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, this._eventListenerOptions);\n      globalThis.removeEventListener('mouseup', this.onPointerUp, this._eventListenerOptions);\n    }\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, this._eventListenerOptions);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, this._eventListenerOptions);\n    }\n    this.interactionDOMElement = null;\n    this.eventsAdded = false;\n  };\n  /**\n   * Updates the state of interactive objects if at least {@link interactionFrequency}\n   * milliseconds have passed since the last invocation.\n   *\n   * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n   * @param deltaTime - time delta since the last call\n   */\n  InteractionManager.prototype.tickerUpdate = function (deltaTime) {\n    this._deltaTime += deltaTime;\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n    this._deltaTime = 0;\n    this.update();\n  };\n  /** Updates the state of interactive objects. */\n  InteractionManager.prototype.update = function () {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this._didMove) {\n      this._didMove = false;\n      return;\n    }\n    this.cursor = null;\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function\n    for (var k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        var interactionData = this.activeInteractionData[k];\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n          this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, true);\n        }\n      }\n    }\n    this.setCursorMode(this.cursor);\n  };\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   * @param mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  InteractionManager.prototype.setCursorMode = function (mode) {\n    mode = mode || 'default';\n    var applyStyles = true;\n    // offscreen canvas does not support setting styles, but cursor modes can be functions,\n    // in order to handle pixi rendered cursors, so we can't bail\n    if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas) {\n      applyStyles = false;\n    }\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    var style = this.cursorStyles[mode];\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          if (applyStyles) {\n            this.interactionDOMElement.style.cursor = style;\n          }\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          if (applyStyles) {\n            Object.assign(this.interactionDOMElement.style, style);\n          }\n          break;\n      }\n    } else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  };\n  /**\n   * Dispatches an event on the display object that was interacted with.\n   * @param displayObject - the display object in question\n   * @param eventString - the name of the event (e.g, mousedown)\n   * @param eventData - the event data object\n   */\n  InteractionManager.prototype.dispatchEvent = function (displayObject, eventString, eventData) {\n    // Even if the event was stopped, at least dispatch any remaining events\n    // for the same display object.\n    if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n      displayObject.emit(eventString, eventData);\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  };\n  /**\n   * Puts a event on a queue to be dispatched later. This is used to guarantee correct\n   * ordering of over/out events.\n   * @param displayObject - the display object in question\n   * @param eventString - the name of the event (e.g, mousedown)\n   * @param eventData - the event data object\n   */\n  InteractionManager.prototype.delayDispatchEvent = function (displayObject, eventString, eventData) {\n    this.delayedEvents.push({\n      displayObject: displayObject,\n      eventString: eventString,\n      eventData: eventData\n    });\n  };\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   * @param point - the point that the result will be stored in\n   * @param x - the x coord of the position to map\n   * @param y - the y coord of the position to map\n   */\n  InteractionManager.prototype.mapPositionToPoint = function (point, x, y) {\n    var rect;\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        width: this.interactionDOMElement.width,\n        height: this.interactionDOMElement.height,\n        left: 0,\n        top: 0\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n    var resolutionMultiplier = 1.0 / this.resolution;\n    point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;\n    point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;\n  };\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   * @protected\n   * @param interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param func - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param hitTest - indicates whether we want to calculate hits\n   *  or just iterate through all interactive objects\n   */\n  InteractionManager.prototype.processInteractive = function (interactionEvent, displayObject, func, hitTest) {\n    var hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);\n    var delayedEvents = this.delayedEvents;\n    if (!delayedEvents.length) {\n      return hit;\n    }\n    // Reset the propagation hint, because we start deeper in the tree again.\n    interactionEvent.stopPropagationHint = false;\n    var delayedLen = delayedEvents.length;\n    this.delayedEvents = [];\n    for (var i = 0; i < delayedLen; i++) {\n      var _a = delayedEvents[i],\n        displayObject_1 = _a.displayObject,\n        eventString = _a.eventString,\n        eventData = _a.eventData;\n      // When we reach the object we wanted to stop propagating at,\n      // set the propagation hint.\n      if (eventData.stopsPropagatingAt === displayObject_1) {\n        eventData.stopPropagationHint = true;\n      }\n      this.dispatchEvent(displayObject_1, eventString, eventData);\n    }\n    return hit;\n  };\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   * @param originalEvent - The DOM event of a pointer button being pressed down\n   */\n  InteractionManager.prototype.onPointerDown = function (originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    /*\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      var cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);\n      if (cancelable) {\n        originalEvent.preventDefault();\n      }\n    }\n    var eventLen = events.length;\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      }\n      // emit a mouse event for \"pen\" pointers, the way a browser would emit a fallback event\n      else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        var isRightButton = event.button === 2;\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  };\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   * @param interactionEvent - The interaction event wrapping the DOM event\n   * @param displayObject - The display object that was tested\n   * @param hit - the result of the hit test on the display object\n   */\n  InteractionManager.prototype.processPointerDown = function (interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);\n      if (data.pointerType === 'touch') {\n        this.dispatchEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        var isRightButton = data.button === 2;\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n        this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is released on the renderer element\n   * @param originalEvent - The DOM event of a pointer button being released\n   * @param cancelled - true if the pointer is cancelled\n   * @param func - Function passed to {@link processInteractive}\n   */\n  InteractionManager.prototype.onPointerComplete = function (originalEvent, cancelled, func) {\n    var events = this.normalizeToPointerData(originalEvent);\n    var eventLen = events.length;\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    var target = originalEvent.target;\n    // if in shadow DOM use composedPath to access target\n    if (originalEvent.composedPath && originalEvent.composedPath().length > 0) {\n      target = originalEvent.composedPath()[0];\n    }\n    var eventAppend = target !== this.interactionDOMElement ? 'outside' : '';\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);\n      this.emit(cancelled ? 'pointercancel' : \"pointerup\" + eventAppend, interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        var isRightButton = event.button === 2;\n        this.emit(isRightButton ? \"rightup\" + eventAppend : \"mouseup\" + eventAppend, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : \"touchend\" + eventAppend, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is cancelled\n   * @param event - The DOM event of a pointer button being released\n   */\n  InteractionManager.prototype.onPointerCancel = function (event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') {\n      return;\n    }\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  };\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   * @param interactionEvent - The interaction event wrapping the DOM event\n   * @param displayObject - The display object that was tested\n   */\n  InteractionManager.prototype.processPointerCancel = function (interactionEvent, displayObject) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);\n      if (data.pointerType === 'touch') {\n        this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer button is released on the renderer element\n   * @param event - The DOM event of a pointer button being released\n   */\n  InteractionManager.prototype.onPointerUp = function (event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') {\n      return;\n    }\n    this.onPointerComplete(event, false, this.processPointerUp);\n  };\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   * @param interactionEvent - The interaction event wrapping the DOM event\n   * @param displayObject - The display object that was tested\n   * @param hit - the result of the hit test on the display object\n   */\n  InteractionManager.prototype.processPointerUp = function (interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var trackingData = displayObject.trackedPointers[id];\n    var isTouch = data.pointerType === 'touch';\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n    // need to track mouse down status in the mouse block so that we can emit\n    // event in a later block\n    var isMouseTap = false;\n    // Mouse only\n    if (isMouse) {\n      var isRightButton = data.button === 2;\n      var flags = InteractionTrackingData.FLAGS;\n      var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n      var isDown = trackingData !== undefined && trackingData.flags & test;\n      if (hit) {\n        this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n        if (isDown) {\n          this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);\n          // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap\n          isMouseTap = true;\n        }\n      } else if (isDown) {\n        this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n    // Pointers and Touches, and Mouse\n    if (hit) {\n      this.dispatchEvent(displayObject, 'pointerup', interactionEvent);\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchend', interactionEvent);\n      }\n      if (trackingData) {\n        // emit pointertap if not a mouse, or if the mouse block decided it was a tap\n        if (!isMouse || isMouseTap) {\n          this.dispatchEvent(displayObject, 'pointertap', interactionEvent);\n        }\n        if (isTouch) {\n          this.dispatchEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);\n      }\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  };\n  /**\n   * Is called when the pointer moves across the renderer element\n   * @param originalEvent - The DOM event of a pointer moving\n   */\n  InteractionManager.prototype.onPointerMove = function (originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {\n      this._didMove = true;\n      this.cursor = null;\n    }\n    var eventLen = events.length;\n    for (var i = 0; i < eventLen; i++) {\n      var event = events[i];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchmove', interactionEvent);\n      }\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mousemove', interactionEvent);\n      }\n    }\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  };\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   * @param interactionEvent - The interaction event wrapping the DOM event\n   * @param displayObject - The display object that was tested\n   * @param hit - the result of the hit test on the display object\n   */\n  InteractionManager.prototype.processPointerMove = function (interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var isTouch = data.pointerType === 'touch';\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n    if (!this.moveWhenInside || hit) {\n      this.dispatchEvent(displayObject, 'pointermove', interactionEvent);\n      if (isTouch) {\n        this.dispatchEvent(displayObject, 'touchmove', interactionEvent);\n      }\n      if (isMouse) {\n        this.dispatchEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n  };\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  InteractionManager.prototype.onPointerOut = function (originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    var event = events[0];\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n    this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  };\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be.\n   * @param interactionEvent - The interaction event wrapping the DOM event\n   * @param displayObject - The display object that was tested\n   * @param hit - the result of the hit test on the display object\n   */\n  InteractionManager.prototype.processPointerOverOut = function (interactionEvent, displayObject, hit) {\n    var data = interactionEvent.data;\n    var id = interactionEvent.data.identifier;\n    var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n    var trackingData = displayObject.trackedPointers[id];\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n    if (trackingData === undefined) {\n      return;\n    }\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.delayDispatchEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.delayDispatchEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.dispatchEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.dispatchEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  };\n  /**\n   * Is called when the pointer is moved into the renderer element.\n   * @param originalEvent - The DOM event of a pointer button being moved into the renderer view.\n   */\n  InteractionManager.prototype.onPointerOver = function (originalEvent) {\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {\n      return;\n    }\n    var events = this.normalizeToPointerData(originalEvent);\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    var event = events[0];\n    var interactionData = this.getInteractionDataForPointerId(event);\n    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n    interactionEvent.data.originalEvent = event;\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  };\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well.\n   * @param event - Normalized pointer event, output from normalizeToPointerData.\n   * @returns - Interaction data for the given pointer identifier.\n   */\n  InteractionManager.prototype.getInteractionDataForPointerId = function (event) {\n    var pointerId = event.pointerId;\n    var interactionData;\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData.copyEvent(event);\n    return interactionData;\n  };\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   * @param pointerId - Identifier from a pointer event\n   */\n  InteractionManager.prototype.releaseInteractionDataForPointerId = function (pointerId) {\n    var interactionData = this.activeInteractionData[pointerId];\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData.reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  };\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   * @param interactionEvent - The event to be configured\n   * @param pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @returns - the interaction event that was passed in\n   */\n  InteractionManager.prototype.configureInteractionEventForDOMEvent = function (interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n    // Not really sure why this is happening, but it's how a previous version handled things\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent.reset();\n    return interactionEvent;\n  };\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @returns - An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  InteractionManager.prototype.normalizeToPointerData = function (event) {\n    var normalizedEvents = [];\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n        var touch = event.changedTouches[i];\n        if (typeof touch.button === 'undefined') {\n          touch.button = event.touches.length ? 1 : 0;\n        }\n        if (typeof touch.buttons === 'undefined') {\n          touch.buttons = event.touches.length ? 1 : 0;\n        }\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') {\n          touch.width = touch.radiusX || 1;\n        }\n        if (typeof touch.height === 'undefined') {\n          touch.height = touch.radiusY || 1;\n        }\n        if (typeof touch.tiltX === 'undefined') {\n          touch.tiltX = 0;\n        }\n        if (typeof touch.tiltY === 'undefined') {\n          touch.tiltY = 0;\n        }\n        if (typeof touch.pointerType === 'undefined') {\n          touch.pointerType = 'touch';\n        }\n        if (typeof touch.pointerId === 'undefined') {\n          touch.pointerId = touch.identifier || 0;\n        }\n        if (typeof touch.pressure === 'undefined') {\n          touch.pressure = touch.force || 0.5;\n        }\n        if (typeof touch.twist === 'undefined') {\n          touch.twist = 0;\n        }\n        if (typeof touch.tangentialPressure === 'undefined') {\n          touch.tangentialPressure = 0;\n        }\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') {\n          touch.layerX = touch.offsetX = touch.clientX;\n        }\n        if (typeof touch.layerY === 'undefined') {\n          touch.layerY = touch.offsetY = touch.clientY;\n        }\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n        normalizedEvents.push(touch);\n      }\n    }\n    // apparently PointerEvent subclasses MouseEvent, so yay\n    else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {\n      var tempEvent = event;\n      if (typeof tempEvent.isPrimary === 'undefined') {\n        tempEvent.isPrimary = true;\n      }\n      if (typeof tempEvent.width === 'undefined') {\n        tempEvent.width = 1;\n      }\n      if (typeof tempEvent.height === 'undefined') {\n        tempEvent.height = 1;\n      }\n      if (typeof tempEvent.tiltX === 'undefined') {\n        tempEvent.tiltX = 0;\n      }\n      if (typeof tempEvent.tiltY === 'undefined') {\n        tempEvent.tiltY = 0;\n      }\n      if (typeof tempEvent.pointerType === 'undefined') {\n        tempEvent.pointerType = 'mouse';\n      }\n      if (typeof tempEvent.pointerId === 'undefined') {\n        tempEvent.pointerId = MOUSE_POINTER_ID;\n      }\n      if (typeof tempEvent.pressure === 'undefined') {\n        tempEvent.pressure = 0.5;\n      }\n      if (typeof tempEvent.twist === 'undefined') {\n        tempEvent.twist = 0;\n      }\n      if (typeof tempEvent.tangentialPressure === 'undefined') {\n        tempEvent.tangentialPressure = 0;\n      }\n      // mark the mouse event as normalized, just so that we know we did it\n      tempEvent.isNormalized = true;\n      normalizedEvents.push(tempEvent);\n    } else {\n      normalizedEvents.push(event);\n    }\n    return normalizedEvents;\n  };\n  /** Destroys the interaction manager. */\n  InteractionManager.prototype.destroy = function () {\n    this.removeEvents();\n    this.removeTickerListener();\n    this.removeAllListeners();\n    this.renderer = null;\n    this.mouse = null;\n    this.eventData = null;\n    this.interactionDOMElement = null;\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n    this.onPointerOver = null;\n    this.search = null;\n  };\n  /** @ignore */\n  InteractionManager.extension = {\n    name: 'interaction',\n    type: [core.ExtensionType.RendererPlugin, core.ExtensionType.CanvasRendererPlugin]\n  };\n  return InteractionManager;\n}(utils.EventEmitter);\nexports.InteractionData = InteractionData;\nexports.InteractionEvent = InteractionEvent;\nexports.InteractionManager = InteractionManager;\nexports.InteractionTrackingData = InteractionTrackingData;\nexports.interactiveTarget = interactiveTarget;","map":{"version":3,"mappings":"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","names":["global","Point","target","originalEvent","identifier","isPrimary","button","buttons","width","height","tiltX","tiltY","pointerType","pressure","rotationAngle","twist","tangentialPressure","Object","InteractionData","get","displayObject","point","globalPos","worldTransform","applyInverse","event","Number","isInteger","which","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","stopped","stopsPropagatingAt","stopPropagationHint","currentTarget","type","data","InteractionEvent","pointerId","_pointerId","_flags","InteractionTrackingData","FLAGS","NONE","flag","yn","set","flags","OVER","_doSet","RIGHT_DOWN","LEFT_DOWN","freeze","_tempPoint","TreeSearch","interactionEvent","func","hitTest","interactive","visible","hit","interactiveParent","hitTestChildren","hitArea","contains","x","y","_mask","maskObject","isMaskData","containsPoint","interactiveChildren","children","i","length","child","childHit","recursiveFindHit","parent","interactiveTarget","buttonMode","cursor","value","trackedPointers","_trackedPointers","undefined","DisplayObject","mixin","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","options","_super","_this","renderer","autoPreventDefault","interactionFrequency","mouse","activeInteractionData","interactionDataPool","eventData","interactionDOMElement","moveWhenInside","eventsAdded","tickerAdded","mouseOverRenderer","globalThis","supportsTouchEvents","supportsPointerEvents","PointerEvent","onPointerUp","bind","processPointerUp","onPointerCancel","processPointerCancel","onPointerDown","processPointerDown","onPointerMove","processPointerMove","onPointerOut","processPointerOverOut","onPointerOver","cursorStyles","default","pointer","currentCursorMode","resolution","delayedEvents","search","_tempDisplayObject","TemporaryDisplayObject","_eventListenerOptions","capture","passive","_useSystemTicker","useSystemTicker","setTargetElement","view","addTickerListener","removeTickerListener","_lastObjectRendered","globalPoint","root","lastObjectRendered","processInteractive","element","removeEvents","addEvents","Ticker","system","add","tickerUpdate","UPDATE_PRIORITY","INTERACTION","remove","style","navigator","msPointerEnabled","msContentZooming","msTouchAction","touchAction","document","addEventListener","removeEventListener","deltaTime","_deltaTime","update","_didMove","k","interactionData","configureInteractionEventForDOMEvent","setCursorMode","mode","applyStyles","OffscreenCanvas","assign","call","eventString","emit","push","rect","parentElement","left","top","getBoundingClientRect","resolutionMultiplier","findHit","delayedLen","displayObject_1","dispatchEvent","events","normalizeToPointerData","isNormalized","cancelable","preventDefault","eventLen","getInteractionDataForPointerId","isRightButton","id","rightDown","leftDown","cancelled","composedPath","eventAppend","releaseInteractionDataForPointerId","onPointerComplete","trackingData","isTouch","isMouse","isMouseTap","test","isDown","over","none","delayDispatchEvent","pop","copyEvent","reset","pointerEvent","mapPositionToPoint","clientX","clientY","globalX","globalY","normalizedEvents","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","force","layerX","offsetX","layerY","offsetY","MouseEvent","tempEvent","removeAllListeners","name","ExtensionType","RendererPlugin","CanvasRendererPlugin","EventEmitter"],"sources":["../../src/InteractionData.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/InteractionEvent.ts","../../src/InteractionTrackingData.ts","../../src/TreeSearch.ts","../../src/interactiveTarget.ts","../../src/InteractionManager.ts"],"sourcesContent":["import type { IPointData } from '@pixi/math';\nimport { Point } from '@pixi/math';\n\nimport type { DisplayObject } from '@pixi/display';\n\nexport type InteractivePointerEvent = PointerEvent | TouchEvent | MouseEvent;\n\n/**\n * Holds all information related to an Interaction event\n * @memberof PIXI\n */\nexport class InteractionData\n{\n    /** This point stores the global coords of where the touch/mouse event happened. */\n    public global: Point;\n\n    /** The target Sprite that was interacted with. */\n    public target: DisplayObject;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    public originalEvent: InteractivePointerEvent;\n\n    /** Unique identifier for this interaction. */\n    public identifier: number;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary: boolean;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     */\n    public button: number;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     */\n    public buttons: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width: number;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     */\n    public rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure = 0;\n\n    constructor()\n    {\n        this.global = new Point();\n        this.target = null;\n        this.originalEvent = null;\n        this.identifier = null;\n        this.isPrimary = false;\n        this.button = 0;\n        this.buttons = 0;\n        this.width = 0;\n        this.height = 0;\n        this.tiltX = 0;\n        this.tiltY = 0;\n        this.pointerType = null;\n        this.pressure = 0;\n        this.rotationAngle = 0;\n        this.twist = 0;\n        this.tangentialPressure = 0;\n    }\n\n    /**\n     * The unique identifier of the pointer. It will be the same as `identifier`.\n     * @readonly\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n     */\n    get pointerId(): number\n    {\n        return this.identifier;\n    }\n\n    /**\n     * This will return the local coordinates of the specified displayObject for this InteractionData\n     * @param displayObject - The DisplayObject that you would like the local\n     *  coords off\n     * @param point - A Point object in which to store the value, optional (otherwise\n     *  will create a new point)\n     * @param globalPos - A Point object containing your custom global coords, optional\n     *  (otherwise will use the current global coords)\n     * @returns - A point containing the coordinates of the InteractionData position relative\n     *  to the DisplayObject\n     */\n    public getLocalPosition<P extends IPointData = Point>(displayObject: DisplayObject, point?: P, globalPos?: IPointData): P\n    {\n        return displayObject.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Copies properties from normalized event data.\n     * @param {Touch|MouseEvent|PointerEvent} event - The normalized event data\n     */\n    public copyEvent(event: Touch | InteractivePointerEvent): void\n    {\n        // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n        // it with \"false\" on later events when our shim for it on touch events might not be\n        // accurate\n        if ('isPrimary' in event && event.isPrimary)\n        {\n            this.isPrimary = true;\n        }\n        this.button = 'button' in event && event.button;\n        // event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard\n        // event.which property instead, which conveys the same information.\n        const buttons = 'buttons' in event && event.buttons;\n\n        this.buttons = Number.isInteger(buttons) ? buttons : 'which' in event && event.which;\n        this.width = 'width' in event && event.width;\n        this.height = 'height' in event && event.height;\n        this.tiltX = 'tiltX' in event && event.tiltX;\n        this.tiltY = 'tiltY' in event && event.tiltY;\n        this.pointerType = 'pointerType' in event && event.pointerType;\n        this.pressure = 'pressure' in event && event.pressure;\n        this.rotationAngle = 'rotationAngle' in event && event.rotationAngle;\n        this.twist = ('twist' in event && event.twist) || 0;\n        this.tangentialPressure = ('tangentialPressure' in event && event.tangentialPressure) || 0;\n    }\n\n    /** Resets the data for pooling. */\n    public reset(): void\n    {\n        // isPrimary is the only property that we really need to reset - everything else is\n        // guaranteed to be overwritten\n        this.isPrimary = false;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import type { DisplayObject } from '@pixi/display';\nimport type { InteractionData } from './InteractionData';\n\nexport type InteractionCallback = (interactionEvent: InteractionEvent, displayObject: DisplayObject, hit?: boolean) => void;\n\n/**\n * Event class that mimics native DOM events.\n * @memberof PIXI\n */\nexport class InteractionEvent\n{\n    /**\n     * Whether this event will continue propagating in the tree.\n     *\n     * Remaining events for the {@link stopsPropagatingAt} object\n     * will still be dispatched.\n     */\n    public stopped: boolean;\n\n    /**\n     * At which object this event stops propagating.\n     * @private\n     */\n    public stopsPropagatingAt: DisplayObject;\n\n    /**\n     * Whether we already reached the element we want to\n     * stop propagating at. This is important for delayed events,\n     * where we start over deeper in the tree again.\n     * @private\n     */\n    public stopPropagationHint: boolean;\n\n    /**\n     * The object which caused this event to be dispatched.\n     * For listener callback see {@link PIXI.InteractionEvent.currentTarget}.\n     */\n    public target: DisplayObject;\n\n    /** The object whose event listeners callback is currently being invoked. */\n    public currentTarget: DisplayObject;\n\n    /** Type of the event. */\n    public type: string;\n\n    /** {@link InteractionData} related to this event */\n    public data: InteractionData;\n\n    constructor()\n    {\n        this.stopped = false;\n        this.stopsPropagatingAt = null;\n        this.stopPropagationHint = false;\n        this.target = null;\n        this.currentTarget = null;\n        this.type = null;\n        this.data = null;\n    }\n\n    /** Prevents event from reaching any objects other than the current object. */\n    public stopPropagation(): void\n    {\n        this.stopped = true;\n        this.stopPropagationHint = true;\n        this.stopsPropagatingAt = this.currentTarget;\n    }\n\n    /** Resets the event. */\n    public reset(): void\n    {\n        this.stopped = false;\n        this.stopsPropagatingAt = null;\n        this.stopPropagationHint = false;\n        this.currentTarget = null;\n        this.target = null;\n    }\n}\n","export interface InteractionTrackingFlags\n{\n    OVER: number;\n    LEFT_DOWN: number;\n    RIGHT_DOWN: number;\n    NONE: number;\n}\n\n/**\n * DisplayObjects with the {@link PIXI.interactiveTarget} mixin use this class to track interactions\n * @class\n * @private\n * @memberof PIXI\n */\nexport class InteractionTrackingData\n{\n    public static FLAGS: Readonly<InteractionTrackingFlags> = Object.freeze({\n        NONE: 0,\n        OVER: 1 << 0,\n        LEFT_DOWN: 1 << 1,\n        RIGHT_DOWN: 1 << 2,\n    });\n\n    private readonly _pointerId: number;\n    private _flags: number;\n\n    /**\n     * @param {number} pointerId - Unique pointer id of the event\n     * @private\n     */\n    constructor(pointerId: number)\n    {\n        this._pointerId = pointerId;\n        this._flags = InteractionTrackingData.FLAGS.NONE;\n    }\n\n    /**\n     *\n     * @private\n     * @param {number} flag - The interaction flag to set\n     * @param {boolean} yn - Should the flag be set or unset\n     */\n    private _doSet(flag: number, yn: boolean): void\n    {\n        if (yn)\n        {\n            this._flags = this._flags | flag;\n        }\n        else\n        {\n            this._flags = this._flags & (~flag);\n        }\n    }\n\n    /**\n     * Unique pointer id of the event\n     * @readonly\n     * @private\n     * @member {number}\n     */\n    get pointerId(): number\n    {\n        return this._pointerId;\n    }\n\n    /**\n     * State of the tracking data, expressed as bit flags\n     * @private\n     * @member {number}\n     */\n    get flags(): number\n    {\n        return this._flags;\n    }\n\n    set flags(flags: number)\n    {\n        this._flags = flags;\n    }\n\n    /**\n     * Is the tracked event inactive (not over or down)?\n     * @private\n     * @member {number}\n     */\n    get none(): boolean\n    {\n        return this._flags === InteractionTrackingData.FLAGS.NONE;\n    }\n\n    /**\n     * Is the tracked event over the DisplayObject?\n     * @private\n     * @member {boolean}\n     */\n    get over(): boolean\n    {\n        return (this._flags & InteractionTrackingData.FLAGS.OVER) !== 0;\n    }\n\n    set over(yn: boolean)\n    {\n        this._doSet(InteractionTrackingData.FLAGS.OVER, yn);\n    }\n\n    /**\n     * Did the right mouse button come down in the DisplayObject?\n     * @private\n     * @member {boolean}\n     */\n    get rightDown(): boolean\n    {\n        return (this._flags & InteractionTrackingData.FLAGS.RIGHT_DOWN) !== 0;\n    }\n\n    set rightDown(yn: boolean)\n    {\n        this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN, yn);\n    }\n\n    /**\n     * Did the left mouse button come down in the DisplayObject?\n     * @private\n     * @member {boolean}\n     */\n    get leftDown(): boolean\n    {\n        return (this._flags & InteractionTrackingData.FLAGS.LEFT_DOWN) !== 0;\n    }\n\n    set leftDown(yn: boolean)\n    {\n        this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN, yn);\n    }\n}\n","import { Point } from '@pixi/math';\n\nimport type { InteractionEvent, InteractionCallback } from './InteractionEvent';\nimport type { Container, DisplayObject } from '@pixi/display';\n\n/**\n * Strategy how to search through stage tree for interactive objects\n * @memberof PIXI\n */\nexport class TreeSearch\n{\n    private readonly _tempPoint: Point;\n\n    constructor()\n    {\n        this._tempPoint = new Point();\n    }\n\n    /**\n     * Recursive implementation for findHit\n     * @private\n     * @param interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param func - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param hitTest - this indicates if the objects inside should be hit test against the point\n     * @param interactive - Whether the displayObject is interactive\n     * @returns - Returns true if the displayObject hit the point\n     */\n    public recursiveFindHit(interactionEvent: InteractionEvent, displayObject: DisplayObject,\n        func?: InteractionCallback, hitTest?: boolean, interactive?: boolean\n    ): boolean\n    {\n        if (!displayObject || !displayObject.visible)\n        {\n            return false;\n        }\n\n        const point = interactionEvent.data.global;\n\n        // Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^\n        //\n        // This function will now loop through all objects and then only hit test the objects it HAS\n        // to, not all of them. MUCH faster..\n        // An object will be hit test if the following is true:\n        //\n        // 1: It is interactive.\n        // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n        //\n        // As another little optimization once an interactive object has been hit we can carry on\n        // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n        // A final optimization is that an object is not hit test directly if a child has already been hit.\n\n        interactive = displayObject.interactive || interactive;\n\n        let hit = false;\n        let interactiveParent = interactive;\n\n        // Flag here can set to false if the event is outside the parents hitArea or mask\n        let hitTestChildren = true;\n\n        // If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea\n        // There is also no longer a need to hitTest children.\n        if (displayObject.hitArea)\n        {\n            if (hitTest)\n            {\n                displayObject.worldTransform.applyInverse(point, this._tempPoint);\n                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y))\n                {\n                    hitTest = false;\n                    hitTestChildren = false;\n                }\n                else\n                {\n                    hit = true;\n                }\n            }\n            interactiveParent = false;\n        }\n        // If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.\n        // We still want to hitTestChildren, however, to ensure a mouseout can still be generated.\n        // https://github.com/pixijs/pixi.js/issues/5135\n        else if (displayObject._mask)\n        {\n            if (hitTest)\n            {\n                const maskObject = ((displayObject._mask as any).isMaskData\n                    ? (displayObject._mask as any).maskObject : displayObject._mask) as any;\n\n                if (maskObject && !maskObject.containsPoint?.(point))\n                {\n                    hitTest = false;\n                }\n            }\n        }\n\n        // ** FREE TIP **! If an object is not interactive or has no buttons in it\n        // (such as a game scene!) set interactiveChildren to false for that displayObject.\n        // This will allow PixiJS to completely ignore and bypass checking the displayObjects children.\n        if (hitTestChildren && displayObject.interactiveChildren && (displayObject as Container).children)\n        {\n            const children = (displayObject as Container).children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i];\n\n                // time to get recursive.. if this function will return if something is hit..\n                const childHit = this.recursiveFindHit(interactionEvent, child, func, hitTest, interactiveParent);\n\n                if (childHit)\n                {\n                    // its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (!child.parent)\n                    {\n                        continue;\n                    }\n\n                    // we no longer need to hit test any more objects in this container as we we\n                    // now know the parent has been hit\n                    interactiveParent = false;\n\n                    // If the child is interactive , that means that the object hit was actually\n                    // interactive and not just the child of an interactive object.\n                    // This means we no longer need to hit test anything else. We still need to run\n                    // through all objects, but we don't need to perform any hit tests.\n\n                    if (childHit)\n                    {\n                        if (interactionEvent.target)\n                        {\n                            hitTest = false;\n                        }\n                        hit = true;\n                    }\n                }\n            }\n        }\n\n        // no point running this if the item is not interactive or does not have an interactive parent.\n        if (interactive)\n        {\n            // if we are hit testing (as in we have no hit any objects yet)\n            // We also don't need to worry about hit testing if once of the displayObjects children\n            // has already been hit - but only if it was interactive, otherwise we need to keep\n            // looking for an interactive child, just in case we hit one\n            if (hitTest && !interactionEvent.target)\n            {\n                // already tested against hitArea if it is defined\n                if (!displayObject.hitArea && (displayObject as any).containsPoint)\n                {\n                    if ((displayObject as any).containsPoint(point))\n                    {\n                        hit = true;\n                    }\n                }\n            }\n\n            if (displayObject.interactive)\n            {\n                if (hit && !interactionEvent.target)\n                {\n                    interactionEvent.target = displayObject;\n                }\n\n                if (func)\n                {\n                    func(interactionEvent, displayObject, !!hit);\n                }\n            }\n        }\n\n        return hit;\n    }\n\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     * @private\n     * @param interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param func - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param hitTest - this indicates if the objects inside should be hit test against the point\n     * @returns - Returns true if the displayObject hit the point\n     */\n    public findHit(interactionEvent: InteractionEvent, displayObject: DisplayObject,\n        func?: InteractionCallback, hitTest?: boolean\n    ): void\n    {\n        this.recursiveFindHit(interactionEvent, displayObject, func, hitTest, false);\n    }\n}\n","import type { InteractionTrackingData } from './InteractionTrackingData';\n\ntype Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\nexport interface IHitArea\n{\n    contains(x: number, y: number): boolean;\n}\n\nexport interface InteractiveTarget\n{\n    interactive: boolean;\n    interactiveChildren: boolean;\n    hitArea: IHitArea | null;\n    cursor: Cursor | string;\n    buttonMode: boolean;\n    trackedPointers: {[x: number]: InteractionTrackingData};\n    _trackedPointers: {[x: number]: InteractionTrackingData};\n}\n\n/**\n * Interface for classes that represent a hit area.\n *\n * It is implemented by the following classes:\n * - {@link PIXI.Circle}\n * - {@link PIXI.Ellipse}\n * - {@link PIXI.Polygon}\n * - {@link PIXI.RoundedRectangle}\n * @interface IHitArea\n * @memberof PIXI\n */\n\n/**\n * Checks whether the x and y coordinates given are contained within this area\n * @method\n * @name contains\n * @memberof PIXI.IHitArea#\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @returns {boolean} Whether the x/y coordinates are within this area\n */\n\n/**\n * Default property values of interactive objects\n * Used by {@link PIXI.InteractionManager} to automatically give all DisplayObjects these properties\n * @private\n * @name interactiveTarget\n * @type {object}\n * @memberof PIXI\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          DisplayObject.prototype,\n *          PIXI.interactiveTarget\n *      );\n */\nexport const interactiveTarget: InteractiveTarget = {\n    interactive: false,\n    interactiveChildren: true,\n    hitArea: null,\n\n    /**\n     * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n     * Setting this changes the 'cursor' property to `'pointer'`.\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.buttonMode = true;\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */\n    get buttonMode(): boolean\n    {\n        return this.cursor === 'pointer';\n    },\n    set buttonMode(value: boolean)\n    {\n        if (value)\n        {\n            this.cursor = 'pointer';\n        }\n        else if (this.cursor === 'pointer')\n        {\n            this.cursor = null;\n        }\n    },\n\n    /**\n     * This defines what cursor mode is used when the mouse cursor\n     * is hovered over the displayObject.\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.cursor = 'wait';\n     * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n     * @member {string}\n     * @memberof PIXI.DisplayObject#\n     */\n    cursor: null,\n\n    /**\n     * Internal set of all active pointers, by identifier\n     * @member {Map<number, InteractionTrackingData>}\n     * @memberof PIXI.DisplayObject#\n     * @private\n     */\n    get trackedPointers()\n    {\n        if (this._trackedPointers === undefined) this._trackedPointers = {};\n\n        return this._trackedPointers;\n    },\n\n    /**\n     * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n     * @private\n     * @type {Map<number, InteractionTrackingData>}\n     */\n    _trackedPointers: undefined,\n};\n","import { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\nimport { DisplayObject, TemporaryDisplayObject } from '@pixi/display';\nimport type { InteractivePointerEvent } from './InteractionData';\nimport { InteractionData } from './InteractionData';\nimport type { InteractionCallback } from './InteractionEvent';\nimport { InteractionEvent } from './InteractionEvent';\nimport { InteractionTrackingData } from './InteractionTrackingData';\nimport { TreeSearch } from './TreeSearch';\nimport { EventEmitter } from '@pixi/utils';\nimport { interactiveTarget } from './interactiveTarget';\n\nimport type { AbstractRenderer, ExtensionMetadata } from '@pixi/core';\nimport { ExtensionType } from '@pixi/core';\nimport type { Point, IPointData } from '@pixi/math';\nimport type { Dict } from '@pixi/utils';\n\n// Mix interactiveTarget into DisplayObject.prototype\nDisplayObject.mixin(interactiveTarget);\n\nconst MOUSE_POINTER_ID = 1;\n\n// Mock interface for hitTestEvent - only used inside hitTest()\ninterface TestInteractionEvent\n{\n    target: DisplayObject;\n    data: {global: Point};\n}\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent: TestInteractionEvent = {\n    target: null,\n    data: {\n        global: null,\n    },\n};\n\nexport interface InteractionManagerOptions\n{\n    autoPreventDefault?: boolean;\n    interactionFrequency?: number;\n    useSystemTicker?: boolean;\n}\n\nexport interface DelayedEvent\n{\n    displayObject: DisplayObject;\n    eventString: string;\n    eventData: InteractionEvent;\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\n/**\n * The interaction manager deals with mouse, touch and pointer events.\n *\n * Any DisplayObject can be interactive if its `interactive` property is set to true.\n *\n * This manager also supports multitouch.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`\n * @memberof PIXI\n */\nexport class InteractionManager extends EventEmitter\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'interaction',\n        type: [\n            ExtensionType.RendererPlugin,\n            ExtensionType.CanvasRendererPlugin,\n        ],\n    };\n\n    /**\n     * Actively tracked InteractionData\n     * @private\n     * @member {Object<number, PIXI.InteractionData>}\n     */\n    public readonly activeInteractionData: { [key: number]: InteractionData };\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents: boolean;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents: boolean;\n\n    /**\n     * Pool of unused InteractionData\n     * @private\n     */\n    public interactionDataPool: InteractionData[];\n\n    /**\n     * Internal cached let.\n     * @private\n     */\n    public cursor: string;\n\n    /**\n     * Delayed pointer events. Used to guarantee correct ordering of over/out events.\n     * @private\n     */\n    public delayedEvents: DelayedEvent[];\n\n    /**\n     * TreeSearch component that is used to hitTest stage tree.\n     * @private\n     */\n    public search: TreeSearch;\n\n    /** The renderer this interaction manager works for. */\n    public renderer: AbstractRenderer;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility as\n     * preventDefault on pointer events stops mouse events from firing.\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Maximum frequency in milliseconds at which pointer over/out states will be checked by {@link tickerUpdate}.\n     * @default 10\n     */\n    public interactionFrequency: number;\n\n    /** The mouse data. */\n    public mouse: InteractionData;\n\n    /** An event data object to handle all the event tracking/dispatching. */\n    public eventData: InteractionEvent;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM version works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how PixiJS used to work. This will be set to true in\n     * future versions of pixi.\n     * @default false\n     */\n    public moveWhenInside: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object<string, Object>}\n     */\n    public cursorStyles: Dict<string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /** The mode of the cursor that is being used. The value of this is a key from the cursorStyles dictionary. */\n    public currentCursorMode: string;\n\n    /**\n     * The current resolution / device pixel ratio.\n     * @default 1\n     */\n    public resolution: number;\n\n    /** The DOM element to bind to. */\n    protected interactionDOMElement: HTMLElement;\n\n    /** Have events been attached to the dom element? */\n    protected eventsAdded: boolean;\n\n    /** Has the system ticker been added? */\n    protected tickerAdded: boolean;\n\n    /** Is the mouse hovering over the renderer? If working in worker mouse considered to be over renderer by default. */\n    protected mouseOverRenderer: boolean;\n\n    private _useSystemTicker: boolean;\n    private _deltaTime: number;\n    private _didMove: boolean;\n\n    /** Used as a last rendered object in case renderer doesnt have _lastObjectRendered. */\n    private _tempDisplayObject: DisplayObject;\n\n    /**\n     * An options object specifies characteristics about the event listener.\n     * @member {Object<string, boolean>}\n     */\n    private readonly _eventListenerOptions: { capture: true, passive: false };\n\n    /**\n     * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer\n     * @param options - The options for the manager.\n     * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.\n     * @param {number} [options.interactionFrequency=10] - Maximum frequency (ms) at pointer over/out states will be checked.\n     * @param {number} [options.useSystemTicker=true] - Whether to add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n     */\n    constructor(renderer: AbstractRenderer, options?: InteractionManagerOptions)\n    {\n        super();\n\n        options = options || {};\n\n        this.renderer = renderer;\n        this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;\n        this.interactionFrequency = options.interactionFrequency || 10;\n        this.mouse = new InteractionData();\n        this.mouse.identifier = MOUSE_POINTER_ID;\n\n        // setting the mouse to start off far off screen will mean that mouse over does\n        //  not get called before we even move the mouse.\n        this.mouse.global.set(-999999);\n\n        this.activeInteractionData = {};\n        this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n        this.interactionDataPool = [];\n        this.eventData = new InteractionEvent();\n        this.interactionDOMElement = null;\n\n        this.moveWhenInside = false;\n        this.eventsAdded = false;\n        this.tickerAdded = false;\n        this.mouseOverRenderer = !('PointerEvent' in globalThis);\n        this.supportsTouchEvents = 'ontouchstart' in globalThis;\n        this.supportsPointerEvents = !!globalThis.PointerEvent;\n\n        // this will make it so that you don't have to call bind all the time\n\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.processPointerUp = this.processPointerUp.bind(this);\n\n        this.onPointerCancel = this.onPointerCancel.bind(this);\n        this.processPointerCancel = this.processPointerCancel.bind(this);\n\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.processPointerDown = this.processPointerDown.bind(this);\n\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.processPointerMove = this.processPointerMove.bind(this);\n\n        this.onPointerOut = this.onPointerOut.bind(this);\n        this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n        this.onPointerOver = this.onPointerOver.bind(this);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n        this.currentCursorMode = null;\n        this.cursor = null;\n\n        this.resolution = 1;\n        this.delayedEvents = [];\n        this.search = new TreeSearch();\n\n        this._tempDisplayObject = new TemporaryDisplayObject();\n        this._eventListenerOptions = { capture: true, passive: false };\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n         * object.\n         * @event PIXI.InteractionManager#mousedown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * on the display object.\n         * @event PIXI.InteractionManager#rightdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released over the display\n         * object.\n         * @event PIXI.InteractionManager#mouseup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * over the display object.\n         * @event PIXI.InteractionManager#rightup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n         * the display object.\n         * @event PIXI.InteractionManager#click\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * and released on the display object.\n         * @event PIXI.InteractionManager#rightclick\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released outside the\n         * display object that initially registered a\n         * [mousedown]{@link PIXI.InteractionManager#event:mousedown}.\n         * @event PIXI.InteractionManager#mouseupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * outside the display object that initially registered a\n         * [rightdown]{@link PIXI.InteractionManager#event:rightdown}.\n         * @event PIXI.InteractionManager#rightupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved while over the display object\n         * @event PIXI.InteractionManager#mousemove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved onto the display object\n         * @event PIXI.InteractionManager#mouseover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved off the display object\n         * @event PIXI.InteractionManager#mouseout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed on the display object.\n         * @event PIXI.InteractionManager#pointerdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released over the display object.\n         * Not always fired when some buttons are held down while others are released. In those cases,\n         * use [mousedown]{@link PIXI.InteractionManager#event:mousedown} and\n         * [mouseup]{@link PIXI.InteractionManager#event:mouseup} instead.\n         * @event PIXI.InteractionManager#pointerup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a pointer event\n         * @event PIXI.InteractionManager#pointercancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed and released on the display object.\n         * @event PIXI.InteractionManager#pointertap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released outside the display object that initially\n         * registered a [pointerdown]{@link PIXI.InteractionManager#event:pointerdown}.\n         * @event PIXI.InteractionManager#pointerupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved while over the display object\n         * @event PIXI.InteractionManager#pointermove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved onto the display object\n         * @event PIXI.InteractionManager#pointerover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved off the display object\n         * @event PIXI.InteractionManager#pointerout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed on the display object.\n         * @event PIXI.InteractionManager#touchstart\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed from the display object.\n         * @event PIXI.InteractionManager#touchend\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a touch\n         * @event PIXI.InteractionManager#touchcancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed and removed from the display object.\n         * @event PIXI.InteractionManager#tap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed outside of the display object that initially\n         * registered a [touchstart]{@link PIXI.InteractionManager#event:touchstart}.\n         * @event PIXI.InteractionManager#touchendoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is moved along the display object.\n         * @event PIXI.InteractionManager#touchmove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n         * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#mousedown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#rightdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released over the display\n         * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#mouseup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#rightup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n         * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#click\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#rightclick\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button (usually a mouse left-button) is released outside the\n         * display object that initially registered a\n         * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#mouseupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * outside the display object that initially registered a\n         * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#rightupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved while over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#mousemove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved onto the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#mouseover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device (usually a mouse) is moved off the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#mouseout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointerdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointerup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a pointer event.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointercancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is pressed and released on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointertap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device button is released outside the display object that initially\n         * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointerupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved while over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointermove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved onto the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointerover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a pointer device is moved off the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#pointerout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#touchstart\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed from the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#touchend\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when the operating system cancels a touch.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#touchcancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is placed and removed from the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#tap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is removed outside of the display object that initially\n         * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#touchendoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        /**\n         * Fired when a touch point is moved along the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         * @event PIXI.DisplayObject#touchmove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */\n\n        this._useSystemTicker = options.useSystemTicker !== undefined ? options.useSystemTicker : true;\n\n        this.setTargetElement(this.renderer.view, this.renderer.resolution);\n    }\n\n    /**\n     * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n     * @default true\n     */\n    get useSystemTicker(): boolean\n    {\n        return this._useSystemTicker;\n    }\n    set useSystemTicker(useSystemTicker: boolean)\n    {\n        this._useSystemTicker = useSystemTicker;\n\n        if (useSystemTicker)\n        {\n            this.addTickerListener();\n        }\n        else\n        {\n            this.removeTickerListener();\n        }\n    }\n\n    /**\n     * Last rendered object or temp object.\n     * @readonly\n     * @protected\n     */\n    get lastObjectRendered(): DisplayObject\n    {\n        return (this.renderer._lastObjectRendered as DisplayObject) || this._tempDisplayObject;\n    }\n\n    /**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     * @param globalPoint - A point to hit test with, in global space.\n     * @param root - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @returns - The hit display object, if any.\n     */\n    public hitTest(globalPoint: Point, root?: DisplayObject): DisplayObject\n    {\n        // clear the target for our hit test\n        hitTestEvent.target = null;\n        // assign the global point\n        hitTestEvent.data.global = globalPoint;\n        // ensure safety of the root\n        if (!root)\n        {\n            root = this.lastObjectRendered;\n        }\n        // run the hit test\n        this.processInteractive(hitTestEvent as InteractionEvent, root, null, true);\n        // return our found object - it'll be null if we didn't hit anything\n\n        return hitTestEvent.target;\n    }\n\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate\n     * another DOM element to receive those events.\n     * @param element - the DOM element which will receive mouse and touch events.\n     * @param resolution - The resolution / device pixel ratio of the new element (relative to the canvas).\n     */\n    public setTargetElement(element: HTMLElement, resolution = 1): void\n    {\n        this.removeTickerListener();\n\n        this.removeEvents();\n\n        this.interactionDOMElement = element;\n\n        this.resolution = resolution;\n\n        this.addEvents();\n\n        this.addTickerListener();\n    }\n\n    /** Adds the ticker listener. */\n    private addTickerListener(): void\n    {\n        if (this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker)\n        {\n            return;\n        }\n\n        Ticker.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this.tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    private removeTickerListener(): void\n    {\n        if (!this.tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this.tickerUpdate, this);\n\n        this.tickerAdded = false;\n    }\n\n    /** Registers all the DOM events. */\n    private addEvents(): void\n    {\n        if (this.eventsAdded || !this.interactionDOMElement)\n        {\n            return;\n        }\n\n        const style = this.interactionDOMElement.style as CrossCSSStyleDeclaration;\n\n        if ((globalThis.navigator as any).msPointerEnabled)\n        {\n            style.msContentZooming = 'none';\n            style.msTouchAction = 'none';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            style.touchAction = 'none';\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this.onPointerMove, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, this._eventListenerOptions);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, this._eventListenerOptions);\n            globalThis.addEventListener('pointercancel', this.onPointerCancel, this._eventListenerOptions);\n            globalThis.addEventListener('pointerup', this.onPointerUp, this._eventListenerOptions);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this.onPointerMove, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, this._eventListenerOptions);\n            globalThis.addEventListener('mouseup', this.onPointerUp, this._eventListenerOptions);\n        }\n\n        // always look directly for touch events so that we can provide original data\n        // In a future version we should change this to being just a fallback and rely solely on\n        // PointerEvents whenever available\n        if (this.supportsTouchEvents)\n        {\n            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, this._eventListenerOptions);\n            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, this._eventListenerOptions);\n        }\n\n        this.eventsAdded = true;\n    }\n\n    /** Removes all the DOM events that were previously registered. */\n    private removeEvents(): void\n    {\n        if (!this.eventsAdded || !this.interactionDOMElement)\n        {\n            return;\n        }\n\n        const style = this.interactionDOMElement.style as CrossCSSStyleDeclaration;\n\n        if ((globalThis.navigator as any).msPointerEnabled)\n        {\n            style.msContentZooming = '';\n            style.msTouchAction = '';\n        }\n        else if (this.supportsPointerEvents)\n        {\n            style.touchAction = '';\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this.onPointerMove, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, this._eventListenerOptions);\n            globalThis.removeEventListener('pointercancel', this.onPointerCancel, this._eventListenerOptions);\n            globalThis.removeEventListener('pointerup', this.onPointerUp, this._eventListenerOptions);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this.onPointerMove, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, this._eventListenerOptions);\n            globalThis.removeEventListener('mouseup', this.onPointerUp, this._eventListenerOptions);\n        }\n\n        if (this.supportsTouchEvents)\n        {\n            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, this._eventListenerOptions);\n            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, this._eventListenerOptions);\n        }\n\n        this.interactionDOMElement = null;\n\n        this.eventsAdded = false;\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n     * @param deltaTime - time delta since the last call\n     */\n    public tickerUpdate(deltaTime: number): void\n    {\n        this._deltaTime += deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this.update();\n    }\n\n    /** Updates the state of interactive objects. */\n    public update(): void\n    {\n        if (!this.interactionDOMElement)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        this.cursor = null;\n\n        // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n        // but there was a scenario of a display object moving under a static mouse cursor.\n        // In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function\n        for (const k in this.activeInteractionData)\n        {\n            // eslint-disable-next-line no-prototype-builtins\n            if (this.activeInteractionData.hasOwnProperty(k))\n            {\n                const interactionData = this.activeInteractionData[k];\n\n                if (interactionData.originalEvent && interactionData.pointerType !== 'touch')\n                {\n                    const interactionEvent = this.configureInteractionEventForDOMEvent(\n                        this.eventData,\n                        interactionData.originalEvent as PointerEvent,\n                        interactionData\n                    );\n\n                    this.processInteractive(\n                        interactionEvent,\n                        this.lastObjectRendered,\n                        this.processPointerOverOut,\n                        true\n                    );\n                }\n            }\n        }\n\n        this.setCursorMode(this.cursor);\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursorMode(mode: string): void\n    {\n        mode = mode || 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this.currentCursorMode === mode)\n        {\n            return;\n        }\n        this.currentCursorMode = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.interactionDOMElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.interactionDOMElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.interactionDOMElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * Dispatches an event on the display object that was interacted with.\n     * @param displayObject - the display object in question\n     * @param eventString - the name of the event (e.g, mousedown)\n     * @param eventData - the event data object\n     */\n    private dispatchEvent(displayObject: DisplayObject, eventString: string, eventData: InteractionEvent): void\n    {\n        // Even if the event was stopped, at least dispatch any remaining events\n        // for the same display object.\n        if (!eventData.stopPropagationHint || displayObject === eventData.stopsPropagatingAt)\n        {\n            eventData.currentTarget = displayObject;\n            eventData.type = eventString;\n\n            displayObject.emit(eventString, eventData);\n\n            if ((displayObject as any)[eventString])\n            {\n                (displayObject as any)[eventString](eventData);\n            }\n        }\n    }\n\n    /**\n     * Puts a event on a queue to be dispatched later. This is used to guarantee correct\n     * ordering of over/out events.\n     * @param displayObject - the display object in question\n     * @param eventString - the name of the event (e.g, mousedown)\n     * @param eventData - the event data object\n     */\n    private delayDispatchEvent(displayObject: DisplayObject, eventString: string, eventData: InteractionEvent): void\n    {\n        this.delayedEvents.push({ displayObject, eventString, eventData });\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param point - the point that the result will be stored in\n     * @param x - the x coord of the position to map\n     * @param y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: IPointData, x: number, y: number): void\n    {\n        let rect;\n\n        // IE 11 fix\n        if (!this.interactionDOMElement.parentElement)\n        {\n            rect = {\n                x: 0,\n                y: 0,\n                width: (this.interactionDOMElement as any).width,\n                height: (this.interactionDOMElement as any).height,\n                left: 0,\n                top: 0\n            };\n        }\n        else\n        {\n            rect = this.interactionDOMElement.getBoundingClientRect();\n        }\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.interactionDOMElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.interactionDOMElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     * @protected\n     * @param interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param func - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param hitTest - indicates whether we want to calculate hits\n     *  or just iterate through all interactive objects\n     */\n    public processInteractive(interactionEvent: InteractionEvent, displayObject: DisplayObject,\n        func?: InteractionCallback, hitTest?: boolean\n    ): void\n    {\n        const hit = this.search.findHit(interactionEvent, displayObject, func, hitTest);\n\n        const delayedEvents = this.delayedEvents;\n\n        if (!delayedEvents.length)\n        {\n            return hit;\n        }\n        // Reset the propagation hint, because we start deeper in the tree again.\n        interactionEvent.stopPropagationHint = false;\n\n        const delayedLen = delayedEvents.length;\n\n        this.delayedEvents = [];\n\n        for (let i = 0; i < delayedLen; i++)\n        {\n            const { displayObject, eventString, eventData } = delayedEvents[i];\n\n            // When we reach the object we wanted to stop propagating at,\n            // set the propagation hint.\n            if (eventData.stopsPropagatingAt === displayObject)\n            {\n                eventData.stopPropagationHint = true;\n            }\n\n            this.dispatchEvent(displayObject, eventString, eventData);\n        }\n\n        return hit;\n    }\n\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     * @param originalEvent - The DOM event of a pointer button being pressed down\n     */\n    private onPointerDown(originalEvent: InteractivePointerEvent): void\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (originalEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);\n\n            if (cancelable)\n            {\n                originalEvent.preventDefault();\n            }\n        }\n\n        const eventLen = events.length;\n\n        for (let i = 0; i < eventLen; i++)\n        {\n            const event = events[i];\n\n            const interactionData = this.getInteractionDataForPointerId(event);\n\n            const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n            interactionEvent.data.originalEvent = originalEvent;\n\n            this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerDown, true);\n\n            this.emit('pointerdown', interactionEvent);\n            if (event.pointerType === 'touch')\n            {\n                this.emit('touchstart', interactionEvent);\n            }\n            // emit a mouse event for \"pen\" pointers, the way a browser would emit a fallback event\n            else if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n            {\n                const isRightButton = event.button === 2;\n\n                this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n            }\n        }\n    }\n\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */\n    private processPointerDown(interactionEvent: InteractionEvent, displayObject: DisplayObject, hit: boolean): void\n    {\n        const data = interactionEvent.data;\n        const id = interactionEvent.data.identifier;\n\n        if (hit)\n        {\n            if (!displayObject.trackedPointers[id])\n            {\n                displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n            }\n            this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);\n\n            if (data.pointerType === 'touch')\n            {\n                this.dispatchEvent(displayObject, 'touchstart', interactionEvent);\n            }\n            else if (data.pointerType === 'mouse' || data.pointerType === 'pen')\n            {\n                const isRightButton = data.button === 2;\n\n                if (isRightButton)\n                {\n                    displayObject.trackedPointers[id].rightDown = true;\n                }\n                else\n                {\n                    displayObject.trackedPointers[id].leftDown = true;\n                }\n\n                this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer button is released on the renderer element\n     * @param originalEvent - The DOM event of a pointer button being released\n     * @param cancelled - true if the pointer is cancelled\n     * @param func - Function passed to {@link processInteractive}\n     */\n    private onPointerComplete(originalEvent: InteractivePointerEvent, cancelled: boolean, func: InteractionCallback): void\n    {\n        const events = this.normalizeToPointerData(originalEvent);\n\n        const eventLen = events.length;\n\n        // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n        // in all cases (unless it was a pointercancel)\n        let target = originalEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (originalEvent.composedPath && originalEvent.composedPath().length > 0)\n        {\n            target = originalEvent.composedPath()[0];\n        }\n\n        const eventAppend = target !== this.interactionDOMElement ? 'outside' : '';\n\n        for (let i = 0; i < eventLen; i++)\n        {\n            const event = events[i];\n\n            const interactionData = this.getInteractionDataForPointerId(event);\n\n            const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n            interactionEvent.data.originalEvent = originalEvent;\n\n            // perform hit testing for events targeting our canvas or cancel events\n            this.processInteractive(interactionEvent, this.lastObjectRendered, func, cancelled || !eventAppend);\n\n            this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n            if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n            {\n                const isRightButton = event.button === 2;\n\n                this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n            }\n            else if (event.pointerType === 'touch')\n            {\n                this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n                this.releaseInteractionDataForPointerId(event.pointerId);\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer button is cancelled\n     * @param event - The DOM event of a pointer button being released\n     */\n    private onPointerCancel(event: InteractivePointerEvent): void\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (event as PointerEvent).pointerType === 'touch') return;\n\n        this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     */\n    private processPointerCancel(interactionEvent: InteractionEvent, displayObject: DisplayObject): void\n    {\n        const data = interactionEvent.data;\n\n        const id = interactionEvent.data.identifier;\n\n        if (displayObject.trackedPointers[id] !== undefined)\n        {\n            delete displayObject.trackedPointers[id];\n            this.dispatchEvent(displayObject, 'pointercancel', interactionEvent);\n\n            if (data.pointerType === 'touch')\n            {\n                this.dispatchEvent(displayObject, 'touchcancel', interactionEvent);\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer button is released on the renderer element\n     * @param event - The DOM event of a pointer button being released\n     */\n    private onPointerUp(event: InteractivePointerEvent): void\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (event as PointerEvent).pointerType === 'touch') return;\n\n        this.onPointerComplete(event, false, this.processPointerUp);\n    }\n\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */\n    private processPointerUp(interactionEvent: InteractionEvent, displayObject: DisplayObject, hit: boolean): void\n    {\n        const data = interactionEvent.data;\n\n        const id = interactionEvent.data.identifier;\n\n        const trackingData = displayObject.trackedPointers[id];\n\n        const isTouch = data.pointerType === 'touch';\n\n        const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n        // need to track mouse down status in the mouse block so that we can emit\n        // event in a later block\n        let isMouseTap = false;\n\n        // Mouse only\n        if (isMouse)\n        {\n            const isRightButton = data.button === 2;\n\n            const flags = InteractionTrackingData.FLAGS;\n\n            const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n            const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n            if (hit)\n            {\n                this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n                if (isDown)\n                {\n                    this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent);\n                    // because we can confirm that the mousedown happened on this object, flag for later emit of pointertap\n                    isMouseTap = true;\n                }\n            }\n            else if (isDown)\n            {\n                this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n            }\n            // update the down state of the tracking data\n            if (trackingData)\n            {\n                if (isRightButton)\n                {\n                    trackingData.rightDown = false;\n                }\n                else\n                {\n                    trackingData.leftDown = false;\n                }\n            }\n        }\n\n        // Pointers and Touches, and Mouse\n        if (hit)\n        {\n            this.dispatchEvent(displayObject, 'pointerup', interactionEvent);\n            if (isTouch) this.dispatchEvent(displayObject, 'touchend', interactionEvent);\n\n            if (trackingData)\n            {\n                // emit pointertap if not a mouse, or if the mouse block decided it was a tap\n                if (!isMouse || isMouseTap)\n                {\n                    this.dispatchEvent(displayObject, 'pointertap', interactionEvent);\n                }\n                if (isTouch)\n                {\n                    this.dispatchEvent(displayObject, 'tap', interactionEvent);\n                    // touches are no longer over (if they ever were) when we get the touchend\n                    // so we should ensure that we don't keep pretending that they are\n                    trackingData.over = false;\n                }\n            }\n        }\n        else if (trackingData)\n        {\n            this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent);\n            if (isTouch) this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent);\n        }\n        // Only remove the tracking data if there is no over/down state still associated with it\n        if (trackingData && trackingData.none)\n        {\n            delete displayObject.trackedPointers[id];\n        }\n    }\n\n    /**\n     * Is called when the pointer moves across the renderer element\n     * @param originalEvent - The DOM event of a pointer moving\n     */\n    private onPointerMove(originalEvent: InteractivePointerEvent): void\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (originalEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen')\n        {\n            this._didMove = true;\n\n            this.cursor = null;\n        }\n\n        const eventLen = events.length;\n\n        for (let i = 0; i < eventLen; i++)\n        {\n            const event = events[i];\n\n            const interactionData = this.getInteractionDataForPointerId(event);\n\n            const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n            interactionEvent.data.originalEvent = originalEvent;\n\n            this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerMove, true);\n\n            this.emit('pointermove', interactionEvent);\n            if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n            if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n        }\n\n        if (events[0].pointerType === 'mouse')\n        {\n            this.setCursorMode(this.cursor);\n\n            // TODO BUG for parents interactive object (border order issue)\n        }\n    }\n\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */\n    private processPointerMove(interactionEvent: InteractionEvent, displayObject: DisplayObject, hit: boolean): void\n    {\n        const data = interactionEvent.data;\n\n        const isTouch = data.pointerType === 'touch';\n\n        const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n        if (isMouse)\n        {\n            this.processPointerOverOut(interactionEvent, displayObject, hit);\n        }\n\n        if (!this.moveWhenInside || hit)\n        {\n            this.dispatchEvent(displayObject, 'pointermove', interactionEvent);\n            if (isTouch) this.dispatchEvent(displayObject, 'touchmove', interactionEvent);\n            if (isMouse) this.dispatchEvent(displayObject, 'mousemove', interactionEvent);\n        }\n    }\n\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n    private onPointerOut(originalEvent: InteractivePointerEvent): void\n    {\n        // if we support touch events, then only use those for touch events, not pointer events\n        if (this.supportsTouchEvents && (originalEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOut, so events will always be length 1\n        const event = events[0];\n\n        if (event.pointerType === 'mouse')\n        {\n            this.mouseOverRenderer = false;\n            this.setCursorMode(null);\n        }\n\n        const interactionData = this.getInteractionDataForPointerId(event);\n\n        const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n        interactionEvent.data.originalEvent = event;\n\n        this.processInteractive(interactionEvent, this.lastObjectRendered, this.processPointerOverOut, false);\n\n        this.emit('pointerout', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n        {\n            this.emit('mouseout', interactionEvent);\n        }\n        else\n        {\n            // we can get touchleave events after touchend, so we want to make sure we don't\n            // introduce memory leaks\n            this.releaseInteractionDataForPointerId(interactionData.identifier);\n        }\n    }\n\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be.\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */\n    private processPointerOverOut(interactionEvent: InteractionEvent, displayObject: DisplayObject, hit: boolean): void\n    {\n        const data = interactionEvent.data;\n\n        const id = interactionEvent.data.identifier;\n\n        const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n        let trackingData = displayObject.trackedPointers[id];\n\n        // if we just moused over the display object, then we need to track that state\n        if (hit && !trackingData)\n        {\n            trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        if (trackingData === undefined) return;\n\n        if (hit && this.mouseOverRenderer)\n        {\n            if (!trackingData.over)\n            {\n                trackingData.over = true;\n                this.delayDispatchEvent(displayObject, 'pointerover', interactionEvent);\n                if (isMouse)\n                {\n                    this.delayDispatchEvent(displayObject, 'mouseover', interactionEvent);\n                }\n            }\n\n            // only change the cursor if it has not already been changed (by something deeper in the\n            // display tree)\n            if (isMouse && this.cursor === null)\n            {\n                this.cursor = displayObject.cursor;\n            }\n        }\n        else if (trackingData.over)\n        {\n            trackingData.over = false;\n            this.dispatchEvent(displayObject, 'pointerout', this.eventData);\n            if (isMouse)\n            {\n                this.dispatchEvent(displayObject, 'mouseout', interactionEvent);\n            }\n            // if there is no mouse down information for the pointer, then it is safe to delete\n            if (trackingData.none)\n            {\n                delete displayObject.trackedPointers[id];\n            }\n        }\n    }\n\n    /**\n     * Is called when the pointer is moved into the renderer element.\n     * @param originalEvent - The DOM event of a pointer button being moved into the renderer view.\n     */\n    private onPointerOver(originalEvent: InteractivePointerEvent): void\n    {\n        if (this.supportsTouchEvents && (originalEvent as PointerEvent).pointerType === 'touch') return;\n\n        const events = this.normalizeToPointerData(originalEvent);\n\n        // Only mouse and pointer can call onPointerOver, so events will always be length 1\n        const event = events[0];\n\n        const interactionData = this.getInteractionDataForPointerId(event);\n\n        const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n        interactionEvent.data.originalEvent = event;\n\n        if (event.pointerType === 'mouse')\n        {\n            this.mouseOverRenderer = true;\n        }\n\n        this.emit('pointerover', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen')\n        {\n            this.emit('mouseover', interactionEvent);\n        }\n    }\n\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well.\n     * @param event - Normalized pointer event, output from normalizeToPointerData.\n     * @returns - Interaction data for the given pointer identifier.\n     */\n    private getInteractionDataForPointerId(event: PointerEvent): InteractionData\n    {\n        const pointerId = event.pointerId;\n\n        let interactionData;\n\n        if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse')\n        {\n            interactionData = this.mouse;\n        }\n        else if (this.activeInteractionData[pointerId])\n        {\n            interactionData = this.activeInteractionData[pointerId];\n        }\n        else\n        {\n            interactionData = this.interactionDataPool.pop() || new InteractionData();\n            interactionData.identifier = pointerId;\n            this.activeInteractionData[pointerId] = interactionData;\n        }\n        // copy properties from the event, so that we can make sure that touch/pointer specific\n        // data is available\n        interactionData.copyEvent(event);\n\n        return interactionData;\n    }\n\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     * @param pointerId - Identifier from a pointer event\n     */\n    private releaseInteractionDataForPointerId(pointerId: number): void\n    {\n        const interactionData = this.activeInteractionData[pointerId];\n\n        if (interactionData)\n        {\n            delete this.activeInteractionData[pointerId];\n            interactionData.reset();\n            this.interactionDataPool.push(interactionData);\n        }\n    }\n\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     * @param interactionEvent - The event to be configured\n     * @param pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @returns - the interaction event that was passed in\n     */\n    private configureInteractionEventForDOMEvent(interactionEvent: InteractionEvent, pointerEvent: PointerEvent,\n        interactionData: InteractionData\n    ): InteractionEvent\n    {\n        interactionEvent.data = interactionData;\n\n        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n        // Not really sure why this is happening, but it's how a previous version handled things\n        if (pointerEvent.pointerType === 'touch')\n        {\n            (pointerEvent as any).globalX = interactionData.global.x;\n            (pointerEvent as any).globalY = interactionData.global.y;\n        }\n\n        interactionData.originalEvent = pointerEvent;\n        interactionEvent.reset();\n\n        return interactionEvent;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @returns - An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private normalizeToPointerData(event: InteractivePointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /** Destroys the interaction manager. */\n    public destroy(): void\n    {\n        this.removeEvents();\n\n        this.removeTickerListener();\n\n        this.removeAllListeners();\n\n        this.renderer = null;\n\n        this.mouse = null;\n\n        this.eventData = null;\n\n        this.interactionDOMElement = null;\n\n        this.onPointerDown = null;\n        this.processPointerDown = null;\n\n        this.onPointerUp = null;\n        this.processPointerUp = null;\n\n        this.onPointerCancel = null;\n        this.processPointerCancel = null;\n\n        this.onPointerMove = null;\n        this.processPointerMove = null;\n\n        this.onPointerOut = null;\n        this.processPointerOverOut = null;\n\n        this.onPointerOver = null;\n\n        this.search = null;\n    }\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n}\n\ninterface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n}\n"]},"metadata":{},"sourceType":"script"}