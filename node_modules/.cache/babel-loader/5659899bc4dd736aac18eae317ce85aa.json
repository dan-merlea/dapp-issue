{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariadicValue = exports.VariadicType = void 0;\nvar types_1 = require(\"./types\");\nvar VariadicType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(VariadicType, _types_1$Type);\n  var _super = _createSuper(VariadicType);\n  function VariadicType(typeParameter) {\n    _classCallCheck(this, VariadicType);\n    return _super.call(this, \"Variadic\", [typeParameter], types_1.TypeCardinality.variable());\n  }\n  _createClass(VariadicType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return VariadicType.ClassName;\n    }\n  }]);\n  return VariadicType;\n}(types_1.Type);\nexports.VariadicType = VariadicType;\nVariadicType.ClassName = \"VariadicType\";\n/**\n * An abstraction that represents a sequence of values held under the umbrella of a variadic input / output parameter.\n *\n * Since at the time of constructing input parameters or decoding output parameters, the length is known,\n * this TypedValue behaves similar to a List.\n */\nvar VariadicValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(VariadicValue, _types_1$TypedValue);\n  var _super2 = _createSuper(VariadicValue);\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of VariadicType), not the type parameter of the VariadicType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  function VariadicValue(type, items) {\n    var _this;\n    _classCallCheck(this, VariadicValue);\n    _this = _super2.call(this, type);\n    // TODO: assert items are of type type.getFirstTypeParameter()\n    _this.items = items;\n    return _this;\n  }\n  _createClass(VariadicValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return VariadicValue.ClassName;\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.items;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.items.map(function (item) {\n        return item.valueOf();\n      });\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.getType().differs(other.getType())) {\n        return false;\n      }\n      for (var i = 0; i < this.items.length; i++) {\n        var selfItem = this.items[i];\n        var otherItem = other.items[i];\n        if (!selfItem.equals(otherItem)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      if (items.length == 0) {\n        return new VariadicValue(new VariadicType(new types_1.TypePlaceholder()), []);\n      }\n      var typeParameter = items[0].getType();\n      return new VariadicValue(new VariadicType(typeParameter), items);\n    }\n  }]);\n  return VariadicValue;\n}(types_1.TypedValue);\nexports.VariadicValue = VariadicValue;\nVariadicValue.ClassName = \"VariadicValue\";","map":null,"metadata":{},"sourceType":"script"}