{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionWatcher = void 0;\nvar asyncTimer_1 = require(\"./asyncTimer\");\nvar logger_1 = require(\"./logger\");\nvar errors_1 = require(\"./errors\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\nvar TransactionWatcher = /*#__PURE__*/function () {\n  /**\n   *\n   * @param fetcher The transaction fetcher\n   * @param pollingInterval The polling interval, in milliseconds\n   * @param timeout The timeout, in milliseconds\n   */\n  function TransactionWatcher(fetcher) {\n    var pollingInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionWatcher.DefaultPollingInterval;\n    var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TransactionWatcher.DefaultTimeout;\n    _classCallCheck(this, TransactionWatcher);\n    this.fetcher = new TransactionFetcherWithTracing(fetcher);\n    this.pollingInterval = pollingInterval;\n    this.timeout = timeout;\n  }\n  /**\n   * Waits until the transaction reaches the \"pending\" status.\n   */\n  _createClass(TransactionWatcher, [{\n    key: \"awaitPending\",\n    value: function awaitPending(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this = this;\n        var isPending, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                isPending = function isPending(transaction) {\n                  return transaction.status.isPending();\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context.abrupt(\"return\", _context.sent);\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionStatusNotReached();\n                };\n                return _context2.abrupt(\"return\", this.awaitConditionally(isPending, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n      * Waits until the transaction is completely processed.\n      */\n  }, {\n    key: \"awaitCompleted\",\n    value: function awaitCompleted(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n        var isCompleted, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isCompleted = function isCompleted(transactionOnNetwork) {\n                  return transactionOnNetwork.isCompleted;\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context3.abrupt(\"return\", _context3.sent);\n                          case 3:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionStatusNotReached();\n                };\n                return _context4.abrupt(\"return\", this.awaitConditionally(isCompleted, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"awaitAllEvents\",\n    value: function awaitAllEvents(transaction, events) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this3 = this;\n        var foundAllEvents, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                foundAllEvents = function foundAllEvents(transactionOnNetwork) {\n                  var allEventIdentifiers = _this3.getAllTransactionEvents(transactionOnNetwork).map(function (event) {\n                    return event.identifier;\n                  });\n                  var allAreFound = events.every(function (event) {\n                    return allEventIdentifiers.includes(event);\n                  });\n                  return allAreFound;\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context5.abrupt(\"return\", _context5.sent);\n                          case 3:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionEventsNotFound();\n                };\n                return _context6.abrupt(\"return\", this.awaitConditionally(foundAllEvents, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"awaitAnyEvent\",\n    value: function awaitAnyEvent(transaction, events) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this4 = this;\n        var foundAnyEvent, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                foundAnyEvent = function foundAnyEvent(transactionOnNetwork) {\n                  var allEventIdentifiers = _this4.getAllTransactionEvents(transactionOnNetwork).map(function (event) {\n                    return event.identifier;\n                  });\n                  var anyIsFound = events.find(function (event) {\n                    return allEventIdentifiers.includes(event);\n                  }) != undefined;\n                  return anyIsFound;\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            _context7.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context7.abrupt(\"return\", _context7.sent);\n                          case 3:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionEventsNotFound();\n                };\n                return _context8.abrupt(\"return\", this.awaitConditionally(foundAnyEvent, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"awaitOnCondition\",\n    value: function awaitOnCondition(transaction, condition) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this5 = this;\n        var doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                doFetch = function doFetch() {\n                  return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n                    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            _context9.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context9.abrupt(\"return\", _context9.sent);\n                          case 3:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionStatusNotReached();\n                };\n                return _context10.abrupt(\"return\", this.awaitConditionally(condition, doFetch, errorProvider));\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"awaitConditionally\",\n    value: function awaitConditionally(isSatisfied, doFetch, createError) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var periodicTimer, timeoutTimer, stop, fetchedData, satisfied;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n                timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n                stop = false;\n                fetchedData = undefined;\n                satisfied = false;\n                timeoutTimer.start(this.timeout).finally(function () {\n                  timeoutTimer.stop();\n                  stop = true;\n                });\n              case 6:\n                if (stop) {\n                  _context11.next = 25;\n                  break;\n                }\n                _context11.next = 9;\n                return periodicTimer.start(this.pollingInterval);\n              case 9:\n                _context11.prev = 9;\n                _context11.next = 12;\n                return doFetch();\n              case 12:\n                fetchedData = _context11.sent;\n                satisfied = isSatisfied(fetchedData);\n                if (!(satisfied || stop)) {\n                  _context11.next = 16;\n                  break;\n                }\n                return _context11.abrupt(\"break\", 25);\n              case 16:\n                _context11.next = 23;\n                break;\n              case 18:\n                _context11.prev = 18;\n                _context11.t0 = _context11[\"catch\"](9);\n                logger_1.Logger.debug(\"TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.\");\n                if (_context11.t0 instanceof errors_1.Err) {\n                  _context11.next = 23;\n                  break;\n                }\n                throw _context11.t0;\n              case 23:\n                _context11.next = 6;\n                break;\n              case 25:\n                if (!timeoutTimer.isStopped()) {\n                  timeoutTimer.stop();\n                }\n                if (!(!fetchedData || !satisfied)) {\n                  _context11.next = 28;\n                  break;\n                }\n                throw createError();\n              case 28:\n                return _context11.abrupt(\"return\", fetchedData);\n              case 29:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[9, 18]]);\n      }));\n    }\n  }, {\n    key: \"getAllTransactionEvents\",\n    value: function getAllTransactionEvents(transaction) {\n      var result = _toConsumableArray(transaction.logs.events);\n      var _iterator = _createForOfIteratorHelper(transaction.contractResults.items),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var resultItem = _step.value;\n          result.push.apply(result, _toConsumableArray(resultItem.logs.events));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }]);\n  return TransactionWatcher;\n}();\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\nTransactionWatcher.NoopOnStatusReceived = function (_) {};\nvar TransactionFetcherWithTracing = /*#__PURE__*/function () {\n  function TransactionFetcherWithTracing(fetcher) {\n    _classCallCheck(this, TransactionFetcherWithTracing);\n    this.fetcher = fetcher;\n  }\n  _createClass(TransactionFetcherWithTracing, [{\n    key: \"getTransaction\",\n    value: function getTransaction(txHash) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                logger_1.Logger.debug(\"transactionWatcher, getTransaction(\".concat(txHash, \")\"));\n                _context12.next = 3;\n                return this.fetcher.getTransaction(txHash);\n              case 3:\n                return _context12.abrupt(\"return\", _context12.sent);\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }]);\n  return TransactionFetcherWithTracing;\n}();","map":null,"metadata":{},"sourceType":"script"}