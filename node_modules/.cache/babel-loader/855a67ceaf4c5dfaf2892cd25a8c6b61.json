{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RelayedTransactionV2Builder = void 0;\nvar transaction_1 = require(\"./transaction\");\nvar transactionPayload_1 = require(\"./transactionPayload\");\nvar smartcontracts_1 = require(\"./smartcontracts\");\nvar errors_1 = require(\"./errors\");\nvar RelayedTransactionV2Builder = /*#__PURE__*/function () {\n  function RelayedTransactionV2Builder() {\n    _classCallCheck(this, RelayedTransactionV2Builder);\n  }\n  _createClass(RelayedTransactionV2Builder, [{\n    key: \"setInnerTransaction\",\n    value:\n    /**\n     * Sets the inner transaction to be used. It has to be already signed and with gasLimit set to 0. These checks\n     * are performed on the build() method\n     *\n     * @param {Transaction} transaction The inner transaction to be used\n     */\n    function setInnerTransaction(transaction) {\n      this.innerTransaction = transaction;\n      return this;\n    }\n    /**\n     * Sets the gas limit to be used for the SC Call inside the inner transaction\n     *\n     * @param {IGasLimit} gasLimit The gas limit to be used. The inner transaction needs to have the gas limit set to 0,\n     * so this field will specify the gas to be used for the SC call of the inner transaction\n     */\n  }, {\n    key: \"setInnerTransactionGasLimit\",\n    value: function setInnerTransactionGasLimit(gasLimit) {\n      this.innerTransactionGasLimit = gasLimit;\n      return this;\n    }\n    /**\n     * Sets the network config to be used for building the relayed v2 transaction\n     *\n     * @param {INetworkConfig} netConfig The network configuration to be used\n     */\n  }, {\n    key: \"setNetworkConfig\",\n    value: function setNetworkConfig(netConfig) {\n      this.netConfig = netConfig;\n      return this;\n    }\n    /**\n     * Sets the address of the relayer (the one that will actually pay the fee)\n     *\n     * @param relayerAddress\n     */\n  }, {\n    key: \"setRelayerAddress\",\n    value: function setRelayerAddress(relayerAddress) {\n      this.relayerAddress = relayerAddress;\n      return this;\n    }\n    /**\n     * (optional) Sets the nonce of the relayer\n     *\n     * @param relayerNonce\n     */\n  }, {\n    key: \"setRelayerNonce\",\n    value: function setRelayerNonce(relayerNonce) {\n      this.relayerNonce = relayerNonce;\n      return this;\n    }\n    /**\n     * Tries to build the relayed v2 transaction based on the previously set fields.\n     * It returns a transaction that isn't signed\n     *\n     * @throws ErrInvalidRelayedV2BuilderArguments\n     * @throws ErrGasLimitShouldBe0ForInnerTransaction\n     * @return Transaction\n     */\n  }, {\n    key: \"build\",\n    value: function build() {\n      if (!this.innerTransaction || !this.innerTransactionGasLimit || !this.relayerAddress || !this.netConfig || !this.innerTransaction.getSignature()) {\n        throw new errors_1.ErrInvalidRelayedV2BuilderArguments();\n      }\n      if (this.innerTransaction.getGasLimit() != 0) {\n        throw new errors_1.ErrGasLimitShouldBe0ForInnerTransaction();\n      }\n      var payload = transactionPayload_1.TransactionPayload.contractCall().setFunction(new smartcontracts_1.ContractFunction(\"relayedTxV2\")).setArgs([new smartcontracts_1.AddressValue(this.innerTransaction.getReceiver()), new smartcontracts_1.U64Value(this.innerTransaction.getNonce().valueOf()), new smartcontracts_1.BytesValue(this.innerTransaction.getData().valueOf()), smartcontracts_1.BytesValue.fromHex(this.innerTransaction.getSignature().hex())]).build();\n      var relayedTransaction = new transaction_1.Transaction({\n        sender: this.relayerAddress,\n        receiver: this.innerTransaction.getSender(),\n        value: 0,\n        gasLimit: this.innerTransactionGasLimit.valueOf() + this.netConfig.MinGasLimit + this.netConfig.GasPerDataByte * payload.length(),\n        data: payload,\n        chainID: this.netConfig.ChainID\n      });\n      if (this.relayerNonce) {\n        relayedTransaction.setNonce(this.relayerNonce);\n      }\n      return relayedTransaction;\n    }\n  }]);\n  return RelayedTransactionV2Builder;\n}();\nexports.RelayedTransactionV2Builder = RelayedTransactionV2Builder;","map":{"version":3,"sources":["../src/relayedTransactionV2Builder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RelayedTransactionV2Builder = void 0;\nconst transaction_1 = require(\"./transaction\");\nconst transactionPayload_1 = require(\"./transactionPayload\");\nconst smartcontracts_1 = require(\"./smartcontracts\");\nconst errors_1 = require(\"./errors\");\nclass RelayedTransactionV2Builder {\n    /**\n     * Sets the inner transaction to be used. It has to be already signed and with gasLimit set to 0. These checks\n     * are performed on the build() method\n     *\n     * @param {Transaction} transaction The inner transaction to be used\n     */\n    setInnerTransaction(transaction) {\n        this.innerTransaction = transaction;\n        return this;\n    }\n    /**\n     * Sets the gas limit to be used for the SC Call inside the inner transaction\n     *\n     * @param {IGasLimit} gasLimit The gas limit to be used. The inner transaction needs to have the gas limit set to 0,\n     * so this field will specify the gas to be used for the SC call of the inner transaction\n     */\n    setInnerTransactionGasLimit(gasLimit) {\n        this.innerTransactionGasLimit = gasLimit;\n        return this;\n    }\n    /**\n     * Sets the network config to be used for building the relayed v2 transaction\n     *\n     * @param {INetworkConfig} netConfig The network configuration to be used\n     */\n    setNetworkConfig(netConfig) {\n        this.netConfig = netConfig;\n        return this;\n    }\n    /**\n     * Sets the address of the relayer (the one that will actually pay the fee)\n     *\n     * @param relayerAddress\n     */\n    setRelayerAddress(relayerAddress) {\n        this.relayerAddress = relayerAddress;\n        return this;\n    }\n    /**\n     * (optional) Sets the nonce of the relayer\n     *\n     * @param relayerNonce\n     */\n    setRelayerNonce(relayerNonce) {\n        this.relayerNonce = relayerNonce;\n        return this;\n    }\n    /**\n     * Tries to build the relayed v2 transaction based on the previously set fields.\n     * It returns a transaction that isn't signed\n     *\n     * @throws ErrInvalidRelayedV2BuilderArguments\n     * @throws ErrGasLimitShouldBe0ForInnerTransaction\n     * @return Transaction\n     */\n    build() {\n        if (!this.innerTransaction || !this.innerTransactionGasLimit || !this.relayerAddress || !this.netConfig || !this.innerTransaction.getSignature()) {\n            throw new errors_1.ErrInvalidRelayedV2BuilderArguments();\n        }\n        if (this.innerTransaction.getGasLimit() != 0) {\n            throw new errors_1.ErrGasLimitShouldBe0ForInnerTransaction();\n        }\n        const payload = transactionPayload_1.TransactionPayload.contractCall()\n            .setFunction(new smartcontracts_1.ContractFunction(\"relayedTxV2\"))\n            .setArgs([\n            new smartcontracts_1.AddressValue(this.innerTransaction.getReceiver()),\n            new smartcontracts_1.U64Value(this.innerTransaction.getNonce().valueOf()),\n            new smartcontracts_1.BytesValue(this.innerTransaction.getData().valueOf()),\n            smartcontracts_1.BytesValue.fromHex(this.innerTransaction.getSignature().hex()),\n        ])\n            .build();\n        let relayedTransaction = new transaction_1.Transaction({\n            sender: this.relayerAddress,\n            receiver: this.innerTransaction.getSender(),\n            value: 0,\n            gasLimit: this.innerTransactionGasLimit.valueOf() + this.netConfig.MinGasLimit + this.netConfig.GasPerDataByte * payload.length(),\n            data: payload,\n            chainID: this.netConfig.ChainID,\n        });\n        if (this.relayerNonce) {\n            relayedTransaction.setNonce(this.relayerNonce);\n        }\n        return relayedTransaction;\n    }\n}\nexports.RelayedTransactionV2Builder = RelayedTransactionV2Builder;\n//# sourceMappingURL=relayedTransactionV2Builder.js.map"]},"metadata":{},"sourceType":"script"}