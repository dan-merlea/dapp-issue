{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariadicValue = exports.VariadicType = void 0;\nvar types_1 = require(\"./types\");\nvar VariadicType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(VariadicType, _types_1$Type);\n  var _super = _createSuper(VariadicType);\n  function VariadicType(typeParameter) {\n    _classCallCheck(this, VariadicType);\n    return _super.call(this, \"Variadic\", [typeParameter], types_1.TypeCardinality.variable());\n  }\n  _createClass(VariadicType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return VariadicType.ClassName;\n    }\n  }]);\n  return VariadicType;\n}(types_1.Type);\nexports.VariadicType = VariadicType;\nVariadicType.ClassName = \"VariadicType\";\n/**\n * An abstraction that represents a sequence of values held under the umbrella of a variadic input / output parameter.\n *\n * Since at the time of constructing input parameters or decoding output parameters, the length is known,\n * this TypedValue behaves similar to a List.\n */\nvar VariadicValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(VariadicValue, _types_1$TypedValue);\n  var _super2 = _createSuper(VariadicValue);\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of VariadicType), not the type parameter of the VariadicType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  function VariadicValue(type, items) {\n    var _this;\n    _classCallCheck(this, VariadicValue);\n    _this = _super2.call(this, type);\n    // TODO: assert items are of type type.getFirstTypeParameter()\n    _this.items = items;\n    return _this;\n  }\n  _createClass(VariadicValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return VariadicValue.ClassName;\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.items;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.items.map(function (item) {\n        return item.valueOf();\n      });\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.getType().differs(other.getType())) {\n        return false;\n      }\n      for (var i = 0; i < this.items.length; i++) {\n        var selfItem = this.items[i];\n        var otherItem = other.items[i];\n        if (!selfItem.equals(otherItem)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      if (items.length == 0) {\n        return new VariadicValue(new VariadicType(new types_1.TypePlaceholder()), []);\n      }\n      var typeParameter = items[0].getType();\n      return new VariadicValue(new VariadicType(typeParameter), items);\n    }\n  }]);\n  return VariadicValue;\n}(types_1.TypedValue);\nexports.VariadicValue = VariadicValue;\nVariadicValue.ClassName = \"VariadicValue\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/variadic.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAA6E,IAEhE,YAAa;EAAA;EAAA;EAGtB,sBAAY,aAAmB,EAAA;IAAA;IAAA,yBACrB,UAAU,EAAE,CAAC,aAAa,CAAC,EAAE,OAAA,CAAA,eAAe,CAAC,QAAQ,EAAE;EACjE;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,YAAY,CAAC,SAAS;IACjC;EAAC;EAAA;AAAA,EAT6B,OAAA,CAAA,IAAI;AAAtC,OAAA,CAAA,YAAA,GAAA,YAAA;AACW,YAAA,CAAA,SAAS,GAAG,cAAc;AAWrC;;;;;AAKG;AALH,IAMa,aAAc;EAAA;EAAA;EAIvB;;;;AAIG;EACH,uBAAY,IAAkB,EAAE,KAAmB,EAAA;IAAA;IAAA;IAC/C,2BAAM,IAAI;IAEV;IAEA,MAAK,KAAK,GAAG,KAAK;IAAC;EACvB;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,aAAa,CAAC,SAAS;IAClC;EAAC;IAAA;IAAA,OAWD,oBAAQ;MACJ,OAAO,IAAI,CAAC,KAAK;IACrB;EAAC;IAAA;IAAA,OAED,mBAAO;MACH,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;QAAA,OAAI,IAAI,CAAC,OAAO,EAAE;MAAA,EAAC;IACjD;EAAC;IAAA;IAAA,OAED,gBAAO,KAAoB,EAAA;MACvB,IAAI,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,EAAE;QACzC,OAAO,KAAK;MACf;MAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACxC,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC5B,IAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QAE9B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE;UAC7B,OAAO,KAAK;QACf;MACJ;MAED,OAAO,IAAI;IACf;EAAC;IAAA;IAAA,OAhCD,qBAAuC;MAAA,kCAAnB,KAAmB;QAAnB,KAAmB;MAAA;MACnC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;QACnB,OAAO,IAAI,aAAa,CAAC,IAAI,YAAY,CAAC,IAAI,OAAA,CAAA,eAAe,EAAE,CAAC,EAAE,EAAE,CAAC;MACxE;MAED,IAAI,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE;MACtC,OAAO,IAAI,aAAa,CAAC,IAAI,YAAY,CAAC,aAAa,CAAC,EAAE,KAAK,CAAC;IACpE;EAAC;EAAA;AAAA,EA5B8B,OAAA,CAAA,UAAU;AAA7C,OAAA,CAAA,aAAA,GAAA,aAAA;AACW,aAAA,CAAA,SAAS,GAAG,eAAe","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VariadicValue = exports.VariadicType = void 0;\nconst types_1 = require(\"./types\");\nclass VariadicType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"Variadic\", [typeParameter], types_1.TypeCardinality.variable());\n    }\n    getClassName() {\n        return VariadicType.ClassName;\n    }\n}\nexports.VariadicType = VariadicType;\nVariadicType.ClassName = \"VariadicType\";\n/**\n * An abstraction that represents a sequence of values held under the umbrella of a variadic input / output parameter.\n *\n * Since at the time of constructing input parameters or decoding output parameters, the length is known,\n * this TypedValue behaves similar to a List.\n */\nclass VariadicValue extends types_1.TypedValue {\n    /**\n     *\n     * @param type the type of this TypedValue (an instance of VariadicType), not the type parameter of the VariadicType\n     * @param items the items, having the type type.getFirstTypeParameter()\n     */\n    constructor(type, items) {\n        super(type);\n        // TODO: assert items are of type type.getFirstTypeParameter()\n        this.items = items;\n    }\n    getClassName() {\n        return VariadicValue.ClassName;\n    }\n    static fromItems(...items) {\n        if (items.length == 0) {\n            return new VariadicValue(new VariadicType(new types_1.TypePlaceholder()), []);\n        }\n        let typeParameter = items[0].getType();\n        return new VariadicValue(new VariadicType(typeParameter), items);\n    }\n    getItems() {\n        return this.items;\n    }\n    valueOf() {\n        return this.items.map(item => item.valueOf());\n    }\n    equals(other) {\n        if (this.getType().differs(other.getType())) {\n            return false;\n        }\n        for (let i = 0; i < this.items.length; i++) {\n            let selfItem = this.items[i];\n            let otherItem = other.items[i];\n            if (!selfItem.equals(otherItem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.VariadicValue = VariadicValue;\nVariadicValue.ClassName = \"VariadicValue\";\n//# sourceMappingURL=variadic.js.map"]},"metadata":{},"sourceType":"script"}