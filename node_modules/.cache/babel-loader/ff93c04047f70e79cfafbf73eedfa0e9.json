{"ast":null,"code":"var backslash = require('backslash');\nmodule.exports = {\n  validate: validate,\n  parse: parse\n};\n\n/**\n * Validates a json string.\n * Errors are returned\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {String} error. undefined if no error\n */\nfunction validate(jsonString, allowDuplicatedKeys) {\n  var error;\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n  if (typeof jsonString !== 'string') {\n    error = 'Input must be a string';\n  } else {\n    try {\n      // Try to find a value starting from index 0\n      _findValue(jsonString, 0, allowDuplicatedKeys, false);\n    } catch (e) {\n      error = e.message;\n    }\n  }\n  return error;\n}\n\n/**\n * Parses a json. Errors are thrown if any\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {Object}\n */\nfunction parse(jsonString, allowDuplicatedKeys) {\n  if (typeof jsonString !== 'string') {\n    throw new Error('Input must be a string');\n  }\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n\n  // Try to find a value starting from index 0\n  var value = _findValue(jsonString, 0, allowDuplicatedKeys, true);\n  return value.value;\n}\n\n/**\n * Find the comma separator, ], } or end of file\n * @param {String} str - original json string\n * @param {Number} startInd - starting index\n * @returns {{start: Number, end: Number, value: String}} value: the separator found\n * @private\n */\nfunction _findSeparator(str, startInd) {\n  var len = str.length;\n  var sepStartInd = startInd;\n  var sepEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ',') {\n      sepEndInd = i;\n      break;\n    } else if (ch === ']' || ch === '}') {\n      sepEndInd = i - 1;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting end of expression or separator');\n    }\n  }\n  var value;\n  if (sepEndInd === undefined) {\n    sepEndInd = len;\n    value = str[sepEndInd];\n  } else {\n    value = str[sepEndInd];\n    sepEndInd++;\n  }\n  return {\n    start: sepStartInd,\n    end: sepEndInd,\n    value: value\n  };\n}\n\n/**\n * Find the semi-colon separator ':'\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number}}\n * @private\n */\nfunction _findSemiColonSeparator(str, startInd) {\n  var len = str.length;\n  var semiColStartInd = startInd;\n  var semiColEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ':') {\n      semiColEndInd = i;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting \\':\\'');\n    }\n  }\n  if (semiColEndInd === undefined) {\n    throw _syntaxError(str, i, 'expecting \\':\\'');\n  }\n  semiColEndInd++;\n  return {\n    start: semiColStartInd,\n    end: semiColEndInd\n  };\n}\n\n/**\n * Find a value it can be number, array, object, strings or boolean\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not\n * @returns {{value: *, start: Number, end: Number}}\n * @private\n */\nfunction _findValue(str, startInd, allowDuplicatedKeys, parse) {\n  var len = str.length;\n  var valueStartInd;\n  var valueEndInd;\n  var isArray = false;\n  var isObject = false;\n  var isString = false;\n  var isNumber = false;\n  var dotFound = false;\n  var whiteSpaceInNumber = false;\n  var value;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (valueStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch === '[') {\n          isArray = true;\n        } else if (ch === '{') {\n          isObject = true;\n        } else if (ch === '\"') {\n          isString = true;\n        } else if (_isTrueFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = true;\n          break;\n        } else if (_isFalseFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 4;\n          valueEndInd = i;\n          value = false;\n          break;\n        } else if (_isNullFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = null;\n          break;\n        } else if (_isNumber(ch)) {\n          isNumber = true;\n        } else if (ch === '-') {\n          isNumber = true;\n        } else {\n          throw _syntaxError(str, i, '');\n        }\n        valueStartInd = i;\n      }\n    } else {\n      if (isArray) {\n        var arr = _findArray(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = arr.end;\n        value = arr.value;\n        break;\n      } else if (isObject) {\n        var obj = _findObject(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = obj.end;\n        value = obj.value;\n        break;\n      } else if (isString && ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        valueEndInd = i;\n        value = backslash(str.substring(valueStartInd + 1, valueEndInd));\n        break;\n      } else if (isNumber) {\n        if (_isWhiteSpace(ch)) {\n          whiteSpaceInNumber = true;\n        } else if (ch === ',' || ch === ']' || ch === '}') {\n          value = parseFloat(str.substring(valueStartInd, valueEndInd), 10);\n          valueEndInd = i - 1;\n          break;\n        } else if (_isNumber(ch) && !whiteSpaceInNumber) {\n          continue;\n        } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {\n          dotFound = true;\n        } else {\n          throw _syntaxError(str, i, 'expecting number');\n        }\n      }\n    }\n  }\n  if (valueEndInd === undefined) {\n    if (isNumber) {\n      value = parseFloat(str.substring(valueStartInd, i), 10);\n      valueEndInd = i - 1;\n    } else {\n      throw _syntaxError(str, i, 'unclosed statement');\n    }\n  }\n  valueEndInd++;\n  return {\n    value: value,\n    start: valueStartInd,\n    end: valueEndInd\n  };\n}\n\n/**\n * Find a key in an object\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: String}}\n * @private\n */\nfunction _findKey(str, startInd) {\n  var len = str.length;\n  var keyStartInd;\n  var keyEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (keyStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch !== '\"') {\n          throw _syntaxError(str, i, 'expecting String');\n        }\n        keyStartInd = i;\n      }\n    } else {\n      if (ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        keyEndInd = i;\n        break;\n      }\n    }\n  }\n  if (keyEndInd === undefined) {\n    throw _syntaxError(str, len, 'expecting String');\n  }\n  var value = backslash(str.substring(keyStartInd + 1, keyEndInd));\n  if (value === '') {\n    throw _syntaxError(str, keyStartInd, 'empty string');\n  }\n  keyEndInd++;\n  return {\n    start: keyStartInd,\n    end: keyEndInd,\n    value: value\n  };\n}\n\n/**\n * Find an object by identifying the key, ':' separator and value\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys\n * @returns {{start: Number, end: Number, value: Object}}\n * @private\n */\nfunction _findObject(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var obj = {};\n  var keys = [];\n  var values = [];\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n  if (str[j] === '}') {\n    return {\n      start: startInd,\n      end: j,\n      value: obj\n    };\n  }\n  while (sepValue === ',') {\n    var key = _findKey(str, i);\n    var semi = _findSemiColonSeparator(str, key.end);\n    var value = _findValue(str, semi.end, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n    if (!allowDuplicatedKeys) {\n      if (keys.indexOf(key.value) !== -1) {\n        key.value = key.value + '1';\n        // throw _syntaxError(str, key.end, 'duplicated keys \"' + key.value + '\"');\n      }\n    }\n\n    keys.push(key.value);\n    values.push(value.value);\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  if (parse) {\n    var indx = 0;\n    for (indx = 0; indx < keys.length; indx++) {\n      obj[keys[indx]] = values[indx];\n    }\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: obj\n  };\n}\n\n/**\n * Going backward from an index, determine if there are even number\n * of consecutive backslashes in the string\n * @param {String} str - original json string\n * @param {Number} endInd\n * @returns {Boolean}\n * @private\n */\nfunction _hasEvenNumberOfBackSlash(str, endInd) {\n  var i = endInd;\n  var count = 0;\n  while (i > -1 && str[i] === '\\\\') {\n    count++;\n    i--;\n  }\n  return count % 2 === 0;\n}\n\n/**\n * Find an array by identifying values separated by ',' separator\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: Array}}\n * @private\n */\nfunction _findArray(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var arr = [];\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n  if (str[j] === ']') {\n    return {\n      start: startInd,\n      end: j,\n      value: arr\n    };\n  }\n  while (sepValue === ',') {\n    var value = _findValue(str, i, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n    if (parse) {\n      arr.push(value.value);\n    }\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: arr\n  };\n}\n\n/**\n * Determine if the string is 'true' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isTrueFromIndex(str, ind) {\n  return str.substr(ind, 4) === 'true';\n}\n\n/**\n * Determine if the string is 'false' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isFalseFromIndex(str, ind) {\n  return str.substr(ind, 5) === 'false';\n}\n\n/**\n * Determine if the string is 'null' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isNullFromIndex(str, ind) {\n  return str.substr(ind, 4) === 'null';\n}\nvar white = new RegExp(/^\\s$/);\n/**\n * Determine if this character is a white space\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isWhiteSpace(ch) {\n  return white.test(ch);\n}\nvar numberReg = new RegExp(/^\\d$/);\n/**\n * Determine if this character is a numeric character\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isNumber(ch) {\n  return numberReg.test(ch);\n}\n\n/**\n * Generate syntax error\n * @param {String} str - original json string\n * @param {Number} index - index in which the error was detected\n * @param {String} reason\n * @returns {Error}\n * @private\n */\nfunction _syntaxError(str, index, reason) {\n  var regionLen = 10;\n  var regionStr;\n  if (str.length < index + regionLen) {\n    regionStr = str.substr(_normalizeNegativeNumber(str.length - regionLen), str.length);\n  } else if (index - regionLen / 2 < 0) {\n    regionStr = str.substr(0, regionLen);\n  } else {\n    regionStr = str.substr(_normalizeNegativeNumber(index - regionLen / 2), regionLen);\n  }\n  var message;\n  if (reason) {\n    message = 'Syntax error: ' + reason + ' near ' + regionStr;\n  } else {\n    message = 'Syntax error near ' + regionStr;\n  }\n  return new Error(message);\n}\n\n/**\n * Return 0 if number is negative, the original number otherwise\n * @param {Number} num\n * @returns {Number}\n * @private\n */\nfunction _normalizeNegativeNumber(num) {\n  return num < 0 ? 0 : num;\n}","map":null,"metadata":{},"sourceType":"script"}