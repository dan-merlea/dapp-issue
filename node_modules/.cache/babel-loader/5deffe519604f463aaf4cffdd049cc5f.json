{"ast":null,"code":"/*!\n * @pixi/sprite-tiling - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar math = require('@pixi/math');\nvar sprite = require('@pixi/sprite');\nvar constants = require('@pixi/constants');\nvar utils = require('@pixi/utils');\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar tempPoint = new math.Point();\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @memberof PIXI\n */\nvar TilingSprite = /** @class */function (_super) {\n  __extends(TilingSprite, _super);\n  /**\n   * @param texture - The texture of the tiling sprite.\n   * @param width - The width of the tiling sprite.\n   * @param height - The height of the tiling sprite.\n   */\n  function TilingSprite(texture, width, height) {\n    if (width === void 0) {\n      width = 100;\n    }\n    if (height === void 0) {\n      height = 100;\n    }\n    var _this = _super.call(this, texture) || this;\n    _this.tileTransform = new math.Transform();\n    // The width of the tiling sprite\n    _this._width = width;\n    // The height of the tiling sprite\n    _this._height = height;\n    _this.uvMatrix = _this.texture.uvMatrix || new core.TextureMatrix(texture);\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_render' method.\n     * @default 'tilingSprite'\n     */\n    _this.pluginName = 'tilingSprite';\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  Object.defineProperty(TilingSprite.prototype, \"clampMargin\", {\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get: function get() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function set(value) {\n      this.uvMatrix.clampMargin = value;\n      this.uvMatrix.update(true);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"tileScale\", {\n    /** The scaling of the image that is being tiled. */\n    get: function get() {\n      return this.tileTransform.scale;\n    },\n    set: function set(value) {\n      this.tileTransform.scale.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"tilePosition\", {\n    /** The offset of the image that is being tiled. */\n    get: function get() {\n      return this.tileTransform.position;\n    },\n    set: function set(value) {\n      this.tileTransform.position.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @protected\n   */\n  TilingSprite.prototype._onTextureUpdate = function () {\n    if (this.uvMatrix) {\n      this.uvMatrix.texture = this._texture;\n    }\n    this._cachedTint = 0xFFFFFF;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   * @param renderer - The renderer\n   */\n  TilingSprite.prototype._render = function (renderer) {\n    // tweak our texture temporarily..\n    var texture = this._texture;\n    if (!texture || !texture.valid) {\n      return;\n    }\n    this.tileTransform.updateLocalTransform();\n    this.uvMatrix.update();\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /** Updates the bounds of the tiling sprite. */\n  TilingSprite.prototype._calculateBounds = function () {\n    var minX = this._width * -this._anchor._x;\n    var minY = this._height * -this._anchor._y;\n    var maxX = this._width * (1 - this._anchor._x);\n    var maxY = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Gets the local bounds of the sprite object.\n   * @param rect - Optional output rectangle.\n   * @returns The bounds.\n   */\n  TilingSprite.prototype.getLocalBounds = function (rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new math.Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n    return _super.prototype.getLocalBounds.call(this, rect);\n  };\n  /**\n   * Checks if a point is inside this tiling sprite.\n   * @param point - The point to check.\n   * @returns Whether or not the sprite contains the point.\n   */\n  TilingSprite.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor._x;\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      var y1 = -height * this.anchor._y;\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Destroys this sprite and optionally its texture and children\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n  TilingSprite.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this, options);\n    this.tileTransform = null;\n    this.uvMatrix = null;\n  };\n  /**\n   * Helper function that creates a new tiling sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   * @static\n   * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n   * @param {number} options.width - required width of the tiling sprite\n   * @param {number} options.height - required height of the tiling sprite\n   * @returns {PIXI.TilingSprite} The newly created texture\n   */\n  TilingSprite.from = function (source, options) {\n    var texture = source instanceof core.Texture ? source : core.Texture.from(source, options);\n    return new TilingSprite(texture, options.width, options.height);\n  };\n  Object.defineProperty(TilingSprite.prototype, \"width\", {\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value) {\n      this._width = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TilingSprite.prototype, \"height\", {\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value) {\n      this._height = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return TilingSprite;\n}(sprite.Sprite);\nvar fragmentSimpleSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\nvar gl1VertexSrc = \"#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar gl1FragmentSrc = \"#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\nvar gl2VertexSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\nvar gl2FragmentSrc = \"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n\";\nvar tempMat = new math.Matrix();\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nvar TilingSpriteRenderer = /** @class */function (_super) {\n  __extends(TilingSpriteRenderer, _super);\n  /**\n   * constructor for renderer\n   * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n   */\n  function TilingSpriteRenderer(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    // WebGL version is not available during initialization!\n    renderer.runners.contextChange.add(_this);\n    _this.quad = new core.QuadUv();\n    /**\n     * The WebGL state in which this renderer will work.\n     * @member {PIXI.State}\n     * @readonly\n     */\n    _this.state = core.State.for2d();\n    return _this;\n  }\n  /** Creates shaders when context is initialized. */\n  TilingSpriteRenderer.prototype.contextChange = function () {\n    var renderer = this.renderer;\n    var uniforms = {\n      globals: renderer.globalUniforms\n    };\n    this.simpleShader = core.Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n    this.shader = renderer.context.webGLVersion > 1 ? core.Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms) : core.Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n  };\n  /**\n   * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n   */\n  TilingSpriteRenderer.prototype.render = function (ts) {\n    var renderer = this.renderer;\n    var quad = this.quad;\n    var vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n    var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n    var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n    vertices = quad.uvs;\n    vertices[0] = vertices[6] = -anchorX;\n    vertices[1] = vertices[3] = -anchorY;\n    vertices[2] = vertices[4] = 1.0 - anchorX;\n    vertices[5] = vertices[7] = 1.0 - anchorY;\n    quad.invalidate();\n    var tex = ts._texture;\n    var baseTex = tex.baseTexture;\n    var premultiplied = baseTex.alphaMode > 0;\n    var lt = ts.tileTransform.localTransform;\n    var uv = ts.uvMatrix;\n    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n    // auto, force repeat wrapMode for big tiling textures\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === constants.WRAP_MODES.CLAMP) {\n          baseTex.wrapMode = constants.WRAP_MODES.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== constants.WRAP_MODES.CLAMP;\n      }\n    }\n    var shader = isSimple ? this.simpleShader : this.shader;\n    var w = tex.width;\n    var h = tex.height;\n    var W = ts._width;\n    var H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n    // that part is the same as above:\n    // tempMat.identity();\n    // tempMat.scale(tex.width, tex.height);\n    // tempMat.prepend(lt);\n    // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n    tempMat.invert();\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = tex;\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(quad);\n    this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n    renderer.state.set(this.state);\n    renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  };\n  /** @ignore */\n  TilingSpriteRenderer.extension = {\n    name: 'tilingSprite',\n    type: core.ExtensionType.RendererPlugin\n  };\n  return TilingSpriteRenderer;\n}(core.ObjectRenderer);\nexports.TilingSprite = TilingSprite;\nexports.TilingSpriteRenderer = TilingSpriteRenderer;","map":null,"metadata":{},"sourceType":"script"}