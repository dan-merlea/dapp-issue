{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _possibleConstructorReturn from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nvar ImageBitmapResource = /*#__PURE__*/function (_BaseImageResource) {\n  _inherits(ImageBitmapResource, _BaseImageResource);\n  var _super = _createSuper(ImageBitmapResource);\n  function ImageBitmapResource(source, options) {\n    var _this2 = this,\n      _options$crossOrigin;\n    var _this;\n    _classCallCheck(this, ImageBitmapResource);\n    var __super = function __super() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _super.call.apply(_super, [_this2].concat(args));\n    };\n    options = options || {};\n    if (typeof source === \"string\") {\n      __super(ImageBitmapResource.EMPTY);\n      _this.url = source;\n    } else {\n      __super(source);\n      _this.url = null;\n    }\n    _this.crossOrigin = (_options$crossOrigin = options.crossOrigin) !== null && _options$crossOrigin !== void 0 ? _options$crossOrigin : true;\n    _this.alphaMode = typeof options.alphaMode === \"number\" ? options.alphaMode : null;\n    _this._load = null;\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _possibleConstructorReturn(_this);\n  }\n  _createClass(ImageBitmapResource, [{\n    key: \"load\",\n    value: function load() {\n      var _this3 = this;\n      if (this._load) {\n        return this._load;\n      }\n      this._load = new Promise( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {\n          var response, imageBlob, imageBitmap;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!(_this3.url === null)) {\n                    _context.next = 3;\n                    break;\n                  }\n                  resolve(_this3);\n                  return _context.abrupt(\"return\");\n                case 3:\n                  _context.prev = 3;\n                  _context.next = 6;\n                  return settings.ADAPTER.fetch(_this3.url, {\n                    mode: _this3.crossOrigin ? \"cors\" : \"no-cors\"\n                  });\n                case 6:\n                  response = _context.sent;\n                  if (!_this3.destroyed) {\n                    _context.next = 9;\n                    break;\n                  }\n                  return _context.abrupt(\"return\");\n                case 9:\n                  _context.next = 11;\n                  return response.blob();\n                case 11:\n                  imageBlob = _context.sent;\n                  if (!_this3.destroyed) {\n                    _context.next = 14;\n                    break;\n                  }\n                  return _context.abrupt(\"return\");\n                case 14:\n                  _context.next = 16;\n                  return createImageBitmap(imageBlob, {\n                    premultiplyAlpha: _this3.alphaMode === null || _this3.alphaMode === ALPHA_MODES.UNPACK ? \"premultiply\" : \"none\"\n                  });\n                case 16:\n                  imageBitmap = _context.sent;\n                  if (!_this3.destroyed) {\n                    _context.next = 19;\n                    break;\n                  }\n                  return _context.abrupt(\"return\");\n                case 19:\n                  _this3.source = imageBitmap;\n                  _this3.update();\n                  resolve(_this3);\n                  _context.next = 30;\n                  break;\n                case 24:\n                  _context.prev = 24;\n                  _context.t0 = _context[\"catch\"](3);\n                  if (!_this3.destroyed) {\n                    _context.next = 28;\n                    break;\n                  }\n                  return _context.abrupt(\"return\");\n                case 28:\n                  reject(_context.t0);\n                  _this3.onError.emit(_context.t0);\n                case 30:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[3, 24]]);\n        }));\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return this._load;\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(renderer, baseTexture, glTexture) {\n      if (!(this.source instanceof ImageBitmap)) {\n        this.load();\n        return false;\n      }\n      if (typeof this.alphaMode === \"number\") {\n        baseTexture.alphaMode = this.alphaMode;\n      }\n      return _get(_getPrototypeOf(ImageBitmapResource.prototype), \"upload\", this).call(this, renderer, baseTexture, glTexture);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.source instanceof ImageBitmap) {\n        this.source.close();\n      }\n      _get(_getPrototypeOf(ImageBitmapResource.prototype), \"dispose\", this).call(this);\n      this._load = null;\n    }\n  }], [{\n    key: \"test\",\n    value: function test(source) {\n      return !!globalThis.createImageBitmap && typeof ImageBitmap !== \"undefined\" && (typeof source === \"string\" || source instanceof ImageBitmap);\n    }\n  }, {\n    key: \"EMPTY\",\n    get: function get() {\n      var _ImageBitmapResource$;\n      ImageBitmapResource._EMPTY = (_ImageBitmapResource$ = ImageBitmapResource._EMPTY) !== null && _ImageBitmapResource$ !== void 0 ? _ImageBitmapResource$ : settings.ADAPTER.createCanvas(0, 0);\n      return ImageBitmapResource._EMPTY;\n    }\n  }]);\n  return ImageBitmapResource;\n}(BaseImageResource);\nexport { ImageBitmapResource };","map":{"version":3,"sources":["../../../src/textures/resources/ImageBitmapResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport { BaseImageResource } from './BaseImageResource';\n\nimport type { ICanvas } from '@pixi/settings';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\n\nexport interface IImageBitmapResourceOptions\n{\n    /** Start loading process automatically when constructed. */\n    autoLoad?: boolean;\n\n    /** Load image using cross origin. */\n    crossOrigin?: boolean;\n\n    /** Alpha mode used when creating the ImageBitmap. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * Resource type for ImageBitmap.\n * @memberof PIXI\n */\nexport class ImageBitmapResource extends BaseImageResource\n{\n    /** URL of the image source. */\n    url: string | null;\n\n    /**\n     * Load image using cross origin.\n     * @default false\n     */\n    crossOrigin: boolean;\n\n    /**\n     * Controls texture alphaMode field\n     * Copies from options\n     * Default is `null`, copies option from baseTexture\n     * @readonly\n     */\n    alphaMode: ALPHA_MODES | null;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<ImageBitmapResource>;\n\n    /**\n     * @param source - ImageBitmap or URL to use\n     * @param options\n     * @param {boolean} [options.autoLoad=true] - Start loading process automatically when constructed.\n     * @param {boolean} [options.crossOrigin=true] - Load image using cross origin.\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=null] - Alpha mode used when creating the ImageBitmap.\n     */\n    constructor(source: ImageBitmap | string, options?: IImageBitmapResourceOptions)\n    {\n        options = options || {};\n\n        if (typeof source === 'string')\n        {\n            super(ImageBitmapResource.EMPTY);\n\n            this.url = source;\n        }\n        else\n        {\n            super(source);\n\n            this.url = null;\n        }\n\n        this.crossOrigin = options.crossOrigin ?? true;\n        this.alphaMode = typeof options.alphaMode === 'number' ? options.alphaMode : null;\n\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<ImageBitmapResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise(async (resolve, reject) =>\n        {\n            if (this.url === null)\n            {\n                resolve(this);\n\n                return;\n            }\n\n            try\n            {\n                const response = await settings.ADAPTER.fetch(this.url, {\n                    mode: this.crossOrigin ? 'cors' : 'no-cors'\n                });\n\n                if (this.destroyed) return;\n\n                const imageBlob = await response.blob();\n\n                if (this.destroyed) return;\n\n                const imageBitmap = await createImageBitmap(imageBlob, {\n                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === ALPHA_MODES.UNPACK\n                        ? 'premultiply' : 'none',\n                });\n\n                if (this.destroyed) return;\n\n                this.source = imageBitmap;\n                this.update();\n\n                resolve(this);\n            }\n            catch (e)\n            {\n                if (this.destroyed) return;\n\n                reject(e);\n                this.onError.emit(e);\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Upload the image bitmap resource to GPU.\n     * @param renderer - Renderer to upload to\n     * @param baseTexture - BaseTexture for this resource\n     * @param glTexture - GLTexture to use\n     * @returns {boolean} true is success\n     */\n    override upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        if (!(this.source instanceof ImageBitmap))\n        {\n            this.load();\n\n            return false;\n        }\n\n        if (typeof this.alphaMode === 'number')\n        {\n            baseTexture.alphaMode = this.alphaMode;\n        }\n\n        return super.upload(renderer, baseTexture, glTexture);\n    }\n\n    /** Destroys this resource. */\n    override dispose(): void\n    {\n        if (this.source instanceof ImageBitmap)\n        {\n            this.source.close();\n        }\n\n        super.dispose();\n\n        this._load = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if current environment support ImageBitmap, and source is string or ImageBitmap\n     */\n    static override test(source: unknown): source is string | ImageBitmap\n    {\n        return !!globalThis.createImageBitmap && typeof ImageBitmap !== 'undefined'\n            && (typeof source === 'string' || source instanceof ImageBitmap);\n    }\n\n    /**\n     * Cached empty placeholder canvas.\n     * @see EMPTY\n     */\n    private static _EMPTY: ICanvas;\n\n    /**\n     * ImageBitmap cannot be created synchronously, so a empty placeholder canvas is needed when loading from URLs.\n     * Only for internal usage.\n     * @returns The cached placeholder canvas.\n     */\n    private static get EMPTY(): ICanvas\n    {\n        ImageBitmapResource._EMPTY = ImageBitmapResource._EMPTY ?? settings.ADAPTER.createCanvas(0, 0);\n\n        return ImageBitmapResource._EMPTY;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}