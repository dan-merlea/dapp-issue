{"ast":null,"code":"import _toConsumableArray from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ExtensionType, settings, extensions } from '@pixi/core';\nvar detectWebp = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: function () {\n    var _test = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var webpData, blob;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (globalThis.createImageBitmap) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 2:\n              webpData = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\";\n              _context.next = 5;\n              return settings.ADAPTER.fetch(webpData).then(function (r) {\n                return r.blob();\n              });\n            case 5:\n              blob = _context.sent;\n              return _context.abrupt(\"return\", createImageBitmap(blob).then(function () {\n                return true;\n              }, function () {\n                return false;\n              }));\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function test() {\n      return _test.apply(this, arguments);\n    }\n    return test;\n  }(),\n  add: function () {\n    var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(formats) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", [].concat(_toConsumableArray(formats), [\"webp\"]));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    function add(_x) {\n      return _add.apply(this, arguments);\n    }\n    return add;\n  }(),\n  remove: function () {\n    var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(formats) {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", formats.filter(function (f) {\n                return f !== \"webp\";\n              }));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    function remove(_x2) {\n      return _remove.apply(this, arguments);\n    }\n    return remove;\n  }()\n};\nextensions.add(detectWebp);\nexport { detectWebp };","map":{"version":3,"sources":["../../../src/detections/parsers/detectWebp.ts"],"names":[],"mappings":";;;;AAGO,IAAM,UAAa,GAAA;EACtB,SAAW,EAAA;IACP,IAAA,EAAM,aAAc,CAAA,eAAA;IACpB,QAAU,EAAA;EAAA,CACd;EACA,IAAA;IAAA,uEAAM;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,IAEG,UAAW,CAAA,iBAAA;gBAAA;gBAAA;cAAA;cAAA,iCAA0B,KAAA;YAAA;cAEpC,QAAW,GAAA,6EAAA;cAAA;cAAA,OACE,QAAS,CAAA,OAAA,CAAQ,KAAM,CAAA,QAAQ,CAAE,CAAA,IAAA,CAAK,UAAC,CAAA;gBAAA,OAAM,CAAE,CAAA,IAAA,EAAM;cAAA,EAAA;YAAA;cAAlE,IAAO;cAAA,iCAEN,iBAAA,CAAkB,IAAI,CAAA,CAAE,IAAA,CAAK;gBAAA,OAAM,IAAA;cAAA,GAAM;gBAAA,OAAM,KAAK;cAAA,EAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAC/D;IAAA;MAAA;IAAA;IAAA;EAAA;EACA,GAAA;IAAA,sEAAK,kBAAO,OAAA;MAAA;QAAA;UAAA;YAAA;cAAA,+DAAgB,OAAA,IAAS,MAAM;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAA;IAAA;MAAA;IAAA;IAAA;EAAA;EAC3C,MAAA;IAAA,yEAAQ,kBAAO,OAAY;MAAA;QAAA;UAAA;YAAA;cAAA,kCAAA,OAAA,CAAQ,MAAA,CAAO,UAAC,CAAA;gBAAA,OAAM,CAAA,KAAM,MAAM;cAAA,EAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;IAAA;MAAA;IAAA;IAAA;EAAA;AACjE,CAAA;AAEA,UAAA,CAAW,GAAA,CAAI,UAAU,CAAA","sourcesContent":["import { settings, extensions, ExtensionType } from '@pixi/core';\nimport type { FormatDetectionParser } from '..';\n\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        if (!globalThis.createImageBitmap) return false;\n\n        const webpData = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=';\n        const blob = await settings.ADAPTER.fetch(webpData).then((r) => r.blob());\n\n        return createImageBitmap(blob).then(() => true, () => false);\n    },\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n\nextensions.add(detectWebp);\n"]},"metadata":{},"sourceType":"module"}