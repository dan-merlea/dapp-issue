{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InteractionChecker = void 0;\nvar errors = __importStar(require(\"../errors\"));\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n/**\n * An interaction checker that aims to be as strict as possible.\n * It is designed to catch programmer errors such as:\n *  - incorrect types of contract call arguments\n *  - errors related to calling \"non-payable\" functions with some value provided\n *  - gas estimation errors (not yet implemented)\n */\nvar InteractionChecker = /*#__PURE__*/function () {\n  function InteractionChecker() {\n    _classCallCheck(this, InteractionChecker);\n  }\n  _createClass(InteractionChecker, [{\n    key: \"checkInteraction\",\n    value: function checkInteraction(interaction, definition) {\n      this.checkPayable(interaction, definition);\n      this.checkArguments(interaction, definition);\n    }\n  }, {\n    key: \"checkPayable\",\n    value: function checkPayable(interaction, definition) {\n      var hasValue = !new bignumber_js_1.default(interaction.getValue().toString()).isZero();\n      var isPayableInEGLD = definition.modifiers.isPayableInEGLD();\n      if (hasValue && !isPayableInEGLD) {\n        throw new errors.ErrContractInteraction(\"cannot send EGLD value to non-payable\");\n      }\n    }\n  }, {\n    key: \"checkArguments\",\n    value: function checkArguments(interaction, definition) {\n      var formalArguments = definition.input;\n      var actualArguments = interaction.getArguments();\n      var numFormalArguments = formalArguments.length;\n      var numActualArguments = actualArguments.length;\n      if (numFormalArguments != numActualArguments) {\n        throw new errors.ErrContractInteraction(\"bad arguments, expected: \".concat(numFormalArguments, \", got: \").concat(numActualArguments));\n      }\n      // TODO: discuss again, possibly redesign the handling of covariance / contravariance.\n      for (var i = 0; i < numFormalArguments; i++) {\n        var expectedType = formalArguments[i].type;\n        var argument = actualArguments[i];\n        var actualType = argument.getType();\n        // isAssignableFrom() is responsible to handle covariance and contravariance (depending on the class that overrides it).\n        var ok = expectedType.isAssignableFrom(actualType);\n        if (!ok) {\n          throw new errors.ErrContractInteraction(\"type mismatch at index \".concat(i, \", expected: \").concat(expectedType, \", got: \").concat(actualType));\n        }\n      }\n    }\n  }]);\n  return InteractionChecker;\n}();\nexports.InteractionChecker = InteractionChecker;","map":{"version":3,"sources":["../../src/smartcontracts/interactionChecker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;AAGA,IAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;AAEA;;;;;;AAMG;AANH,IAOa,kBAAkB;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OAC3B,0BAAiB,WAAwB,EAAE,UAA8B,EAAA;MACrE,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,UAAU,CAAC;MAC1C,IAAI,CAAC,cAAc,CAAC,WAAW,EAAE,UAAU,CAAC;IAChD;EAAC;IAAA;IAAA,OAEO,sBAAa,WAAwB,EAAE,UAA8B,EAAA;MACzE,IAAI,QAAQ,GAAG,CAAC,IAAI,cAAA,CAAA,OAAS,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC,MAAM,EAAE;MACzE,IAAI,eAAe,GAAG,UAAU,CAAC,SAAS,CAAC,eAAe,EAAE;MAE5D,IAAI,QAAQ,IAAI,CAAC,eAAe,EAAE;QAC9B,MAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC,uCAAuC,CAAC;MACnF;IACL;EAAC;IAAA;IAAA,OAEO,wBAAe,WAAwB,EAAE,UAA8B,EAAA;MAC3E,IAAI,eAAe,GAAG,UAAU,CAAC,KAAK;MACtC,IAAI,eAAe,GAAG,WAAW,CAAC,YAAY,EAAE;MAChD,IAAI,kBAAkB,GAAG,eAAe,CAAC,MAAM;MAC/C,IAAI,kBAAkB,GAAG,eAAe,CAAC,MAAM;MAE/C,IAAI,kBAAkB,IAAI,kBAAkB,EAAE;QAC1C,MAAM,IAAI,MAAM,CAAC,sBAAsB,oCAA6B,kBAAkB,oBAAU,kBAAkB,EAAG;MACxH;MAED;MAEA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,kBAAkB,EAAE,CAAC,EAAE,EAAE;QACzC,IAAI,YAAY,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI;QAC1C,IAAI,QAAQ,GAAG,eAAe,CAAC,CAAC,CAAC;QACjC,IAAI,UAAU,GAAG,QAAQ,CAAC,OAAO,EAAE;QACnC;QACA,IAAI,EAAE,GAAG,YAAY,CAAC,gBAAgB,CAAC,UAAU,CAAC;QAElD,IAAI,CAAC,EAAE,EAAE;UACL,MAAM,IAAI,MAAM,CAAC,sBAAsB,kCAA2B,CAAC,yBAAe,YAAY,oBAAU,UAAU,EAAG;QACxH;MACJ;IACL;EAAC;EAAA;AAAA;AAtCL,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InteractionChecker = void 0;\nconst errors = __importStar(require(\"../errors\"));\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n/**\n * An interaction checker that aims to be as strict as possible.\n * It is designed to catch programmer errors such as:\n *  - incorrect types of contract call arguments\n *  - errors related to calling \"non-payable\" functions with some value provided\n *  - gas estimation errors (not yet implemented)\n */\nclass InteractionChecker {\n    checkInteraction(interaction, definition) {\n        this.checkPayable(interaction, definition);\n        this.checkArguments(interaction, definition);\n    }\n    checkPayable(interaction, definition) {\n        let hasValue = !new bignumber_js_1.default(interaction.getValue().toString()).isZero();\n        let isPayableInEGLD = definition.modifiers.isPayableInEGLD();\n        if (hasValue && !isPayableInEGLD) {\n            throw new errors.ErrContractInteraction(\"cannot send EGLD value to non-payable\");\n        }\n    }\n    checkArguments(interaction, definition) {\n        let formalArguments = definition.input;\n        let actualArguments = interaction.getArguments();\n        let numFormalArguments = formalArguments.length;\n        let numActualArguments = actualArguments.length;\n        if (numFormalArguments != numActualArguments) {\n            throw new errors.ErrContractInteraction(`bad arguments, expected: ${numFormalArguments}, got: ${numActualArguments}`);\n        }\n        // TODO: discuss again, possibly redesign the handling of covariance / contravariance.\n        for (let i = 0; i < numFormalArguments; i++) {\n            let expectedType = formalArguments[i].type;\n            let argument = actualArguments[i];\n            let actualType = argument.getType();\n            // isAssignableFrom() is responsible to handle covariance and contravariance (depending on the class that overrides it).\n            let ok = expectedType.isAssignableFrom(actualType);\n            if (!ok) {\n                throw new errors.ErrContractInteraction(`type mismatch at index ${i}, expected: ${expectedType}, got: ${actualType}`);\n            }\n        }\n    }\n}\nexports.InteractionChecker = InteractionChecker;\n//# sourceMappingURL=interactionChecker.js.map"]},"metadata":{},"sourceType":"script"}