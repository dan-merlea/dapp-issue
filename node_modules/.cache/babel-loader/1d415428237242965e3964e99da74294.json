{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SmartContract = void 0;\nvar address_1 = require(\"../address\");\nvar transaction_1 = require(\"../transaction\");\nvar transactionPayload_1 = require(\"../transactionPayload\");\nvar codeMetadata_1 = require(\"./codeMetadata\");\nvar transactionPayloadBuilders_1 = require(\"./transactionPayloadBuilders\");\nvar function_1 = require(\"./function\");\nvar query_1 = require(\"./query\");\nvar utils_1 = require(\"../utils\");\nvar utils_2 = require(\"./codec/utils\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar interaction_1 = require(\"./interaction\");\nvar nativeSerializer_1 = require(\"./nativeSerializer\");\nvar errors_1 = require(\"../errors\");\nvar createKeccakHash = require(\"keccak\");\n/**\n * An abstraction for deploying and interacting with Smart Contracts.\n */\nvar SmartContract = /*#__PURE__*/function () {\n  /**\n   * Create a SmartContract object by providing its address on the Network.\n   */\n  function SmartContract(_ref) {\n    var address = _ref.address,\n      abi = _ref.abi;\n    _classCallCheck(this, SmartContract);\n    this.address = new address_1.Address();\n    /**\n     * This object contains a function for each endpoint defined by the contract.\n     * (a bit similar to web3js's \"contract.methods\").\n     */\n    this.methodsExplicit = {};\n    /**\n     * This object contains a function for each endpoint defined by the contract.\n     * (a bit similar to web3js's \"contract.methods\").\n     *\n     * This is an alternative to {@link methodsExplicit}.\n     * Unlike {@link methodsExplicit}, automatic type inference (wrt. ABI) is applied when using {@link methods}.\n     */\n    this.methods = {};\n    this.address = address || new address_1.Address();\n    this.abi = abi;\n    if (abi) {\n      this.setupMethods();\n    }\n  }\n  _createClass(SmartContract, [{\n    key: \"setupMethods\",\n    value: function setupMethods() {\n      var _this = this;\n      var contract = this;\n      var abi = this.getAbi();\n      var _iterator = _createForOfIteratorHelper(abi.getAllEndpoints()),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var definition = _step.value;\n          var functionName = definition.name;\n          // For each endpoint defined by the ABI, we attach a function to the \"methods\" and \"methodsAuto\" objects,\n          // a function that receives typed values as arguments\n          // and returns a prepared contract interaction.\n          _this.methodsExplicit[functionName] = function (args) {\n            var func = new function_1.ContractFunction(functionName);\n            var interaction = new interaction_1.Interaction(contract, func, args || []);\n            return interaction;\n          };\n          _this.methods[functionName] = function (args) {\n            var func = new function_1.ContractFunction(functionName);\n            // Perform automatic type inference, wrt. the endpoint definition:\n            var typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args || [], definition);\n            var interaction = new interaction_1.Interaction(contract, func, typedArgs || []);\n            return interaction;\n          };\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Sets the address, as on Network.\n     */\n  }, {\n    key: \"setAddress\",\n    value: function setAddress(address) {\n      this.address = address;\n    }\n    /**\n     * Gets the address, as on Network.\n     */\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return this.address;\n    }\n  }, {\n    key: \"setAbi\",\n    value: function setAbi(abi) {\n      this.abi = abi;\n    }\n  }, {\n    key: \"getAbi\",\n    value: function getAbi() {\n      utils_1.guardValueIsSet(\"abi\", this.abi);\n      return this.abi;\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint(name) {\n      return this.getAbi().getEndpoint(name);\n    }\n    /**\n     * Creates a {@link Transaction} for deploying the Smart Contract to the Network.\n     */\n  }, {\n    key: \"deploy\",\n    value: function deploy(_ref2) {\n      var code = _ref2.code,\n        codeMetadata = _ref2.codeMetadata,\n        initArguments = _ref2.initArguments,\n        value = _ref2.value,\n        gasLimit = _ref2.gasLimit,\n        gasPrice = _ref2.gasPrice,\n        chainID = _ref2.chainID;\n      codeMetadata = codeMetadata || new codeMetadata_1.CodeMetadata();\n      initArguments = initArguments || [];\n      value = value || 0;\n      var payload = transactionPayload_1.TransactionPayload.contractDeploy().setCode(code).setCodeMetadata(codeMetadata).setInitArgs(initArguments).build();\n      var transaction = new transaction_1.Transaction({\n        receiver: address_1.Address.Zero(),\n        value: value,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice,\n        data: payload,\n        chainID: chainID\n      });\n      return transaction;\n    }\n    /**\n     * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.\n     */\n  }, {\n    key: \"upgrade\",\n    value: function upgrade(_ref3) {\n      var code = _ref3.code,\n        codeMetadata = _ref3.codeMetadata,\n        initArguments = _ref3.initArguments,\n        value = _ref3.value,\n        gasLimit = _ref3.gasLimit,\n        gasPrice = _ref3.gasPrice,\n        chainID = _ref3.chainID;\n      this.ensureHasAddress();\n      codeMetadata = codeMetadata || new codeMetadata_1.CodeMetadata();\n      initArguments = initArguments || [];\n      value = value || 0;\n      var payload = transactionPayload_1.TransactionPayload.contractUpgrade().setCode(code).setCodeMetadata(codeMetadata).setInitArgs(initArguments).build();\n      var transaction = new transaction_1.Transaction({\n        receiver: this.getAddress(),\n        value: value,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice,\n        data: payload,\n        chainID: chainID\n      });\n      return transaction;\n    }\n    /**\n     * Creates a {@link Transaction} for calling (a function of) the Smart Contract.\n     */\n  }, {\n    key: \"call\",\n    value: function call(_ref4) {\n      var func = _ref4.func,\n        args = _ref4.args,\n        value = _ref4.value,\n        gasLimit = _ref4.gasLimit,\n        receiver = _ref4.receiver,\n        gasPrice = _ref4.gasPrice,\n        chainID = _ref4.chainID;\n      this.ensureHasAddress();\n      args = args || [];\n      value = value || 0;\n      var payload = transactionPayload_1.TransactionPayload.contractCall().setFunction(func).setArgs(args).build();\n      var transaction = new transaction_1.Transaction({\n        receiver: receiver ? receiver : this.getAddress(),\n        value: value,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice,\n        data: payload,\n        chainID: chainID\n      });\n      return transaction;\n    }\n  }, {\n    key: \"createQuery\",\n    value: function createQuery(_ref5) {\n      var func = _ref5.func,\n        args = _ref5.args,\n        value = _ref5.value,\n        caller = _ref5.caller;\n      this.ensureHasAddress();\n      return new query_1.Query({\n        address: this.getAddress(),\n        func: func,\n        args: args,\n        value: value,\n        caller: caller\n      });\n    }\n  }, {\n    key: \"ensureHasAddress\",\n    value: function ensureHasAddress() {\n      if (!this.getAddress().bech32()) {\n        throw new errors_1.ErrContractHasNoAddress();\n      }\n    }\n    /**\n     * Computes the address of a Smart Contract.\n     * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.\n     *\n     * @param owner The owner of the Smart Contract\n     * @param nonce The owner nonce used for the deployment transaction\n     */\n  }], [{\n    key: \"computeAddress\",\n    value: function computeAddress(owner, nonce) {\n      var initialPadding = Buffer.alloc(8, 0);\n      var ownerPubkey = new address_1.Address(owner.bech32()).pubkey();\n      var shardSelector = ownerPubkey.slice(30);\n      var ownerNonceBytes = Buffer.alloc(8);\n      var bigNonce = new bignumber_js_1.default(nonce.valueOf().toString(10));\n      var bigNonceBuffer = utils_2.bigIntToBuffer(bigNonce);\n      ownerNonceBytes.write(bigNonceBuffer.reverse().toString('hex'), 'hex');\n      var bytesToHash = Buffer.concat([ownerPubkey, ownerNonceBytes]);\n      var hash = createKeccakHash(\"keccak256\").update(bytesToHash).digest();\n      var vmTypeBytes = Buffer.from(transactionPayloadBuilders_1.ArwenVirtualMachine, \"hex\");\n      var addressBytes = Buffer.concat([initialPadding, vmTypeBytes, hash.slice(10, 30), shardSelector]);\n      var address = new address_1.Address(addressBytes);\n      return address;\n    }\n  }]);\n  return SmartContract;\n}();\nexports.SmartContract = SmartContract;","map":null,"metadata":{},"sourceType":"script"}