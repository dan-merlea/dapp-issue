{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BytesBinaryCodec = void 0;\nvar bytes_1 = require(\"../typesystem/bytes\");\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"BytesValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nvar BytesBinaryCodec = /*#__PURE__*/function () {\n  function BytesBinaryCodec() {\n    _classCallCheck(this, BytesBinaryCodec);\n  }\n  _createClass(BytesBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer) {\n      var length = buffer.readUInt32BE(0);\n      var payload = buffer.slice(constants_1.SizeOfU32, constants_1.SizeOfU32 + length);\n      var result = new bytes_1.BytesValue(payload);\n      return [result, constants_1.SizeOfU32 + length];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer) {\n      return new bytes_1.BytesValue(buffer);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(bytes) {\n      var lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n      lengthBuffer.writeUInt32BE(bytes.getLength());\n      var buffer = Buffer.concat([lengthBuffer, bytes.valueOf()]);\n      return buffer;\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(bytes) {\n      return bytes.valueOf();\n    }\n  }]);\n  return BytesBinaryCodec;\n}();\nexports.BytesBinaryCodec = BytesBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/bytes.ts"],"names":[],"mappings":";;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;AAGG;AAHH,IAIa,gBAAgB;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OACzB,sBAAa,MAAc,EAAA;MACvB,IAAI,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC;MACnC,IAAI,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,WAAA,CAAA,SAAS,EAAE,WAAA,CAAA,SAAS,GAAG,MAAM,CAAC;MACzD,IAAI,MAAM,GAAG,IAAI,OAAA,CAAA,UAAU,CAAC,OAAO,CAAC;MACpC,OAAO,CAAC,MAAM,EAAE,WAAA,CAAA,SAAS,GAAG,MAAM,CAAC;IACvC;EAAC;IAAA;IAAA,OAED,wBAAe,MAAc,EAAA;MACzB,OAAO,IAAI,OAAA,CAAA,UAAU,CAAC,MAAM,CAAC;IACjC;EAAC;IAAA;IAAA,OAED,sBAAa,KAAiB,EAAA;MAC1B,IAAI,YAAY,GAAG,MAAM,CAAC,KAAK,CAAC,WAAA,CAAA,SAAS,CAAC;MAC1C,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC;MAC7C,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,YAAY,EAAE,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;MAC3D,OAAO,MAAM;IACjB;EAAC;IAAA;IAAA,OAED,wBAAe,KAAiB,EAAA;MAC5B,OAAO,KAAK,CAAC,OAAO,EAAE;IAC1B;EAAC;EAAA;AAAA;AArBL,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BytesBinaryCodec = void 0;\nconst bytes_1 = require(\"../typesystem/bytes\");\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"BytesValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nclass BytesBinaryCodec {\n    decodeNested(buffer) {\n        let length = buffer.readUInt32BE(0);\n        let payload = buffer.slice(constants_1.SizeOfU32, constants_1.SizeOfU32 + length);\n        let result = new bytes_1.BytesValue(payload);\n        return [result, constants_1.SizeOfU32 + length];\n    }\n    decodeTopLevel(buffer) {\n        return new bytes_1.BytesValue(buffer);\n    }\n    encodeNested(bytes) {\n        let lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n        lengthBuffer.writeUInt32BE(bytes.getLength());\n        let buffer = Buffer.concat([lengthBuffer, bytes.valueOf()]);\n        return buffer;\n    }\n    encodeTopLevel(bytes) {\n        return bytes.valueOf();\n    }\n}\nexports.BytesBinaryCodec = BytesBinaryCodec;\n//# sourceMappingURL=bytes.js.map"]},"metadata":{},"sourceType":"script"}