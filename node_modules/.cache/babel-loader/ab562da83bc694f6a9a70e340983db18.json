{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeMetadata = void 0;\n/**\n * The metadata of a Smart Contract, as an abstraction.\n */\nvar CodeMetadata = /*#__PURE__*/function () {\n  /**\n   * Creates a metadata object. By default, set the `upgradeable` attribute, and uset all others.\n   *\n   * @param upgradeable Whether the contract is upgradeable\n   * @param readable Whether other contracts can read this contract's data (without calling one of its pure functions)\n   * @param payable Whether the contract is payable\n   * @param payableBySc Whether the contract is payable by other smart contracts\n   */\n  function CodeMetadata() {\n    var upgradeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var readable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var payable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var payableBySc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, CodeMetadata);\n    this.upgradeable = upgradeable;\n    this.readable = readable;\n    this.payable = payable;\n    this.payableBySc = payableBySc;\n  }\n  /**\n   * Adjust the metadata (the `upgradeable` attribute), when preparing the deployment transaction.\n   */\n  _createClass(CodeMetadata, [{\n    key: \"toggleUpgradeable\",\n    value: function toggleUpgradeable(value) {\n      this.upgradeable = value;\n    }\n    /**\n     * Adjust the metadata (the `readable` attribute), when preparing the deployment transaction.\n     */\n  }, {\n    key: \"toggleReadable\",\n    value: function toggleReadable(value) {\n      this.readable = value;\n    }\n    /**\n     * Adjust the metadata (the `payable` attribute), when preparing the deployment transaction.\n     */\n  }, {\n    key: \"togglePayable\",\n    value: function togglePayable(value) {\n      this.payable = value;\n    }\n    /**\n     * Adjust the metadata (the `payableBySc` attribute), when preparing the deployment transaction.\n     */\n  }, {\n    key: \"togglePayableBySc\",\n    value: function togglePayableBySc(value) {\n      this.payableBySc = value;\n    }\n    /**\n     * Converts the metadata to the protocol-friendly representation.\n     */\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var byteZero = 0;\n      var byteOne = 0;\n      if (this.upgradeable) {\n        byteZero |= ByteZero.Upgradeable;\n      }\n      if (this.readable) {\n        byteZero |= ByteZero.Readable;\n      }\n      if (this.payable) {\n        byteOne |= ByteOne.Payable;\n      }\n      if (this.payableBySc) {\n        byteOne |= ByteOne.PayableBySc;\n      }\n      return Buffer.from([byteZero, byteOne]);\n    }\n    /**\n     * Converts the metadata to a hex-encoded string.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toBuffer().toString(\"hex\");\n    }\n    /**\n     * Converts the metadata to a pretty, plain JavaScript object.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        upgradeable: this.upgradeable,\n        readable: this.readable,\n        payable: this.payable,\n        payableBySc: this.payableBySc\n      };\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.upgradeable == other.upgradeable && this.readable == other.readable && this.payable == other.payable && this.payableBySc == other.payableBySc;\n    }\n  }]);\n  return CodeMetadata;\n}();\nexports.CodeMetadata = CodeMetadata;\nvar ByteZero;\n(function (ByteZero) {\n  ByteZero[ByteZero[\"Upgradeable\"] = 1] = \"Upgradeable\";\n  ByteZero[ByteZero[\"Reserved2\"] = 2] = \"Reserved2\";\n  ByteZero[ByteZero[\"Readable\"] = 4] = \"Readable\";\n})(ByteZero || (ByteZero = {}));\nvar ByteOne;\n(function (ByteOne) {\n  ByteOne[ByteOne[\"Reserved1\"] = 1] = \"Reserved1\";\n  ByteOne[ByteOne[\"Payable\"] = 2] = \"Payable\";\n  ByteOne[ByteOne[\"PayableBySc\"] = 4] = \"PayableBySc\";\n})(ByteOne || (ByteOne = {}));","map":null,"metadata":{},"sourceType":"script"}