{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentErrorContext = void 0;\nvar errors_1 = require(\"../errors\");\nvar ArgumentErrorContext = /*#__PURE__*/function () {\n  function ArgumentErrorContext(endpointName, argumentIndex, parameterDefinition) {\n    _classCallCheck(this, ArgumentErrorContext);\n    this.endpointName = endpointName;\n    this.argumentIndex = argumentIndex;\n    this.parameterDefinition = parameterDefinition;\n  }\n  _createClass(ArgumentErrorContext, [{\n    key: \"throwError\",\n    value: function throwError(specificError) {\n      throw new errors_1.ErrInvalidArgument(\"Error when converting arguments for endpoint (endpoint name: \".concat(this.endpointName, \", argument index: \").concat(this.argumentIndex, \", name: \").concat(this.parameterDefinition.name, \", type: \").concat(this.parameterDefinition.type, \")\\nNested error: \").concat(specificError));\n    }\n  }, {\n    key: \"convertError\",\n    value: function convertError(native, typeName) {\n      this.throwError(\"Can't convert argument (argument: \".concat(native, \", type \").concat(typeof native, \"), wanted type: \").concat(typeName, \")\"));\n    }\n  }, {\n    key: \"unhandledType\",\n    value: function unhandledType(functionName, type) {\n      this.throwError(\"Unhandled type (function: \".concat(functionName, \", type: \").concat(type, \")\"));\n    }\n  }, {\n    key: \"guardSameLength\",\n    value: function guardSameLength(native, valueTypes) {\n      native = native || [];\n      if (native.length != valueTypes.length) {\n        this.throwError(\"Incorrect composite type length: have \".concat(native.length, \", expected \").concat(valueTypes.length, \" (argument: \").concat(native, \")\"));\n      }\n    }\n  }, {\n    key: \"guardHasField\",\n    value: function guardHasField(native, fieldName) {\n      native = native || {};\n      if (!(fieldName in native)) {\n        this.throwError(\"Struct argument does not contain a field named \\\"\".concat(fieldName, \"\\\" (argument: \").concat(JSON.stringify(native), \")\"));\n      }\n    }\n  }]);\n  return ArgumentErrorContext;\n}();\nexports.ArgumentErrorContext = ArgumentErrorContext;","map":null,"metadata":{},"sourceType":"script"}