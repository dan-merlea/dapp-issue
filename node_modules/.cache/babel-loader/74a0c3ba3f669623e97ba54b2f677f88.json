{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\nvar errors_1 = require(\"../../errors\");\nvar fields_1 = require(\"./fields\");\nvar types_1 = require(\"./types\");\nvar StructType = /*#__PURE__*/function (_types_1$CustomType) {\n  _inherits(StructType, _types_1$CustomType);\n  var _super = _createSuper(StructType);\n  function StructType(name, fieldsDefinitions) {\n    var _this;\n    _classCallCheck(this, StructType);\n    _this = _super.call(this, name);\n    _this.fieldsDefinitions = [];\n    _this.fieldsDefinitions = fieldsDefinitions;\n    return _this;\n  }\n  _createClass(StructType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return StructType.ClassName;\n    }\n  }, {\n    key: \"getFieldsDefinitions\",\n    value: function getFieldsDefinitions() {\n      return this.fieldsDefinitions;\n    }\n  }, {\n    key: \"getFieldDefinition\",\n    value: function getFieldDefinition(name) {\n      return this.fieldsDefinitions.find(function (item) {\n        return item.name == name;\n      });\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var definitions = (json.fields || []).map(function (definition) {\n        return fields_1.FieldDefinition.fromJSON(definition);\n      });\n      return new StructType(json.name, definitions);\n    }\n  }]);\n  return StructType;\n}(types_1.CustomType);\nexports.StructType = StructType;\nStructType.ClassName = \"StructType\";\nvar Struct = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(Struct, _types_1$TypedValue);\n  var _super2 = _createSuper(Struct);\n  /**\n   * One can only set fields at initialization time.\n   */\n  function Struct(type, fields) {\n    var _this2;\n    _classCallCheck(this, Struct);\n    _this2 = _super2.call(this, type);\n    _this2.fields = fields;\n    _this2.fieldsByName = new Map(fields.map(function (field) {\n      return [field.name, field];\n    }));\n    _this2.checkTyping();\n    return _this2;\n  }\n  _createClass(Struct, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return Struct.ClassName;\n    }\n  }, {\n    key: \"checkTyping\",\n    value: function checkTyping() {\n      var type = this.getType();\n      var definitions = type.getFieldsDefinitions();\n      fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      return this.fields;\n    }\n  }, {\n    key: \"getFieldValue\",\n    value: function getFieldValue(name) {\n      var field = this.fieldsByName.get(name);\n      if (field) {\n        return field.value.valueOf();\n      }\n      throw new errors_1.ErrMissingFieldOnStruct(name, this.getType().getName());\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var result = {};\n      var _iterator = _createForOfIteratorHelper(this.fields),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          result[field.name] = field.value.valueOf();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.getType().equals(other.getType())) {\n        return false;\n      }\n      var selfFields = this.getFields();\n      var otherFields = other.getFields();\n      return fields_1.Fields.equals(selfFields, otherFields);\n    }\n  }]);\n  return Struct;\n}(types_1.TypedValue);\nexports.Struct = Struct;\nStruct.ClassName = \"Struct\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAAiD,IAEpC,UAAW;EAAA;EAAA;EAIpB,oBAAY,IAAY,EAAE,iBAAoC,EAAA;IAAA;IAAA;IAC1D,0BAAM,IAAI;IAHG,MAAA,iBAAiB,GAAsB,EAAE;IAItD,MAAK,iBAAiB,GAAG,iBAAiB;IAAC;EAC/C;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,UAAU,CAAC,SAAS;IAC/B;EAAC;IAAA;IAAA,OAOD,gCAAoB;MAChB,OAAO,IAAI,CAAC,iBAAiB;IACjC;EAAC;IAAA;IAAA,OAED,4BAAmB,IAAY,EAAA;MAC3B,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,UAAA,IAAI;QAAA,OAAI,IAAI,CAAC,IAAI,IAAI,IAAI;MAAA,EAAC;IACjE;EAAC;IAAA;IAAA,OAED,kCAAsB;MAClB,OAAO,QAAA,CAAA,MAAM,CAAC,0BAA0B,CAAC,IAAI,CAAC,iBAAiB,CAAC;IACpE;EAAC;IAAA;IAAA,OAfD,kBAAgB,IAAqC,EAAA;MACjD,IAAI,WAAW,GAAG,CAAC,IAAI,CAAC,MAAM,IAAI,EAAE,EAAE,GAAG,CAAC,UAAA,UAAU;QAAA,OAAI,QAAA,CAAA,eAAe,CAAC,QAAQ,CAAC,UAAU,CAAC;MAAA,EAAC;MAC7F,OAAO,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,CAAC;IACjD;EAAC;EAAA;AAAA,EAhB2B,OAAA,CAAA,UAAU;AAA1C,OAAA,CAAA,UAAA,GAAA,UAAA;AACW,UAAA,CAAA,SAAS,GAAG,YAAY;AAAC,IA8BvB,MAAO;EAAA;EAAA;EAKhB;;AAEG;EACH,gBAAY,IAAgB,EAAE,MAAe,EAAA;IAAA;IAAA;IACzC,4BAAM,IAAI;IACV,OAAK,MAAM,GAAG,MAAM;IACpB,OAAK,YAAY,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,UAAA,KAAK;MAAA,OAAI,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC;IAAA,EAAC,CAAC;IAErE,OAAK,WAAW,EAAE;IAAC;EACvB;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,MAAM,CAAC,SAAS;IAC3B;EAAC;IAAA;IAAA,OAEO,uBAAW;MACf,IAAI,IAAI,GAAe,IAAI,CAAC,OAAO,EAAE;MACrC,IAAI,WAAW,GAAG,IAAI,CAAC,oBAAoB,EAAE;MAC7C,QAAA,CAAA,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC;IAChD;EAAC;IAAA;IAAA,OAED,qBAAS;MACL,OAAO,IAAI,CAAC,MAAM;IACtB;EAAC;IAAA;IAAA,OAED,uBAAc,IAAY,EAAA;MACtB,IAAI,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC;MACvC,IAAI,KAAK,EAAE;QACP,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE;MAC/B;MAED,MAAM,IAAI,QAAA,CAAA,uBAAuB,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,EAAE,CAAC;IACrE;EAAC;IAAA;IAAA,OAED,mBAAO;MACH,IAAI,MAAM,GAAQ,CAAA,CAAE;MAAC,2CAED,IAAI,CAAC,MAAM;QAAA;MAAA;QAA/B,oDAAiC;UAAA,IAAtB,KAAK;UACZ,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE;;MAC7C;QAAA;MAAA;QAAA;MAAA;MAED,OAAO,MAAM;IACjB;EAAC;IAAA;IAAA,OAED,gBAAO,KAAa,EAAA;MAChB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,EAAE;QACzC,OAAO,KAAK;MACf;MAED,IAAI,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE;MACjC,IAAI,WAAW,GAAG,KAAK,CAAC,SAAS,EAAE;MAEnC,OAAO,QAAA,CAAA,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,WAAW,CAAC;IACjD;EAAC;EAAA;AAAA,EA1DuB,OAAA,CAAA,UAAU;AAAtC,OAAA,CAAA,MAAA,GAAA,MAAA;AACW,MAAA,CAAA,SAAS,GAAG,QAAQ","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Struct = exports.StructType = void 0;\nconst errors_1 = require(\"../../errors\");\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nclass StructType extends types_1.CustomType {\n    constructor(name, fieldsDefinitions) {\n        super(name);\n        this.fieldsDefinitions = [];\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    getClassName() {\n        return StructType.ClassName;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n        return new StructType(json.name, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n    getFieldDefinition(name) {\n        return this.fieldsDefinitions.find(item => item.name == name);\n    }\n    getNamesOfDependencies() {\n        return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);\n    }\n}\nexports.StructType = StructType;\nStructType.ClassName = \"StructType\";\nclass Struct extends types_1.TypedValue {\n    /**\n     * One can only set fields at initialization time.\n     */\n    constructor(type, fields) {\n        super(type);\n        this.fields = fields;\n        this.fieldsByName = new Map(fields.map(field => [field.name, field]));\n        this.checkTyping();\n    }\n    getClassName() {\n        return Struct.ClassName;\n    }\n    checkTyping() {\n        let type = this.getType();\n        let definitions = type.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    getFields() {\n        return this.fields;\n    }\n    getFieldValue(name) {\n        let field = this.fieldsByName.get(name);\n        if (field) {\n            return field.value.valueOf();\n        }\n        throw new errors_1.ErrMissingFieldOnStruct(name, this.getType().getName());\n    }\n    valueOf() {\n        let result = {};\n        for (const field of this.fields) {\n            result[field.name] = field.value.valueOf();\n        }\n        return result;\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        return fields_1.Fields.equals(selfFields, otherFields);\n    }\n}\nexports.Struct = Struct;\nStruct.ClassName = \"Struct\";\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}