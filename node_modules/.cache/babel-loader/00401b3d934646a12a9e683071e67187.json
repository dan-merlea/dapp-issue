{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\nvar utils_1 = require(\"../../utils\");\nvar collections_1 = require(\"./collections\");\nvar types_1 = require(\"./types\");\n// TODO: Move to a new file, \"genericOption.ts\"\nvar OptionType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(OptionType, _types_1$Type);\n  var _super = _createSuper(OptionType);\n  function OptionType(typeParameter) {\n    _classCallCheck(this, OptionType);\n    return _super.call(this, \"Option\", [typeParameter]);\n  }\n  _createClass(OptionType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionType.ClassName;\n    }\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      if (!type.hasExactClass(OptionType.ClassName)) {\n        return false;\n      }\n      var invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n      var fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n      return invariantTypeParameters || fakeCovarianceToNull;\n    }\n  }]);\n  return OptionType;\n}(types_1.Type);\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\";\n// TODO: Move to a new file, \"genericList.ts\"\nvar ListType = /*#__PURE__*/function (_types_1$Type2) {\n  _inherits(ListType, _types_1$Type2);\n  var _super2 = _createSuper(ListType);\n  function ListType(typeParameter) {\n    _classCallCheck(this, ListType);\n    return _super2.call(this, \"List\", [typeParameter]);\n  }\n  _createClass(ListType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return ListType.ClassName;\n    }\n  }]);\n  return ListType;\n}(types_1.Type);\nexports.ListType = ListType;\nListType.ClassName = \"ListType\";\n// TODO: Move to a new file, \"genericOption.ts\"\nvar OptionValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(OptionValue, _types_1$TypedValue);\n  var _super3 = _createSuper(OptionValue);\n  function OptionValue(type) {\n    var _this;\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, OptionValue);\n    _this = _super3.call(this, type);\n    // TODO: assert value is of type type.getFirstTypeParameter()\n    _this.value = value;\n    return _this;\n  }\n  _createClass(OptionValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionValue.ClassName;\n    }\n    /**\n     * Creates an OptionValue, as a missing option argument.\n     */\n  }, {\n    key: \"isSet\",\n    value: function isSet() {\n      return this.value ? true : false;\n    }\n  }, {\n    key: \"getTypedValue\",\n    value: function getTypedValue() {\n      utils_1.guardValueIsSet(\"value\", this.value);\n      return this.value;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value ? this.value.valueOf() : null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var _a;\n      return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n  }], [{\n    key: \"newMissing\",\n    value: function newMissing() {\n      var type = new OptionType(new types_1.NullType());\n      return new OptionValue(type);\n    }\n  }, {\n    key: \"newMissingTyped\",\n    value: function newMissingTyped(type) {\n      return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n  }, {\n    key: \"newProvided\",\n    value: function newProvided(typedValue) {\n      var type = new OptionType(typedValue.getType());\n      return new OptionValue(type, typedValue);\n    }\n  }]);\n  return OptionValue;\n}(types_1.TypedValue);\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\";\n// TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\nvar List = /*#__PURE__*/function (_types_1$TypedValue2) {\n  _inherits(List, _types_1$TypedValue2);\n  var _super4 = _createSuper(List);\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  function List(type, items) {\n    var _this2;\n    _classCallCheck(this, List);\n    _this2 = _super4.call(this, type);\n    // TODO: assert items are of type type.getFirstTypeParameter()\n    _this2.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    return _this2;\n  }\n  _createClass(List, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return List.ClassName;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.backingCollection.getLength();\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.backingCollection.getItems();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.backingCollection.valueOf();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.backingCollection.equals(other.backingCollection);\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems(items) {\n      if (items.length == 0) {\n        return new List(new types_1.TypePlaceholder(), []);\n      }\n      var typeParameter = items[0].getType();\n      var listType = new ListType(typeParameter);\n      return new List(listType, items);\n    }\n  }]);\n  return List;\n}(types_1.TypedValue);\nexports.List = List;\nList.ClassName = \"List\";","map":{"version":3,"mappings":"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","names":["OptionType","typeParameter","ClassName","type","hasExactClass","invariantTypeParameters","getFirstTypeParameter","equals","fakeCovarianceToNull","types_1","exports","ListType","OptionValue","value","utils_1","valueOf","other","typedValue","getType","List","items","backingCollection","collections_1","getLength","getItems","length","listType"],"sourceRoot":"","sources":["../../../src/smartcontracts/typesystem/generic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}