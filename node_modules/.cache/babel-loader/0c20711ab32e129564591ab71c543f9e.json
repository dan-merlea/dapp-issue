{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar generateBlurVertSource = require('./generateBlurVertSource.js');\nvar generateBlurFragSource = require('./generateBlurFragSource.js');\nvar BlurFilterPass = /*#__PURE__*/function (_core$Filter) {\n  _inherits(BlurFilterPass, _core$Filter);\n  var _super = _createSuper(BlurFilterPass);\n  function BlurFilterPass(horizontal) {\n    var _this;\n    var strength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n    var quality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n    var resolution = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : core.settings.FILTER_RESOLUTION;\n    var kernelSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n    _classCallCheck(this, BlurFilterPass);\n    var vertSrc = generateBlurVertSource.generateBlurVertSource(kernelSize, horizontal);\n    var fragSrc = generateBlurFragSource.generateBlurFragSource(kernelSize);\n    _this = _super.call(this, vertSrc, fragSrc);\n    _this.horizontal = horizontal;\n    _this.resolution = resolution;\n    _this._quality = 0;\n    _this.quality = quality;\n    _this.blur = strength;\n    return _this;\n  }\n  _createClass(BlurFilterPass, [{\n    key: \"apply\",\n    value: function apply(filterManager, input, output, clearMode) {\n      if (output) {\n        if (this.horizontal) {\n          this.uniforms.strength = 1 / output.width * (output.width / input.width);\n        } else {\n          this.uniforms.strength = 1 / output.height * (output.height / input.height);\n        }\n      } else {\n        if (this.horizontal) {\n          this.uniforms.strength = 1 / filterManager.renderer.width * (filterManager.renderer.width / input.width);\n        } else {\n          this.uniforms.strength = 1 / filterManager.renderer.height * (filterManager.renderer.height / input.height);\n        }\n      }\n      this.uniforms.strength *= this.strength;\n      this.uniforms.strength /= this.passes;\n      if (this.passes === 1) {\n        filterManager.applyFilter(this, input, output, clearMode);\n      } else {\n        var renderTarget = filterManager.getFilterTexture();\n        var renderer = filterManager.renderer;\n        var flip = input;\n        var flop = renderTarget;\n        this.state.blend = false;\n        filterManager.applyFilter(this, flip, flop, core.CLEAR_MODES.CLEAR);\n        for (var i = 1; i < this.passes - 1; i++) {\n          filterManager.bindAndClear(flip, core.CLEAR_MODES.BLIT);\n          this.uniforms.uSampler = flop;\n          var temp = flop;\n          flop = flip;\n          flip = temp;\n          renderer.shader.bind(this);\n          renderer.geometry.draw(5);\n        }\n        this.state.blend = true;\n        filterManager.applyFilter(this, flop, output, clearMode);\n        filterManager.returnFilterTexture(renderTarget);\n      }\n    }\n  }, {\n    key: \"blur\",\n    get: function get() {\n      return this.strength;\n    },\n    set: function set(value) {\n      this.padding = 1 + Math.abs(value) * 2;\n      this.strength = value;\n    }\n  }, {\n    key: \"quality\",\n    get: function get() {\n      return this._quality;\n    },\n    set: function set(value) {\n      this._quality = value;\n      this.passes = value;\n    }\n  }]);\n  return BlurFilterPass;\n}(core.Filter);\nexports.BlurFilterPass = BlurFilterPass;","map":{"version":3,"sources":["../src/BlurFilterPass.ts"],"names":["Filter","generateBlurVertSource","generateBlurFragSource","CLEAR_MODES"],"mappings":"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","sourcesContent":["import { Filter, settings, CLEAR_MODES } from '@pixi/core';\nimport { generateBlurVertSource } from './generateBlurVertSource';\nimport { generateBlurFragSource } from './generateBlurFragSource';\n\nimport type { FilterSystem, RenderTexture } from '@pixi/core';\n\n/**\n * The BlurFilterPass applies a horizontal or vertical Gaussian blur to an object.\n * @memberof PIXI.filters\n */\nexport class BlurFilterPass extends Filter\n{\n    public horizontal: boolean;\n    public strength: number;\n    public passes: number;\n\n    private _quality: number;\n\n    /**\n     * @param horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).\n     * @param strength - The strength of the blur filter.\n     * @param quality - The quality of the blur filter.\n     * @param resolution - The resolution of the blur filter.\n     * @param kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.\n     */\n    constructor(horizontal: boolean, strength = 8, quality = 4, resolution = settings.FILTER_RESOLUTION, kernelSize = 5)\n    {\n        const vertSrc = generateBlurVertSource(kernelSize, horizontal);\n        const fragSrc = generateBlurFragSource(kernelSize);\n\n        super(\n            // vertex shader\n            vertSrc,\n            // fragment shader\n            fragSrc\n        );\n\n        this.horizontal = horizontal;\n\n        this.resolution = resolution;\n\n        this._quality = 0;\n\n        this.quality = quality;\n\n        this.blur = strength;\n    }\n\n    /**\n     * Applies the filter.\n     * @param filterManager - The manager.\n     * @param input - The input target.\n     * @param output - The output target.\n     * @param clearMode - How to clear\n     */\n    public apply(\n        filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clearMode: CLEAR_MODES\n    ): void\n    {\n        if (output)\n        {\n            if (this.horizontal)\n            {\n                this.uniforms.strength = (1 / output.width) * (output.width / input.width);\n            }\n            else\n            {\n                this.uniforms.strength = (1 / output.height) * (output.height / input.height);\n            }\n        }\n        else\n        {\n            if (this.horizontal) // eslint-disable-line\n            {\n                this.uniforms.strength = (1 / filterManager.renderer.width) * (filterManager.renderer.width / input.width);\n            }\n            else\n            {\n                this.uniforms.strength = (1 / filterManager.renderer.height) * (filterManager.renderer.height / input.height); // eslint-disable-line\n            }\n        }\n\n        // screen space!\n        this.uniforms.strength *= this.strength;\n        this.uniforms.strength /= this.passes;\n\n        if (this.passes === 1)\n        {\n            filterManager.applyFilter(this, input, output, clearMode);\n        }\n        else\n        {\n            const renderTarget = filterManager.getFilterTexture();\n            const renderer = filterManager.renderer;\n\n            let flip = input;\n            let flop = renderTarget;\n\n            this.state.blend = false;\n            filterManager.applyFilter(this, flip, flop, CLEAR_MODES.CLEAR);\n\n            for (let i = 1; i < this.passes - 1; i++)\n            {\n                filterManager.bindAndClear(flip, CLEAR_MODES.BLIT);\n\n                this.uniforms.uSampler = flop;\n\n                const temp = flop;\n\n                flop = flip;\n                flip = temp;\n\n                renderer.shader.bind(this);\n                renderer.geometry.draw(5);\n            }\n\n            this.state.blend = true;\n            filterManager.applyFilter(this, flop, output, clearMode);\n            filterManager.returnFilterTexture(renderTarget);\n        }\n    }\n    /**\n     * Sets the strength of both the blur.\n     * @default 16\n     */\n    get blur(): number\n    {\n        return this.strength;\n    }\n\n    set blur(value: number)\n    {\n        this.padding = 1 + (Math.abs(value) * 2);\n        this.strength = value;\n    }\n\n    /**\n     * Sets the quality of the blur by modifying the number of passes. More passes means higher\n     * quality bluring but the lower the performance.\n     * @default 4\n     */\n    get quality(): number\n    {\n        return this._quality;\n    }\n\n    set quality(value: number)\n    {\n        this._quality = value;\n        this.passes = value;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}