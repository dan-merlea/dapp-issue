{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar SIGN_RAW_TX_INS = 0x04;\nvar SIGN_HASH_TX_INS = 0x07;\nvar SIGN_MESSAGE_INS = 0x06;\nvar GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\nvar ACTIVE_SIGNERS = [SIGN_RAW_TX_INS, SIGN_HASH_TX_INS, SIGN_MESSAGE_INS, GET_ADDRESS_AUTH_TOKEN_INS];\nvar Elrond = /*#__PURE__*/function () {\n  function Elrond(transport) {\n    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"eGLD\";\n    _classCallCheck(this, Elrond);\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\", \"getAddressAndSignAuthToken\"], scrambleKey);\n  }\n  _createClass(Elrond, [{\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(account, index, display) {\n        var cla, ins, p1, p2, data, response, addressLength, address;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                cla = 0xed;\n                ins = 0x03;\n                p1 = display ? 0x01 : 0x00;\n                p2 = 0x00;\n                data = Buffer.alloc(8);\n                data.writeInt32BE(account, 0);\n                data.writeUInt32BE(index, 4);\n                _context.next = 9;\n                return this.transport.send(cla, ins, p1, p2, data);\n              case 9:\n                response = _context.sent;\n                addressLength = response[0];\n                address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n                return _context.abrupt(\"return\", {\n                  address: address\n                });\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getAddress(_x, _x2, _x3) {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n  }, {\n    key: \"setAddress\",\n    value: function () {\n      var _setAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, index, display) {\n        var cla, ins, p1, p2, data;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cla = 0xed;\n                ins = 0x05;\n                p1 = display ? 0x01 : 0x00;\n                p2 = 0x00;\n                data = Buffer.alloc(8);\n                data.writeInt32BE(account, 0);\n                data.writeUInt32BE(index, 4);\n                _context2.next = 9;\n                return this.transport.send(cla, ins, p1, p2, data);\n              case 9:\n                return _context2.abrupt(\"return\", _context2.sent);\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function setAddress(_x4, _x5, _x6) {\n        return _setAddress.apply(this, arguments);\n      }\n      return setAddress;\n    }()\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(rawTx, usingHash) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) : this.sign(rawTx, SIGN_RAW_TX_INS));\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function signTransaction(_x7, _x8) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signMessage\",\n    value: function () {\n      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(message) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.sign(message, SIGN_MESSAGE_INS));\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function signMessage(_x9) {\n        return _signMessage.apply(this, arguments);\n      }\n      return signMessage;\n    }()\n  }, {\n    key: \"getAddressAndSignAuthToken\",\n    value: function () {\n      var _getAddressAndSignAuthToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(account, index, token) {\n        var data, buffersArray, result, splitRes;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                data = Buffer.alloc(12);\n                data.writeInt32BE(account, 0);\n                data.writeUInt32BE(index, 4);\n                data.writeUInt32BE(token.length, 8);\n                buffersArray = [data, token];\n                _context5.next = 7;\n                return this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n              case 7:\n                result = _context5.sent;\n                splitRes = result.split(\"|\");\n                return _context5.abrupt(\"return\", {\n                  address: splitRes[0],\n                  signature: splitRes[1]\n                });\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getAddressAndSignAuthToken(_x10, _x11, _x12) {\n        return _getAddressAndSignAuthToken.apply(this, arguments);\n      }\n      return getAddressAndSignAuthToken;\n    }()\n  }, {\n    key: \"getAppConfiguration\",\n    value: function () {\n      var _getAppConfiguration = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var response;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.transport.send(0xed, 0x02, 0x00, 0x00);\n              case 2:\n                response = _context6.sent;\n                return _context6.abrupt(\"return\", {\n                  contractData: response[0],\n                  accountIndex: response[1],\n                  addressIndex: response[2],\n                  version: \"\".concat(response[3], \".\").concat(response[4], \".\").concat(response[5])\n                });\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function getAppConfiguration() {\n        return _getAppConfiguration.apply(this, arguments);\n      }\n      return getAppConfiguration;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message, type) {\n        var apdus, offset, isFirst, maxChunkSize, hasMore, chunkSize, apdu, response, _i, _apdus, _apdu;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (ACTIVE_SIGNERS.includes(type)) {\n                  _context7.next = 2;\n                  break;\n                }\n                throw new Error(\"invalid sign instruction called: \".concat(type));\n              case 2:\n                apdus = [];\n                offset = 0;\n                while (offset !== message.length) {\n                  isFirst = offset === 0;\n                  maxChunkSize = 150;\n                  hasMore = offset + maxChunkSize < message.length;\n                  chunkSize = hasMore ? maxChunkSize : message.length - offset;\n                  apdu = {\n                    cla: 0xed,\n                    ins: type,\n                    p1: isFirst ? 0x00 : 0x80,\n                    p2: 0x00,\n                    data: Buffer.alloc(chunkSize)\n                  };\n                  message.copy(apdu.data, 0, offset, offset + chunkSize);\n                  apdus.push(apdu);\n                  offset += chunkSize;\n                }\n                response = Buffer.alloc(0);\n                _i = 0, _apdus = apdus;\n              case 7:\n                if (!(_i < _apdus.length)) {\n                  _context7.next = 15;\n                  break;\n                }\n                _apdu = _apdus[_i];\n                _context7.next = 11;\n                return this.transport.send(_apdu.cla, _apdu.ins, _apdu.p1, _apdu.p2, _apdu.data);\n              case 11:\n                response = _context7.sent;\n              case 12:\n                _i++;\n                _context7.next = 7;\n                break;\n              case 15:\n                if (!(GET_ADDRESS_AUTH_TOKEN_INS === type)) {\n                  _context7.next = 17;\n                  break;\n                }\n                return _context7.abrupt(\"return\", this.handleAuthTokenResponse(response));\n              case 17:\n                if (!(response.length !== 67 || response[0] !== 64)) {\n                  _context7.next = 19;\n                  break;\n                }\n                throw new Error(\"invalid signature received from ledger device\");\n              case 19:\n                return _context7.abrupt(\"return\", response.slice(1, response.length - 2).toString(\"hex\"));\n              case 20:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function sign(_x13, _x14) {\n        return _sign.apply(this, arguments);\n      }\n      return sign;\n    }()\n  }, {\n    key: \"handleAuthTokenResponse\",\n    value: function handleAuthTokenResponse(response) {\n      if (response.length !== 129 && response[0] !== 126) {\n        throw new Error(\"invalid address and token signature received from ledger device\");\n      }\n      var address = response.slice(1, 63).toString(\"ascii\");\n      var signature = response.slice(63, response.length - 2).toString(\"hex\");\n      return address + \"|\" + signature;\n    }\n  }]);\n  return Elrond;\n}();\nexport { Elrond as default };","map":{"version":3,"sources":["../src/Elrond.js"],"names":["SIGN_RAW_TX_INS","SIGN_HASH_TX_INS","SIGN_MESSAGE_INS","GET_ADDRESS_AUTH_TOKEN_INS","ACTIVE_SIGNERS","Elrond","transport","constructor","scrambleKey","decorateAppAPIMethods","account","index","display","cla","ins","p1","p2","data","Buffer","alloc","writeInt32BE","writeUInt32BE","response","send","addressLength","address","slice","toString","rawTx","usingHash","sign","message","token","length","buffersArray","result","concat","splitRes","split","signature","contractData","accountIndex","addressIndex","version","type","includes","Error","apdus","offset","isFirst","maxChunkSize","hasMore","chunkSize","apdu","copy","push","handleAuthTokenResponse"],"mappings":"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","sourcesContent":["//@flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\n\nconst SIGN_RAW_TX_INS = 0x04;\nconst SIGN_HASH_TX_INS = 0x07;\nconst SIGN_MESSAGE_INS = 0x06;\nconst GET_ADDRESS_AUTH_TOKEN_INS = 0x09;\n\nconst ACTIVE_SIGNERS = [\n    SIGN_RAW_TX_INS,\n    SIGN_HASH_TX_INS,\n    SIGN_MESSAGE_INS,\n    GET_ADDRESS_AUTH_TOKEN_INS\n];\n\nexport default class Elrond {\n    transport: Transport<*>;\n\n    constructor(transport: Transport<*>, scrambleKey: string = \"eGLD\") {\n        this.transport = transport;\n        transport.decorateAppAPIMethods(\n            this,\n            [\"getAddress\", \"setAddress\", \"signTransaction\", \"signMessage\", \"getAppConfiguration\", \"getAddressAndSignAuthToken\"],\n            scrambleKey\n        );\n    }\n\n    async getAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ): Promise<{\n        publicKey: string,\n        address: string,\n        chainCode?: string,\n    }> {\n        const cla = 0xed;\n        const ins = 0x03;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        const response = await this.transport.send(cla, ins, p1, p2, data);\n\n        const addressLength = response[0];\n        const address = response.slice(1, 1 + addressLength).toString(\"ascii\");\n\n        return {address};\n    }\n\n    async setAddress(\n        account: number,\n        index: number,\n        display?: boolean,\n    ) {\n        const cla = 0xed;\n        const ins = 0x05;\n        const p1 = display ? 0x01 : 0x00;\n        const p2 = 0x00;\n        const data = Buffer.alloc(8);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n\n        return await this.transport.send(cla, ins, p1, p2, data);\n    }\n\n    async signTransaction(\n        rawTx: Buffer,\n        usingHash: boolean,\n    ): Promise<string> {\n        return usingHash ? this.sign(rawTx, SIGN_HASH_TX_INS) :\n            this.sign(rawTx, SIGN_RAW_TX_INS);\n    }\n\n    async signMessage(message: Buffer): Promise<string> {\n        return this.sign(message, SIGN_MESSAGE_INS);\n    }\n\n    async getAddressAndSignAuthToken(\n        account: number,\n        index: number,\n        token: Buffer,\n    ): Promise<{\n        address: string,\n        signature: string,\n    }> {\n        const data = Buffer.alloc(12);\n\n        data.writeInt32BE(account, 0);\n        data.writeUInt32BE(index, 4);\n        data.writeUInt32BE(token.length, 8);\n\n        let buffersArray = [data, token];\n        let result = await this.sign(Buffer.concat(buffersArray), GET_ADDRESS_AUTH_TOKEN_INS);\n\n        let splitRes = result.split(\"|\");\n        return {\n            address: splitRes[0],\n            signature: splitRes[1]\n        }\n    }\n\n    async getAppConfiguration(): Promise<{\n        version: string,\n    }> {\n        const response = await this.transport.send(0xed, 0x02, 0x00, 0x00);\n        return {\n            contractData: response[0],\n            accountIndex: response[1],\n            addressIndex: response[2],\n            version: `${response[3]}.${response[4]}.${response[5]}`\n        }\n    }\n\n    async sign(message: Buffer, type: number): Promise<string> {\n        if (!ACTIVE_SIGNERS.includes(type)) {\n            throw new Error(`invalid sign instruction called: ${type}`);\n        }\n\n        const apdus = [];\n        let offset = 0;\n\n        while (offset !== message.length) {\n            const isFirst = offset === 0;\n            const maxChunkSize = 150;\n\n            const hasMore = offset + maxChunkSize < message.length;\n            const chunkSize = hasMore ? maxChunkSize : message.length - offset;\n\n            const apdu = {\n                cla: 0xed,\n                ins: type,\n                p1: isFirst ? 0x00 : 0x80,\n                p2: 0x00,\n                data: Buffer.alloc(chunkSize),\n            };\n\n            message.copy(apdu.data, 0, offset, offset + chunkSize);\n\n            apdus.push(apdu);\n            offset += chunkSize;\n        }\n\n        let response = Buffer.alloc(0);\n        for (let apdu of apdus) {\n            response = await this.transport.send(\n                apdu.cla,\n                apdu.ins,\n                apdu.p1,\n                apdu.p2,\n                apdu.data\n            );\n        }\n\n        if (GET_ADDRESS_AUTH_TOKEN_INS === type) {\n            return this.handleAuthTokenResponse(response);\n        }\n\n        if (response.length !== 67 || response[0] !== 64) {\n            throw new Error(\"invalid signature received from ledger device\")\n        }\n\n        return response.slice(1, response.length - 2).toString(\"hex\");\n    }\n\n    handleAuthTokenResponse(response: Buffer) : Promise<string> {\n        if (response.length !== 129 && response[0] !== 126) {\n            throw new Error(\"invalid address and token signature received from ledger device\")\n        }\n\n        const address = response.slice(1, 63).toString(\"ascii\");\n        const signature = response.slice(63, response.length - 2).toString(\"hex\");\n        return address + \"|\" + signature;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}