{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { settings, ExtensionType, BaseTexture, utils, extensions } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { WorkerManager } from '../WorkerManager.mjs';\nimport { checkExtension } from './utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\nvar validImages = [\".jpg\", \".png\", \".jpeg\", \".avif\", \".webp\"];\nfunction loadImageBitmap(_x) {\n  return _loadImageBitmap.apply(this, arguments);\n}\nfunction _loadImageBitmap() {\n  _loadImageBitmap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {\n    var response, imageBlob, imageBitmap;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return settings.ADAPTER.fetch(url);\n          case 2:\n            response = _context2.sent;\n            if (response.ok) {\n              _context2.next = 5;\n              break;\n            }\n            throw new Error(\"[loadImageBitmap] Failed to fetch \".concat(url, \": \").concat(response.status, \" \").concat(response.statusText));\n          case 5:\n            _context2.next = 7;\n            return response.blob();\n          case 7:\n            imageBlob = _context2.sent;\n            _context2.next = 10;\n            return createImageBitmap(imageBlob);\n          case 10:\n            imageBitmap = _context2.sent;\n            return _context2.abrupt(\"return\", imageBitmap);\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadImageBitmap.apply(this, arguments);\n}\nvar loadTextures = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High\n  },\n  config: {\n    preferWorkers: true\n  },\n  test: function test(url) {\n    var isValidBase64Suffix = false;\n    for (var i = 0; i < validImages.length; i++) {\n      if (url.startsWith(\"data:image/\".concat(validImages[i].slice(1)))) {\n        isValidBase64Suffix = true;\n        break;\n      }\n    }\n    return isValidBase64Suffix || checkExtension(url, validImages);\n  },\n  load: function load(url, asset, loader) {\n    var _this = this;\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var src, base;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              src = null;\n              if (!globalThis.createImageBitmap) {\n                _context.next = 18;\n                break;\n              }\n              _context.t0 = _this.config.preferWorkers;\n              if (!_context.t0) {\n                _context.next = 7;\n                break;\n              }\n              _context.next = 6;\n              return WorkerManager.isImageBitmapSupported();\n            case 6:\n              _context.t0 = _context.sent;\n            case 7:\n              if (!_context.t0) {\n                _context.next = 13;\n                break;\n              }\n              _context.next = 10;\n              return WorkerManager.loadImageBitmap(url);\n            case 10:\n              src = _context.sent;\n              _context.next = 16;\n              break;\n            case 13:\n              _context.next = 15;\n              return loadImageBitmap(url);\n            case 15:\n              src = _context.sent;\n            case 16:\n              _context.next = 21;\n              break;\n            case 18:\n              _context.next = 20;\n              return new Promise(function (resolve) {\n                src = new Image();\n                src.crossOrigin = \"anonymous\";\n                src.src = url;\n                if (src.complete) {\n                  resolve(src);\n                } else {\n                  src.onload = function () {\n                    resolve(src);\n                  };\n                }\n              });\n            case 20:\n              src = _context.sent;\n            case 21:\n              base = new BaseTexture(src, _objectSpread({\n                resolution: utils.getResolutionOfUrl(url)\n              }, asset.data));\n              base.resource.src = url;\n              return _context.abrupt(\"return\", createTexture(base, loader, url));\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  unload: function unload(texture) {\n    texture.destroy(true);\n  }\n};\nextensions.add(loadTextures);\nexport { loadImageBitmap, loadTextures };","map":{"version":3,"sources":["../../../../src/loader/parsers/textures/loadTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { checkExtension } from './utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { Loader } from '../../Loader';\nimport type { LoadAsset } from '../../types';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImages = ['.jpg', '.png', '.jpeg', '.avif', '.webp'];\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n */\nexport const loadTextures = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n    },\n\n    test(url: string): boolean\n    {\n        let isValidBase64Suffix = false;\n\n        for (let i = 0; i < validImages.length; i++)\n        {\n            if (url.startsWith(`data:image/${validImages[i].slice(1)}`))\n            {\n                isValidBase64Suffix = true;\n                break;\n            }\n        }\n\n        return isValidBase64Suffix || checkExtension(url, validImages);\n    },\n\n    async load(url: string, asset: LoadAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve) =>\n            {\n                src = new Image();\n                src.crossOrigin = 'anonymous';\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                }\n            });\n        }\n\n        const base = new BaseTexture(src, {\n            resolution: utils.getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions>;\n\nextensions.add(loadTextures);\n"]},"metadata":{},"sourceType":"module"}