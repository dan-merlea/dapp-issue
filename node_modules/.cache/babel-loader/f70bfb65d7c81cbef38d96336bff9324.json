{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar BitmapFontData = require('../BitmapFontData.js');\nvar TextFormat = /*#__PURE__*/function () {\n  function TextFormat() {\n    _classCallCheck(this, TextFormat);\n  }\n  _createClass(TextFormat, null, [{\n    key: \"test\",\n    value: function test(data) {\n      return typeof data === \"string\" && data.startsWith(\"info face=\");\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(txt) {\n      var items = txt.match(/^[a-z]+\\s+.+$/gm);\n      var rawData = {\n        info: [],\n        common: [],\n        page: [],\n        char: [],\n        chars: [],\n        kerning: [],\n        kernings: [],\n        distanceField: []\n      };\n      for (var i in items) {\n        var name = items[i].match(/^[a-z]+/gm)[0];\n        var attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n        var itemData = {};\n        for (var i2 in attributeList) {\n          var split = attributeList[i2].split(\"=\");\n          var key = split[0];\n          var strValue = split[1].replace(/\"/gm, \"\");\n          var floatValue = parseFloat(strValue);\n          var value = isNaN(floatValue) ? strValue : floatValue;\n          itemData[key] = value;\n        }\n        rawData[name].push(itemData);\n      }\n      var font = new BitmapFontData.BitmapFontData();\n      rawData.info.forEach(function (info) {\n        return font.info.push({\n          face: info.face,\n          size: parseInt(info.size, 10)\n        });\n      });\n      rawData.common.forEach(function (common) {\n        return font.common.push({\n          lineHeight: parseInt(common.lineHeight, 10)\n        });\n      });\n      rawData.page.forEach(function (page) {\n        return font.page.push({\n          id: parseInt(page.id, 10),\n          file: page.file\n        });\n      });\n      rawData.char.forEach(function (char) {\n        return font.char.push({\n          id: parseInt(char.id, 10),\n          page: parseInt(char.page, 10),\n          x: parseInt(char.x, 10),\n          y: parseInt(char.y, 10),\n          width: parseInt(char.width, 10),\n          height: parseInt(char.height, 10),\n          xoffset: parseInt(char.xoffset, 10),\n          yoffset: parseInt(char.yoffset, 10),\n          xadvance: parseInt(char.xadvance, 10)\n        });\n      });\n      rawData.kerning.forEach(function (kerning) {\n        return font.kerning.push({\n          first: parseInt(kerning.first, 10),\n          second: parseInt(kerning.second, 10),\n          amount: parseInt(kerning.amount, 10)\n        });\n      });\n      rawData.distanceField.forEach(function (df) {\n        return font.distanceField.push({\n          distanceRange: parseInt(df.distanceRange, 10),\n          fieldType: df.fieldType\n        });\n      });\n      return font;\n    }\n  }]);\n  return TextFormat;\n}();\nexports.TextFormat = TextFormat;","map":{"version":3,"sources":["../../src/formats/TextFormat.ts"],"names":["BitmapFontData"],"mappings":"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","sourcesContent":["import { BitmapFontData } from '../BitmapFontData';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface IBitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string;\n        page: string;\n        x: string;\n        y: string;\n        width: string;\n        height: string;\n        xoffset: string;\n        yoffset: string;\n        xadvance: string;\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: string;\n        distanceRange: string;\n    }[]\n}\n\n/**\n * BitmapFont format that's Text-based.\n * @private\n */\nexport class TextFormat\n{\n    /**\n     * Check if resource refers to txt font data.\n     * @param data\n     * @returns - True if resource could be treated as font data, false otherwise.\n     */\n    static test(data: unknown): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    }\n\n    /**\n     * Convert text font data to a javascript object.\n     * @param txt - Raw string data to be converted\n     * @returns - Parsed font data\n     */\n    static parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: IBitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font = new BitmapFontData();\n\n        rawData.info.forEach((info) => font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }));\n\n        rawData.common.forEach((common) => font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }));\n\n        rawData.page.forEach((page) => font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }));\n\n        rawData.char.forEach((char) => font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }));\n\n        rawData.kerning.forEach((kerning) => font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }));\n\n        rawData.distanceField.forEach((df) => font.distanceField.push({\n            distanceRange: parseInt(df.distanceRange, 10),\n            fieldType: df.fieldType,\n        }));\n\n        return font;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}