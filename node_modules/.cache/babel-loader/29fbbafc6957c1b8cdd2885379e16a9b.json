{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DRAW_CALL_POOL, BATCH_POOL, FILL_COMMANDS } from './utils/index.mjs';\nimport { Point, BatchGeometry, WRAP_MODES, BaseTexture, BatchDrawCall, BatchTextureArray, DRAW_MODES, utils } from '@pixi/core';\nimport { GraphicsData } from './GraphicsData.mjs';\nimport { Bounds } from '@pixi/display';\nimport { BatchPart } from './utils/BatchPart.mjs';\nimport { buildPoly } from './utils/buildPoly.mjs';\nimport { buildLine } from './utils/buildLine.mjs';\nvar tmpPoint = new Point();\nvar _GraphicsGeometry = /*#__PURE__*/function (_BatchGeometry) {\n  _inherits(_GraphicsGeometry, _BatchGeometry);\n  var _super = _createSuper(_GraphicsGeometry);\n  function _GraphicsGeometry() {\n    var _this;\n    _classCallCheck(this, _GraphicsGeometry);\n    _this = _super.call(this);\n    _this.closePointEps = 1e-4;\n    _this.boundsPadding = 0;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    _this.batchable = false;\n    _this.points = [];\n    _this.colors = [];\n    _this.uvs = [];\n    _this.indices = [];\n    _this.textureIds = [];\n    _this.graphicsData = [];\n    _this.drawCalls = [];\n    _this.batchDirty = -1;\n    _this.batches = [];\n    _this.dirty = 0;\n    _this.cacheDirty = -1;\n    _this.clearDirty = 0;\n    _this.shapeIndex = 0;\n    _this._bounds = new Bounds();\n    _this.boundsDirty = -1;\n    return _this;\n  }\n  _createClass(_GraphicsGeometry, [{\n    key: \"bounds\",\n    get: function get() {\n      this.updateBatches();\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n      return this._bounds;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      this.boundsDirty = -1;\n      this.dirty++;\n      this.batchDirty++;\n      this.shapeIndex = 0;\n      this.points.length = 0;\n      this.colors.length = 0;\n      this.uvs.length = 0;\n      this.indices.length = 0;\n      this.textureIds.length = 0;\n      for (var i = 0; i < this.drawCalls.length; i++) {\n        this.drawCalls[i].texArray.clear();\n        DRAW_CALL_POOL.push(this.drawCalls[i]);\n      }\n      this.drawCalls.length = 0;\n      for (var _i = 0; _i < this.batches.length; _i++) {\n        var batchPart = this.batches[_i];\n        batchPart.reset();\n        BATCH_POOL.push(batchPart);\n      }\n      this.batches.length = 0;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.graphicsData.length > 0) {\n        this.invalidate();\n        this.clearDirty++;\n        this.graphicsData.length = 0;\n      }\n      return this;\n    }\n  }, {\n    key: \"drawShape\",\n    value: function drawShape(shape) {\n      var fillStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var lineStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var matrix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n      this.graphicsData.push(data);\n      this.dirty++;\n      return this;\n    }\n  }, {\n    key: \"drawHole\",\n    value: function drawHole(shape) {\n      var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (!this.graphicsData.length) {\n        return null;\n      }\n      var data = new GraphicsData(shape, null, null, matrix);\n      var lastShape = this.graphicsData[this.graphicsData.length - 1];\n      data.lineStyle = lastShape.lineStyle;\n      lastShape.holes.push(data);\n      this.dirty++;\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(_GraphicsGeometry.prototype), \"destroy\", this).call(this);\n      for (var i = 0; i < this.graphicsData.length; ++i) {\n        this.graphicsData[i].destroy();\n      }\n      this.points.length = 0;\n      this.points = null;\n      this.colors.length = 0;\n      this.colors = null;\n      this.uvs.length = 0;\n      this.uvs = null;\n      this.indices.length = 0;\n      this.indices = null;\n      this.indexBuffer.destroy();\n      this.indexBuffer = null;\n      this.graphicsData.length = 0;\n      this.graphicsData = null;\n      this.drawCalls.length = 0;\n      this.drawCalls = null;\n      this.batches.length = 0;\n      this.batches = null;\n      this._bounds = null;\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var graphicsData = this.graphicsData;\n      for (var i = 0; i < graphicsData.length; ++i) {\n        var data = graphicsData[i];\n        if (!data.fillStyle.visible) {\n          continue;\n        }\n        if (data.shape) {\n          if (data.matrix) {\n            data.matrix.applyInverse(point, tmpPoint);\n          } else {\n            tmpPoint.copyFrom(point);\n          }\n          if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n            var hitHole = false;\n            if (data.holes) {\n              for (var i2 = 0; i2 < data.holes.length; i2++) {\n                var hole = data.holes[i2];\n                if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                  hitHole = true;\n                  break;\n                }\n              }\n            }\n            if (!hitHole) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"updateBatches\",\n    value: function updateBatches() {\n      if (!this.graphicsData.length) {\n        this.batchable = true;\n        return;\n      }\n      if (!this.validateBatching()) {\n        return;\n      }\n      this.cacheDirty = this.dirty;\n      var uvs = this.uvs;\n      var graphicsData = this.graphicsData;\n      var batchPart = null;\n      var currentStyle = null;\n      if (this.batches.length > 0) {\n        batchPart = this.batches[this.batches.length - 1];\n        currentStyle = batchPart.style;\n      }\n      for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n        this.shapeIndex++;\n        var data = graphicsData[i];\n        var fillStyle = data.fillStyle;\n        var lineStyle = data.lineStyle;\n        var command = FILL_COMMANDS[data.type];\n        command.build(data);\n        if (data.matrix) {\n          this.transformPoints(data.points, data.matrix);\n        }\n        if (fillStyle.visible || lineStyle.visible) {\n          this.processHoles(data.holes);\n        }\n        for (var j = 0; j < 2; j++) {\n          var style = j === 0 ? fillStyle : lineStyle;\n          if (!style.visible) continue;\n          var nextTexture = style.texture.baseTexture;\n          var index2 = this.indices.length;\n          var attribIndex = this.points.length / 2;\n          nextTexture.wrapMode = WRAP_MODES.REPEAT;\n          if (j === 0) {\n            this.processFill(data);\n          } else {\n            this.processLine(data);\n          }\n          var size = this.points.length / 2 - attribIndex;\n          if (size === 0) continue;\n          if (batchPart && !this._compareStyles(currentStyle, style)) {\n            batchPart.end(index2, attribIndex);\n            batchPart = null;\n          }\n          if (!batchPart) {\n            batchPart = BATCH_POOL.pop() || new BatchPart();\n            batchPart.begin(style, index2, attribIndex);\n            this.batches.push(batchPart);\n            currentStyle = style;\n          }\n          this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n        }\n      }\n      var index = this.indices.length;\n      var attrib = this.points.length / 2;\n      if (batchPart) {\n        batchPart.end(index, attrib);\n      }\n      if (this.batches.length === 0) {\n        this.batchable = true;\n        return;\n      }\n      var need32 = attrib > 65535;\n      if (this.indicesUint16 && this.indices.length === this.indicesUint16.length && need32 === this.indicesUint16.BYTES_PER_ELEMENT > 2) {\n        this.indicesUint16.set(this.indices);\n      } else {\n        this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n      }\n      this.batchable = this.isBatchable();\n      if (this.batchable) {\n        this.packBatches();\n      } else {\n        this.buildDrawCalls();\n      }\n    }\n  }, {\n    key: \"_compareStyles\",\n    value: function _compareStyles(styleA, styleB) {\n      if (!styleA || !styleB) {\n        return false;\n      }\n      if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n        return false;\n      }\n      if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n        return false;\n      }\n      if (!!styleA.native !== !!styleB.native) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"validateBatching\",\n    value: function validateBatching() {\n      if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n        return false;\n      }\n      for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n        var data = this.graphicsData[i];\n        var fill = data.fillStyle;\n        var line = data.lineStyle;\n        if (fill && !fill.texture.baseTexture.valid) return false;\n        if (line && !line.texture.baseTexture.valid) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"packBatches\",\n    value: function packBatches() {\n      this.batchDirty++;\n      this.uvsFloat32 = new Float32Array(this.uvs);\n      var batches = this.batches;\n      for (var i = 0, l = batches.length; i < l; i++) {\n        var batch = batches[i];\n        for (var j = 0; j < batch.size; j++) {\n          var index = batch.start + j;\n          this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n        }\n      }\n    }\n  }, {\n    key: \"isBatchable\",\n    value: function isBatchable() {\n      if (this.points.length > 65535 * 2) {\n        return false;\n      }\n      var batches = this.batches;\n      for (var i = 0; i < batches.length; i++) {\n        if (batches[i].style.native) {\n          return false;\n        }\n      }\n      return this.points.length < _GraphicsGeometry.BATCHABLE_SIZE * 2;\n    }\n  }, {\n    key: \"buildDrawCalls\",\n    value: function buildDrawCalls() {\n      var TICK = ++BaseTexture._globalBatch;\n      for (var i = 0; i < this.drawCalls.length; i++) {\n        this.drawCalls[i].texArray.clear();\n        DRAW_CALL_POOL.push(this.drawCalls[i]);\n      }\n      this.drawCalls.length = 0;\n      var colors = this.colors;\n      var textureIds = this.textureIds;\n      var currentGroup = DRAW_CALL_POOL.pop();\n      if (!currentGroup) {\n        currentGroup = new BatchDrawCall();\n        currentGroup.texArray = new BatchTextureArray();\n      }\n      currentGroup.texArray.count = 0;\n      currentGroup.start = 0;\n      currentGroup.size = 0;\n      currentGroup.type = DRAW_MODES.TRIANGLES;\n      var textureCount = 0;\n      var currentTexture = null;\n      var textureId = 0;\n      var native = false;\n      var drawMode = DRAW_MODES.TRIANGLES;\n      var index = 0;\n      this.drawCalls.push(currentGroup);\n      for (var _i2 = 0; _i2 < this.batches.length; _i2++) {\n        var data = this.batches[_i2];\n        var MAX_TEXTURES = 8;\n        var style = data.style;\n        var nextTexture = style.texture.baseTexture;\n        if (native !== !!style.native) {\n          native = !!style.native;\n          drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n          currentTexture = null;\n          textureCount = MAX_TEXTURES;\n          TICK++;\n        }\n        if (currentTexture !== nextTexture) {\n          currentTexture = nextTexture;\n          if (nextTexture._batchEnabled !== TICK) {\n            if (textureCount === MAX_TEXTURES) {\n              TICK++;\n              textureCount = 0;\n              if (currentGroup.size > 0) {\n                currentGroup = DRAW_CALL_POOL.pop();\n                if (!currentGroup) {\n                  currentGroup = new BatchDrawCall();\n                  currentGroup.texArray = new BatchTextureArray();\n                }\n                this.drawCalls.push(currentGroup);\n              }\n              currentGroup.start = index;\n              currentGroup.size = 0;\n              currentGroup.texArray.count = 0;\n              currentGroup.type = drawMode;\n            }\n            nextTexture.touched = 1;\n            nextTexture._batchEnabled = TICK;\n            nextTexture._batchLocation = textureCount;\n            nextTexture.wrapMode = WRAP_MODES.REPEAT;\n            currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n            textureCount++;\n          }\n        }\n        currentGroup.size += data.size;\n        index += data.size;\n        textureId = nextTexture._batchLocation;\n        this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n        this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n      }\n      BaseTexture._globalBatch = TICK;\n      this.packAttributes();\n    }\n  }, {\n    key: \"packAttributes\",\n    value: function packAttributes() {\n      var verts = this.points;\n      var uvs = this.uvs;\n      var colors = this.colors;\n      var textureIds = this.textureIds;\n      var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n      var f32 = new Float32Array(glPoints);\n      var u32 = new Uint32Array(glPoints);\n      var p = 0;\n      for (var i = 0; i < verts.length / 2; i++) {\n        f32[p++] = verts[i * 2];\n        f32[p++] = verts[i * 2 + 1];\n        f32[p++] = uvs[i * 2];\n        f32[p++] = uvs[i * 2 + 1];\n        u32[p++] = colors[i];\n        f32[p++] = textureIds[i];\n      }\n      this._buffer.update(glPoints);\n      this._indexBuffer.update(this.indicesUint16);\n    }\n  }, {\n    key: \"processFill\",\n    value: function processFill(data) {\n      if (data.holes.length) {\n        buildPoly.triangulate(data, this);\n      } else {\n        var command = FILL_COMMANDS[data.type];\n        command.triangulate(data, this);\n      }\n    }\n  }, {\n    key: \"processLine\",\n    value: function processLine(data) {\n      buildLine(data, this);\n      for (var i = 0; i < data.holes.length; i++) {\n        buildLine(data.holes[i], this);\n      }\n    }\n  }, {\n    key: \"processHoles\",\n    value: function processHoles(holes) {\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        var command = FILL_COMMANDS[hole.type];\n        command.build(hole);\n        if (hole.matrix) {\n          this.transformPoints(hole.points, hole.matrix);\n        }\n      }\n    }\n  }, {\n    key: \"calculateBounds\",\n    value: function calculateBounds() {\n      var bounds = this._bounds;\n      bounds.clear();\n      bounds.addVertexData(this.points, 0, this.points.length);\n      bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n  }, {\n    key: \"transformPoints\",\n    value: function transformPoints(points, matrix) {\n      for (var i = 0; i < points.length / 2; i++) {\n        var x = points[i * 2];\n        var y = points[i * 2 + 1];\n        points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n        points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n      }\n    }\n  }, {\n    key: \"addColors\",\n    value: function addColors(colors, color, alpha, size) {\n      var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var rgb = (color >> 16) + (color & 65280) + ((color & 255) << 16);\n      var rgba = utils.premultiplyTint(rgb, alpha);\n      colors.length = Math.max(colors.length, offset + size);\n      for (var i = 0; i < size; i++) {\n        colors[offset + i] = rgba;\n      }\n    }\n  }, {\n    key: \"addTextureIds\",\n    value: function addTextureIds(textureIds, id, size) {\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      textureIds.length = Math.max(textureIds.length, offset + size);\n      for (var i = 0; i < size; i++) {\n        textureIds[offset + i] = id;\n      }\n    }\n  }, {\n    key: \"addUvs\",\n    value: function addUvs(verts, uvs, texture, start, size) {\n      var matrix = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      var index = 0;\n      var uvsStart = uvs.length;\n      var frame = texture.frame;\n      while (index < size) {\n        var x = verts[(start + index) * 2];\n        var y = verts[(start + index) * 2 + 1];\n        if (matrix) {\n          var nx = matrix.a * x + matrix.c * y + matrix.tx;\n          y = matrix.b * x + matrix.d * y + matrix.ty;\n          x = nx;\n        }\n        index++;\n        uvs.push(x / frame.width, y / frame.height);\n      }\n      var baseTexture = texture.baseTexture;\n      if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n        this.adjustUvs(uvs, texture, uvsStart, size);\n      }\n    }\n  }, {\n    key: \"adjustUvs\",\n    value: function adjustUvs(uvs, texture, start, size) {\n      var baseTexture = texture.baseTexture;\n      var eps = 1e-6;\n      var finish = start + size * 2;\n      var frame = texture.frame;\n      var scaleX = frame.width / baseTexture.width;\n      var scaleY = frame.height / baseTexture.height;\n      var offsetX = frame.x / frame.width;\n      var offsetY = frame.y / frame.height;\n      var minX = Math.floor(uvs[start] + eps);\n      var minY = Math.floor(uvs[start + 1] + eps);\n      for (var i = start + 2; i < finish; i += 2) {\n        minX = Math.min(minX, Math.floor(uvs[i] + eps));\n        minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n      }\n      offsetX -= minX;\n      offsetY -= minY;\n      for (var _i3 = start; _i3 < finish; _i3 += 2) {\n        uvs[_i3] = (uvs[_i3] + offsetX) * scaleX;\n        uvs[_i3 + 1] = (uvs[_i3 + 1] + offsetY) * scaleY;\n      }\n    }\n  }]);\n  return _GraphicsGeometry;\n}(BatchGeometry);\nvar GraphicsGeometry = _GraphicsGeometry;\nGraphicsGeometry.BATCHABLE_SIZE = 100;\nexport { GraphicsGeometry };","map":{"version":3,"sources":["../src/GraphicsGeometry.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL,\n} from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture,\n    DRAW_MODES,\n    WRAP_MODES,\n    Point,\n    utils,\n} from '@pixi/core';\n\nimport { GraphicsData } from './GraphicsData';\nimport { Bounds } from '@pixi/display';\n\nimport type { Texture, Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData, Matrix } from '@pixi/core';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /**\n     * The maximum number of points to consider an object \"batchable\",\n     * able to be batched by the renderer's batch system.\n\\\n     */\n    public static BATCHABLE_SIZE = 100;\n\n    /** Minimal distance between points that are considered different. Affects line tesselation. */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        this.updateBatches();\n\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /** Call if you changed graphicsData manually. Empties all batch buffers. */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     * @returns - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @returns - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     */\n    updateBatches(): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        const need32 = attrib > 0xffff;\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length\n            && need32 === (this.indicesUint16.BYTES_PER_ELEMENT > 2))\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /**\n     * Process fill part of Graphics.\n     * @param data\n     */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /**\n     * Process line part of Graphics.\n     * @param data\n     */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /**\n     * Process the holes data.\n     * @param holes\n     */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n        bounds.addVertexData((this.points as any), 0, this.points.length);\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba = utils.premultiplyTint(rgb, alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = rgba;\n        }\n    }\n\n    /**\n     * Add texture id that the shader/fragment wants to use.\n     * @param textureIds\n     * @param id\n     * @param size\n     * @param offset\n     */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}