{"ast":null,"code":"import { GLProgram } from '../GLProgram.mjs';\nimport { compileShader } from './compileShader.mjs';\nimport { defaultValue } from './defaultValue.mjs';\nimport { getAttributeData } from './getAttributeData.mjs';\nimport { getUniformData } from './getUniformData.mjs';\nimport { logProgramError } from './logProgramError.mjs';\nfunction generateProgram(gl, program) {\n  var _program$extra;\n  var glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);\n  var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);\n  var webGLProgram = gl.createProgram();\n  gl.attachShader(webGLProgram, glVertShader);\n  gl.attachShader(webGLProgram, glFragShader);\n  var transformFeedbackVaryings = (_program$extra = program.extra) === null || _program$extra === void 0 ? void 0 : _program$extra.transformFeedbackVaryings;\n  if (transformFeedbackVaryings) {\n    if (typeof gl.transformFeedbackVaryings !== \"function\") {} else {\n      gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, transformFeedbackVaryings.bufferMode === \"separate\" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS);\n    }\n  }\n  gl.linkProgram(webGLProgram);\n  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {\n    logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n  }\n  program.attributeData = getAttributeData(webGLProgram, gl);\n  program.uniformData = getUniformData(webGLProgram, gl);\n  if (!/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(program.vertexSrc)) {\n    var keys = Object.keys(program.attributeData);\n    keys.sort(function (a, b) {\n      return a > b ? 1 : -1;\n    });\n    for (var i = 0; i < keys.length; i++) {\n      program.attributeData[keys[i]].location = i;\n      gl.bindAttribLocation(webGLProgram, i, keys[i]);\n    }\n    gl.linkProgram(webGLProgram);\n  }\n  gl.deleteShader(glVertShader);\n  gl.deleteShader(glFragShader);\n  var uniformData = {};\n  for (var _i in program.uniformData) {\n    var data = program.uniformData[_i];\n    uniformData[_i] = {\n      location: gl.getUniformLocation(webGLProgram, _i),\n      value: defaultValue(data.type, data.size)\n    };\n  }\n  var glProgram = new GLProgram(webGLProgram, uniformData);\n  return glProgram;\n}\nexport { generateProgram };","map":{"version":3,"sources":["../../../src/shader/utils/generateProgram.ts"],"names":[],"mappings":";;;;;;AAeO,SAAA,eAAA,CAAyB,EAAA,EAAuB,OACvD,EAAA;EAAA;EACI,IAAM,YAAA,GAAe,aAAc,CAAA,EAAA,EAAI,EAAG,CAAA,aAAA,EAAe,OAAA,CAAQ,SAAS,CAAA;EAC1E,IAAM,YAAA,GAAe,aAAc,CAAA,EAAA,EAAI,EAAG,CAAA,eAAA,EAAiB,OAAA,CAAQ,WAAW,CAAA;EAExE,IAAA,YAAA,GAAe,EAAA,CAAG,aAAc,EAAA;EAEnC,EAAA,CAAA,YAAA,CAAa,YAAA,EAAc,YAAY,CAAA;EACvC,EAAA,CAAA,YAAA,CAAa,YAAA,EAAc,YAAY,CAAA;EAEpC,IAAA,yBAAA,qBAA4B,OAAA,CAAQ,KAAO,mDAAf,eAAe,yBAAA;EAEjD,IAAI,yBACJ,EAAA;IACQ,IAAA,OAAO,EAAG,CAAA,yBAAA,KAA8B,UAC5C,EAAA,CAAA,CAMA,MAAA;MACO,EAAA,CAAA,yBAAA,CACC,YACA,EAAA,yBAAA,CAA0B,KAC1B,EAAA,yBAAA,CAA0B,UAAA,KAAe,UACnC,GAAA,EAAA,CAAG,gBACH,GAAA,EAAA,CAAG,mBACb,CAAA;IAAA;EACJ;EAGJ,EAAA,CAAG,WAAA,CAAY,YAAY,CAAA;EAE3B,IAAI,CAAC,EAAG,CAAA,mBAAA,CAAoB,YAAc,EAAA,EAAA,CAAG,WAAW,CACxD,EAAA;IACoB,eAAA,CAAA,EAAA,EAAI,YAAc,EAAA,YAAA,EAAc,YAAY,CAAA;EAAA;EAGxD,OAAA,CAAA,aAAA,GAAgB,gBAAiB,CAAA,YAAA,EAAc,EAAE,CAAA;EACjD,OAAA,CAAA,WAAA,GAAc,cAAe,CAAA,YAAA,EAAc,EAAE,CAAA;EAKrD,IAAI,CAAE,gDAAA,CAAkD,IAAK,CAAA,OAAA,CAAQ,SAAS,CAC9E,EAAA;IACI,IAAM,IAAO,GAAA,MAAA,CAAO,IAAK,CAAA,OAAA,CAAQ,aAAa,CAAA;IAE9C,IAAA,CAAK,IAAA,CAAK,UAAC,CAAA,EAAG,CAAA;MAAA,OAAO,CAAI,GAAA,CAAA,GAAK,CAAA,GAAI,CAAE,CAAA;IAAA,EAAA;IAEpC,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,MAAA,EAAQ,CACjC,EAAA,EAAA;MACY,OAAA,CAAA,aAAA,CAAc,IAAK,CAAA,CAAA,CAAA,CAAA,CAAI,QAAW,GAAA,CAAA;MAE1C,EAAA,CAAG,kBAAmB,CAAA,YAAA,EAAc,CAAG,EAAA,IAAA,CAAK,CAAE,CAAA,CAAA;IAAA;IAGlD,EAAA,CAAG,WAAA,CAAY,YAAY,CAAA;EAAA;EAG/B,EAAA,CAAG,YAAA,CAAa,YAAY,CAAA;EAC5B,EAAA,CAAG,YAAA,CAAa,YAAY,CAAA;EAE5B,IAAM,WAAA,GAA+C,CAAA,CAAC;EAE3C,KAAA,IAAA,EAAA,IAAK,OAAA,CAAQ,WACxB,EAAA;IACU,IAAA,IAAA,GAAO,OAAA,CAAQ,WAAY,CAAA,EAAA,CAAA;IAEjC,WAAA,CAAY,EAAK,CAAA,GAAA;MACb,QAAU,EAAA,EAAA,CAAG,kBAAmB,CAAA,YAAA,EAAc,EAAC,CAAA;MAC/C,KAAO,EAAA,YAAA,CAAa,IAAK,CAAA,IAAA,EAAM,IAAA,CAAK,IAAI;IAAA,CAC5C;EAAA;EAGJ,IAAM,SAAY,GAAA,IAAI,SAAU,CAAA,YAAA,EAAc,WAAW,CAAA;EAElD,OAAA,SAAA;AACX","sourcesContent":["import type { Program } from '../Program';\nimport type { IGLUniformData } from '../GLProgram';\nimport { GLProgram } from '../GLProgram';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { getAttributeData } from './getAttributeData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\nimport type { IRenderingContext } from '../../IRenderer';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n */\nexport function generateProgram(gl: IRenderingContext, program: Program): GLProgram\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            console.warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    program.attributeData = getAttributeData(webGLProgram, gl);\n    program.uniformData = getUniformData(webGLProgram, gl);\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    if (!(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertexSrc))\n    {\n        const keys = Object.keys(program.attributeData);\n\n        keys.sort((a, b) => (a > b) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            program.attributeData[keys[i]].location = i;\n\n            gl.bindAttribLocation(webGLProgram, i, keys[i]);\n        }\n\n        gl.linkProgram(webGLProgram);\n    }\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program.uniformData)\n    {\n        const data = program.uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GLProgram(webGLProgram, uniformData);\n\n    return glProgram;\n}\n"]},"metadata":{},"sourceType":"module"}