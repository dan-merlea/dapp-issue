{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Fields = exports.Field = exports.FieldDefinition = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar typeExpressionParser_1 = require(\"./typeExpressionParser\");\nvar FieldDefinition = /*#__PURE__*/function () {\n  function FieldDefinition(name, description, type) {\n    _classCallCheck(this, FieldDefinition);\n    this.name = name;\n    this.description = description;\n    this.type = type;\n  }\n  _createClass(FieldDefinition, null, [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n      return new FieldDefinition(json.name, json.description, parsedType);\n    }\n  }]);\n  return FieldDefinition;\n}();\nexports.FieldDefinition = FieldDefinition;\nvar Field = /*#__PURE__*/function () {\n  function Field(value) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    _classCallCheck(this, Field);\n    this.value = value;\n    this.name = name;\n  }\n  _createClass(Field, [{\n    key: \"checkTyping\",\n    value: function checkTyping(expectedDefinition) {\n      var actualType = this.value.getType();\n      if (!actualType.equals(expectedDefinition.type)) {\n        throw new errors.ErrTypingSystem(\"check type of field \\\"\".concat(expectedDefinition.name, \"; expected: \").concat(expectedDefinition.type, \", actual: \").concat(actualType, \"\\\"\"));\n      }\n      if (this.name != expectedDefinition.name) {\n        throw new errors.ErrTypingSystem(\"check name of field \\\"\".concat(expectedDefinition.name, \"\\\"\"));\n      }\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.name == other.name && this.value.equals(other.value);\n    }\n  }]);\n  return Field;\n}();\nexports.Field = Field;\nvar Fields = /*#__PURE__*/function () {\n  function Fields() {\n    _classCallCheck(this, Fields);\n  }\n  _createClass(Fields, null, [{\n    key: \"checkTyping\",\n    value: function checkTyping(fields, definitions) {\n      if (fields.length != definitions.length) {\n        throw new errors.ErrTypingSystem(\"fields length vs. field definitions length\");\n      }\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        var definition = definitions[i];\n        field.checkTyping(definition);\n      }\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(actual, expected) {\n      if (actual.length != expected.length) {\n        return false;\n      }\n      for (var i = 0; i < actual.length; i++) {\n        var selfField = actual[i];\n        var otherField = expected[i];\n        if (!selfField.equals(otherField)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"getNamesOfTypeDependencies\",\n    value: function getNamesOfTypeDependencies(definitions) {\n      var dependencies = [];\n      var _iterator = _createForOfIteratorHelper(definitions),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var definition = _step.value;\n          dependencies.push(definition.type.getName());\n          dependencies.push.apply(dependencies, _toConsumableArray(definition.type.getNamesOfDependencies()));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return _toConsumableArray(new Set(dependencies));\n    }\n  }]);\n  return Fields;\n}();\nexports.Fields = Fields;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/fields.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Fields = exports.Field = exports.FieldDefinition = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst typeExpressionParser_1 = require(\"./typeExpressionParser\");\nclass FieldDefinition {\n    constructor(name, description, type) {\n        this.name = name;\n        this.description = description;\n        this.type = type;\n    }\n    static fromJSON(json) {\n        let parsedType = new typeExpressionParser_1.TypeExpressionParser().parse(json.type);\n        return new FieldDefinition(json.name, json.description, parsedType);\n    }\n}\nexports.FieldDefinition = FieldDefinition;\nclass Field {\n    constructor(value, name = \"\") {\n        this.value = value;\n        this.name = name;\n    }\n    checkTyping(expectedDefinition) {\n        const actualType = this.value.getType();\n        if (!actualType.equals(expectedDefinition.type)) {\n            throw new errors.ErrTypingSystem(`check type of field \"${expectedDefinition.name}; expected: ${expectedDefinition.type}, actual: ${actualType}\"`);\n        }\n        if (this.name != expectedDefinition.name) {\n            throw new errors.ErrTypingSystem(`check name of field \"${expectedDefinition.name}\"`);\n        }\n    }\n    equals(other) {\n        return this.name == other.name && this.value.equals(other.value);\n    }\n}\nexports.Field = Field;\nclass Fields {\n    static checkTyping(fields, definitions) {\n        if (fields.length != definitions.length) {\n            throw new errors.ErrTypingSystem(\"fields length vs. field definitions length\");\n        }\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            let definition = definitions[i];\n            field.checkTyping(definition);\n        }\n    }\n    static equals(actual, expected) {\n        if (actual.length != expected.length) {\n            return false;\n        }\n        for (let i = 0; i < actual.length; i++) {\n            let selfField = actual[i];\n            let otherField = expected[i];\n            if (!selfField.equals(otherField)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static getNamesOfTypeDependencies(definitions) {\n        const dependencies = [];\n        for (const definition of definitions) {\n            dependencies.push(definition.type.getName());\n            dependencies.push(...definition.type.getNamesOfDependencies());\n        }\n        return [...new Set(dependencies)];\n    }\n}\nexports.Fields = Fields;\n//# sourceMappingURL=fields.js.map"]},"metadata":{},"sourceType":"script"}