{"ast":null,"code":"/*!\n * @pixi/display - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { settings } from '@pixi/settings';\nimport { Rectangle, RAD_TO_DEG, DEG_TO_RAD, Transform } from '@pixi/math';\nimport { EventEmitter, removeItems } from '@pixi/utils';\nimport { MASK_TYPES } from '@pixi/constants';\n\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.SORTABLE_CHILDREN = false;\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n * @memberof PIXI\n */\nvar Bounds = /** @class */function () {\n  function Bounds() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.rect = null;\n    this.updateID = -1;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  Bounds.prototype.isEmpty = function () {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  };\n  /** Clears the bounds and resets. */\n  Bounds.prototype.clear = function () {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n  };\n  /**\n   * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n   * It is not guaranteed that it will return tempRect\n   * @param rect - Temporary object will be used if AABB is not empty\n   * @returns - A rectangle of the bounds\n   */\n  Bounds.prototype.getRectangle = function (rect) {\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      return Rectangle.EMPTY;\n    }\n    rect = rect || new Rectangle(0, 0, 1, 1);\n    rect.x = this.minX;\n    rect.y = this.minY;\n    rect.width = this.maxX - this.minX;\n    rect.height = this.maxY - this.minY;\n    return rect;\n  };\n  /**\n   * This function should be inlined when its possible.\n   * @param point - The point to add.\n   */\n  Bounds.prototype.addPoint = function (point) {\n    this.minX = Math.min(this.minX, point.x);\n    this.maxX = Math.max(this.maxX, point.x);\n    this.minY = Math.min(this.minY, point.y);\n    this.maxY = Math.max(this.maxY, point.y);\n  };\n  /**\n   * Adds a point, after transformed. This should be inlined when its possible.\n   * @param matrix\n   * @param point\n   */\n  Bounds.prototype.addPointMatrix = function (matrix, point) {\n    var a = matrix.a,\n      b = matrix.b,\n      c = matrix.c,\n      d = matrix.d,\n      tx = matrix.tx,\n      ty = matrix.ty;\n    var x = a * point.x + c * point.y + tx;\n    var y = b * point.x + d * point.y + ty;\n    this.minX = Math.min(this.minX, x);\n    this.maxX = Math.max(this.maxX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxY = Math.max(this.maxY, y);\n  };\n  /**\n   * Adds a quad, not transformed\n   * @param vertices - The verts to add.\n   */\n  Bounds.prototype.addQuad = function (vertices) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    var x = vertices[0];\n    var y = vertices[1];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[2];\n    y = vertices[3];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[4];\n    y = vertices[5];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = vertices[6];\n    y = vertices[7];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Adds sprite frame, transformed.\n   * @param transform - transform to apply\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  Bounds.prototype.addFrame = function (transform, x0, y0, x1, y1) {\n    this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n  };\n  /**\n   * Adds sprite frame, multiplied by matrix\n   * @param matrix - matrix to apply\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  Bounds.prototype.addFrameMatrix = function (matrix, x0, y0, x1, y1) {\n    var a = matrix.a;\n    var b = matrix.b;\n    var c = matrix.c;\n    var d = matrix.d;\n    var tx = matrix.tx;\n    var ty = matrix.ty;\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    var x = a * x0 + c * y0 + tx;\n    var y = b * x0 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   */\n  Bounds.prototype.addVertexData = function (vertexData, beginOffset, endOffset) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    for (var i = beginOffset; i < endOffset; i += 2) {\n      var x = vertexData[i];\n      var y = vertexData[i + 1];\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Add an array of mesh vertices\n   * @param transform - mesh transform\n   * @param vertices - mesh coordinates in array\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   */\n  Bounds.prototype.addVertices = function (transform, vertices, beginOffset, endOffset) {\n    this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n  };\n  /**\n   * Add an array of mesh vertices.\n   * @param matrix - mesh matrix\n   * @param vertices - mesh coordinates in array\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param padX - x padding\n   * @param padY - y padding\n   */\n  Bounds.prototype.addVerticesMatrix = function (matrix, vertices, beginOffset, endOffset, padX, padY) {\n    if (padX === void 0) {\n      padX = 0;\n    }\n    if (padY === void 0) {\n      padY = padX;\n    }\n    var a = matrix.a;\n    var b = matrix.b;\n    var c = matrix.c;\n    var d = matrix.d;\n    var tx = matrix.tx;\n    var ty = matrix.ty;\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    for (var i = beginOffset; i < endOffset; i += 2) {\n      var rawX = vertices[i];\n      var rawY = vertices[i + 1];\n      var x = a * rawX + c * rawY + tx;\n      var y = d * rawY + b * rawX + ty;\n      minX = Math.min(minX, x - padX);\n      maxX = Math.max(maxX, x + padX);\n      minY = Math.min(minY, y - padY);\n      maxY = Math.max(maxY, y + padY);\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  };\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   */\n  Bounds.prototype.addBounds = function (bounds) {\n    var minX = this.minX;\n    var minY = this.minY;\n    var maxX = this.maxX;\n    var maxY = this.maxY;\n    this.minX = bounds.minX < minX ? bounds.minX : minX;\n    this.minY = bounds.minY < minY ? bounds.minY : minY;\n    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n  };\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param bounds - The Bounds to be added.\n   * @param mask - TODO\n   */\n  Bounds.prototype.addBoundsMask = function (bounds, mask) {\n    var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n    var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n    var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n    var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      var minX = this.minX;\n      var minY = this.minY;\n      var maxX = this.maxX;\n      var maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  };\n  /**\n   * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n   * @param bounds - other bounds\n   * @param matrix - multiplicator\n   */\n  Bounds.prototype.addBoundsMatrix = function (bounds, matrix) {\n    this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n  };\n  /**\n   * Adds other Bounds, masked with Rectangle.\n   * @param bounds - TODO\n   * @param area - TODO\n   */\n  Bounds.prototype.addBoundsArea = function (bounds, area) {\n    var _minX = bounds.minX > area.x ? bounds.minX : area.x;\n    var _minY = bounds.minY > area.y ? bounds.minY : area.y;\n    var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;\n    var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;\n    if (_minX <= _maxX && _minY <= _maxY) {\n      var minX = this.minX;\n      var minY = this.minY;\n      var maxX = this.maxX;\n      var maxY = this.maxY;\n      this.minX = _minX < minX ? _minX : minX;\n      this.minY = _minY < minY ? _minY : minY;\n      this.maxX = _maxX > maxX ? _maxX : maxX;\n      this.maxY = _maxY > maxY ? _maxY : maxY;\n    }\n  };\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  Bounds.prototype.pad = function (paddingX, paddingY) {\n    if (paddingX === void 0) {\n      paddingX = 0;\n    }\n    if (paddingY === void 0) {\n      paddingY = paddingX;\n    }\n    if (!this.isEmpty()) {\n      this.minX -= paddingX;\n      this.maxX += paddingX;\n      this.minY -= paddingY;\n      this.maxY += paddingY;\n    }\n  };\n  /**\n   * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param padX - padding X\n   * @param padY - padding Y\n   */\n  Bounds.prototype.addFramePad = function (x0, y0, x1, y1, padX, padY) {\n    x0 -= padX;\n    y0 -= padY;\n    x1 += padX;\n    y1 += padY;\n    this.minX = this.minX < x0 ? this.minX : x0;\n    this.maxX = this.maxX > x1 ? this.maxX : x1;\n    this.minY = this.minY < y0 ? this.minY : y0;\n    this.maxY = this.maxY > y1 ? this.maxY : y1;\n  };\n  return Bounds;\n}();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds(): void\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * It is recommended that applications use the `renderable` property for culling. See\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n * @memberof PIXI\n */\nvar DisplayObject = /** @class */function (_super) {\n  __extends(DisplayObject, _super);\n  function DisplayObject() {\n    var _this = _super.call(this) || this;\n    _this.tempDisplayObjectParent = null;\n    // TODO: need to create Transform from factory\n    _this.transform = new Transform();\n    _this.alpha = 1;\n    _this.visible = true;\n    _this.renderable = true;\n    _this.cullable = false;\n    _this.cullArea = null;\n    _this.parent = null;\n    _this.worldAlpha = 1;\n    _this._lastSortedIndex = 0;\n    _this._zIndex = 0;\n    _this.filterArea = null;\n    _this.filters = null;\n    _this._enabledFilters = null;\n    _this._bounds = new Bounds();\n    _this._localBounds = null;\n    _this._boundsID = 0;\n    _this._boundsRect = null;\n    _this._localBoundsRect = null;\n    _this._mask = null;\n    _this._maskRefCount = 0;\n    _this._destroyed = false;\n    _this.isSprite = false;\n    _this.isMask = false;\n    return _this;\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to DisplayObject.\n   * @param source - The source of properties and methods to mix in.\n   */\n  DisplayObject.mixin = function (source) {\n    // in ES8/ES2017, this would be really easy:\n    // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n    // get all the enumerable property keys\n    var keys = Object.keys(source);\n    // loop through properties\n    for (var i = 0; i < keys.length; ++i) {\n      var propertyName = keys[i];\n      // Set the property using the property descriptor - this works for accessors and normal value properties\n      Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n    }\n  };\n  Object.defineProperty(DisplayObject.prototype, \"destroyed\", {\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     * @instance\n     * @event added\n     * @param {PIXI.Container} container - The container added to.\n     */\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     * @instance\n     * @event removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n    /**\n     * Fired when this DisplayObject is destroyed. This event is emitted once\n     * destroy is finished.\n     * @instance\n     * @event destroyed\n     */\n    /** Readonly flag for destroyed display objects. */\n    get: function get() {\n      return this._destroyed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\n  DisplayObject.prototype._recursivePostUpdateTransform = function () {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  };\n  /** Updates the object transform for rendering. TODO - Optimization pass! */\n  DisplayObject.prototype.updateTransform = function () {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    // multiply the alphas..\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n  };\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n   *\n   * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n   * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n   * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n   * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n   * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n   * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n   * its height increases.\n   *\n   * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n   * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n   *\n   * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n   * calculation if needed.\n   *\n   * ```js\n   * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n   * ```\n   *\n   * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n   * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n   * details.\n   *\n   * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n   * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n   * cases.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param rect - Optional rectangle to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   */\n  DisplayObject.prototype.getBounds = function (skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n        this.updateTransform();\n      }\n    }\n    if (this._bounds.updateID !== this._boundsID) {\n      this.calculateBounds();\n      this._bounds.updateID = this._boundsID;\n    }\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new Rectangle();\n      }\n      rect = this._boundsRect;\n    }\n    return this._bounds.getRectangle(rect);\n  };\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   * @param rect - Optional rectangle to store the result of the bounds calculation.\n   * @returns - The rectangular bounding area.\n   */\n  DisplayObject.prototype.getLocalBounds = function (rect) {\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new Rectangle();\n      }\n      rect = this._localBoundsRect;\n    }\n    if (!this._localBounds) {\n      this._localBounds = new Bounds();\n    }\n    var transformRef = this.transform;\n    var parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n    var worldBounds = this._bounds;\n    var worldBoundsID = this._boundsID;\n    this._bounds = this._localBounds;\n    var bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    this._bounds = worldBounds;\n    this._bounds.updateID += this._boundsID - worldBoundsID; // reflect side-effects\n    return bounds;\n  };\n  /**\n   * Calculates the global position of the display object.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   */\n  DisplayObject.prototype.toGlobal = function (position, point, skipUpdate) {\n    if (skipUpdate === void 0) {\n      skipUpdate = false;\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    // don't need to update the lot\n    return this.worldTransform.apply(position, point);\n  };\n  /**\n   * Calculates the local position of the display object relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The DisplayObject to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   */\n  DisplayObject.prototype.toLocal = function (position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    // simply apply the matrix..\n    return this.worldTransform.applyInverse(position, point);\n  };\n  /**\n   * Set the parent Container of this DisplayObject.\n   * @param container - The Container to add this DisplayObject to.\n   * @returns - The Container that this DisplayObject was added to.\n   */\n  DisplayObject.prototype.setParent = function (container) {\n    if (!container || !container.addChild) {\n      throw new Error('setParent: Argument must be a Container');\n    }\n    container.addChild(this);\n    return container;\n  };\n  /**\n   * Convenience function to set the position, scale, skew and pivot at once.\n   * @param x - The X position\n   * @param y - The Y position\n   * @param scaleX - The X scale value\n   * @param scaleY - The Y scale value\n   * @param rotation - The rotation\n   * @param skewX - The X skew value\n   * @param skewY - The Y skew value\n   * @param pivotX - The X pivot value\n   * @param pivotY - The Y pivot value\n   * @returns - The DisplayObject instance\n   */\n  DisplayObject.prototype.setTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {\n    if (x === void 0) {\n      x = 0;\n    }\n    if (y === void 0) {\n      y = 0;\n    }\n    if (scaleX === void 0) {\n      scaleX = 1;\n    }\n    if (scaleY === void 0) {\n      scaleY = 1;\n    }\n    if (rotation === void 0) {\n      rotation = 0;\n    }\n    if (skewX === void 0) {\n      skewX = 0;\n    }\n    if (skewY === void 0) {\n      skewY = 0;\n    }\n    if (pivotX === void 0) {\n      pivotX = 0;\n    }\n    if (pivotY === void 0) {\n      pivotY = 0;\n    }\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  };\n  /**\n   * Base destroy method for generic display objects. This will automatically\n   * remove the display object from its parent Container as well as remove\n   * all current event listeners and internal references. Do not use a DisplayObject\n   * after calling `destroy()`.\n   * @param _options\n   */\n  DisplayObject.prototype.destroy = function (_options) {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n    this._destroyed = true;\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this.mask = null;\n    this.cullArea = null;\n    this.filters = null;\n    this.filterArea = null;\n    this.hitArea = null;\n    this.interactive = false;\n    this.interactiveChildren = false;\n    this.emit('destroyed');\n    this.removeAllListeners();\n  };\n  Object.defineProperty(DisplayObject.prototype, \"_tempDisplayObjectParent\", {\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get: function get() {\n      if (this.tempDisplayObjectParent === null) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        this.tempDisplayObjectParent = new TemporaryDisplayObject();\n      }\n      return this.tempDisplayObjectParent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\n   *\n   * ```\n   * const cacheParent = elem.enableTempParent();\n   * elem.updateTransform();\n   * elem.disableTempParent(cacheParent);\n   * ```\n   * @returns - current parent\n   */\n  DisplayObject.prototype.enableTempParent = function () {\n    var myParent = this.parent;\n    this.parent = this._tempDisplayObjectParent;\n    return myParent;\n  };\n  /**\n   * Pair method for `enableTempParent`\n   * @param cacheParent - Actual parent of element\n   */\n  DisplayObject.prototype.disableTempParent = function (cacheParent) {\n    this.parent = cacheParent;\n  };\n  Object.defineProperty(DisplayObject.prototype, \"x\", {\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) {\n      this.transform.position.x = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"y\", {\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) {\n      this.transform.position.y = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"worldTransform\", {\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get: function get() {\n      return this.transform.worldTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"localTransform\", {\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    get: function get() {\n      return this.transform.localTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"position\", {\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get: function get() {\n      return this.transform.position;\n    },\n    set: function set(value) {\n      this.transform.position.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"scale\", {\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get: function get() {\n      return this.transform.scale;\n    },\n    set: function set(value) {\n      this.transform.scale.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"pivot\", {\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get: function get() {\n      return this.transform.pivot;\n    },\n    set: function set(value) {\n      this.transform.pivot.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"skew\", {\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get: function get() {\n      return this.transform.skew;\n    },\n    set: function set(value) {\n      this.transform.skew.copyFrom(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"rotation\", {\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get: function get() {\n      return this.transform.rotation;\n    },\n    set: function set(value) {\n      this.transform.rotation = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"angle\", {\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get: function get() {\n      return this.transform.rotation * RAD_TO_DEG;\n    },\n    set: function set(value) {\n      this.transform.rotation = value * DEG_TO_RAD;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"zIndex\", {\n    /**\n     * The zIndex of the displayObject.\n     *\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see PIXI.Container#sortableChildren\n     */\n    get: function get() {\n      return this._zIndex;\n    },\n    set: function set(value) {\n      this._zIndex = value;\n      if (this.parent) {\n        this.parent.sortDirty = true;\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"worldVisible\", {\n    /**\n     * Indicates if the object is globally visible.\n     * @readonly\n     */\n    get: function get() {\n      var item = this;\n      do {\n        if (!item.visible) {\n          return false;\n        }\n        item = item.parent;\n      } while (item);\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(DisplayObject.prototype, \"mask\", {\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * const graphics = new PIXI.Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     */\n    get: function get() {\n      return this._mask;\n    },\n    set: function set(value) {\n      if (this._mask === value) {\n        return;\n      }\n      if (this._mask) {\n        var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n        if (maskObject) {\n          maskObject._maskRefCount--;\n          if (maskObject._maskRefCount === 0) {\n            maskObject.renderable = true;\n            maskObject.isMask = false;\n          }\n        }\n      }\n      this._mask = value;\n      if (this._mask) {\n        var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n        if (maskObject) {\n          if (maskObject._maskRefCount === 0) {\n            maskObject.renderable = false;\n            maskObject.isMask = true;\n          }\n          maskObject._maskRefCount++;\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DisplayObject;\n}(EventEmitter);\n/**\n * @private\n */\nvar TemporaryDisplayObject = /** @class */function (_super) {\n  __extends(TemporaryDisplayObject, _super);\n  function TemporaryDisplayObject() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.sortDirty = null;\n    return _this;\n  }\n  return TemporaryDisplayObject;\n}(DisplayObject);\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\nfunction sortChildren(a, b) {\n  if (a.zIndex === b.zIndex) {\n    return a._lastSortedIndex - b._lastSortedIndex;\n  }\n  return a.zIndex - b.zIndex;\n}\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * ```js\n * import { BlurFilter } from '@pixi/filter-blur';\n * import { Container } from '@pixi/display';\n * import { Graphics } from '@pixi/graphics';\n * import { Sprite } from '@pixi/sprite';\n *\n * let container = new Container();\n * let sprite = Sprite.from(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png\");\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *  .beginFill(0xffffff)\n *  .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *  .endFill();\n * ```\n * @memberof PIXI\n */\nvar Container = /** @class */function (_super) {\n  __extends(Container, _super);\n  function Container() {\n    var _this = _super.call(this) || this;\n    _this.children = [];\n    _this.sortableChildren = settings.SORTABLE_CHILDREN;\n    _this.sortDirty = false;\n    return _this;\n    /**\n     * Fired when a DisplayObject is added to this Container.\n     * @event PIXI.Container#childAdded\n     * @param {PIXI.DisplayObject} child - The child added to the Container.\n     * @param {PIXI.Container} container - The container that added the child.\n     * @param {number} index - The children's index of the added child.\n     */\n    /**\n     * Fired when a DisplayObject is removed from this Container.\n     * @event PIXI.DisplayObject#childRemoved\n     * @param {PIXI.DisplayObject} child - The child removed from the Container.\n     * @param {PIXI.Container} container - The container that removed the child.\n     * @param {number} index - The former children's index of the removed child\n     */\n  }\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified.\n   * @param _length\n   */\n  Container.prototype.onChildrenChange = function (_length) {\n    /* empty */\n  };\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n   * @returns {PIXI.DisplayObject} - The first child that was added.\n   */\n  Container.prototype.addChild = function () {\n    var arguments$1 = arguments;\n    var children = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      children[_i] = arguments$1[_i];\n    }\n    // if there is only one argument we can bypass looping through the them\n    if (children.length > 1) {\n      // loop through the array and add all children\n      for (var i = 0; i < children.length; i++) {\n        // eslint-disable-next-line prefer-rest-params\n        this.addChild(children[i]);\n      }\n    } else {\n      var child = children[0];\n      // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n      child.parent = this;\n      this.sortDirty = true;\n      // ensure child transform will be recalculated\n      child.transform._parentID = -1;\n      this.children.push(child);\n      // ensure bounds will be recalculated\n      this._boundsID++;\n      // TODO - lets either do all callbacks or all events.. not both!\n      this.onChildrenChange(this.children.length - 1);\n      this.emit('childAdded', child, this, this.children.length - 1);\n      child.emit('added', this);\n    }\n    return children[0];\n  };\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n   * @param {PIXI.DisplayObject} child - The child to add\n   * @param {number} index - The index to place the child in\n   * @returns {PIXI.DisplayObject} The child that was added.\n   */\n  Container.prototype.addChildAt = function (child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + \"addChildAt: The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    child.parent = this;\n    this.sortDirty = true;\n    // ensure child transform will be recalculated\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child);\n    // ensure bounds will be recalculated\n    this._boundsID++;\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('added', this);\n    this.emit('childAdded', child, this, index);\n    return child;\n  };\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   * @param child - First display object to swap\n   * @param child2 - Second display object to swap\n   */\n  Container.prototype.swapChildren = function (child, child2) {\n    if (child === child2) {\n      return;\n    }\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n  /**\n   * Returns the index position of a child DisplayObject instance\n   * @param child - The DisplayObject instance to identify\n   * @returns - The index position of the child display object to identify\n   */\n  Container.prototype.getChildIndex = function (child) {\n    var index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n    return index;\n  };\n  /**\n   * Changes the position of an existing child in the display object container\n   * @param child - The child DisplayObject instance for which you want to change the index number\n   * @param index - The resulting index number for the child display object\n   */\n  Container.prototype.setChildIndex = function (child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"The index \" + index + \" supplied is out of bounds \" + this.children.length);\n    }\n    var currentIndex = this.getChildIndex(child);\n    removeItems(this.children, currentIndex, 1); // remove from old position\n    this.children.splice(index, 0, child); // add at new position\n    this.onChildrenChange(index);\n  };\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   */\n  Container.prototype.getChildAt = function (index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(\"getChildAt: Index (\" + index + \") does not exist.\");\n    }\n    return this.children[index];\n  };\n  /**\n   * Removes one or more children from the container.\n   * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n   * @returns {PIXI.DisplayObject} The first child that was removed.\n   */\n  Container.prototype.removeChild = function () {\n    var arguments$1 = arguments;\n    var children = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      children[_i] = arguments$1[_i];\n    }\n    // if there is only one argument we can bypass looping through the them\n    if (children.length > 1) {\n      // loop through the arguments property and remove all children\n      for (var i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n    } else {\n      var child = children[0];\n      var index = this.children.indexOf(child);\n      if (index === -1) {\n        return null;\n      }\n      child.parent = null;\n      // ensure child transform will be recalculated\n      child.transform._parentID = -1;\n      removeItems(this.children, index, 1);\n      // ensure bounds will be recalculated\n      this._boundsID++;\n      // TODO - lets either do all callbacks or all events.. not both!\n      this.onChildrenChange(index);\n      child.emit('removed', this);\n      this.emit('childRemoved', child, this, index);\n    }\n    return children[0];\n  };\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   */\n  Container.prototype.removeChildAt = function (index) {\n    var child = this.getChildAt(index);\n    // ensure child transform will be recalculated..\n    child.parent = null;\n    child.transform._parentID = -1;\n    removeItems(this.children, index, 1);\n    // ensure bounds will be recalculated\n    this._boundsID++;\n    // TODO - lets either do all callbacks or all events.. not both!\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n    this.emit('childRemoved', child, this, index);\n    return child;\n  };\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   */\n  Container.prototype.removeChildren = function (beginIndex, endIndex) {\n    if (beginIndex === void 0) {\n      beginIndex = 0;\n    }\n    if (endIndex === void 0) {\n      endIndex = this.children.length;\n    }\n    var begin = beginIndex;\n    var end = endIndex;\n    var range = end - begin;\n    var removed;\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].emit('removed', this);\n        this.emit('childRemoved', removed[i], this, i);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n  };\n  /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */\n  Container.prototype.sortChildren = function () {\n    var sortRequired = false;\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      child._lastSortedIndex = i;\n      if (!sortRequired && child.zIndex !== 0) {\n        sortRequired = true;\n      }\n    }\n    if (sortRequired && this.children.length > 1) {\n      this.children.sort(sortChildren);\n    }\n    this.sortDirty = false;\n  };\n  /** Updates the transform on all children of this container for rendering. */\n  Container.prototype.updateTransform = function () {\n    if (this.sortableChildren && this.sortDirty) {\n      this.sortChildren();\n    }\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform);\n    // TODO: check render flags, how to process stuff here\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n  /**\n   * Recalculates the bounds of the container.\n   *\n   * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds\n   * is limited to its mask's bounds or filterArea, if any is applied.\n   */\n  Container.prototype.calculateBounds = function () {\n    this._bounds.clear();\n    this._calculateBounds();\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n      child.calculateBounds();\n      // TODO: filter+mask, need to mask both somehow\n      if (child._mask) {\n        var maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;\n        if (maskObject) {\n          maskObject.calculateBounds();\n          this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n        } else {\n          this._bounds.addBounds(child._bounds);\n        }\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n    this._bounds.updateID = this._boundsID;\n  };\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object.\n   *\n   * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\n   * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\n   * @param rect - Optional rectangle to store the result of the bounds calculation.\n   * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\n   *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n   * @returns - The rectangular bounding area.\n   */\n  Container.prototype.getLocalBounds = function (rect, skipChildrenUpdate) {\n    if (skipChildrenUpdate === void 0) {\n      skipChildrenUpdate = false;\n    }\n    var result = _super.prototype.getLocalBounds.call(this, rect);\n    if (!skipChildrenUpdate) {\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        var child = this.children[i];\n        if (child.visible) {\n          child.updateTransform();\n        }\n      }\n    }\n    return result;\n  };\n  /**\n   * Recalculates the content bounds of this object. This should be overriden to\n   * calculate the bounds of this specific object (not including children).\n   * @protected\n   */\n  Container.prototype._calculateBounds = function () {\n    // FILL IN//\n  };\n  /**\n   * Renders this object and its children with culling.\n   * @protected\n   * @param {PIXI.Renderer} renderer - The renderer\n   */\n  Container.prototype._renderWithCulling = function (renderer) {\n    var sourceFrame = renderer.renderTexture.sourceFrame;\n    // If the source frame is empty, stop rendering.\n    if (!(sourceFrame.width > 0 && sourceFrame.height > 0)) {\n      return;\n    }\n    // Render the content of the container only if its bounds intersect with the source frame.\n    // All filters are on the stack at this point, and the filter source frame is bound:\n    // therefore, even if the bounds to non intersect the filter frame, the filter\n    // is still applied and any filter padding that is in the frame is rendered correctly.\n    var bounds;\n    var transform;\n    // If cullArea is set, we use this rectangle instead of the bounds of the object. The cullArea\n    // rectangle must completely contain the container and its children including filter padding.\n    if (this.cullArea) {\n      bounds = this.cullArea;\n      transform = this.worldTransform;\n    }\n    // If the container doesn't override _render, we can skip the bounds calculation and intersection test.\n    else if (this._render !== Container.prototype._render) {\n      bounds = this.getBounds(true);\n    }\n    // Render the container if the source frame intersects the bounds.\n    if (bounds && sourceFrame.intersects(bounds, transform)) {\n      this._render(renderer);\n    }\n    // If the bounds are defined by cullArea and do not intersect with the source frame, stop rendering.\n    else if (this.cullArea) {\n      return;\n    }\n    // Unless cullArea is set, we cannot skip the children if the bounds of the container do not intersect\n    // the source frame, because the children might have filters with nonzero padding, which may intersect\n    // with the source frame while the bounds do not: filter padding is not included in the bounds.\n    // If cullArea is not set, render the children with culling temporarily enabled so that they are not rendered\n    // if they are out of frame; otherwise, render the children normally.\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n      var childCullable = child.cullable;\n      child.cullable = childCullable || !this.cullArea;\n      child.render(renderer);\n      child.cullable = childCullable;\n    }\n  };\n  /**\n   * Renders the object using the WebGL renderer.\n   *\n   * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\n   * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\n   * children afterward.\n   *\n   * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\n   * the bounds of this object are out of frame, this implementation will entirely skip rendering.\n   * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\n   * setting alpha to zero is not recommended for purely skipping rendering.\n   *\n   * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\n   * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\n   * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\n   * Other culling methods might be better suited for a large number static objects; see\n   * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\n   * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\n   *\n   * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\n   * filtering is applied on a container. This does, however, break batching and can affect performance when\n   * masking and filtering is applied extensively throughout the scene graph.\n   * @param renderer - The renderer\n   */\n  Container.prototype.render = function (renderer) {\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n    // do a quick check to see if this element has a mask or a filter.\n    if (this._mask || this.filters && this.filters.length) {\n      this.renderAdvanced(renderer);\n    } else if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n  };\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   * @param renderer - The renderer\n   */\n  Container.prototype.renderAdvanced = function (renderer) {\n    var filters = this.filters;\n    var mask = this._mask;\n    // push filter first as we need to ensure the stencil buffer is correct for any masking\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n      this._enabledFilters.length = 0;\n      for (var i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n    }\n    var flush = filters && this._enabledFilters && this._enabledFilters.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE));\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filter.push(this, this._enabledFilters);\n    }\n    if (mask) {\n      renderer.mask.push(this, this._mask);\n    }\n    if (this.cullable) {\n      this._renderWithCulling(renderer);\n    } else {\n      this._render(renderer);\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].render(renderer);\n      }\n    }\n    if (flush) {\n      renderer.batch.flush();\n    }\n    if (mask) {\n      renderer.mask.pop(this);\n    }\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filter.pop();\n    }\n  };\n  /**\n   * To be overridden by the subclasses.\n   * @param _renderer - The renderer\n   */\n  Container.prototype._render = function (_renderer) {\n    // this is where content itself gets rendered...\n  };\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n  Container.prototype.destroy = function (options) {\n    _super.prototype.destroy.call(this);\n    this.sortDirty = false;\n    var destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n    if (destroyChildren) {\n      for (var i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  };\n  Object.defineProperty(Container.prototype, \"width\", {\n    /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n    get: function get() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function set(value) {\n      var width = this.getLocalBounds().width;\n      if (width !== 0) {\n        this.scale.x = value / width;\n      } else {\n        this.scale.x = 1;\n      }\n      this._width = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Container.prototype, \"height\", {\n    /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n    get: function get() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function set(value) {\n      var height = this.getLocalBounds().height;\n      if (height !== 0) {\n        this.scale.y = value / height;\n      } else {\n        this.scale.y = 1;\n      }\n      this._height = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Container;\n}(DisplayObject);\n/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.Container#\n * @method containerUpdateTransform\n */\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\nexport { Bounds, Container, DisplayObject, TemporaryDisplayObject };","map":{"version":3,"mappings":"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","names":["settings","SORTABLE_CHILDREN","minX","Infinity","minY","maxX","maxY","rect","updateID","Bounds","Rectangle","EMPTY","x","y","width","height","point","Math","min","max","matrix","b","c","d","tx","ty","a","vertices","transform","x0","y0","x1","y1","addFrameMatrix","worldTransform","vertexData","beginOffset","endOffset","i","addVerticesMatrix","padX","padY","rawX","rawY","bounds","mask","_minX","_minY","_maxX","_maxY","area","paddingX","paddingY","isEmpty","extendStatics","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","_super","_this","tempDisplayObjectParent","Transform","alpha","visible","renderable","cullable","cullArea","parent","worldAlpha","_lastSortedIndex","_zIndex","filterArea","filters","_enabledFilters","_bounds","_localBounds","_boundsID","_boundsRect","_localBoundsRect","_mask","_maskRefCount","_destroyed","isSprite","isMask","DisplayObject","source","keys","length","propertyName","defineProperty","getOwnPropertyDescriptor","get","_recursivePostUpdateTransform","updateTransform","_tempDisplayObjectParent","skipUpdate","calculateBounds","getRectangle","transformRef","parentRef","worldBounds","worldBoundsID","getBounds","position","displayObjectUpdateTransform","apply","from","toGlobal","applyInverse","container","addChild","Error","scaleX","scaleY","rotation","skewX","skewY","pivotX","pivotY","scale","skew","pivot","_options","removeChild","hitArea","interactive","interactiveChildren","emit","removeAllListeners","TemporaryDisplayObject","myParent","cacheParent","set","value","localTransform","copyFrom","RAD_TO_DEG","DEG_TO_RAD","sortDirty","item","maskObject","isMaskData","EventEmitter","sortChildren","zIndex","children","sortableChildren","Container","_length","_i","child","_parentID","push","onChildrenChange","index","splice","child2","index1","getChildIndex","index2","indexOf","currentIndex","removeItems","getChildAt","beginIndex","endIndex","begin","end","range","removed","RangeError","sortRequired","j","sort","clear","_calculateBounds","addBoundsMask","addBounds","addBoundsArea","skipChildrenUpdate","result","getLocalBounds","call","renderer","sourceFrame","renderTexture","_render","intersects","childCullable","render","renderAdvanced","_renderWithCulling","enabled","flush","autoDetect","type","MASK_TYPES","NONE","batch","filter","pop","_renderer","options","destroyChildren","oldChildren","removeChildren","destroy","_width","_height","containerUpdateTransform"],"sources":["../../src/settings.ts","../../src/Bounds.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/DisplayObject.ts","../../src/Container.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\n\n/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.SORTABLE_CHILDREN = false;\n\nexport { settings };\n","import { Rectangle } from '@pixi/math';\n\nimport type { IPointData, Transform, Matrix } from '@pixi/math';\n\n/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n * @memberof PIXI\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX: number;\n\n    /** @default Infinity */\n    public minY: number;\n\n    /** @default -Infinity */\n    public maxX: number;\n\n    /** @default -Infinity */\n    public maxY: number;\n\n    public rect: Rectangle;\n\n    /**\n     * It is updated to _boundsID of corresponding object to keep bounds in sync with content.\n     * Updated from outside, thus public modifier.\n     */\n    public updateID: number;\n\n    constructor()\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.rect = null;\n        this.updateID = -1;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** Clears the bounds and resets. */\n    clear(): void\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n    }\n\n    /**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     * @param rect - Temporary object will be used if AABB is not empty\n     * @returns - A rectangle of the bounds\n     */\n    getRectangle(rect?: Rectangle): Rectangle\n    {\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            return Rectangle.EMPTY;\n        }\n\n        rect = rect || new Rectangle(0, 0, 1, 1);\n\n        rect.x = this.minX;\n        rect.y = this.minY;\n        rect.width = this.maxX - this.minX;\n        rect.height = this.maxY - this.minY;\n\n        return rect;\n    }\n\n    /**\n     * This function should be inlined when its possible.\n     * @param point - The point to add.\n     */\n    addPoint(point: IPointData): void\n    {\n        this.minX = Math.min(this.minX, point.x);\n        this.maxX = Math.max(this.maxX, point.x);\n        this.minY = Math.min(this.minY, point.y);\n        this.maxY = Math.max(this.maxY, point.y);\n    }\n\n    /**\n     * Adds a point, after transformed. This should be inlined when its possible.\n     * @param matrix\n     * @param point\n     */\n    addPointMatrix(matrix: Matrix, point: IPointData): void\n    {\n        const { a, b, c, d, tx, ty } = matrix;\n\n        const x = (a * point.x) + (c * point.y) + tx;\n        const y = (b * point.x) + (d * point.y) + ty;\n\n        this.minX = Math.min(this.minX, x);\n        this.maxX = Math.max(this.maxX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxY = Math.max(this.maxY, y);\n    }\n\n    /**\n     * Adds a quad, not transformed\n     * @param vertices - The verts to add.\n     */\n    addQuad(vertices: Float32Array): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = vertices[0];\n        let y = vertices[1];\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[2];\n        y = vertices[3];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[4];\n        y = vertices[5];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = vertices[6];\n        y = vertices[7];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds sprite frame, transformed.\n     * @param transform - transform to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrame(transform: Transform, x0: number, y0: number, x1: number, y1: number): void\n    {\n        this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);\n    }\n\n    /**\n     * Adds sprite frame, multiplied by matrix\n     * @param matrix - matrix to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    addFrameMatrix(matrix: Matrix, x0: number, y0: number, x1: number, y1: number): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const x = vertexData[i];\n            const y = vertexData[i + 1];\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Add an array of mesh vertices\n     * @param transform - mesh transform\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */\n    addVertices(transform: Transform, vertices: Float32Array, beginOffset: number, endOffset: number): void\n    {\n        this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);\n    }\n\n    /**\n     * Add an array of mesh vertices.\n     * @param matrix - mesh matrix\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param padX - x padding\n     * @param padY - y padding\n     */\n    addVerticesMatrix(matrix: Matrix, vertices: Float32Array, beginOffset: number,\n        endOffset: number, padX = 0, padY = padX): void\n    {\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const rawX = vertices[i];\n            const rawY = vertices[i + 1];\n            const x = (a * rawX) + (c * rawY) + tx;\n            const y = (d * rawY) + (b * rawX) + ty;\n\n            minX = Math.min(minX, x - padX);\n            maxX = Math.max(maxX, x + padX);\n            minY = Math.min(minY, y - padY);\n            maxY = Math.max(maxY, y + padY);\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     */\n    addBounds(bounds: Bounds): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        this.minX = bounds.minX < minX ? bounds.minX : minX;\n        this.minY = bounds.minY < minY ? bounds.minY : minY;\n        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;\n        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param bounds - The Bounds to be added.\n     * @param mask - TODO\n     */\n    addBoundsMask(bounds: Bounds, mask: Bounds): void\n    {\n        const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;\n        const _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;\n        const _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;\n        const _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n     * @param bounds - other bounds\n     * @param matrix - multiplicator\n     */\n    addBoundsMatrix(bounds: Bounds, matrix: Matrix): void\n    {\n        this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);\n    }\n\n    /**\n     * Adds other Bounds, masked with Rectangle.\n     * @param bounds - TODO\n     * @param area - TODO\n     */\n    addBoundsArea(bounds: Bounds, area: Rectangle): void\n    {\n        const _minX = bounds.minX > area.x ? bounds.minX : area.x;\n        const _minY = bounds.minY > area.y ? bounds.minY : area.y;\n        const _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);\n        const _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);\n\n        if (_minX <= _maxX && _minY <= _maxY)\n        {\n            const minX = this.minX;\n            const minY = this.minY;\n            const maxX = this.maxX;\n            const maxY = this.maxY;\n\n            this.minX = _minX < minX ? _minX : minX;\n            this.minY = _minY < minY ? _minY : minY;\n            this.maxX = _maxX > maxX ? _maxX : maxX;\n            this.maxY = _maxY > maxY ? _maxY : maxY;\n        }\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    pad(paddingX = 0, paddingY = paddingX): void\n    {\n        if (!this.isEmpty())\n        {\n            this.minX -= paddingX;\n            this.maxX += paddingX;\n            this.minY -= paddingY;\n            this.maxY += paddingY;\n        }\n    }\n\n    /**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param padX - padding X\n     * @param padY - padding Y\n     */\n    addFramePad(x0: number, y0: number, x1: number, y1: number, padX: number, padY: number): void\n    {\n        x0 -= padX;\n        y0 -= padY;\n        x1 += padX;\n        y1 += padY;\n\n        this.minX = this.minX < x0 ? this.minX : x0;\n        this.maxX = this.maxX > x1 ? this.maxX : x1;\n        this.minY = this.minY < y0 ? this.minY : y0;\n        this.maxY = this.maxY > y1 ? this.maxY : y1;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { DEG_TO_RAD, RAD_TO_DEG, Rectangle, Transform } from '@pixi/math';\nimport { EventEmitter } from '@pixi/utils';\nimport { Bounds } from './Bounds';\n\nimport type { Container } from './Container';\nimport type { Filter, MaskData, Renderer } from '@pixi/core';\nimport type { IPointData, ObservablePoint, Matrix, Point } from '@pixi/math';\nimport type { Dict } from '@pixi/utils';\n\nexport interface IDestroyOptions\n{\n    children?: boolean;\n    texture?: boolean;\n    baseTexture?: boolean;\n}\n\nexport interface DisplayObject extends Omit<GlobalMixins.DisplayObject, keyof EventEmitter>, EventEmitter {}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds(): void\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * It is recommended that applications use the `renderable` property for culling. See\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n * @memberof PIXI\n */\nexport abstract class DisplayObject extends EventEmitter\n{\n    abstract sortDirty: boolean;\n\n    /** The display object container that contains this display object. */\n    public parent: Container;\n\n    /**\n     * The multiplied alpha of the displayObject.\n     * @readonly\n     */\n    public worldAlpha: number;\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     */\n    public transform: Transform;\n\n    /** The opacity of the object. */\n    public alpha: number;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     */\n    public visible: boolean;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     */\n    public renderable: boolean;\n\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     */\n    public cullable: boolean;\n\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     */\n    public cullArea: Rectangle;\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     */\n    public filterArea: Rectangle;\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     */\n    public filters: Filter[] | null;\n\n    /** Used to fast check if a sprite is.. a sprite! */\n    public isSprite: boolean;\n\n    /** Does any other displayObject use this object as a mask? */\n    public isMask: boolean;\n\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     * @protected\n     */\n    public _lastSortedIndex: number;\n\n    /**\n     * The original, cached mask of the object.\n     * @protected\n     */\n    public _mask: Container | MaskData;\n\n    /** The bounds object, this is used to calculate and store the bounds of the displayObject. */\n    public _bounds: Bounds;\n\n    /** Local bounds object, swapped with `_bounds` when using `getLocalBounds()`. */\n    public _localBounds: Bounds;\n\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     * @protected\n     */\n    protected _zIndex: number;\n\n    /**\n     * Currently enabled filters.\n     * @protected\n     */\n    protected _enabledFilters: Filter[];\n\n    /** Flags the cached bounds as dirty. */\n    protected _boundsID: number;\n\n    /** Cache of this display-object's bounds-rectangle. */\n    protected _boundsRect: Rectangle;\n\n    /** Cache of this display-object's local-bounds rectangle. */\n    protected _localBoundsRect: Rectangle;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    protected _destroyed: boolean;\n\n    /** The number of times this object is used as a mask by another object. */\n    private _maskRefCount: number;\n    private tempDisplayObjectParent: TemporaryDisplayObject;\n    public displayObjectUpdateTransform: () => void;\n\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     * @param source - The source of properties and methods to mix in.\n     */\n    static mixin(source: Dict<any>): void\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        this.transform = new Transform();\n        this.alpha = 1;\n        this.visible = true;\n        this.renderable = true;\n        this.cullable = false;\n        this.cullArea = null;\n\n        this.parent = null;\n        this.worldAlpha = 1;\n\n        this._lastSortedIndex = 0;\n        this._zIndex = 0;\n\n        this.filterArea = null;\n        this.filters = null;\n        this._enabledFilters = null;\n\n        this._bounds = new Bounds();\n        this._localBounds = null;\n        this._boundsID = 0;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n        this._mask = null;\n        this._maskRefCount = 0;\n        this._destroyed = false;\n\n        this.isSprite = false;\n        this.isMask = false;\n    }\n\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     * @instance\n     * @event added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     * @instance\n     * @event removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    /**\n     * Fired when this DisplayObject is destroyed. This event is emitted once\n     * destroy is finished.\n     * @instance\n     * @event destroyed\n     */\n\n    /** Readonly flag for destroyed display objects. */\n    get destroyed(): boolean\n    {\n        return this._destroyed;\n    }\n\n    /** Recalculates the bounds of the display object. */\n    abstract calculateBounds(): void;\n\n    abstract removeChild(child: DisplayObject): void;\n\n    /**\n     * Renders the object using the WebGL renderer.\n     * @param renderer - The renderer.\n     */\n    abstract render(renderer: Renderer): void;\n\n    /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\n    protected _recursivePostUpdateTransform(): void\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /** Updates the object transform for rendering. TODO - Optimization pass! */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n     *\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n     * its height increases.\n     *\n     * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n     * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n     *\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n     * calculation if needed.\n     *\n     * ```js\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n     * ```\n     *\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n     * details.\n     *\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n     * cases.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     */\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._bounds.updateID !== this._boundsID)\n        {\n            this.calculateBounds();\n            this._bounds.updateID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The rectangular bounding area.\n     */\n    getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        if (!this._localBounds)\n        {\n            this._localBounds = new Bounds();\n        }\n\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        const worldBounds = this._bounds;\n        const worldBoundsID = this._boundsID;\n\n        this._bounds = this._localBounds;\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        this._bounds = worldBounds;\n        this._bounds.updateID += this._boundsID - worldBoundsID;// reflect side-effects\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     */\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply<P>(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The DisplayObject to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     */\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     * @param container - The Container to add this DisplayObject to.\n     * @returns - The Container that this DisplayObject was added to.\n     */\n    setParent(container: Container): Container\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     * @param x - The X position\n     * @param y - The Y position\n     * @param scaleX - The X scale value\n     * @param scaleY - The Y scale value\n     * @param rotation - The rotation\n     * @param skewX - The X skew value\n     * @param skewY - The Y skew value\n     * @param pivotX - The X pivot value\n     * @param pivotY - The Y pivot value\n     * @returns - The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0): this\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     * @param _options\n     */\n    destroy(_options?: IDestroyOptions | boolean): void\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this._destroyed = true;\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this.mask = null;\n\n        this.cullArea = null;\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this.emit('destroyed');\n        this.removeAllListeners();\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get _tempDisplayObjectParent(): TemporaryDisplayObject\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this.tempDisplayObjectParent = new TemporaryDisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\n     *\n     * ```\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     * @returns - current parent\n     */\n    enableTempParent(): Container\n    {\n        const myParent = this.parent;\n\n        this.parent = this._tempDisplayObjectParent as Container;\n\n        return myParent;\n    }\n\n    /**\n     * Pair method for `enableTempParent`\n     * @param cacheParent - Actual parent of element\n     */\n    disableTempParent(cacheParent: Container): void\n    {\n        this.parent = cacheParent;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this.position.x;\n    }\n\n    set x(value: number)\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this.position.y;\n    }\n\n    set y(value: number)\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform(): Matrix\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    get localTransform(): Matrix\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this.transform.position;\n    }\n\n    set position(value: IPointData)\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value: IPointData)\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value: IPointData)\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value: IPointData)\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     *\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see PIXI.Container#sortableChildren\n     */\n    get zIndex(): number\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value: number)\n    {\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     * @readonly\n     */\n    get worldVisible(): boolean\n    {\n        let item = this as DisplayObject;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * const graphics = new PIXI.Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     */\n    get mask(): Container | MaskData | null\n    {\n        return this._mask;\n    }\n\n    set mask(value: Container | MaskData | null)\n    {\n        if (this._mask === value)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                maskObject._maskRefCount--;\n\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = true;\n                    maskObject.isMask = false;\n                }\n            }\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = false;\n                    maskObject.isMask = true;\n                }\n\n                maskObject._maskRefCount++;\n            }\n        }\n    }\n}\n\n/**\n * @private\n */\nexport class TemporaryDisplayObject extends DisplayObject\n{\n    calculateBounds: () => null;\n    removeChild: (child: DisplayObject) => null;\n    render: (renderer: Renderer) => null;\n    sortDirty: boolean = null;\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n","import { settings } from '@pixi/settings';\nimport { removeItems } from '@pixi/utils';\nimport { DisplayObject } from './DisplayObject';\nimport type { Matrix, Rectangle } from '@pixi/math';\nimport { MASK_TYPES } from '@pixi/constants';\n\nimport type { MaskData, Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from './DisplayObject';\n\nfunction sortChildren(a: DisplayObject, b: DisplayObject): number\n{\n    if (a.zIndex === b.zIndex)\n    {\n        return a._lastSortedIndex - b._lastSortedIndex;\n    }\n\n    return a.zIndex - b.zIndex;\n}\n\nexport interface Container extends GlobalMixins.Container, DisplayObject {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * ```js\n * import { BlurFilter } from '@pixi/filter-blur';\n * import { Container } from '@pixi/display';\n * import { Graphics } from '@pixi/graphics';\n * import { Sprite } from '@pixi/sprite';\n *\n * let container = new Container();\n * let sprite = Sprite.from(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png\");\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *  .beginFill(0xffffff)\n *  .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *  .endFill();\n * ```\n * @memberof PIXI\n */\nexport class Container<T extends DisplayObject = DisplayObject> extends DisplayObject\n{\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public readonly children: T[];\n\n    /**\n     * If set to true, the container will sort its children by zIndex value\n     * when updateTransform() is called, or manually if sortChildren() is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as @link https://github.com/pixijs/pixi-display\n     *\n     * Also be aware of that this may not work nicely with the addChildAt() function,\n     * as the zIndex sorting may cause the child to automatically sorted to another position.\n     * @see PIXI.settings.SORTABLE_CHILDREN\n     */\n    public sortableChildren: boolean;\n\n    /**\n     * Should children be sorted by zIndex at the next updateTransform call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     */\n    public sortDirty: boolean;\n    public parent: Container;\n    public containerUpdateTransform: () => void;\n\n    protected _width: number;\n    protected _height: number;\n\n    constructor()\n    {\n        super();\n\n        this.children = [];\n        this.sortableChildren = settings.SORTABLE_CHILDREN;\n        this.sortDirty = false;\n\n        /**\n         * Fired when a DisplayObject is added to this Container.\n         * @event PIXI.Container#childAdded\n         * @param {PIXI.DisplayObject} child - The child added to the Container.\n         * @param {PIXI.Container} container - The container that added the child.\n         * @param {number} index - The children's index of the added child.\n         */\n\n        /**\n         * Fired when a DisplayObject is removed from this Container.\n         * @event PIXI.DisplayObject#childRemoved\n         * @param {PIXI.DisplayObject} child - The child removed from the Container.\n         * @param {PIXI.Container} container - The container that removed the child.\n         * @param {number} index - The former children's index of the removed child\n         */\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified.\n     * @param _length\n     */\n    protected onChildrenChange(_length?: number): void\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n     * @returns {PIXI.DisplayObject} - The first child that was added.\n     */\n    addChild<U extends T[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                // eslint-disable-next-line prefer-rest-params\n                this.addChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            this.sortDirty = true;\n\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            this.emit('childAdded', child, this, this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @returns {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt<U extends T>(child: U, index: number): U\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        this.sortDirty = true;\n\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n        this.emit('childAdded', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     * @param child - First display object to swap\n     * @param child2 - Second display object to swap\n     */\n    swapChildren(child: T, child2: T): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     * @param child - The DisplayObject instance to identify\n     * @returns - The index position of the child display object to identify\n     */\n    getChildIndex(child: T): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     * @param child - The child DisplayObject instance for which you want to change the index number\n     * @param index - The resulting index number for the child display object\n     */\n    setChildIndex(child: T, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     */\n    getChildAt(index: number): T\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n     * @returns {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild<U extends T[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n        }\n        else\n        {\n            const child = children[0];\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n            this.emit('childRemoved', child, this, index);\n        }\n\n        return children[0];\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     */\n    removeChildAt(index: number): T\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n        this.emit('childRemoved', child, this, index);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex = this.children.length): T[]\n    {\n        const begin = beginIndex;\n        const end = endIndex;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n                this.emit('childRemoved', removed[i], this, i);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */\n    sortChildren(): void\n    {\n        let sortRequired = false;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            child._lastSortedIndex = i;\n\n            if (!sortRequired && child.zIndex !== 0)\n            {\n                sortRequired = true;\n            }\n        }\n\n        if (sortRequired && this.children.length > 1)\n        {\n            this.children.sort(sortChildren);\n        }\n\n        this.sortDirty = false;\n    }\n\n    /** Updates the transform on all children of this container for rendering. */\n    updateTransform(): void\n    {\n        if (this.sortableChildren && this.sortDirty)\n        {\n            this.sortChildren();\n        }\n\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds\n     * is limited to its mask's bounds or filterArea, if any is applied.\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                const maskObject = ((child._mask as MaskData).isMaskData\n                    ? (child._mask as MaskData).maskObject : child._mask) as Container;\n\n                if (maskObject)\n                {\n                    maskObject.calculateBounds();\n                    this._bounds.addBoundsMask(child._bounds, maskObject._bounds);\n                }\n                else\n                {\n                    this._bounds.addBounds(child._bounds);\n                }\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._bounds.updateID = this._boundsID;\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\n     * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\n     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n     * @returns - The rectangular bounding area.\n     */\n    public getLocalBounds(rect?: Rectangle, skipChildrenUpdate = false): Rectangle\n    {\n        const result = super.getLocalBounds(rect);\n\n        if (!skipChildrenUpdate)\n        {\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                const child = this.children[i];\n\n                if (child.visible)\n                {\n                    child.updateTransform();\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Recalculates the content bounds of this object. This should be overriden to\n     * calculate the bounds of this specific object (not including children).\n     * @protected\n     */\n    protected _calculateBounds(): void\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders this object and its children with culling.\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    protected _renderWithCulling(renderer: Renderer): void\n    {\n        const sourceFrame = renderer.renderTexture.sourceFrame;\n\n        // If the source frame is empty, stop rendering.\n        if (!(sourceFrame.width > 0 && sourceFrame.height > 0))\n        {\n            return;\n        }\n\n        // Render the content of the container only if its bounds intersect with the source frame.\n        // All filters are on the stack at this point, and the filter source frame is bound:\n        // therefore, even if the bounds to non intersect the filter frame, the filter\n        // is still applied and any filter padding that is in the frame is rendered correctly.\n\n        let bounds: Rectangle;\n        let transform: Matrix;\n\n        // If cullArea is set, we use this rectangle instead of the bounds of the object. The cullArea\n        // rectangle must completely contain the container and its children including filter padding.\n        if (this.cullArea)\n        {\n            bounds = this.cullArea;\n            transform = this.worldTransform;\n        }\n        // If the container doesn't override _render, we can skip the bounds calculation and intersection test.\n        else if (this._render !== Container.prototype._render)\n        {\n            bounds = this.getBounds(true);\n        }\n\n        // Render the container if the source frame intersects the bounds.\n        if (bounds && sourceFrame.intersects(bounds, transform))\n        {\n            this._render(renderer);\n        }\n        // If the bounds are defined by cullArea and do not intersect with the source frame, stop rendering.\n        else if (this.cullArea)\n        {\n            return;\n        }\n\n        // Unless cullArea is set, we cannot skip the children if the bounds of the container do not intersect\n        // the source frame, because the children might have filters with nonzero padding, which may intersect\n        // with the source frame while the bounds do not: filter padding is not included in the bounds.\n\n        // If cullArea is not set, render the children with culling temporarily enabled so that they are not rendered\n        // if they are out of frame; otherwise, render the children normally.\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n            const childCullable = child.cullable;\n\n            child.cullable = childCullable || !this.cullArea;\n            child.render(renderer);\n            child.cullable = childCullable;\n        }\n    }\n\n    /**\n     * Renders the object using the WebGL renderer.\n     *\n     * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\n     * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\n     * children afterward.\n     *\n     * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\n     * the bounds of this object are out of frame, this implementation will entirely skip rendering.\n     * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\n     * setting alpha to zero is not recommended for purely skipping rendering.\n     *\n     * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\n     * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\n     * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\n     * Other culling methods might be better suited for a large number static objects; see\n     * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\n     * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\n     *\n     * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\n     * filtering is applied on a container. This does, however, break batching and can affect performance when\n     * masking and filtering is applied extensively throughout the scene graph.\n     * @param renderer - The renderer\n     */\n    render(renderer: Renderer): void\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvanced(renderer);\n        }\n        else if (this.cullable)\n        {\n            this._renderWithCulling(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     * @param renderer - The renderer\n     */\n    protected renderAdvanced(renderer: Renderer): void\n    {\n        const filters = this.filters;\n        const mask = this._mask as MaskData;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n        }\n\n        const flush = (filters && this._enabledFilters && this._enabledFilters.length)\n            || (mask && (!mask.isMaskData\n                || (mask.enabled && (mask.autoDetect || mask.type !== MASK_TYPES.NONE))));\n\n        if (flush)\n        {\n            renderer.batch.flush();\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.push(this, this._enabledFilters);\n        }\n\n        if (mask)\n        {\n            renderer.mask.push(this, this._mask);\n        }\n\n        if (this.cullable)\n        {\n            this._renderWithCulling(renderer);\n        }\n        else\n        {\n            this._render(renderer);\n\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].render(renderer);\n            }\n        }\n\n        if (flush)\n        {\n            renderer.batch.flush();\n        }\n\n        if (mask)\n        {\n            renderer.mask.pop(this);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filter.pop();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     * @param _renderer - The renderer\n     */\n    protected _render(_renderer: Renderer): void // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy();\n\n        this.sortDirty = false;\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value: number)\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value: number)\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.Container#\n * @method containerUpdateTransform\n */\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"]},"metadata":{},"sourceType":"module"}