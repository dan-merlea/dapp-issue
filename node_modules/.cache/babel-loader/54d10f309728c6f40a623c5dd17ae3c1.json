{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeExpressionParser = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar types_1 = require(\"./types\");\nvar jsonHandler = require(\"json-duplicate-key-handle\");\nvar TypeExpressionParser = /*#__PURE__*/function () {\n  function TypeExpressionParser() {\n    _classCallCheck(this, TypeExpressionParser);\n  }\n  _createClass(TypeExpressionParser, [{\n    key: \"parse\",\n    value: function parse(expression) {\n      var root = this.doParse(expression);\n      var rootKeys = Object.keys(root);\n      if (rootKeys.length != 1) {\n        throw new errors.ErrTypingSystem(\"bad type expression: \".concat(expression));\n      }\n      var name = rootKeys[0];\n      var type = this.nodeToType(name, root[name]);\n      return type;\n    }\n  }, {\n    key: \"doParse\",\n    value: function doParse(expression) {\n      var jsoned = this.getJsonedString(expression);\n      try {\n        return jsonHandler.parse(jsoned);\n      } catch (error) {\n        throw new errors.ErrTypingSystem(\"cannot parse type expression: \".concat(expression, \". internal json: \").concat(jsoned, \".\"));\n      }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n  }, {\n    key: \"getJsonedString\",\n    value: function getJsonedString(expression) {\n      var jsoned = \"\";\n      for (var i = 0; i < expression.length; i++) {\n        var char = expression.charAt(i);\n        var previousChar = expression.charAt(i - 1);\n        var nextChar = expression.charAt(i + 1);\n        if (char == \"<\") {\n          jsoned += \": {\";\n        } else if (char == \">\") {\n          if (previousChar != \">\") {\n            jsoned += \": {} }\";\n          } else {\n            jsoned += \"}\";\n          }\n        } else if (char == \",\") {\n          if (nextChar == \">\") {\n            // Skip superfluous comma\n          } else {\n            jsoned += \": {},\";\n          }\n        } else {\n          jsoned += char;\n        }\n      }\n      // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n      var symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n      var tokens = jsoned\n      // Hack for Safari compatibility, where we can't use negative lookbehind\n      .replace(/utf\\-8\\sstring/ig, \"utf-8-string\").split(symbolsRegex).filter(function (token) {\n        return token;\n      });\n      jsoned = tokens.map(function (token) {\n        return symbolsRegex.test(token) ? token : \"\\\"\".concat(token, \"\\\"\");\n      }).map(function (token) {\n        return token.replace(/utf\\-8\\-string/ig, \"utf-8 string\");\n      }).join(\"\");\n      if (tokens.length == 1) {\n        // Workaround for simple, non-generic types.\n        return \"{\".concat(jsoned, \": {}}\");\n      }\n      return \"{\".concat(jsoned, \"}\");\n    }\n  }, {\n    key: \"nodeToType\",\n    value: function nodeToType(name, node) {\n      var _this = this;\n      if (name.charAt(name.length - 1) === \"1\") {\n        name = name.slice(0, -1);\n      }\n      var typeParameters = Object.keys(node).map(function (key) {\n        return _this.nodeToType(key, node[key]);\n      });\n      return new types_1.Type(name, typeParameters);\n    }\n  }]);\n  return TypeExpressionParser;\n}();\nexports.TypeExpressionParser = TypeExpressionParser;","map":null,"metadata":{},"sourceType":"script"}