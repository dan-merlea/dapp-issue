{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _defineProperty = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProviderV2 = void 0;\nvar sign_client_1 = __importDefault(require(\"@walletconnect/sign-client\"));\nvar utils_1 = require(\"@walletconnect/utils\");\nvar constants_1 = require(\"./constants\");\nvar operation_1 = require(\"./operation\");\nvar logger_1 = require(\"./logger\");\nvar primitives_1 = require(\"./primitives\");\nvar userAddress_1 = require(\"./userAddress\");\nvar WalletConnectProviderV2 = /*#__PURE__*/function () {\n  function WalletConnectProviderV2(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId) {\n    _classCallCheck(this, WalletConnectProviderV2);\n    this.chainId = \"\";\n    this.address = \"\";\n    this.signature = \"\";\n    this.isInitializing = false;\n    this.events = [];\n    this.methods = [];\n    this.onClientConnect = onClientConnect;\n    this.chainId = chainId;\n    this.walletConnectV2Relay = walletConnectV2Relay;\n    this.walletConnectV2ProjectId = walletConnectV2ProjectId;\n  }\n  /**\n   * Initiates WalletConnect client.\n   */\n  _createClass(WalletConnectProviderV2, [{\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var client;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return sign_client_1.default.init({\n                  relayUrl: this.walletConnectV2Relay,\n                  projectId: this.walletConnectV2ProjectId\n                });\n              case 3:\n                client = _context.sent;\n                this.walletConnector = client;\n                _context.next = 7;\n                return this.subscribeToEvents(client);\n              case 7:\n                _context.next = 9;\n                return this.checkPersistedState(client);\n              case 9:\n                _context.next = 14;\n                break;\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](0);\n                throw new Error(\"connect: WalletConnect is unable to init\");\n              case 14:\n                _context.prev = 14;\n                this.isInitializing = false;\n                return _context.finish(14);\n              case 17:\n                return _context.abrupt(\"return\", true);\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 11, 14, 17]]);\n      }));\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !!this.walletConnector;\n    }\n    /**\n     * Returns true if provider is initialized and a valid session is set\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var _this = this;\n      return new Promise(function (resolve, _) {\n        return resolve(Boolean(_this.isInitialized() && typeof _this.session !== \"undefined\"));\n      });\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(options) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var methods, chains, events, response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context2.next = 3;\n                  break;\n                }\n                _context2.next = 3;\n                return this.init();\n              case 3:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context2.next = 5;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 5:\n                methods = [].concat(_toConsumableArray(Object.values(operation_1.Operation)), _toConsumableArray((_a = options === null || options === void 0 ? void 0 : options.methods) !== null && _a !== void 0 ? _a : []));\n                chains = [\"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId)];\n                events = (_b = options === null || options === void 0 ? void 0 : options.events) !== null && _b !== void 0 ? _b : [];\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this.walletConnector.connect({\n                  pairingTopic: options === null || options === void 0 ? void 0 : options.topic,\n                  requiredNamespaces: _defineProperty({}, constants_1.WALLETCONNECT_ELROND_NAMESPACE, {\n                    methods: methods,\n                    chains: chains,\n                    events: events\n                  })\n                });\n              case 11:\n                response = _context2.sent;\n                this.events = events;\n                this.methods = methods;\n                return _context2.abrupt(\"return\", response);\n              case 17:\n                _context2.prev = 17;\n                _context2.t0 = _context2[\"catch\"](8);\n                if (!(options === null || options === void 0 ? void 0 : options.topic)) {\n                  _context2.next = 26;\n                  break;\n                }\n                _context2.next = 22;\n                return this.logout({\n                  topic: options.topic\n                });\n              case 22:\n                logger_1.Logger.error(\"connect: WalletConnect is unable to connect to existing pairing\");\n                throw new Error(\"connect: WalletConnect is unable to connect to existing pairing\");\n              case 26:\n                logger_1.Logger.error(\"connect: WalletConnect is unable to connect\");\n                throw new Error(\"connect: WalletConnect is unable to connect\");\n              case 28:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 17]]);\n      }));\n    }\n  }, {\n    key: \"login\",\n    value: function login(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var session, address, _yield$this$walletCon, signature;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.isInitializing = true;\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context3.next = 4;\n                  break;\n                }\n                _context3.next = 4;\n                return this.connect();\n              case 4:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context3.next = 6;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 6:\n                if (!(typeof this.session !== \"undefined\")) {\n                  _context3.next = 9;\n                  break;\n                }\n                _context3.next = 9;\n                return this.logout();\n              case 9:\n                _context3.prev = 9;\n                if (!(options && options.approval)) {\n                  _context3.next = 29;\n                  break;\n                }\n                _context3.next = 13;\n                return options.approval();\n              case 13:\n                session = _context3.sent;\n                if (!options.token) {\n                  _context3.next = 26;\n                  break;\n                }\n                address = this.getAddressFromSession(session);\n                _context3.next = 18;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_LOGIN_TOKEN,\n                    params: {\n                      token: options.token,\n                      address: address\n                    }\n                  }\n                });\n              case 18:\n                _yield$this$walletCon = _context3.sent;\n                signature = _yield$this$walletCon.signature;\n                if (signature) {\n                  _context3.next = 23;\n                  break;\n                }\n                logger_1.Logger.error(\"login: WalletConnect could not sign login token\");\n                throw new Error(\"WalletConnect could not sign login token\");\n              case 23:\n                _context3.next = 25;\n                return this.onSessionConnected({\n                  session: session,\n                  signature: signature\n                });\n              case 25:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 26:\n                _context3.next = 28;\n                return this.onSessionConnected({\n                  session: session,\n                  signature: \"\"\n                });\n              case 28:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 29:\n                _context3.next = 35;\n                break;\n              case 31:\n                _context3.prev = 31;\n                _context3.t0 = _context3[\"catch\"](9);\n                logger_1.Logger.error(\"login: WalletConnect is unable to login\");\n                throw new Error(\"login: WalletConnect is unable to login\");\n              case 35:\n                _context3.prev = 35;\n                this.isInitializing = false;\n                return _context3.finish(35);\n              case 38:\n                return _context3.abrupt(\"return\", \"\");\n              case 39:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[9, 31, 35, 38]]);\n      }));\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n  }, {\n    key: \"logout\",\n    value: function logout(options) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var topic, newPairings;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context4.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"logout: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                _context4.prev = 3;\n                topic = (_a = options === null || options === void 0 ? void 0 : options.topic) !== null && _a !== void 0 ? _a : (_b = this.session) === null || _b === void 0 ? void 0 : _b.topic;\n                if (!topic) {\n                  _context4.next = 10;\n                  break;\n                }\n                _context4.next = 8;\n                return this.walletConnector.disconnect({\n                  topic: topic,\n                  reason: utils_1.getSdkError(\"USER_DISCONNECTED\")\n                });\n              case 8:\n                newPairings = this.walletConnector.pairing.getAll({\n                  active: true\n                }).filter(function (pairing) {\n                  return pairing.topic !== topic;\n                });\n                this.pairings = newPairings;\n              case 10:\n                _context4.next = 15;\n                break;\n              case 12:\n                _context4.prev = 12;\n                _context4.t0 = _context4[\"catch\"](3);\n                logger_1.Logger.error(\"logout: WalletConnect was unable to logout\");\n              case 15:\n                return _context4.abrupt(\"return\", true);\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 12]]);\n      }));\n    }\n    /**\n     * Fetches the WalletConnect address\n     */\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context5.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getAddress: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                return _context5.abrupt(\"return\", this.address);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Fetches the WalletConnect signature\n     */\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context6.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getSignature: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                return _context6.abrupt(\"return\", this.signature);\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Fetches the WalletConnect pairings\n     */\n  }, {\n    key: \"getPairings\",\n    value: function getPairings() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context7.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getPairings: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                return _context7.abrupt(\"return\", (_a = this.pairings) !== null && _a !== void 0 ? _a : this.walletConnector.pairing.getAll({\n                  active: true\n                }));\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Method will be available once the Maiar WalletConnect hook is implemented\n     * @param _\n     */\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var address, _yield$this$walletCon2, signature;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context8.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signMessage: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                _context8.next = 5;\n                return this.getAddress();\n              case 5:\n                address = _context8.sent;\n                _context8.next = 8;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_MESSAGE,\n                    params: {\n                      address: address,\n                      message: message.message.toString()\n                    }\n                  }\n                });\n              case 8:\n                _yield$this$walletCon2 = _context8.sent;\n                signature = _yield$this$walletCon2.signature;\n                if (signature) {\n                  _context8.next = 13;\n                  break;\n                }\n                logger_1.Logger.error(\"signMessage: WalletConnect could not sign the message\");\n                throw new Error(\"WalletConnect could not sign the message\");\n              case 13:\n                message.applySignature(new primitives_1.Signature(signature), userAddress_1.UserAddress.fromBech32(address));\n                return _context8.abrupt(\"return\", message);\n              case 15:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var address, sender, wcTransaction, _yield$this$walletCon3, signature;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context9.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                _context9.next = 5;\n                return this.getAddress();\n              case 5:\n                address = _context9.sent;\n                sender = new primitives_1.Address(address);\n                wcTransaction = transaction.toPlainObject(sender);\n                if (!(this.chainId !== transaction.getChainID().valueOf())) {\n                  _context9.next = 11;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: Transaction Chain Id different than Connection Chain Id\");\n                throw new Error(\"Transaction Chain Id different than Connection Chain Id\");\n              case 11:\n                _context9.next = 13;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_TRANSACTION,\n                    params: {\n                      transaction: wcTransaction\n                    }\n                  }\n                });\n              case 13:\n                _yield$this$walletCon3 = _context9.sent;\n                signature = _yield$this$walletCon3.signature;\n                if (signature) {\n                  _context9.next = 18;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: WalletConnect could not sign the transaction\");\n                throw new Error(\"WalletConnect could not sign the transaction\");\n              case 18:\n                transaction.applySignature(primitives_1.Signature.fromHex(signature), userAddress_1.UserAddress.fromBech32(address));\n                return _context9.abrupt(\"return\", transaction);\n              case 20:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(transactions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this2 = this;\n        var address, sender, wcTransactions, _yield$this$walletCon4, signatures, _iterator, _step, _step$value, index, transaction;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context10.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                _context10.next = 5;\n                return this.getAddress();\n              case 5:\n                address = _context10.sent;\n                sender = new primitives_1.Address(address);\n                wcTransactions = transactions.map(function (transaction) {\n                  if (_this2.chainId !== transaction.getChainID().valueOf()) {\n                    logger_1.Logger.error(\"signTransactions: Transaction Chain Id different than Connection Chain Id\");\n                    throw new Error(\"Transactions Chain Id different than Connection Chain Id\");\n                  }\n                  return transaction.toPlainObject(sender);\n                });\n                _context10.next = 10;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_TRANSACTIONS,\n                    params: {\n                      transactions: wcTransactions\n                    }\n                  }\n                });\n              case 10:\n                _yield$this$walletCon4 = _context10.sent;\n                signatures = _yield$this$walletCon4.signatures;\n                if (!(!signatures || !Array.isArray(signatures))) {\n                  _context10.next = 15;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: WalletConnect could not sign the transactions\");\n                throw new Error(\"WalletConnect could not sign the transactions\");\n              case 15:\n                if (!(transactions.length !== signatures.length)) {\n                  _context10.next = 18;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: WalletConnect could not sign the transactions. Invalid signatures.\");\n                throw new Error(\"WalletConnect could not sign the transactions. Invalid signatures.\");\n              case 18:\n                _iterator = _createForOfIteratorHelper(transactions.entries());\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], transaction = _step$value[1];\n                    transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n                return _context10.abrupt(\"return\", transactions);\n              case 21:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Sends a custom request\n     * @param request\n     */\n  }, {\n    key: \"sendCustomRequest\",\n    value: function sendCustomRequest(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$walletCon5, response;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context11.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomRequest: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                if (!(options === null || options === void 0 ? void 0 : options.request)) {\n                  _context11.next = 12;\n                  break;\n                }\n                _context11.next = 6;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: options.request\n                });\n              case 6:\n                _yield$this$walletCon5 = _context11.sent;\n                response = _yield$this$walletCon5.response;\n                if (response) {\n                  _context11.next = 11;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomRequest: WalletConnect could not send the custom request\");\n                throw new Error(\"WalletConnect could not send the custom request\");\n              case 11:\n                return _context11.abrupt(\"return\", response);\n              case 12:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"loginAccount\",\n    value: function loginAccount(options) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var newPairings;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (options) {\n                  _context12.next = 2;\n                  break;\n                }\n                return _context12.abrupt(\"return\");\n              case 2:\n                if (!this.addressIsValid(options.address)) {\n                  _context12.next = 7;\n                  break;\n                }\n                this.address = options.address;\n                if (options.signature) {\n                  this.signature = options.signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return _context12.abrupt(\"return\");\n              case 7:\n                logger_1.Logger.error(\"WalletConnect invalid address \".concat(options.address));\n                if (!(((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) && this.walletConnector)) {\n                  _context12.next = 13;\n                  break;\n                }\n                _context12.next = 11;\n                return this.walletConnector.disconnect({\n                  topic: this.session.topic,\n                  reason: utils_1.getSdkError(\"USER_DISCONNECTED\")\n                });\n              case 11:\n                newPairings = this.walletConnector.pairing.getAll({\n                  active: true\n                });\n                this.pairings = newPairings;\n              case 13:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"onSessionConnected\",\n    value: function onSessionConnected(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var address;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (options) {\n                  _context13.next = 2;\n                  break;\n                }\n                return _context13.abrupt(\"return\", \"\");\n              case 2:\n                this.session = options.session;\n                address = this.getAddressFromSession(options.session);\n                if (!address) {\n                  _context13.next = 7;\n                  break;\n                }\n                _context13.next = 7;\n                return this.loginAccount({\n                  address: address,\n                  signature: options.signature\n                });\n              case 7:\n                return _context13.abrupt(\"return\", \"\");\n              case 8:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n  }, {\n    key: \"handleTopicUpdateEvent\",\n    value: function handleTopicUpdateEvent(_ref) {\n      var topic = _ref.topic;\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context14.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                this.pairings = this.walletConnector.pairing.getAll({\n                  active: true\n                });\n                if (this.address && !this.isInitializing && (((_a = this === null || this === void 0 ? void 0 : this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic || this.pairings.length === 0)) {\n                  this.onClientConnect.onClientLogout();\n                }\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n  }, {\n    key: \"handleSessionEvents\",\n    value: function handleSessionEvents(_ref2) {\n      var topic = _ref2.topic,\n        params = _ref2.params;\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var event, eventData, session;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context15.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                event = params.event;\n                if ((event === null || event === void 0 ? void 0 : event.name) && ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {\n                  eventData = event.data;\n                  session = this.walletConnector.session.get(topic);\n                  this.onClientConnect.onClientEvent(eventData);\n                }\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n    }\n  }, {\n    key: \"subscribeToEvents\",\n    value: function subscribeToEvents(client) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!(typeof client === \"undefined\")) {\n                  _context16.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                client.on(\"session_update\", function (_ref3) {\n                  var topic = _ref3.topic,\n                    params = _ref3.params;\n                  var namespaces = params.namespaces;\n                  var _session = client.session.get(topic);\n                  var updatedSession = Object.assign(Object.assign({}, _session), {\n                    namespaces: namespaces\n                  });\n                  _this3.onSessionConnected({\n                    session: updatedSession\n                  });\n                });\n                client.on(\"session_event\", this.handleSessionEvents.bind(this));\n                client.on(\"session_expire\", this.handleTopicUpdateEvent.bind(this));\n                client.on(\"session_delete\", this.handleTopicUpdateEvent.bind(this));\n                client.on(\"pairing_expire\", this.handleTopicUpdateEvent.bind(this));\n                client.on(\"pairing_delete\", this.handleTopicUpdateEvent.bind(this));\n              case 8:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n  }, {\n    key: \"checkPersistedState\",\n    value: function checkPersistedState(client) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var lastKeyIndex, session;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!(typeof client === \"undefined\")) {\n                  _context17.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                this.pairings = client.pairing.getAll({\n                  active: true\n                });\n                if (!(typeof this.session !== \"undefined\")) {\n                  _context17.next = 5;\n                  break;\n                }\n                return _context17.abrupt(\"return\");\n              case 5:\n                if (!(client.session.length && !this.address && !this.isInitializing)) {\n                  _context17.next = 11;\n                  break;\n                }\n                lastKeyIndex = client.session.keys.length - 1;\n                session = client.session.get(client.session.keys[lastKeyIndex]);\n                _context17.next = 10;\n                return this.onSessionConnected({\n                  session: session\n                });\n              case 10:\n                return _context17.abrupt(\"return\", session);\n              case 11:\n                return _context17.abrupt(\"return\");\n              case 12:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n  }, {\n    key: \"addressIsValid\",\n    value: function addressIsValid(destinationAddress) {\n      try {\n        var addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n        return !!addr;\n      } catch (_a) {\n        return false;\n      }\n    }\n  }, {\n    key: \"getAddressFromSession\",\n    value: function getAddressFromSession(session) {\n      var selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_ELROND_NAMESPACE];\n      if (selectedNamespace && selectedNamespace.accounts) {\n        // Use only the first address in case of multiple provided addresses\n        var currentSession = selectedNamespace.accounts[0];\n        var _currentSession$split = currentSession.split(\":\"),\n          _currentSession$split2 = _slicedToArray(_currentSession$split, 3),\n          namespace = _currentSession$split2[0],\n          reference = _currentSession$split2[1],\n          address = _currentSession$split2[2];\n        return address;\n      }\n      return \"\";\n    }\n  }]);\n  return WalletConnectProviderV2;\n}();\nexports.WalletConnectProviderV2 = WalletConnectProviderV2;","map":{"version":3,"sources":["../src/walletConnectProviderV2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletConnectProviderV2 = void 0;\nconst sign_client_1 = __importDefault(require(\"@walletconnect/sign-client\"));\nconst utils_1 = require(\"@walletconnect/utils\");\nconst constants_1 = require(\"./constants\");\nconst operation_1 = require(\"./operation\");\nconst logger_1 = require(\"./logger\");\nconst primitives_1 = require(\"./primitives\");\nconst userAddress_1 = require(\"./userAddress\");\nclass WalletConnectProviderV2 {\n    constructor(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId) {\n        this.chainId = \"\";\n        this.address = \"\";\n        this.signature = \"\";\n        this.isInitializing = false;\n        this.events = [];\n        this.methods = [];\n        this.onClientConnect = onClientConnect;\n        this.chainId = chainId;\n        this.walletConnectV2Relay = walletConnectV2Relay;\n        this.walletConnectV2ProjectId = walletConnectV2ProjectId;\n    }\n    /**\n     * Initiates WalletConnect client.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const client = yield sign_client_1.default.init({\n                    relayUrl: this.walletConnectV2Relay,\n                    projectId: this.walletConnectV2ProjectId,\n                });\n                this.walletConnector = client;\n                yield this.subscribeToEvents(client);\n                yield this.checkPersistedState(client);\n            }\n            catch (error) {\n                throw new Error(\"connect: WalletConnect is unable to init\");\n            }\n            finally {\n                this.isInitializing = false;\n            }\n            return true;\n        });\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n    isInitialized() {\n        return !!this.walletConnector;\n    }\n    /**\n     * Returns true if provider is initialized and a valid session is set\n     */\n    isConnected() {\n        return new Promise((resolve, _) => resolve(Boolean(this.isInitialized() && typeof this.session !== \"undefined\")));\n    }\n    connect(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                yield this.init();\n            }\n            if (typeof this.walletConnector === \"undefined\") {\n                throw new Error(\"WalletConnect is not initialized\");\n            }\n            const methods = [...Object.values(operation_1.Operation), ...((_a = options === null || options === void 0 ? void 0 : options.methods) !== null && _a !== void 0 ? _a : [])];\n            const chains = [`${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`];\n            const events = (_b = options === null || options === void 0 ? void 0 : options.events) !== null && _b !== void 0 ? _b : [];\n            try {\n                const response = yield this.walletConnector.connect({\n                    pairingTopic: options === null || options === void 0 ? void 0 : options.topic,\n                    requiredNamespaces: {\n                        [constants_1.WALLETCONNECT_ELROND_NAMESPACE]: {\n                            methods,\n                            chains,\n                            events,\n                        },\n                    },\n                });\n                this.events = events;\n                this.methods = methods;\n                return response;\n            }\n            catch (error) {\n                if (options === null || options === void 0 ? void 0 : options.topic) {\n                    yield this.logout({ topic: options.topic });\n                    logger_1.Logger.error(\"connect: WalletConnect is unable to connect to existing pairing\");\n                    throw new Error(\"connect: WalletConnect is unable to connect to existing pairing\");\n                }\n                else {\n                    logger_1.Logger.error(\"connect: WalletConnect is unable to connect\");\n                    throw new Error(\"connect: WalletConnect is unable to connect\");\n                }\n            }\n        });\n    }\n    login(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.isInitializing = true;\n            if (typeof this.walletConnector === \"undefined\") {\n                yield this.connect();\n            }\n            if (typeof this.walletConnector === \"undefined\") {\n                throw new Error(\"WalletConnect is not initialized\");\n            }\n            if (typeof this.session !== \"undefined\") {\n                yield this.logout();\n            }\n            try {\n                if (options && options.approval) {\n                    const session = yield options.approval();\n                    if (options.token) {\n                        const address = this.getAddressFromSession(session);\n                        const { signature } = yield this.walletConnector.request({\n                            chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,\n                            topic: session.topic,\n                            request: {\n                                method: operation_1.Operation.SIGN_LOGIN_TOKEN,\n                                params: {\n                                    token: options.token,\n                                    address,\n                                },\n                            },\n                        });\n                        if (!signature) {\n                            logger_1.Logger.error(\"login: WalletConnect could not sign login token\");\n                            throw new Error(\"WalletConnect could not sign login token\");\n                        }\n                        return yield this.onSessionConnected({\n                            session,\n                            signature,\n                        });\n                    }\n                    return yield this.onSessionConnected({\n                        session,\n                        signature: \"\",\n                    });\n                }\n            }\n            catch (error) {\n                logger_1.Logger.error(\"login: WalletConnect is unable to login\");\n                throw new Error(\"login: WalletConnect is unable to login\");\n            }\n            finally {\n                this.isInitializing = false;\n            }\n            return \"\";\n        });\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n    logout(options) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"logout: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            try {\n                const topic = (_a = options === null || options === void 0 ? void 0 : options.topic) !== null && _a !== void 0 ? _a : (_b = this.session) === null || _b === void 0 ? void 0 : _b.topic;\n                if (topic) {\n                    yield this.walletConnector.disconnect({\n                        topic,\n                        reason: utils_1.getSdkError(\"USER_DISCONNECTED\"),\n                    });\n                    const newPairings = this.walletConnector.pairing\n                        .getAll({ active: true })\n                        .filter((pairing) => pairing.topic !== topic);\n                    this.pairings = newPairings;\n                }\n            }\n            catch (_c) {\n                logger_1.Logger.error(\"logout: WalletConnect was unable to logout\");\n            }\n            return true;\n        });\n    }\n    /**\n     * Fetches the WalletConnect address\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"getAddress: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            return this.address;\n        });\n    }\n    /**\n     * Fetches the WalletConnect signature\n     */\n    getSignature() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"getSignature: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            return this.signature;\n        });\n    }\n    /**\n     * Fetches the WalletConnect pairings\n     */\n    getPairings() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"getPairings: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            return ((_a = this.pairings) !== null && _a !== void 0 ? _a : this.walletConnector.pairing.getAll({ active: true }));\n        });\n    }\n    /**\n     * Method will be available once the Maiar WalletConnect hook is implemented\n     * @param _\n     */\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"signMessage: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const { signature } = yield this.walletConnector.request({\n                chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,\n                topic: this.session.topic,\n                request: {\n                    method: operation_1.Operation.SIGN_MESSAGE,\n                    params: {\n                        address,\n                        message: message.message.toString(),\n                    },\n                },\n            });\n            if (!signature) {\n                logger_1.Logger.error(\"signMessage: WalletConnect could not sign the message\");\n                throw new Error(\"WalletConnect could not sign the message\");\n            }\n            message.applySignature(new primitives_1.Signature(signature), userAddress_1.UserAddress.fromBech32(address));\n            return message;\n        });\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"signTransaction: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const sender = new primitives_1.Address(address);\n            const wcTransaction = transaction.toPlainObject(sender);\n            if (this.chainId !== transaction.getChainID().valueOf()) {\n                logger_1.Logger.error(\"signTransaction: Transaction Chain Id different than Connection Chain Id\");\n                throw new Error(\"Transaction Chain Id different than Connection Chain Id\");\n            }\n            const { signature } = yield this.walletConnector.request({\n                chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,\n                topic: this.session.topic,\n                request: {\n                    method: operation_1.Operation.SIGN_TRANSACTION,\n                    params: {\n                        transaction: wcTransaction,\n                    },\n                },\n            });\n            if (!signature) {\n                logger_1.Logger.error(\"signTransaction: WalletConnect could not sign the transaction\");\n                throw new Error(\"WalletConnect could not sign the transaction\");\n            }\n            transaction.applySignature(primitives_1.Signature.fromHex(signature), userAddress_1.UserAddress.fromBech32(address));\n            return transaction;\n        });\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n    signTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"signTransactions: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const sender = new primitives_1.Address(address);\n            const wcTransactions = transactions.map((transaction) => {\n                if (this.chainId !== transaction.getChainID().valueOf()) {\n                    logger_1.Logger.error(\"signTransactions: Transaction Chain Id different than Connection Chain Id\");\n                    throw new Error(\"Transactions Chain Id different than Connection Chain Id\");\n                }\n                return transaction.toPlainObject(sender);\n            });\n            const { signatures } = yield this.walletConnector.request({\n                chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,\n                topic: this.session.topic,\n                request: {\n                    method: operation_1.Operation.SIGN_TRANSACTIONS,\n                    params: {\n                        transactions: wcTransactions,\n                    },\n                },\n            });\n            if (!signatures || !Array.isArray(signatures)) {\n                logger_1.Logger.error(\"signTransactions: WalletConnect could not sign the transactions\");\n                throw new Error(\"WalletConnect could not sign the transactions\");\n            }\n            if (transactions.length !== signatures.length) {\n                logger_1.Logger.error(\"signTransactions: WalletConnect could not sign the transactions. Invalid signatures.\");\n                throw new Error(\"WalletConnect could not sign the transactions. Invalid signatures.\");\n            }\n            for (const [index, transaction] of transactions.entries()) {\n                transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n            }\n            return transactions;\n        });\n    }\n    /**\n     * Sends a custom request\n     * @param request\n     */\n    sendCustomRequest(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                logger_1.Logger.error(\"sendCustomRequest: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n            }\n            if (options === null || options === void 0 ? void 0 : options.request) {\n                const { response } = yield this.walletConnector.request({\n                    chainId: `${constants_1.WALLETCONNECT_ELROND_NAMESPACE}:${this.chainId}`,\n                    topic: this.session.topic,\n                    request: options.request,\n                });\n                if (!response) {\n                    logger_1.Logger.error(\"sendCustomRequest: WalletConnect could not send the custom request\");\n                    throw new Error(\"WalletConnect could not send the custom request\");\n                }\n                return response;\n            }\n        });\n    }\n    loginAccount(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!options) {\n                return;\n            }\n            if (this.addressIsValid(options.address)) {\n                this.address = options.address;\n                if (options.signature) {\n                    this.signature = options.signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return;\n            }\n            logger_1.Logger.error(`WalletConnect invalid address ${options.address}`);\n            if (((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) && this.walletConnector) {\n                yield this.walletConnector.disconnect({\n                    topic: this.session.topic,\n                    reason: utils_1.getSdkError(\"USER_DISCONNECTED\"),\n                });\n                const newPairings = this.walletConnector.pairing.getAll({ active: true });\n                this.pairings = newPairings;\n            }\n        });\n    }\n    onSessionConnected(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!options) {\n                return \"\";\n            }\n            this.session = options.session;\n            const address = this.getAddressFromSession(options.session);\n            if (address) {\n                yield this.loginAccount({ address, signature: options.signature });\n            }\n            return \"\";\n        });\n    }\n    handleTopicUpdateEvent({ topic, }) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                throw new Error(\"WalletConnect is not initialized\");\n            }\n            this.pairings = this.walletConnector.pairing.getAll({ active: true });\n            if (this.address &&\n                !this.isInitializing &&\n                (((_a = this === null || this === void 0 ? void 0 : this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic || this.pairings.length === 0)) {\n                this.onClientConnect.onClientLogout();\n            }\n        });\n    }\n    handleSessionEvents({ topic, params, }) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof this.walletConnector === \"undefined\") {\n                throw new Error(\"WalletConnect is not initialized\");\n            }\n            const { event } = params;\n            if ((event === null || event === void 0 ? void 0 : event.name) && ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {\n                const eventData = event.data;\n                const session = this.walletConnector.session.get(topic);\n                this.onClientConnect.onClientEvent(eventData);\n            }\n        });\n    }\n    subscribeToEvents(client) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof client === \"undefined\") {\n                throw new Error(\"WalletConnect is not initialized\");\n            }\n            client.on(\"session_update\", ({ topic, params }) => {\n                const { namespaces } = params;\n                const _session = client.session.get(topic);\n                const updatedSession = Object.assign(Object.assign({}, _session), { namespaces });\n                this.onSessionConnected({ session: updatedSession });\n            });\n            client.on(\"session_event\", this.handleSessionEvents.bind(this));\n            client.on(\"session_expire\", this.handleTopicUpdateEvent.bind(this));\n            client.on(\"session_delete\", this.handleTopicUpdateEvent.bind(this));\n            client.on(\"pairing_expire\", this.handleTopicUpdateEvent.bind(this));\n            client.on(\"pairing_delete\", this.handleTopicUpdateEvent.bind(this));\n        });\n    }\n    checkPersistedState(client) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof client === \"undefined\") {\n                throw new Error(\"WalletConnect is not initialized\");\n            }\n            this.pairings = client.pairing.getAll({ active: true });\n            if (typeof this.session !== \"undefined\") {\n                return;\n            }\n            // Populates existing session to state (assume only the top one)\n            if (client.session.length && !this.address && !this.isInitializing) {\n                const lastKeyIndex = client.session.keys.length - 1;\n                const session = client.session.get(client.session.keys[lastKeyIndex]);\n                yield this.onSessionConnected({ session });\n                return session;\n            }\n            return;\n        });\n    }\n    addressIsValid(destinationAddress) {\n        try {\n            const addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n            return !!addr;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    getAddressFromSession(session) {\n        const selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_ELROND_NAMESPACE];\n        if (selectedNamespace && selectedNamespace.accounts) {\n            // Use only the first address in case of multiple provided addresses\n            const currentSession = selectedNamespace.accounts[0];\n            const [namespace, reference, address] = currentSession.split(\":\");\n            return address;\n        }\n        return \"\";\n    }\n}\nexports.WalletConnectProviderV2 = WalletConnectProviderV2;\n//# sourceMappingURL=walletConnectProviderV2.js.map"]},"metadata":{},"sourceType":"script"}