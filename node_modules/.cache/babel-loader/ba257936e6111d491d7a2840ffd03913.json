{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\nvar reflection_1 = require(\"../../reflection\");\nvar utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\nvar Type = /*#__PURE__*/function () {\n  function Type(name) {\n    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n    _classCallCheck(this, Type);\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n  _createClass(Type, [{\n    key: \"getName\",\n    value: function getName() {\n      return this.name;\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return Type.ClassName;\n    }\n  }, {\n    key: \"getClassHierarchy\",\n    value: function getClassHierarchy() {\n      var prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, function (prototype) {\n        return prototype.belongsToTypesystem;\n      });\n      var classNames = prototypes.map(function (prototype) {\n        return prototype.getClassName();\n      }).reverse();\n      return classNames;\n    }\n    /**\n     * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within erdjs' typesystem.\n     */\n  }, {\n    key: \"getFullyQualifiedName\",\n    value: function getFullyQualifiedName() {\n      var joinedTypeParameters = this.getTypeParameters().map(function (type) {\n        return type.getFullyQualifiedName();\n      }).join(\", \");\n      return this.isGenericType() ? \"erdjs:types:\".concat(this.getName(), \"<\").concat(joinedTypeParameters, \">\") : \"erdjs:types:\".concat(this.getName());\n    }\n  }, {\n    key: \"hasExactClass\",\n    value: function hasExactClass(className) {\n      return this.getClassName() == className;\n    }\n  }, {\n    key: \"hasClassOrSuperclass\",\n    value: function hasClassOrSuperclass(className) {\n      var hierarchy = this.getClassHierarchy();\n      return hierarchy.includes(className);\n    }\n  }, {\n    key: \"getTypeParameters\",\n    value: function getTypeParameters() {\n      return this.typeParameters;\n    }\n  }, {\n    key: \"isGenericType\",\n    value: function isGenericType() {\n      return this.typeParameters.length > 0;\n    }\n  }, {\n    key: \"getFirstTypeParameter\",\n    value: function getFirstTypeParameter() {\n      utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n      return this.typeParameters[0];\n    }\n    /**\n     * Generates type expressions similar to elrond-wasm-rs.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var typeParameters = this.getTypeParameters().map(function (type) {\n        return type.toString();\n      }).join(\", \");\n      var typeParametersExpression = typeParameters ? \"<\".concat(typeParameters, \">\") : \"\";\n      return \"\".concat(this.name).concat(typeParametersExpression);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return Type.equals(this, other);\n    }\n  }, {\n    key: \"differs\",\n    value: function differs(other) {\n      return !this.equals(other);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.name;\n    }\n    /**\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n     *\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n     * For example, Option<u32> is assignable from Option<?>.\n     * For more details, see the implementation of {@link OptionType} and @{@link OptionalType}.\n     *\n     * Also see:\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n     */\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(other) {\n      var invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), other.getTypeParameters());\n      if (!invariantTypeParameters) {\n        return false;\n      }\n      var fullyQualifiedNameOfThis = this.getFullyQualifiedName();\n      var fullyQualifiedNamesInHierarchyOfOther = Type.getFullyQualifiedNamesInHierarchy(other);\n      if (fullyQualifiedNamesInHierarchyOfOther.includes(fullyQualifiedNameOfThis)) {\n        return true;\n      }\n      return other.hasClassOrSuperclass(this.getClassName());\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      var dependencies = [];\n      var _iterator = _createForOfIteratorHelper(this.typeParameters),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          dependencies.push(type.getName());\n          dependencies.push.apply(dependencies, _toConsumableArray(type.getNamesOfDependencies()));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return _toConsumableArray(new Set(dependencies));\n    }\n    /**\n     * Converts the account to a pretty, plain JavaScript object.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        typeParameters: this.typeParameters.map(function (item) {\n          return item.toJSON();\n        })\n      };\n    }\n  }, {\n    key: \"getCardinality\",\n    value: function getCardinality() {\n      return this.cardinality;\n    }\n    /**\n     * A special marker for types within erdjs' typesystem.\n     */\n  }, {\n    key: \"belongsToTypesystem\",\n    value: function belongsToTypesystem() {}\n  }], [{\n    key: \"equals\",\n    value: function equals(a, b) {\n      return a.getFullyQualifiedName() == b.getFullyQualifiedName();\n    }\n  }, {\n    key: \"equalsMany\",\n    value: function equalsMany(a, b) {\n      return a.every(function (type, i) {\n        return type.equals(b[i]);\n      });\n    }\n  }, {\n    key: \"isAssignableFromMany\",\n    value: function isAssignableFromMany(a, b) {\n      return a.every(function (type, i) {\n        return type.isAssignableFrom(b[i]);\n      });\n    }\n  }, {\n    key: \"getFullyQualifiedNamesInHierarchy\",\n    value: function getFullyQualifiedNamesInHierarchy(type) {\n      var prototypes = reflection_1.getJavascriptPrototypesInHierarchy(type, function (prototype) {\n        return prototype.belongsToTypesystem;\n      });\n      var fullyQualifiedNames = prototypes.map(function (prototype) {\n        return prototype.getFullyQualifiedName.call(type);\n      });\n      return fullyQualifiedNames;\n    }\n  }]);\n  return Type;\n}();\nexports.Type = Type;\nType.ClassName = \"Type\";\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\nvar TypeCardinality = /*#__PURE__*/function () {\n  function TypeCardinality(lowerBound, upperBound) {\n    _classCallCheck(this, TypeCardinality);\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n  _createClass(TypeCardinality, [{\n    key: \"isSingular\",\n    value: function isSingular() {\n      return this.lowerBound == 1 && this.upperBound == 1;\n    }\n  }, {\n    key: \"isSingularOrNone\",\n    value: function isSingularOrNone() {\n      return this.lowerBound == 0 && this.upperBound == 1;\n    }\n  }, {\n    key: \"isComposite\",\n    value: function isComposite() {\n      return this.upperBound != 1;\n    }\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.lowerBound == this.upperBound;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.lowerBound;\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      return this.upperBound || TypeCardinality.MaxCardinality;\n    }\n  }], [{\n    key: \"fixed\",\n    value: function fixed(value) {\n      return new TypeCardinality(value, value);\n    }\n  }, {\n    key: \"variable\",\n    value: function variable(value) {\n      return new TypeCardinality(0, value);\n    }\n  }]);\n  return TypeCardinality;\n}();\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\nTypeCardinality.MaxCardinality = 4096;\nvar PrimitiveType = /*#__PURE__*/function (_Type) {\n  _inherits(PrimitiveType, _Type);\n  var _super = _createSuper(PrimitiveType);\n  function PrimitiveType(name) {\n    _classCallCheck(this, PrimitiveType);\n    return _super.call(this, name);\n  }\n  _createClass(PrimitiveType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return PrimitiveType.ClassName;\n    }\n  }]);\n  return PrimitiveType;\n}(Type);\nexports.PrimitiveType = PrimitiveType;\nPrimitiveType.ClassName = \"PrimitiveType\";\nvar CustomType = /*#__PURE__*/function (_Type2) {\n  _inherits(CustomType, _Type2);\n  var _super2 = _createSuper(CustomType);\n  function CustomType() {\n    _classCallCheck(this, CustomType);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(CustomType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return CustomType.ClassName;\n    }\n  }]);\n  return CustomType;\n}(Type);\nexports.CustomType = CustomType;\nCustomType.ClassName = \"CustomType\";\nvar TypedValue = /*#__PURE__*/function () {\n  function TypedValue(type) {\n    _classCallCheck(this, TypedValue);\n    this.type = type;\n  }\n  _createClass(TypedValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return TypedValue.ClassName;\n    }\n  }, {\n    key: \"getClassHierarchy\",\n    value: function getClassHierarchy() {\n      var prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, function (prototype) {\n        return prototype.belongsToTypesystem;\n      });\n      var classNames = prototypes.map(function (prototype) {\n        return prototype.getClassName();\n      }).reverse();\n      return classNames;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this.type;\n    }\n  }, {\n    key: \"hasExactClass\",\n    value: function hasExactClass(className) {\n      return this.getClassName() == className;\n    }\n  }, {\n    key: \"hasClassOrSuperclass\",\n    value: function hasClassOrSuperclass(className) {\n      var hierarchy = this.getClassHierarchy();\n      return hierarchy.includes(className);\n    }\n    /**\n     * A special marker for values within erdjs' typesystem.\n     */\n  }, {\n    key: \"belongsToTypesystem\",\n    value: function belongsToTypesystem() {}\n  }]);\n  return TypedValue;\n}();\nexports.TypedValue = TypedValue;\nTypedValue.ClassName = \"TypedValue\";\nvar PrimitiveValue = /*#__PURE__*/function (_TypedValue) {\n  _inherits(PrimitiveValue, _TypedValue);\n  var _super3 = _createSuper(PrimitiveValue);\n  function PrimitiveValue(type) {\n    _classCallCheck(this, PrimitiveValue);\n    return _super3.call(this, type);\n  }\n  _createClass(PrimitiveValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return PrimitiveValue.ClassName;\n    }\n  }]);\n  return PrimitiveValue;\n}(TypedValue);\nexports.PrimitiveValue = PrimitiveValue;\nPrimitiveValue.ClassName = \"PrimitiveValue\";\nfunction isTyped(value) {\n  return value.belongsToTypesystem !== undefined;\n}\nexports.isTyped = isTyped;\nvar TypePlaceholder = /*#__PURE__*/function (_Type3) {\n  _inherits(TypePlaceholder, _Type3);\n  var _super4 = _createSuper(TypePlaceholder);\n  function TypePlaceholder() {\n    _classCallCheck(this, TypePlaceholder);\n    return _super4.call(this, \"...\");\n  }\n  _createClass(TypePlaceholder, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return TypePlaceholder.ClassName;\n    }\n  }]);\n  return TypePlaceholder;\n}(Type);\nexports.TypePlaceholder = TypePlaceholder;\nTypePlaceholder.ClassName = \"TypePlaceholder\";\nvar NullType = /*#__PURE__*/function (_Type4) {\n  _inherits(NullType, _Type4);\n  var _super5 = _createSuper(NullType);\n  function NullType() {\n    _classCallCheck(this, NullType);\n    return _super5.call(this, \"?\");\n  }\n  _createClass(NullType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return NullType.ClassName;\n    }\n  }]);\n  return NullType;\n}(Type);\nexports.NullType = NullType;\nNullType.ClassName = \"NullType\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\nconst reflection_1 = require(\"../../reflection\");\nconst utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\nclass Type {\n    constructor(name, typeParameters = [], cardinality = TypeCardinality.fixed(1)) {\n        utils_1.guardValueIsSet(\"name\", name);\n        this.name = name;\n        this.typeParameters = typeParameters;\n        this.cardinality = cardinality;\n    }\n    getName() {\n        return this.name;\n    }\n    getClassName() {\n        return Type.ClassName;\n    }\n    getClassHierarchy() {\n        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, prototype => prototype.belongsToTypesystem);\n        let classNames = prototypes.map(prototype => prototype.getClassName()).reverse();\n        return classNames;\n    }\n    /**\n     * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within erdjs' typesystem.\n     */\n    getFullyQualifiedName() {\n        let joinedTypeParameters = this.getTypeParameters().map(type => type.getFullyQualifiedName()).join(\", \");\n        return this.isGenericType() ?\n            `erdjs:types:${this.getName()}<${joinedTypeParameters}>` :\n            `erdjs:types:${this.getName()}`;\n    }\n    hasExactClass(className) {\n        return this.getClassName() == className;\n    }\n    hasClassOrSuperclass(className) {\n        let hierarchy = this.getClassHierarchy();\n        return hierarchy.includes(className);\n    }\n    getTypeParameters() {\n        return this.typeParameters;\n    }\n    isGenericType() {\n        return this.typeParameters.length > 0;\n    }\n    getFirstTypeParameter() {\n        utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n        return this.typeParameters[0];\n    }\n    /**\n     * Generates type expressions similar to elrond-wasm-rs.\n     */\n    toString() {\n        let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n        let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n        return `${this.name}${typeParametersExpression}`;\n    }\n    equals(other) {\n        return Type.equals(this, other);\n    }\n    static equals(a, b) {\n        return a.getFullyQualifiedName() == b.getFullyQualifiedName();\n    }\n    static equalsMany(a, b) {\n        return a.every((type, i) => type.equals(b[i]));\n    }\n    static isAssignableFromMany(a, b) {\n        return a.every((type, i) => type.isAssignableFrom(b[i]));\n    }\n    differs(other) {\n        return !this.equals(other);\n    }\n    valueOf() {\n        return this.name;\n    }\n    /**\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n     *\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n     * For example, Option<u32> is assignable from Option<?>.\n     * For more details, see the implementation of {@link OptionType} and @{@link OptionalType}.\n     *\n     * Also see:\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n     */\n    isAssignableFrom(other) {\n        let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), other.getTypeParameters());\n        if (!invariantTypeParameters) {\n            return false;\n        }\n        let fullyQualifiedNameOfThis = this.getFullyQualifiedName();\n        let fullyQualifiedNamesInHierarchyOfOther = Type.getFullyQualifiedNamesInHierarchy(other);\n        if (fullyQualifiedNamesInHierarchyOfOther.includes(fullyQualifiedNameOfThis)) {\n            return true;\n        }\n        return other.hasClassOrSuperclass(this.getClassName());\n    }\n    static getFullyQualifiedNamesInHierarchy(type) {\n        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(type, prototype => prototype.belongsToTypesystem);\n        let fullyQualifiedNames = prototypes.map(prototype => prototype.getFullyQualifiedName.call(type));\n        return fullyQualifiedNames;\n    }\n    getNamesOfDependencies() {\n        const dependencies = [];\n        for (const type of this.typeParameters) {\n            dependencies.push(type.getName());\n            dependencies.push(...type.getNamesOfDependencies());\n        }\n        return [...new Set(dependencies)];\n    }\n    /**\n     * Converts the account to a pretty, plain JavaScript object.\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            typeParameters: this.typeParameters.map(item => item.toJSON())\n        };\n    }\n    getCardinality() {\n        return this.cardinality;\n    }\n    /**\n     * A special marker for types within erdjs' typesystem.\n     */\n    belongsToTypesystem() { }\n}\nexports.Type = Type;\nType.ClassName = \"Type\";\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\nclass TypeCardinality {\n    constructor(lowerBound, upperBound) {\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n    }\n    static fixed(value) {\n        return new TypeCardinality(value, value);\n    }\n    static variable(value) {\n        return new TypeCardinality(0, value);\n    }\n    isSingular() {\n        return this.lowerBound == 1 && this.upperBound == 1;\n    }\n    isSingularOrNone() {\n        return this.lowerBound == 0 && this.upperBound == 1;\n    }\n    isComposite() {\n        return this.upperBound != 1;\n    }\n    isFixed() {\n        return this.lowerBound == this.upperBound;\n    }\n    getLowerBound() {\n        return this.lowerBound;\n    }\n    getUpperBound() {\n        return this.upperBound || TypeCardinality.MaxCardinality;\n    }\n}\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\nTypeCardinality.MaxCardinality = 4096;\nclass PrimitiveType extends Type {\n    constructor(name) {\n        super(name);\n    }\n    getClassName() {\n        return PrimitiveType.ClassName;\n    }\n}\nexports.PrimitiveType = PrimitiveType;\nPrimitiveType.ClassName = \"PrimitiveType\";\nclass CustomType extends Type {\n    getClassName() {\n        return CustomType.ClassName;\n    }\n}\nexports.CustomType = CustomType;\nCustomType.ClassName = \"CustomType\";\nclass TypedValue {\n    constructor(type) {\n        this.type = type;\n    }\n    getClassName() {\n        return TypedValue.ClassName;\n    }\n    getClassHierarchy() {\n        let prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, prototype => prototype.belongsToTypesystem);\n        let classNames = prototypes.map(prototype => prototype.getClassName()).reverse();\n        return classNames;\n    }\n    getType() {\n        return this.type;\n    }\n    hasExactClass(className) {\n        return this.getClassName() == className;\n    }\n    hasClassOrSuperclass(className) {\n        let hierarchy = this.getClassHierarchy();\n        return hierarchy.includes(className);\n    }\n    /**\n     * A special marker for values within erdjs' typesystem.\n     */\n    belongsToTypesystem() { }\n}\nexports.TypedValue = TypedValue;\nTypedValue.ClassName = \"TypedValue\";\nclass PrimitiveValue extends TypedValue {\n    constructor(type) {\n        super(type);\n    }\n    getClassName() {\n        return PrimitiveValue.ClassName;\n    }\n}\nexports.PrimitiveValue = PrimitiveValue;\nPrimitiveValue.ClassName = \"PrimitiveValue\";\nfunction isTyped(value) {\n    return value.belongsToTypesystem !== undefined;\n}\nexports.isTyped = isTyped;\nclass TypePlaceholder extends Type {\n    constructor() {\n        super(\"...\");\n    }\n    getClassName() {\n        return TypePlaceholder.ClassName;\n    }\n}\nexports.TypePlaceholder = TypePlaceholder;\nTypePlaceholder.ClassName = \"TypePlaceholder\";\nclass NullType extends Type {\n    constructor() {\n        super(\"?\");\n    }\n    getClassName() {\n        return NullType.ClassName;\n    }\n}\nexports.NullType = NullType;\nNullType.ClassName = \"NullType\";\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}