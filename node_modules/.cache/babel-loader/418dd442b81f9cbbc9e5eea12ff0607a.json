{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar utils = require('@pixi/utils');\nvar constants = require('@pixi/constants');\nvar Resource = require('./resources/Resource.js');\nvar BufferResource = require('./resources/BufferResource.js');\nvar autoDetectResource = require('./resources/autoDetectResource.js');\nvar settings = require('@pixi/settings');\nvar defaultBufferOptions = {\n  scaleMode: constants.SCALE_MODES.NEAREST,\n  format: constants.FORMATS.RGBA,\n  alphaMode: constants.ALPHA_MODES.NPM\n};\nvar _BaseTexture = /*#__PURE__*/function (_utils$EventEmitter) {\n  _inherits(_BaseTexture, _utils$EventEmitter);\n  var _super = _createSuper(_BaseTexture);\n  function _BaseTexture() {\n    var _this;\n    var resource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, _BaseTexture);\n    _this = _super.call(this);\n    options = options || {};\n    var _options = options,\n      alphaMode = _options.alphaMode,\n      mipmap = _options.mipmap,\n      anisotropicLevel = _options.anisotropicLevel,\n      scaleMode = _options.scaleMode,\n      width = _options.width,\n      height = _options.height,\n      wrapMode = _options.wrapMode,\n      format = _options.format,\n      type = _options.type,\n      target = _options.target,\n      resolution = _options.resolution,\n      resourceOptions = _options.resourceOptions;\n    if (resource && !(resource instanceof Resource.Resource)) {\n      resource = autoDetectResource.autoDetectResource(resource, resourceOptions);\n      resource.internal = true;\n    }\n    _this.resolution = resolution || settings.settings.RESOLUTION;\n    _this.width = Math.round((width || 0) * _this.resolution) / _this.resolution;\n    _this.height = Math.round((height || 0) * _this.resolution) / _this.resolution;\n    _this._mipmap = mipmap !== null && mipmap !== void 0 ? mipmap : settings.settings.MIPMAP_TEXTURES;\n    _this.anisotropicLevel = anisotropicLevel !== null && anisotropicLevel !== void 0 ? anisotropicLevel : settings.settings.ANISOTROPIC_LEVEL;\n    _this._wrapMode = wrapMode || settings.settings.WRAP_MODE;\n    _this._scaleMode = scaleMode !== null && scaleMode !== void 0 ? scaleMode : settings.settings.SCALE_MODE;\n    _this.format = format || constants.FORMATS.RGBA;\n    _this.type = type || constants.TYPES.UNSIGNED_BYTE;\n    _this.target = target || constants.TARGETS.TEXTURE_2D;\n    _this.alphaMode = alphaMode !== null && alphaMode !== void 0 ? alphaMode : constants.ALPHA_MODES.UNPACK;\n    _this.uid = utils.uid();\n    _this.touched = 0;\n    _this.isPowerOfTwo = false;\n    _this._refreshPOT();\n    _this._glTextures = {};\n    _this.dirtyId = 0;\n    _this.dirtyStyleId = 0;\n    _this.cacheId = null;\n    _this.valid = width > 0 && height > 0;\n    _this.textureCacheIds = [];\n    _this.destroyed = false;\n    _this.resource = null;\n    _this._batchEnabled = 0;\n    _this._batchLocation = 0;\n    _this.parentTextureArray = null;\n    _this.setResource(resource);\n    return _this;\n  }\n  _createClass(_BaseTexture, [{\n    key: \"realWidth\",\n    get: function get() {\n      return Math.round(this.width * this.resolution);\n    }\n  }, {\n    key: \"realHeight\",\n    get: function get() {\n      return Math.round(this.height * this.resolution);\n    }\n  }, {\n    key: \"mipmap\",\n    get: function get() {\n      return this._mipmap;\n    },\n    set: function set(value) {\n      if (this._mipmap !== value) {\n        this._mipmap = value;\n        this.dirtyStyleId++;\n      }\n    }\n  }, {\n    key: \"scaleMode\",\n    get: function get() {\n      return this._scaleMode;\n    },\n    set: function set(value) {\n      if (this._scaleMode !== value) {\n        this._scaleMode = value;\n        this.dirtyStyleId++;\n      }\n    }\n  }, {\n    key: \"wrapMode\",\n    get: function get() {\n      return this._wrapMode;\n    },\n    set: function set(value) {\n      if (this._wrapMode !== value) {\n        this._wrapMode = value;\n        this.dirtyStyleId++;\n      }\n    }\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(scaleMode, mipmap) {\n      var dirty;\n      if (scaleMode !== void 0 && scaleMode !== this.scaleMode) {\n        this.scaleMode = scaleMode;\n        dirty = true;\n      }\n      if (mipmap !== void 0 && mipmap !== this.mipmap) {\n        this.mipmap = mipmap;\n        dirty = true;\n      }\n      if (dirty) {\n        this.dirtyStyleId++;\n      }\n      return this;\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(desiredWidth, desiredHeight, resolution) {\n      resolution = resolution || this.resolution;\n      return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n    }\n  }, {\n    key: \"setRealSize\",\n    value: function setRealSize(realWidth, realHeight, resolution) {\n      this.resolution = resolution || this.resolution;\n      this.width = Math.round(realWidth) / this.resolution;\n      this.height = Math.round(realHeight) / this.resolution;\n      this._refreshPOT();\n      this.update();\n      return this;\n    }\n  }, {\n    key: \"_refreshPOT\",\n    value: function _refreshPOT() {\n      this.isPowerOfTwo = utils.isPow2(this.realWidth) && utils.isPow2(this.realHeight);\n    }\n  }, {\n    key: \"setResolution\",\n    value: function setResolution(resolution) {\n      var oldResolution = this.resolution;\n      if (oldResolution === resolution) {\n        return this;\n      }\n      this.resolution = resolution;\n      if (this.valid) {\n        this.width = Math.round(this.width * oldResolution) / resolution;\n        this.height = Math.round(this.height * oldResolution) / resolution;\n        this.emit(\"update\", this);\n      }\n      this._refreshPOT();\n      return this;\n    }\n  }, {\n    key: \"setResource\",\n    value: function setResource(resource) {\n      if (this.resource === resource) {\n        return this;\n      }\n      if (this.resource) {\n        throw new Error(\"Resource can be set only once\");\n      }\n      resource.bind(this);\n      this.resource = resource;\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.valid) {\n        if (this.width > 0 && this.height > 0) {\n          this.valid = true;\n          this.emit(\"loaded\", this);\n          this.emit(\"update\", this);\n        }\n      } else {\n        this.dirtyId++;\n        this.dirtyStyleId++;\n        this.emit(\"update\", this);\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(event) {\n      this.emit(\"error\", this, event);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.resource) {\n        this.resource.unbind(this);\n        if (this.resource.internal) {\n          this.resource.destroy();\n        }\n        this.resource = null;\n      }\n      if (this.cacheId) {\n        delete utils.BaseTextureCache[this.cacheId];\n        delete utils.TextureCache[this.cacheId];\n        this.cacheId = null;\n      }\n      this.dispose();\n      _BaseTexture.removeFromCache(this);\n      this.textureCacheIds = null;\n      this.destroyed = true;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.emit(\"dispose\", this);\n    }\n  }, {\n    key: \"castToBaseTexture\",\n    value: function castToBaseTexture() {\n      return this;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(source, options) {\n      var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : settings.settings.STRICT_TEXTURE_CACHE;\n      var isFrame = typeof source === \"string\";\n      var cacheId = null;\n      if (isFrame) {\n        cacheId = source;\n      } else {\n        if (!source._pixiId) {\n          var prefix = (options === null || options === void 0 ? void 0 : options.pixiIdPrefix) || \"pixiid\";\n          source._pixiId = \"\".concat(prefix, \"_\").concat(utils.uid());\n        }\n        cacheId = source._pixiId;\n      }\n      var baseTexture = utils.BaseTextureCache[cacheId];\n      if (isFrame && strict && !baseTexture) {\n        throw new Error(\"The cacheId \\\"\".concat(cacheId, \"\\\" does not exist in BaseTextureCache.\"));\n      }\n      if (!baseTexture) {\n        baseTexture = new _BaseTexture(source, options);\n        baseTexture.cacheId = cacheId;\n        _BaseTexture.addToCache(baseTexture, cacheId);\n      }\n      return baseTexture;\n    }\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer, width, height, options) {\n      buffer = buffer || new Float32Array(width * height * 4);\n      var resource = new BufferResource.BufferResource(buffer, {\n        width: width,\n        height: height\n      });\n      var type = buffer instanceof Float32Array ? constants.TYPES.FLOAT : constants.TYPES.UNSIGNED_BYTE;\n      return new _BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || {\n        width: width,\n        height: height,\n        type: type\n      }));\n    }\n  }, {\n    key: \"addToCache\",\n    value: function addToCache(baseTexture, id) {\n      if (id) {\n        if (!baseTexture.textureCacheIds.includes(id)) {\n          baseTexture.textureCacheIds.push(id);\n        }\n        if (utils.BaseTextureCache[id]) {\n          console.warn(\"BaseTexture added to the cache with an id [\".concat(id, \"] that already had an entry\"));\n        }\n        utils.BaseTextureCache[id] = baseTexture;\n      }\n    }\n  }, {\n    key: \"removeFromCache\",\n    value: function removeFromCache(baseTexture) {\n      if (typeof baseTexture === \"string\") {\n        var baseTextureFromCache = utils.BaseTextureCache[baseTexture];\n        if (baseTextureFromCache) {\n          var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n          if (index > -1) {\n            baseTextureFromCache.textureCacheIds.splice(index, 1);\n          }\n          delete utils.BaseTextureCache[baseTexture];\n          return baseTextureFromCache;\n        }\n      } else if (baseTexture !== null && baseTexture !== void 0 && baseTexture.textureCacheIds) {\n        for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {\n          delete utils.BaseTextureCache[baseTexture.textureCacheIds[i]];\n        }\n        baseTexture.textureCacheIds.length = 0;\n        return baseTexture;\n      }\n      return null;\n    }\n  }]);\n  return _BaseTexture;\n}(utils.EventEmitter);\nvar BaseTexture = _BaseTexture;\nBaseTexture._globalBatch = 0;\nexports.BaseTexture = BaseTexture;","map":{"version":3,"sources":["../../src/textures/BaseTexture.ts"],"names":["SCALE_MODES","FORMATS","ALPHA_MODES","EventEmitter","Resource","settings","TYPES","TARGETS","uid","isPow2","BaseTextureCache","TextureCache","BufferResource"],"mappings":"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","sourcesContent":["import { BaseTextureCache, EventEmitter, isPow2, TextureCache, uid } from '@pixi/utils';\nimport { FORMATS, SCALE_MODES, TARGETS, TYPES, ALPHA_MODES } from '@pixi/constants';\nimport { Resource } from './resources/Resource';\nimport { BufferResource } from './resources/BufferResource';\nimport { autoDetectResource } from './resources/autoDetectResource';\nimport { settings } from '@pixi/settings';\n\nimport type { MSAA_QUALITY, MIPMAP_MODES, WRAP_MODES } from '@pixi/constants';\nimport type { ICanvas } from '@pixi/settings';\nimport type { IAutoDetectOptions } from './resources/autoDetectResource';\nimport type { GLTexture } from './GLTexture';\n\nconst defaultBufferOptions = {\n    scaleMode: SCALE_MODES.NEAREST,\n    format: FORMATS.RGBA,\n    alphaMode: ALPHA_MODES.NPM,\n};\n\nexport type ImageSource = HTMLImageElement | HTMLVideoElement | ImageBitmap | ICanvas;\n\nexport interface IBaseTextureOptions<RO = any>\n{\n    alphaMode?: ALPHA_MODES;\n    mipmap?: MIPMAP_MODES;\n    anisotropicLevel?: number;\n    scaleMode?: SCALE_MODES;\n    width?: number;\n    height?: number;\n    wrapMode?: WRAP_MODES;\n    format?: FORMATS;\n    type?: TYPES;\n    target?: TARGETS;\n    resolution?: number;\n    multisample?: MSAA_QUALITY;\n    resourceOptions?: RO;\n    pixiIdPrefix?: string;\n}\n\nexport interface BaseTexture extends GlobalMixins.BaseTexture, EventEmitter {}\n\n/**\n * A Texture stores the information that represents an image.\n * All textures have a base texture, which contains information about the source.\n * Therefore you can have many textures all using a single BaseTexture\n * @memberof PIXI\n * @typeParam R - The BaseTexture's Resource type.\n * @typeParam RO - The options for constructing resource.\n */\nexport class BaseTexture<R extends Resource = Resource, RO = IAutoDetectOptions> extends EventEmitter\n{\n    /**\n     * The width of the base texture set when the image has loaded\n     * @readonly\n     */\n    public width: number;\n\n    /**\n     * The height of the base texture set when the image has loaded\n     * @readonly\n     */\n    public height: number;\n\n    /**\n     * The resolution / device pixel ratio of the texture\n     * @readonly\n     * @default PIXI.settings.RESOLUTION\n     */\n    public resolution: number;\n\n    /**\n     * How to treat premultiplied alpha, see {@link PIXI.ALPHA_MODES}.\n     * @member {PIXI.ALPHA_MODES}\n     * @default PIXI.ALPHA_MODES.UNPACK\n     */\n    public alphaMode?: ALPHA_MODES;\n\n    /**\n     * Anisotropic filtering level of texture\n     * @member {number}\n     * @default PIXI.settings.ANISOTROPIC_LEVEL\n     */\n    public anisotropicLevel?: number;\n\n    /**\n     * The pixel format of the texture\n     * @default PIXI.FORMATS.RGBA\n     */\n    public format?: FORMATS;\n\n    /**\n     * The type of resource data\n     * @default PIXI.TYPES.UNSIGNED_BYTE\n     */\n    public type?: TYPES;\n\n    /**\n     * The target type\n     * @default PIXI.TARGETS.TEXTURE_2D\n     */\n    public target?: TARGETS;\n\n    /**\n     * Global unique identifier for this BaseTexture\n     * @protected\n     */\n    public readonly uid: number;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    touched: number;\n\n    /**\n     * Whether or not the texture is a power of two, try to use power of two textures as much\n     * as you can\n     * @readonly\n     * @default false\n     */\n    isPowerOfTwo: boolean;\n\n    /**\n     * The map of render context textures where this is bound\n     * @private\n     */\n    _glTextures: { [key: number]: GLTexture };\n\n    /**\n     * Used by TextureSystem to only update texture to the GPU when needed.\n     * Please call `update()` to increment it.\n     * @readonly\n     */\n    dirtyId: number;\n\n    /**\n     * Used by TextureSystem to only update texture style when needed.\n     * @protected\n     */\n    dirtyStyleId: number;\n\n    /**\n     * Currently default cache ID.\n     * @member {string}\n     */\n    public cacheId: string;\n\n    /**\n     * Generally speaking means when resource is loaded.\n     * @readonly\n     * @member {boolean}\n     */\n    public valid: boolean;\n\n    /**\n     * The collection of alternative cache ids, since some BaseTextures\n     * can have more than one ID, short name and longer full URL\n     * @member {Array<string>}\n     * @readonly\n     */\n    public textureCacheIds: Array<string>;\n\n    /**\n     * Flag if BaseTexture has been destroyed.\n     * @member {boolean}\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * The resource used by this BaseTexture, there can only\n     * be one resource per BaseTexture, but textures can share\n     * resources.\n     * @member {PIXI.Resource}\n     * @readonly\n     */\n    public resource: R;\n\n    /**\n     * Number of the texture batch, used by multi-texture renderers\n     * @member {number}\n     */\n    _batchEnabled: number;\n\n    /**\n     * Location inside texture batch, used by multi-texture renderers\n     * @member {number}\n     */\n    _batchLocation: number;\n\n    /**\n     * Whether its a part of another texture, handled by ArrayResource or CubeResource\n     * @member {PIXI.BaseTexture}\n     */\n    parentTextureArray: BaseTexture;\n\n    private _mipmap?: MIPMAP_MODES;\n    private _scaleMode?: SCALE_MODES;\n    private _wrapMode?: WRAP_MODES;\n\n    /**\n     * @param {PIXI.Resource|HTMLImageElement|HTMLVideoElement|ImageBitmap|ICanvas|string} [resource=null] -\n     *        The current resource to use, for things that aren't Resource objects, will be converted\n     *        into a Resource.\n     * @param options - Collection of options\n     * @param {PIXI.MIPMAP_MODES} [options.mipmap=PIXI.settings.MIPMAP_TEXTURES] - If mipmapping is enabled for texture\n     * @param {number} [options.anisotropicLevel=PIXI.settings.ANISOTROPIC_LEVEL] - Anisotropic filtering level of texture\n     * @param {PIXI.WRAP_MODES} [options.wrapMode=PIXI.settings.WRAP_MODE] - Wrap mode for textures\n     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.settings.SCALE_MODE] - Default scale mode, linear, nearest\n     * @param {PIXI.FORMATS} [options.format=PIXI.FORMATS.RGBA] - GL format type\n     * @param {PIXI.TYPES} [options.type=PIXI.TYPES.UNSIGNED_BYTE] - GL data type\n     * @param {PIXI.TARGETS} [options.target=PIXI.TARGETS.TEXTURE_2D] - GL texture target\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.UNPACK] - Pre multiply the image alpha\n     * @param {number} [options.width=0] - Width of the texture\n     * @param {number} [options.height=0] - Height of the texture\n     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - Resolution of the base texture\n     * @param {object} [options.resourceOptions] - Optional resource options,\n     *        see {@link PIXI.autoDetectResource autoDetectResource}\n     */\n    constructor(resource: R | ImageSource | string | any = null, options: IBaseTextureOptions<RO> = null)\n    {\n        super();\n\n        options = options || {};\n\n        const { alphaMode, mipmap, anisotropicLevel, scaleMode, width, height,\n            wrapMode, format, type, target, resolution, resourceOptions } = options;\n\n        // Convert the resource to a Resource object\n        if (resource && !(resource instanceof Resource))\n        {\n            resource = autoDetectResource<R, RO>(resource, resourceOptions);\n            resource.internal = true;\n        }\n\n        this.resolution = resolution || settings.RESOLUTION;\n        this.width = Math.round((width || 0) * this.resolution) / this.resolution;\n        this.height = Math.round((height || 0) * this.resolution) / this.resolution;\n        this._mipmap = mipmap ?? settings.MIPMAP_TEXTURES;\n        this.anisotropicLevel = anisotropicLevel ?? settings.ANISOTROPIC_LEVEL;\n        this._wrapMode = wrapMode || settings.WRAP_MODE;\n        this._scaleMode = scaleMode ?? settings.SCALE_MODE;\n        this.format = format || FORMATS.RGBA;\n        this.type = type || TYPES.UNSIGNED_BYTE;\n        this.target = target || TARGETS.TEXTURE_2D;\n        this.alphaMode = alphaMode ?? ALPHA_MODES.UNPACK;\n\n        this.uid = uid();\n        this.touched = 0;\n        this.isPowerOfTwo = false;\n        this._refreshPOT();\n\n        this._glTextures = {};\n        this.dirtyId = 0;\n        this.dirtyStyleId = 0;\n        this.cacheId = null;\n        this.valid = width > 0 && height > 0;\n        this.textureCacheIds = [];\n        this.destroyed = false;\n        this.resource = null;\n\n        this._batchEnabled = 0;\n        this._batchLocation = 0;\n        this.parentTextureArray = null;\n\n        /**\n         * Fired when a not-immediately-available source finishes loading.\n         * @protected\n         * @event PIXI.BaseTexture#loaded\n         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.\n         */\n\n        /**\n         * Fired when a not-immediately-available source fails to load.\n         * @protected\n         * @event PIXI.BaseTexture#error\n         * @param {PIXI.BaseTexture} baseTexture - Resource errored.\n         * @param {ErrorEvent} event - Load error event.\n         */\n\n        /**\n         * Fired when BaseTexture is updated.\n         * @protected\n         * @event PIXI.BaseTexture#loaded\n         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.\n         */\n\n        /**\n         * Fired when BaseTexture is updated.\n         * @protected\n         * @event PIXI.BaseTexture#update\n         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.\n         */\n\n        /**\n         * Fired when BaseTexture is destroyed.\n         * @protected\n         * @event PIXI.BaseTexture#dispose\n         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.\n         */\n\n        // Set the resource\n        this.setResource(resource);\n    }\n\n    /**\n     * Pixel width of the source of this texture\n     * @readonly\n     */\n    get realWidth(): number\n    {\n        return Math.round(this.width * this.resolution);\n    }\n\n    /**\n     * Pixel height of the source of this texture\n     * @readonly\n     */\n    get realHeight(): number\n    {\n        return Math.round(this.height * this.resolution);\n    }\n\n    /**\n     * Mipmap mode of the texture, affects downscaled images\n     * @default PIXI.settings.MIPMAP_TEXTURES\n     */\n    get mipmap(): MIPMAP_MODES\n    {\n        return this._mipmap;\n    }\n    set mipmap(value: MIPMAP_MODES)\n    {\n        if (this._mipmap !== value)\n        {\n            this._mipmap = value;\n            this.dirtyStyleId++;\n        }\n    }\n\n    /**\n     * The scale mode to apply when scaling this texture\n     * @default PIXI.settings.SCALE_MODE\n     */\n    get scaleMode(): SCALE_MODES\n    {\n        return this._scaleMode;\n    }\n    set scaleMode(value: SCALE_MODES)\n    {\n        if (this._scaleMode !== value)\n        {\n            this._scaleMode = value;\n            this.dirtyStyleId++;\n        }\n    }\n\n    /**\n     * How the texture wraps\n     * @default PIXI.settings.WRAP_MODE\n     */\n    get wrapMode(): WRAP_MODES\n    {\n        return this._wrapMode;\n    }\n    set wrapMode(value: WRAP_MODES)\n    {\n        if (this._wrapMode !== value)\n        {\n            this._wrapMode = value;\n            this.dirtyStyleId++;\n        }\n    }\n\n    /**\n     * Changes style options of BaseTexture\n     * @param scaleMode - Pixi scalemode\n     * @param mipmap - enable mipmaps\n     * @returns - this\n     */\n    setStyle(scaleMode?: SCALE_MODES, mipmap?: MIPMAP_MODES): this\n    {\n        let dirty;\n\n        if (scaleMode !== undefined && scaleMode !== this.scaleMode)\n        {\n            this.scaleMode = scaleMode;\n            dirty = true;\n        }\n\n        if (mipmap !== undefined && mipmap !== this.mipmap)\n        {\n            this.mipmap = mipmap;\n            dirty = true;\n        }\n\n        if (dirty)\n        {\n            this.dirtyStyleId++;\n        }\n\n        return this;\n    }\n\n    /**\n     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.\n     * @param desiredWidth - Desired visual width\n     * @param desiredHeight - Desired visual height\n     * @param resolution - Optionally set resolution\n     * @returns - this\n     */\n    setSize(desiredWidth: number, desiredHeight: number, resolution?: number): this\n    {\n        resolution = resolution || this.resolution;\n\n        return this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);\n    }\n\n    /**\n     * Sets real size of baseTexture, preserves current resolution.\n     * @param realWidth - Full rendered width\n     * @param realHeight - Full rendered height\n     * @param resolution - Optionally set resolution\n     * @returns - this\n     */\n    setRealSize(realWidth: number, realHeight: number, resolution?: number): this\n    {\n        this.resolution = resolution || this.resolution;\n        this.width = Math.round(realWidth) / this.resolution;\n        this.height = Math.round(realHeight) / this.resolution;\n        this._refreshPOT();\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);\n    }\n\n    /**\n     * Changes resolution\n     * @param resolution - res\n     * @returns - this\n     */\n    setResolution(resolution: number): this\n    {\n        const oldResolution = this.resolution;\n\n        if (oldResolution === resolution)\n        {\n            return this;\n        }\n\n        this.resolution = resolution;\n\n        if (this.valid)\n        {\n            this.width = Math.round(this.width * oldResolution) / resolution;\n            this.height = Math.round(this.height * oldResolution) / resolution;\n            this.emit('update', this);\n        }\n\n        this._refreshPOT();\n\n        return this;\n    }\n\n    /**\n     * Sets the resource if it wasn't set. Throws error if resource already present\n     * @param resource - that is managing this BaseTexture\n     * @returns - this\n     */\n    setResource(resource: R): this\n    {\n        if (this.resource === resource)\n        {\n            return this;\n        }\n\n        if (this.resource)\n        {\n            throw new Error('Resource can be set only once');\n        }\n\n        resource.bind(this);\n\n        this.resource = resource;\n\n        return this;\n    }\n\n    /** Invalidates the object. Texture becomes valid if width and height are greater than zero. */\n    update(): void\n    {\n        if (!this.valid)\n        {\n            if (this.width > 0 && this.height > 0)\n            {\n                this.valid = true;\n                this.emit('loaded', this);\n                this.emit('update', this);\n            }\n        }\n        else\n        {\n            this.dirtyId++;\n            this.dirtyStyleId++;\n            this.emit('update', this);\n        }\n    }\n\n    /**\n     * Handle errors with resources.\n     * @private\n     * @param event - Error event emitted.\n     */\n    onError(event: ErrorEvent): void\n    {\n        this.emit('error', this, event);\n    }\n\n    /**\n     * Destroys this base texture.\n     * The method stops if resource doesn't want this texture to be destroyed.\n     * Removes texture from all caches.\n     */\n    destroy(): void\n    {\n        // remove and destroy the resource\n        if (this.resource)\n        {\n            this.resource.unbind(this);\n            // only destroy resourced created internally\n            if (this.resource.internal)\n            {\n                this.resource.destroy();\n            }\n            this.resource = null;\n        }\n\n        if (this.cacheId)\n        {\n            delete BaseTextureCache[this.cacheId];\n            delete TextureCache[this.cacheId];\n\n            this.cacheId = null;\n        }\n\n        // finally let the WebGL renderer know..\n        this.dispose();\n\n        BaseTexture.removeFromCache(this);\n        this.textureCacheIds = null;\n\n        this.destroyed = true;\n    }\n\n    /**\n     * Frees the texture from WebGL memory without destroying this texture object.\n     * This means you can still use the texture later which will upload it to GPU\n     * memory again.\n     * @fires PIXI.BaseTexture#dispose\n     */\n    dispose(): void\n    {\n        this.emit('dispose', this);\n    }\n\n    /** Utility function for BaseTexture|Texture cast. */\n    castToBaseTexture(): BaseTexture\n    {\n        return this;\n    }\n\n    /**\n     * Helper function that creates a base texture based on the source you provide.\n     * The source can be - image url, image element, canvas element. If the\n     * source is an image url or an image element and not in the base texture\n     * cache, it will be created and loaded.\n     * @static\n     * @param {HTMLImageElement|HTMLVideoElement|ImageBitmap|PIXI.ICanvas|string|string[]} source - The\n     *        source to create base texture from.\n     * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {string} [options.pixiIdPrefix=pixiid] - If a source has no id, this is the prefix of the generated id\n     * @param {boolean} [strict] - Enforce strict-mode, see {@link PIXI.settings.STRICT_TEXTURE_CACHE}.\n     * @returns {PIXI.BaseTexture} The new base texture.\n     */\n    static from<R extends Resource = Resource, RO = IAutoDetectOptions>(source: ImageSource | string | string[],\n        options?: IBaseTextureOptions<RO>, strict = settings.STRICT_TEXTURE_CACHE): BaseTexture<R>\n    {\n        const isFrame = typeof source === 'string';\n        let cacheId = null;\n\n        if (isFrame)\n        {\n            cacheId = source;\n        }\n        else\n        {\n            if (!(source as any)._pixiId)\n            {\n                const prefix = options?.pixiIdPrefix || 'pixiid';\n\n                (source as any)._pixiId = `${prefix}_${uid()}`;\n            }\n\n            cacheId = (source as any)._pixiId;\n        }\n\n        let baseTexture = BaseTextureCache[cacheId] as BaseTexture<R>;\n\n        // Strict-mode rejects invalid cacheIds\n        if (isFrame && strict && !baseTexture)\n        {\n            throw new Error(`The cacheId \"${cacheId}\" does not exist in BaseTextureCache.`);\n        }\n\n        if (!baseTexture)\n        {\n            baseTexture = new BaseTexture<R>(source, options);\n            baseTexture.cacheId = cacheId;\n            BaseTexture.addToCache(baseTexture, cacheId);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Create a new BaseTexture with a BufferResource from a Float32Array.\n     * RGBA values are floats from 0 to 1.\n     * @param {Float32Array|Uint8Array} buffer - The optional array to use, if no data\n     *        is provided, a new Float32Array is created.\n     * @param width - Width of the resource\n     * @param height - Height of the resource\n     * @param options - See {@link PIXI.BaseTexture}'s constructor for options.\n     *        Default properties are different from the constructor's defaults.\n     * @param {PIXI.FORMATS} [options.format=PIXI.FORMATS.RGBA] - GL format type\n     * @param {PIXI.ALPHA_MODES} [options.alphaMode=PIXI.ALPHA_MODES.NPM] - Image alpha, not premultiplied by default\n     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.SCALE_MODES.NEAREST] - Scale mode, pixelating by default\n     * @returns - The resulting new BaseTexture\n     */\n    static fromBuffer(buffer: Float32Array | Uint8Array,\n        width: number, height: number, options?: IBaseTextureOptions): BaseTexture<BufferResource>\n    {\n        buffer = buffer || new Float32Array(width * height * 4);\n\n        const resource = new BufferResource(buffer, { width, height });\n        const type = buffer instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;\n\n        return new BaseTexture(resource, Object.assign({}, defaultBufferOptions, options || { width, height, type }));\n    }\n\n    /**\n     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.\n     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.\n     * @param {string} id - The id that the BaseTexture will be stored against.\n     */\n    static addToCache(baseTexture: BaseTexture, id: string): void\n    {\n        if (id)\n        {\n            if (!baseTexture.textureCacheIds.includes(id))\n            {\n                baseTexture.textureCacheIds.push(id);\n            }\n\n            if (BaseTextureCache[id])\n            {\n                // eslint-disable-next-line no-console\n                console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`);\n            }\n\n            BaseTextureCache[id] = baseTexture;\n        }\n    }\n\n    /**\n     * Remove a BaseTexture from the global BaseTextureCache.\n     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.\n     * @returns {PIXI.BaseTexture|null} The BaseTexture that was removed.\n     */\n    static removeFromCache(baseTexture: string | BaseTexture): BaseTexture | null\n    {\n        if (typeof baseTexture === 'string')\n        {\n            const baseTextureFromCache = BaseTextureCache[baseTexture];\n\n            if (baseTextureFromCache)\n            {\n                const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);\n\n                if (index > -1)\n                {\n                    baseTextureFromCache.textureCacheIds.splice(index, 1);\n                }\n\n                delete BaseTextureCache[baseTexture];\n\n                return baseTextureFromCache;\n            }\n        }\n        else if (baseTexture?.textureCacheIds)\n        {\n            for (let i = 0; i < baseTexture.textureCacheIds.length; ++i)\n            {\n                delete BaseTextureCache[baseTexture.textureCacheIds[i]];\n            }\n\n            baseTexture.textureCacheIds.length = 0;\n\n            return baseTexture;\n        }\n\n        return null;\n    }\n\n    /** Global number of the texture batch, used by multi-texture renderers. */\n    static _globalBatch = 0;\n}\n"]},"metadata":{},"sourceType":"script"}