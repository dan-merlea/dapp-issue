{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar TextFormat = require('./TextFormat.js');\nvar XMLFormat = require('./XMLFormat.js');\nvar XMLStringFormat = require('./XMLStringFormat.js');\nvar formats = [TextFormat.TextFormat, XMLFormat.XMLFormat, XMLStringFormat.XMLStringFormat];\nfunction autoDetectFormat(data) {\n  for (var i = 0; i < formats.length; i++) {\n    if (formats[i].test(data)) {\n      return formats[i];\n    }\n  }\n  return null;\n}\nexports.TextFormat = TextFormat.TextFormat;\nexports.XMLFormat = XMLFormat.XMLFormat;\nexports.XMLStringFormat = XMLStringFormat.XMLStringFormat;\nexports.autoDetectFormat = autoDetectFormat;","map":{"version":3,"sources":["../../src/formats/index.ts"],"names":["XMLStringFormat"],"mappings":";;;;;;;;AAKA,IAAM,OAAU,GAAA,CACZ,UAAA,CAAA,UAAA,EACA,SAAA,CAAA,SAAA,EACAA,eAAAA,CAAAA,eAAAA,CACJ;AAQO,SAAA,gBAAA,CAA0B,IACjC,EAAA;EACI,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,CAAQ,MAAA,EAAQ,CACpC,EAAA,EAAA;IACI,IAAI,OAAQ,CAAA,CAAA,CAAA,CAAG,IAAK,CAAA,IAAI,CACxB,EAAA;MACI,OAAO,OAAQ,CAAA,CAAA,CAAA;IAAA;EACnB;EAGG,OAAA,IAAA;AACX","sourcesContent":["import { TextFormat } from './TextFormat';\nimport { XMLFormat } from './XMLFormat';\nimport { XMLStringFormat } from './XMLStringFormat';\n\n// Registered formats, maybe make this extensible in the future?\nconst formats = [\n    TextFormat,\n    XMLFormat,\n    XMLStringFormat,\n] as const;\n\n/**\n * Auto-detect BitmapFont parsing format based on data.\n * @private\n * @param {any} data - Data to detect format\n * @returns {any} Format or null\n */\nexport function autoDetectFormat(data: unknown): typeof formats[number] | null\n{\n    for (let i = 0; i < formats.length; i++)\n    {\n        if (formats[i].test(data))\n        {\n            return formats[i];\n        }\n    }\n\n    return null;\n}\n\nexport type { IBitmapFontRawData } from './TextFormat';\nexport { TextFormat, XMLFormat, XMLStringFormat };\n"]},"metadata":{},"sourceType":"script"}