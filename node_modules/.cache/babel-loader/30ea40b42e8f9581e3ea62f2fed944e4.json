{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _objectWithoutProperties = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _excluded = [\"chars\", \"padding\", \"resolution\", \"textureWidth\", \"textureHeight\"];\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar text = require('@pixi/text');\nvar index = require('./formats/index.js');\nvar BitmapFontData = require('./BitmapFontData.js');\nrequire('./utils/index.js');\nvar resolveCharacters = require('./utils/resolveCharacters.js');\nvar drawGlyph = require('./utils/drawGlyph.js');\nvar extractCharCode = require('./utils/extractCharCode.js');\nvar _BitmapFont = /*#__PURE__*/function () {\n  function _BitmapFont(data, textures, ownsTextures) {\n    var _distanceField$fieldT, _distanceField$fieldT2;\n    _classCallCheck(this, _BitmapFont);\n    var _data$info = _slicedToArray(data.info, 1),\n      info = _data$info[0];\n    var _data$common = _slicedToArray(data.common, 1),\n      common = _data$common[0];\n    var _data$page = _slicedToArray(data.page, 1),\n      page = _data$page[0];\n    var _data$distanceField = _slicedToArray(data.distanceField, 1),\n      distanceField = _data$distanceField[0];\n    var res = core.utils.getResolutionOfUrl(page.file);\n    var pageTextures = {};\n    this._ownsTextures = ownsTextures;\n    this.font = info.face;\n    this.size = info.size;\n    this.lineHeight = common.lineHeight / res;\n    this.chars = {};\n    this.pageTextures = pageTextures;\n    for (var i = 0; i < data.page.length; i++) {\n      var _data$page$i = data.page[i],\n        id = _data$page$i.id,\n        file = _data$page$i.file;\n      pageTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n      if (distanceField !== null && distanceField !== void 0 && distanceField.fieldType && distanceField.fieldType !== \"none\") {\n        pageTextures[id].baseTexture.alphaMode = core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;\n        pageTextures[id].baseTexture.mipmap = core.MIPMAP_MODES.OFF;\n      }\n    }\n    for (var _i = 0; _i < data.char.length; _i++) {\n      var _data$char$_i = data.char[_i],\n        _id = _data$char$_i.id,\n        page2 = _data$char$_i.page;\n      var _data$char$_i2 = data.char[_i],\n        x = _data$char$_i2.x,\n        y = _data$char$_i2.y,\n        width = _data$char$_i2.width,\n        height = _data$char$_i2.height,\n        xoffset = _data$char$_i2.xoffset,\n        yoffset = _data$char$_i2.yoffset,\n        xadvance = _data$char$_i2.xadvance;\n      x /= res;\n      y /= res;\n      width /= res;\n      height /= res;\n      xoffset /= res;\n      yoffset /= res;\n      xadvance /= res;\n      var rect = new core.Rectangle(x + pageTextures[page2].frame.x / res, y + pageTextures[page2].frame.y / res, width, height);\n      this.chars[_id] = {\n        xOffset: xoffset,\n        yOffset: yoffset,\n        xAdvance: xadvance,\n        kerning: {},\n        texture: new core.Texture(pageTextures[page2].baseTexture, rect),\n        page: page2\n      };\n    }\n    for (var _i2 = 0; _i2 < data.kerning.length; _i2++) {\n      var _data$kerning$_i = data.kerning[_i2],\n        first = _data$kerning$_i.first,\n        second = _data$kerning$_i.second,\n        amount = _data$kerning$_i.amount;\n      first /= res;\n      second /= res;\n      amount /= res;\n      if (this.chars[second]) {\n        this.chars[second].kerning[first] = amount;\n      }\n    }\n    this.distanceFieldRange = distanceField === null || distanceField === void 0 ? void 0 : distanceField.distanceRange;\n    this.distanceFieldType = (_distanceField$fieldT = distanceField === null || distanceField === void 0 ? void 0 : (_distanceField$fieldT2 = distanceField.fieldType) === null || _distanceField$fieldT2 === void 0 ? void 0 : _distanceField$fieldT2.toLowerCase()) !== null && _distanceField$fieldT !== void 0 ? _distanceField$fieldT : \"none\";\n  }\n  _createClass(_BitmapFont, [{\n    key: \"destroy\",\n    value: function destroy() {\n      for (var id in this.chars) {\n        this.chars[id].texture.destroy();\n        this.chars[id].texture = null;\n      }\n      for (var _id2 in this.pageTextures) {\n        if (this._ownsTextures) {\n          this.pageTextures[_id2].destroy(true);\n        }\n        this.pageTextures[_id2] = null;\n      }\n      this.chars = null;\n      this.pageTextures = null;\n    }\n  }], [{\n    key: \"install\",\n    value: function install(data, textures, ownsTextures) {\n      var fontData;\n      if (data instanceof BitmapFontData.BitmapFontData) {\n        fontData = data;\n      } else {\n        var format = index.autoDetectFormat(data);\n        if (!format) {\n          throw new Error(\"Unrecognized data format for font.\");\n        }\n        fontData = format.parse(data);\n      }\n      if (textures instanceof core.Texture) {\n        textures = [textures];\n      }\n      var font = new _BitmapFont(fontData, textures, ownsTextures);\n      _BitmapFont.available[font.font] = font;\n      return font;\n    }\n  }, {\n    key: \"uninstall\",\n    value: function uninstall(name) {\n      var font = _BitmapFont.available[name];\n      if (!font) {\n        throw new Error(\"No font found named '\".concat(name, \"'\"));\n      }\n      font.destroy();\n      delete _BitmapFont.available[name];\n    }\n  }, {\n    key: \"from\",\n    value: function from(name, textStyle, options) {\n      if (!name) {\n        throw new Error(\"[BitmapFont] Property `name` is required.\");\n      }\n      var _Object$assign = Object.assign({}, _BitmapFont.defaultOptions, options),\n        chars = _Object$assign.chars,\n        padding = _Object$assign.padding,\n        resolution = _Object$assign.resolution,\n        textureWidth = _Object$assign.textureWidth,\n        textureHeight = _Object$assign.textureHeight,\n        baseOptions = _objectWithoutProperties(_Object$assign, _excluded);\n      var charsList = resolveCharacters.resolveCharacters(chars);\n      var style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle);\n      var lineWidth = textureWidth;\n      var fontData = new BitmapFontData.BitmapFontData();\n      fontData.info[0] = {\n        face: style.fontFamily,\n        size: style.fontSize\n      };\n      fontData.common[0] = {\n        lineHeight: style.fontSize\n      };\n      var positionX = 0;\n      var positionY = 0;\n      var canvas;\n      var context;\n      var baseTexture;\n      var maxCharHeight = 0;\n      var baseTextures = [];\n      var textures = [];\n      for (var i = 0; i < charsList.length; i++) {\n        if (!canvas) {\n          canvas = core.settings.ADAPTER.createCanvas();\n          canvas.width = textureWidth;\n          canvas.height = textureHeight;\n          context = canvas.getContext(\"2d\");\n          baseTexture = new core.BaseTexture(canvas, _objectSpread({\n            resolution: resolution\n          }, baseOptions));\n          baseTextures.push(baseTexture);\n          textures.push(new core.Texture(baseTexture));\n          fontData.page.push({\n            id: textures.length - 1,\n            file: \"\"\n          });\n        }\n        var character = charsList[i];\n        var metrics = text.TextMetrics.measureText(character, style, false, canvas);\n        var width = metrics.width;\n        var height = Math.ceil(metrics.height);\n        var textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n        if (positionY >= textureHeight - height * resolution) {\n          if (positionY === 0) {\n            throw new Error(\"[BitmapFont] textureHeight \".concat(textureHeight, \"px is too small (fontFamily: '\").concat(style.fontFamily, \"', fontSize: \").concat(style.fontSize, \"px, char: '\").concat(character, \"')\"));\n          }\n          --i;\n          canvas = null;\n          context = null;\n          baseTexture = null;\n          positionY = 0;\n          positionX = 0;\n          maxCharHeight = 0;\n          continue;\n        }\n        maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n        if (textureGlyphWidth * resolution + positionX >= lineWidth) {\n          if (positionX === 0) {\n            throw new Error(\"[BitmapFont] textureWidth \".concat(textureWidth, \"px is too small (fontFamily: '\").concat(style.fontFamily, \"', fontSize: \").concat(style.fontSize, \"px, char: '\").concat(character, \"')\"));\n          }\n          --i;\n          positionY += maxCharHeight * resolution;\n          positionY = Math.ceil(positionY);\n          positionX = 0;\n          maxCharHeight = 0;\n          continue;\n        }\n        drawGlyph.drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n        var id = extractCharCode.extractCharCode(metrics.text);\n        fontData.char.push({\n          id: id,\n          page: textures.length - 1,\n          x: positionX / resolution,\n          y: positionY / resolution,\n          width: textureGlyphWidth,\n          height: height,\n          xoffset: 0,\n          yoffset: 0,\n          xadvance: Math.ceil(width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0))\n        });\n        positionX += (textureGlyphWidth + 2 * padding) * resolution;\n        positionX = Math.ceil(positionX);\n      }\n      for (var _i3 = 0, len = charsList.length; _i3 < len; _i3++) {\n        var first = charsList[_i3];\n        for (var j = 0; j < len; j++) {\n          var second = charsList[j];\n          var c1 = context.measureText(first).width;\n          var c2 = context.measureText(second).width;\n          var total = context.measureText(first + second).width;\n          var amount = total - (c1 + c2);\n          if (amount) {\n            fontData.kerning.push({\n              first: extractCharCode.extractCharCode(first),\n              second: extractCharCode.extractCharCode(second),\n              amount: amount\n            });\n          }\n        }\n      }\n      var font = new _BitmapFont(fontData, textures, true);\n      if (_BitmapFont.available[name] !== void 0) {\n        _BitmapFont.uninstall(name);\n      }\n      _BitmapFont.available[name] = font;\n      return font;\n    }\n  }]);\n  return _BitmapFont;\n}();\nvar BitmapFont = _BitmapFont;\nBitmapFont.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\nBitmapFont.NUMERIC = [[\"0\", \"9\"]];\nBitmapFont.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\nBitmapFont.ASCII = [[\" \", \"~\"]];\nBitmapFont.defaultOptions = {\n  resolution: 1,\n  textureWidth: 512,\n  textureHeight: 512,\n  padding: 4,\n  chars: _BitmapFont.ALPHANUMERIC\n};\nBitmapFont.available = {};\nexports.BitmapFont = BitmapFont;","map":{"version":3,"sources":["../src/BitmapFont.ts"],"names":["ALPHA_MODES","MIPMAP_MODES","Rectangle","Texture","BitmapFontData","autoDetectFormat","resolveCharacters","TextStyle","BaseTexture","TextMetrics","extractCharCode"],"mappings":"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","sourcesContent":["import { ALPHA_MODES, MIPMAP_MODES, settings, Texture, BaseTexture, Rectangle, utils } from '@pixi/core';\nimport { TextStyle, TextMetrics } from '@pixi/text';\nimport { autoDetectFormat } from './formats';\nimport { BitmapFontData } from './BitmapFontData';\nimport { resolveCharacters, drawGlyph, extractCharCode } from './utils';\n\nimport type { IBaseTextureOptions, ICanvas, ICanvasRenderingContext2D, SCALE_MODES } from '@pixi/core';\nimport type { ITextStyle } from '@pixi/text';\n\nexport interface IBitmapFontCharacter\n{\n    xOffset: number;\n    yOffset: number;\n    xAdvance: number;\n    texture: Texture;\n    page: number;\n    kerning: utils.Dict<number>;\n}\n\ntype BaseOptions = Pick<IBaseTextureOptions, 'scaleMode' | 'mipmap' | 'anisotropicLevel' | 'alphaMode'>;\n\n/** @memberof PIXI */\nexport interface IBitmapFontOptions extends BaseOptions\n{\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default PIXI.BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n\n    /**\n     * Optional width of atlas, smaller values to reduce memory.\n     * @default 512\n     */\n    textureWidth?: number;\n\n    /**\n     * Optional height of atlas, smaller values to reduce memory.\n     * @default 512\n     */\n    textureHeight?: number;\n\n    /**\n     * If mipmapping is enabled for texture. For instance, by default PixiJS only enables mipmapping\n     * on Power-of-Two textures. If your textureWidth or textureHeight are not power-of-two, you\n     * may consider enabling mipmapping to get better quality with lower font sizes. Note:\n     * for MSDF/SDF fonts, mipmapping is not supported.\n     * @default PIXI.settings.MIPMAP_TEXTURES\n     */\n    mipmap?: MIPMAP_MODES;\n\n    /**\n     * Anisotropic filtering level of texture.\n     * @default PIXI.settings.ANISOTROPIC_LEVEL\n     */\n    anisotropicLevel?: number;\n\n    /**\n     * Default scale mode, linear, nearest. Nearest can be helpful for bitmap-style fonts.\n     * @default PIXI.settings.SCALE_MODE\n     */\n    scaleMode?: SCALE_MODES;\n\n    /**\n     * Pre multiply the image alpha.  Note: for MSDF/SDF fonts, alphaMode is not supported.\n     * @default PIXI.ALPHA_MODES.UNPACK\n     */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * BitmapFont represents a typeface available for use with the BitmapText class. Use the `install`\n * method for adding a font to be used.\n * @memberof PIXI\n */\nexport class BitmapFont\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public static readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public static readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public static readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public static readonly ASCII = [[' ', '~']];\n\n    /**\n     * Collection of default options when using `BitmapFont.from`.\n     * @property {number} [resolution=1] -\n     * @property {number} [textureWidth=512] -\n     * @property {number} [textureHeight=512] -\n     * @property {number} [padding=4] -\n     * @property {string|string[]|string[][]} chars = PIXI.BitmapFont.ALPHANUMERIC\n     */\n    public static readonly defaultOptions: IBitmapFontOptions = {\n        resolution: 1,\n        textureWidth: 512,\n        textureHeight: 512,\n        padding: 4,\n        chars: BitmapFont.ALPHANUMERIC,\n    };\n\n    /** Collection of available/installed fonts. */\n    public static readonly available: utils.Dict<BitmapFont> = {};\n\n    /** The name of the font face. */\n    public readonly font: string;\n\n    /** The size of the font face in pixels. */\n    public readonly size: number;\n\n    /** The line-height of the font face in pixels. */\n    public readonly lineHeight: number;\n\n    /** The map of characters by character code. */\n    public readonly chars: utils.Dict<IBitmapFontCharacter>;\n\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pageTextures: utils.Dict<Texture>;\n\n    /** The range of the distance field in pixels. */\n    public readonly distanceFieldRange: number;\n\n    /** The kind of distance field for this font or \"none\". */\n    public readonly distanceFieldType: string;\n\n    private _ownsTextures: boolean;\n\n    /**\n     * @param data\n     * @param textures\n     * @param ownsTextures - Setting to `true` will destroy page textures\n     *        when the font is uninstalled.\n     */\n    constructor(data: BitmapFontData, textures: Texture[] | utils.Dict<Texture>, ownsTextures?: boolean)\n    {\n        const [info] = data.info;\n        const [common] = data.common;\n        const [page] = data.page;\n        const [distanceField] = data.distanceField;\n        const res = utils.getResolutionOfUrl(page.file);\n        const pageTextures: utils.Dict<Texture> = {};\n\n        this._ownsTextures = ownsTextures;\n        this.font = info.face;\n        this.size = info.size;\n        this.lineHeight = common.lineHeight / res;\n        this.chars = {};\n        this.pageTextures = pageTextures;\n\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (let i = 0; i < data.page.length; i++)\n        {\n            const { id, file } = data.page[i];\n\n            pageTextures[id] = textures instanceof Array\n                ? textures[i] : textures[file];\n\n            // only MSDF and SDF fonts need no-premultiplied-alpha\n            if (distanceField?.fieldType && distanceField.fieldType !== 'none')\n            {\n                pageTextures[id].baseTexture.alphaMode = ALPHA_MODES.NO_PREMULTIPLIED_ALPHA;\n                pageTextures[id].baseTexture.mipmap = MIPMAP_MODES.OFF;\n            }\n        }\n\n        // parse letters\n        for (let i = 0; i < data.char.length; i++)\n        {\n            const { id, page } = data.char[i];\n            let { x, y, width, height, xoffset, yoffset, xadvance } = data.char[i];\n\n            x /= res;\n            y /= res;\n            width /= res;\n            height /= res;\n            xoffset /= res;\n            yoffset /= res;\n            xadvance /= res;\n\n            const rect = new Rectangle(\n                x + (pageTextures[page].frame.x / res),\n                y + (pageTextures[page].frame.y / res),\n                width,\n                height\n            );\n\n            this.chars[id] = {\n                xOffset: xoffset,\n                yOffset: yoffset,\n                xAdvance: xadvance,\n                kerning: {},\n                texture: new Texture(\n                    pageTextures[page].baseTexture,\n                    rect\n                ),\n                page,\n            };\n        }\n\n        // parse kernings\n        for (let i = 0; i < data.kerning.length; i++)\n        {\n            let { first, second, amount } = data.kerning[i];\n\n            first /= res;\n            second /= res;\n            amount /= res;\n\n            if (this.chars[second])\n            {\n                this.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // Store distance field information\n        this.distanceFieldRange = distanceField?.distanceRange;\n        this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? 'none';\n    }\n\n    /** Remove references to created glyph textures. */\n    public destroy(): void\n    {\n        for (const id in this.chars)\n        {\n            this.chars[id].texture.destroy();\n            this.chars[id].texture = null;\n        }\n\n        for (const id in this.pageTextures)\n        {\n            if (this._ownsTextures)\n            {\n                this.pageTextures[id].destroy(true);\n            }\n\n            this.pageTextures[id] = null;\n        }\n\n        // Set readonly null.\n        (this as any).chars = null;\n        (this as any).pageTextures = null;\n    }\n\n    /**\n     * Register a new bitmap font.\n     * @param data - The\n     *        characters map that could be provided as xml or raw string.\n     * @param textures - List of textures for each page.\n     * @param ownsTextures - Set to `true` to destroy page textures\n     *        when the font is uninstalled. By default fonts created with\n     *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.\n     * @returns {PIXI.BitmapFont} Result font object with font, size, lineHeight\n     *         and char fields.\n     */\n    public static install(\n        data: string | XMLDocument | BitmapFontData,\n        textures: Texture | Texture[] | utils.Dict<Texture>,\n        ownsTextures?: boolean\n    ): BitmapFont\n    {\n        let fontData;\n\n        if (data instanceof BitmapFontData)\n        {\n            fontData = data;\n        }\n        else\n        {\n            const format = autoDetectFormat(data);\n\n            if (!format)\n            {\n                throw new Error('Unrecognized data format for font.');\n            }\n\n            fontData = format.parse(data as any);\n        }\n\n        // Single texture, convert to list\n        if (textures instanceof Texture)\n        {\n            textures = [textures];\n        }\n\n        const font = new BitmapFont(fontData, textures, ownsTextures);\n\n        BitmapFont.available[font.font] = font;\n\n        return font;\n    }\n\n    /**\n     * Remove bitmap font by name.\n     * @param name - Name of the font to uninstall.\n     */\n    public static uninstall(name: string): void\n    {\n        const font = BitmapFont.available[name];\n\n        if (!font)\n        {\n            throw new Error(`No font found named '${name}'`);\n        }\n\n        font.destroy();\n        delete BitmapFont.available[name];\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set. This does not support\n     * kernings yet. With `style` properties, only the following non-layout properties are used:\n     *\n     * - {@link PIXI.TextStyle#dropShadow|dropShadow}\n     * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}\n     * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}\n     * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}\n     * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}\n     * - {@link PIXI.TextStyle#fill|fill}\n     * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}\n     * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}\n     * - {@link PIXI.TextStyle#fontFamily|fontFamily}\n     * - {@link PIXI.TextStyle#fontSize|fontSize}\n     * - {@link PIXI.TextStyle#fontVariant|fontVariant}\n     * - {@link PIXI.TextStyle#fontWeight|fontWeight}\n     * - {@link PIXI.TextStyle#lineJoin|lineJoin}\n     * - {@link PIXI.TextStyle#miterLimit|miterLimit}\n     * - {@link PIXI.TextStyle#stroke|stroke}\n     * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}\n     * - {@link PIXI.TextStyle#textBaseline|textBaseline}\n     * @param name - The name of the custom font to use with BitmapText.\n     * @param textStyle - Style options to render with BitmapFont.\n     * @param options - Setup options for font or name of the font.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFont, BitmapText } from 'pixi.js';\n     *\n     * BitmapFont.from('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText('This is the title', { fontName: 'TitleFont' });\n     */\n    public static from(name: string, textStyle?: TextStyle | Partial<ITextStyle>, options?: IBitmapFontOptions): BitmapFont\n    {\n        if (!name)\n        {\n            throw new Error('[BitmapFont] Property `name` is required.');\n        }\n\n        const {\n            chars,\n            padding,\n            resolution,\n            textureWidth,\n            textureHeight,\n            ...baseOptions } = Object.assign(\n            {}, BitmapFont.defaultOptions, options);\n\n        const charsList = resolveCharacters(chars);\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const lineWidth = textureWidth;\n        const fontData = new BitmapFontData();\n\n        fontData.info[0] = {\n            face: style.fontFamily as string,\n            size: style.fontSize as number,\n        };\n        fontData.common[0] = {\n            lineHeight: style.fontSize as number,\n        };\n\n        let positionX = 0;\n        let positionY = 0;\n\n        let canvas: ICanvas;\n        let context: ICanvasRenderingContext2D;\n        let baseTexture: BaseTexture;\n        let maxCharHeight = 0;\n        const baseTextures: BaseTexture[] = [];\n        const textures: Texture[] = [];\n\n        for (let i = 0; i < charsList.length; i++)\n        {\n            if (!canvas)\n            {\n                canvas = settings.ADAPTER.createCanvas();\n                canvas.width = textureWidth;\n                canvas.height = textureHeight;\n\n                context = canvas.getContext('2d');\n                baseTexture = new BaseTexture(canvas, { resolution, ...baseOptions });\n\n                baseTextures.push(baseTexture);\n                textures.push(new Texture(baseTexture));\n\n                fontData.page.push({\n                    id: textures.length - 1,\n                    file: '',\n                });\n            }\n\n            // Measure glyph dimensions\n            const character = charsList[i];\n            const metrics = TextMetrics.measureText(character, style, false, canvas);\n            const width = metrics.width;\n            const height = Math.ceil(metrics.height);\n\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            // Can't fit char anymore: next canvas please!\n            if (positionY >= textureHeight - (height * resolution))\n            {\n                if (positionY === 0)\n                {\n                    // We don't want user debugging an infinite loop (or do we? :)\n                    throw new Error(`[BitmapFont] textureHeight ${textureHeight}px is too small `\n                        + `(fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);\n                }\n\n                --i;\n\n                // Create new atlas once current has filled up\n                canvas = null;\n                context = null;\n                baseTexture = null;\n                positionY = 0;\n                positionX = 0;\n                maxCharHeight = 0;\n\n                continue;\n            }\n\n            maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n\n            // Wrap line once full row has been rendered\n            if ((textureGlyphWidth * resolution) + positionX >= lineWidth)\n            {\n                if (positionX === 0)\n                {\n                    // Avoid infinite loop (There can be some very wide char like '\\uFDFD'!)\n                    throw new Error(`[BitmapFont] textureWidth ${textureWidth}px is too small `\n                        + `(fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);\n                }\n\n                --i;\n                positionY += maxCharHeight * resolution;\n                positionY = Math.ceil(positionY);\n                positionX = 0;\n                maxCharHeight = 0;\n\n                continue;\n            }\n\n            drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n\n            // Unique (numeric) ID mapping to this glyph\n            const id = extractCharCode(metrics.text);\n\n            // Create a texture holding just the glyph\n            fontData.char.push({\n                id,\n                page: textures.length - 1,\n                x: positionX / resolution,\n                y: positionY / resolution,\n                width: textureGlyphWidth,\n                height,\n                xoffset: 0,\n                yoffset: 0,\n                xadvance: Math.ceil(width\n                        - (style.dropShadow ? style.dropShadowDistance : 0)\n                        - (style.stroke ? style.strokeThickness : 0)),\n            });\n\n            positionX += (textureGlyphWidth + (2 * padding)) * resolution;\n            positionX = Math.ceil(positionX);\n        }\n\n        // Brute-force kerning info, this can be expensive b/c it's an O(n²),\n        // but we're using measureText which is native and fast.\n        for (let i = 0, len = charsList.length; i < len; i++)\n        {\n            const first = charsList[i];\n\n            for (let j = 0; j < len; j++)\n            {\n                const second = charsList[j];\n                const c1 = context.measureText(first).width;\n                const c2 = context.measureText(second).width;\n                const total = context.measureText(first + second).width;\n                const amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    fontData.kerning.push({\n                        first: extractCharCode(first),\n                        second: extractCharCode(second),\n                        amount,\n                    });\n                }\n            }\n        }\n\n        const font = new BitmapFont(fontData, textures, true);\n\n        // Make it easier to replace a font\n        if (BitmapFont.available[name] !== undefined)\n        {\n            BitmapFont.uninstall(name);\n        }\n\n        BitmapFont.available[name] = font;\n\n        return font;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}