{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProtoSerializer = void 0;\nvar errors = __importStar(require(\"../errors\"));\nvar utils_1 = require(\"../smartcontracts/codec/utils\");\nvar compiled_1 = require(\"./compiled\");\nvar constants_1 = require(\"../constants\");\nvar address_1 = require(\"../address\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n/**\n * Hides away the serialization complexity, for each type of object (e.g. transactions).\n \n * The implementation is non-generic, but practical: there's a pair of `serialize` / `deserialize` method for each type of object.\n */\nvar ProtoSerializer = /*#__PURE__*/function () {\n  function ProtoSerializer() {\n    _classCallCheck(this, ProtoSerializer);\n  }\n  _createClass(ProtoSerializer, [{\n    key: \"serializeTransaction\",\n    value:\n    /**\n     * Serializes a Transaction object to a Buffer. Handles low-level conversion logic and field-mappings as well.\n     */\n    function serializeTransaction(transaction) {\n      var receiverPubkey = new address_1.Address(transaction.getReceiver().bech32()).pubkey();\n      var senderPubkey = new address_1.Address(transaction.getSender().bech32()).pubkey();\n      var protoTransaction = new compiled_1.proto.Transaction({\n        // elrond-go's serializer handles nonce == 0 differently, thus we treat 0 as \"undefined\".\n        Nonce: transaction.getNonce().valueOf() ? transaction.getNonce().valueOf() : undefined,\n        Value: this.serializeTransactionValue(transaction.getValue()),\n        RcvAddr: receiverPubkey,\n        RcvUserName: null,\n        SndAddr: senderPubkey,\n        SndUserName: null,\n        GasPrice: transaction.getGasPrice().valueOf(),\n        GasLimit: transaction.getGasLimit().valueOf(),\n        Data: transaction.getData().length() == 0 ? null : transaction.getData().valueOf(),\n        ChainID: Buffer.from(transaction.getChainID().valueOf()),\n        Version: transaction.getVersion().valueOf(),\n        Signature: Buffer.from(transaction.getSignature().hex(), \"hex\")\n      });\n      if (transaction.getOptions().valueOf() !== constants_1.TRANSACTION_OPTIONS_DEFAULT) {\n        protoTransaction.Options = transaction.getOptions().valueOf();\n      }\n      var encoded = compiled_1.proto.Transaction.encode(protoTransaction).finish();\n      var buffer = Buffer.from(encoded);\n      return buffer;\n    }\n    /**\n     * Custom serialization, compatible with elrond-go.\n     */\n  }, {\n    key: \"serializeTransactionValue\",\n    value: function serializeTransactionValue(transactionValue) {\n      var value = new bignumber_js_1.default(transactionValue.toString());\n      if (value.isZero()) {\n        return Buffer.from([0, 0]);\n      }\n      // Will retain the magnitude, as a buffer.\n      var buffer = utils_1.bigIntToBuffer(value);\n      // We prepend the \"positive\" sign marker, in order to be compatible with Elrond Go's \"sign & magnitude\" proto-representation (a custom one).\n      buffer = Buffer.concat([Buffer.from([0x00]), buffer]);\n      return buffer;\n    }\n  }, {\n    key: \"deserializeTransaction\",\n    value: function deserializeTransaction(_buffer) {\n      // Not needed (yet).\n      throw new errors.ErrUnsupportedOperation(\"deserializeTransaction\");\n    }\n  }]);\n  return ProtoSerializer;\n}();\nexports.ProtoSerializer = ProtoSerializer;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;;;;AAAA,IAKaA,eAAe;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IACxB;;;IAGA,8BAAqBC,WAAwB;MACzC,IAAIC,cAAc,GAAG,IAAIC,iBAAO,CAACF,WAAW,CAACG,WAAW,EAAE,CAACC,MAAM,EAAE,CAAC,CAACC,MAAM,EAAE;MAC7E,IAAIC,YAAY,GAAG,IAAIJ,iBAAO,CAACF,WAAW,CAACO,SAAS,EAAE,CAACH,MAAM,EAAE,CAAC,CAACC,MAAM,EAAE;MAEzE,IAAIG,gBAAgB,GAAG,IAAIC,gBAAK,CAACC,WAAW,CAAC;QACzC;QACAC,KAAK,EAAEX,WAAW,CAACY,QAAQ,EAAE,CAACC,OAAO,EAAE,GAAGb,WAAW,CAACY,QAAQ,EAAE,CAACC,OAAO,EAAE,GAAGC,SAAS;QACtFC,KAAK,EAAE,IAAI,CAACC,yBAAyB,CAAChB,WAAW,CAACiB,QAAQ,EAAE,CAAC;QAC7DC,OAAO,EAAEjB,cAAc;QACvBkB,WAAW,EAAE,IAAI;QACjBC,OAAO,EAAEd,YAAY;QACrBe,WAAW,EAAE,IAAI;QACjBC,QAAQ,EAAEtB,WAAW,CAACuB,WAAW,EAAE,CAACV,OAAO,EAAE;QAC7CW,QAAQ,EAAExB,WAAW,CAACyB,WAAW,EAAE,CAACZ,OAAO,EAAE;QAC7Ca,IAAI,EAAE1B,WAAW,CAAC2B,OAAO,EAAE,CAACC,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,GAAG5B,WAAW,CAAC2B,OAAO,EAAE,CAACd,OAAO,EAAE;QAClFgB,OAAO,EAAEC,MAAM,CAACC,IAAI,CAAC/B,WAAW,CAACgC,UAAU,EAAE,CAACnB,OAAO,EAAE,CAAC;QACxDoB,OAAO,EAAEjC,WAAW,CAACkC,UAAU,EAAE,CAACrB,OAAO,EAAE;QAC3CsB,SAAS,EAAEL,MAAM,CAACC,IAAI,CAAC/B,WAAW,CAACoC,YAAY,EAAE,CAACC,GAAG,EAAE,EAAE,KAAK;OACjE,CAAC;MAEF,IAAKrC,WAAW,CAACsC,UAAU,EAAE,CAACzB,OAAO,EAAE,KAAK0B,uCAA2B,EAAG;QACtE/B,gBAAgB,CAACgC,OAAO,GAAGxC,WAAW,CAACsC,UAAU,EAAE,CAACzB,OAAO,EAAE;;MAGjE,IAAI4B,OAAO,GAAGhC,gBAAK,CAACC,WAAW,CAACgC,MAAM,CAAClC,gBAAgB,CAAC,CAACmC,MAAM,EAAE;MACjE,IAAIC,MAAM,GAAGd,MAAM,CAACC,IAAI,CAACU,OAAO,CAAC;MACjC,OAAOG,MAAM;IACjB;IAEA;;;EAAA;IAAA;IAAA,OAGQ,mCAA0BC,gBAAmC;MACjE,IAAIC,KAAK,GAAG,IAAIC,sBAAS,CAACF,gBAAgB,CAACG,QAAQ,EAAE,CAAC;MACtD,IAAIF,KAAK,CAACG,MAAM,EAAE,EAAE;QAChB,OAAOnB,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;MAG9B;MACA,IAAIa,MAAM,GAAGM,sBAAc,CAACJ,KAAK,CAAC;MAClC;MACAF,MAAM,GAAGd,MAAM,CAACqB,MAAM,CAAC,CAACrB,MAAM,CAACC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAEa,MAAM,CAAC,CAAC;MACrD,OAAOA,MAAM;IACjB;EAAC;IAAA;IAAA,OAED,gCAAuBQ,OAAe;MAClC;MACA,MAAM,IAAIC,MAAM,CAACC,uBAAuB,CAAC,wBAAwB,CAAC;IACtE;EAAC;EAAA;AAAA;AApDLC","names":["ProtoSerializer","transaction","receiverPubkey","address_1","getReceiver","bech32","pubkey","senderPubkey","getSender","protoTransaction","compiled_1","Transaction","Nonce","getNonce","valueOf","undefined","Value","serializeTransactionValue","getValue","RcvAddr","RcvUserName","SndAddr","SndUserName","GasPrice","getGasPrice","GasLimit","getGasLimit","Data","getData","length","ChainID","Buffer","from","getChainID","Version","getVersion","Signature","getSignature","hex","getOptions","constants_1","Options","encoded","encode","finish","buffer","transactionValue","value","bignumber_js_1","toString","isZero","utils_1","concat","_buffer","errors","ErrUnsupportedOperation","exports"],"sourceRoot":"","sources":["../../src/proto/serializer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}