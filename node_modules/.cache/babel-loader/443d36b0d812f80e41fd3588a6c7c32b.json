{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnumValue = exports.EnumVariantDefinition = exports.EnumType = void 0;\nvar errors_1 = require(\"../../errors\");\nvar utils_1 = require(\"../../utils\");\nvar fields_1 = require(\"./fields\");\nvar types_1 = require(\"./types\");\nvar SimpleEnumMaxDiscriminant = 256;\nvar EnumType = /*#__PURE__*/function (_types_1$CustomType) {\n  _inherits(EnumType, _types_1$CustomType);\n  var _super = _createSuper(EnumType);\n  function EnumType(name, variants) {\n    var _this;\n    _classCallCheck(this, EnumType);\n    _this = _super.call(this, name);\n    _this.variants = [];\n    _this.variants = variants;\n    return _this;\n  }\n  _createClass(EnumType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return EnumType.ClassName;\n    }\n  }, {\n    key: \"getVariantByDiscriminant\",\n    value: function getVariantByDiscriminant(discriminant) {\n      var result = this.variants.find(function (e) {\n        return e.discriminant == discriminant;\n      });\n      utils_1.guardValueIsSet(\"variant by discriminant (\".concat(discriminant, \")\"), result);\n      return result;\n    }\n  }, {\n    key: \"getVariantByName\",\n    value: function getVariantByName(name) {\n      var result = this.variants.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSet(\"variant by name (\".concat(name, \")\"), result);\n      return result;\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      var dependencies = [];\n      var _iterator = _createForOfIteratorHelper(this.variants),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var variant = _step.value;\n          dependencies.push.apply(dependencies, _toConsumableArray(variant.getNamesOfDependencies()));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return _toConsumableArray(new Set(dependencies));\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var variants = (json.variants || []).map(function (variant) {\n        return EnumVariantDefinition.fromJSON(variant);\n      });\n      return new EnumType(json.name, variants);\n    }\n  }]);\n  return EnumType;\n}(types_1.CustomType);\nexports.EnumType = EnumType;\nEnumType.ClassName = \"EnumType\";\nvar EnumVariantDefinition = /*#__PURE__*/function () {\n  function EnumVariantDefinition(name, discriminant) {\n    var fieldsDefinitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    _classCallCheck(this, EnumVariantDefinition);\n    this.fieldsDefinitions = [];\n    utils_1.guardTrue(discriminant < SimpleEnumMaxDiscriminant, \"discriminant for simple enum should be less than \".concat(SimpleEnumMaxDiscriminant));\n    this.name = name;\n    this.discriminant = discriminant;\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n  _createClass(EnumVariantDefinition, [{\n    key: \"getFieldsDefinitions\",\n    value: function getFieldsDefinitions() {\n      return this.fieldsDefinitions;\n    }\n  }, {\n    key: \"getFieldDefinition\",\n    value: function getFieldDefinition(name) {\n      return this.fieldsDefinitions.find(function (item) {\n        return item.name == name;\n      });\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var definitions = (json.fields || []).map(function (definition) {\n        return fields_1.FieldDefinition.fromJSON(definition);\n      });\n      return new EnumVariantDefinition(json.name, json.discriminant, definitions);\n    }\n  }]);\n  return EnumVariantDefinition;\n}();\nexports.EnumVariantDefinition = EnumVariantDefinition;\nvar EnumValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(EnumValue, _types_1$TypedValue);\n  var _super2 = _createSuper(EnumValue);\n  function EnumValue(type, variant, fields) {\n    var _this2;\n    _classCallCheck(this, EnumValue);\n    _this2 = _super2.call(this, type);\n    _this2.fields = [];\n    _this2.name = variant.name;\n    _this2.discriminant = variant.discriminant;\n    _this2.fields = fields;\n    _this2.fieldsByName = new Map(fields.map(function (field) {\n      return [field.name, field];\n    }));\n    var definitions = variant.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(_this2.fields, definitions);\n    return _this2;\n  }\n  _createClass(EnumValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return EnumValue.ClassName;\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.getType().equals(other.getType())) {\n        return false;\n      }\n      var selfFields = this.getFields();\n      var otherFields = other.getFields();\n      var nameIsSame = this.name == other.name;\n      var discriminantIsSame = this.discriminant == other.discriminant;\n      var fieldsAreSame = fields_1.Fields.equals(selfFields, otherFields);\n      return nameIsSame && discriminantIsSame && fieldsAreSame;\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      return this.fields;\n    }\n  }, {\n    key: \"getFieldValue\",\n    value: function getFieldValue(name) {\n      var field = this.fieldsByName.get(name);\n      if (field) {\n        return field.value.valueOf();\n      }\n      throw new errors_1.ErrMissingFieldOnEnum(name, this.getType().getName());\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var result = {\n        name: this.name,\n        fields: []\n      };\n      this.fields.forEach(function (field) {\n        return result.fields[field.name] = field.value.valueOf();\n      });\n      return result;\n    }\n  }], [{\n    key: \"fromName\",\n    value: function fromName(type, name) {\n      var variant = type.getVariantByName(name);\n      return new EnumValue(type, variant, []);\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n  }, {\n    key: \"fromDiscriminant\",\n    value: function fromDiscriminant(type, discriminant) {\n      var variant = type.getVariantByDiscriminant(discriminant);\n      return new EnumValue(type, variant, []);\n    }\n  }]);\n  return EnumValue;\n}(types_1.TypedValue);\nexports.EnumValue = EnumValue;\nEnumValue.ClassName = \"EnumValue\";","map":null,"metadata":{},"sourceType":"script"}