{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionWatcher = void 0;\nvar asyncTimer_1 = require(\"./asyncTimer\");\nvar logger_1 = require(\"./logger\");\nvar errors_1 = require(\"./errors\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\nvar TransactionWatcher = /*#__PURE__*/function () {\n  /**\n   *\n   * @param fetcher The transaction fetcher\n   * @param pollingInterval The polling interval, in milliseconds\n   * @param timeout The timeout, in milliseconds\n   */\n  function TransactionWatcher(fetcher) {\n    var pollingInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TransactionWatcher.DefaultPollingInterval;\n    var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TransactionWatcher.DefaultTimeout;\n    _classCallCheck(this, TransactionWatcher);\n    this.fetcher = new TransactionFetcherWithTracing(fetcher);\n    this.pollingInterval = pollingInterval;\n    this.timeout = timeout;\n  }\n  /**\n   * Waits until the transaction reaches the \"pending\" status.\n   */\n  _createClass(TransactionWatcher, [{\n    key: \"awaitPending\",\n    value: function awaitPending(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this = this;\n        var isPending, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                isPending = function isPending(transaction) {\n                  return transaction.status.isPending();\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context.abrupt(\"return\", _context.sent);\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionStatusNotReached();\n                };\n                return _context2.abrupt(\"return\", this.awaitConditionally(isPending, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n      * Waits until the transaction is completely processed.\n      */\n  }, {\n    key: \"awaitCompleted\",\n    value: function awaitCompleted(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n        var isCompleted, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isCompleted = function isCompleted(transactionOnNetwork) {\n                  return transactionOnNetwork.isCompleted;\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context3.abrupt(\"return\", _context3.sent);\n                          case 3:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionStatusNotReached();\n                };\n                return _context4.abrupt(\"return\", this.awaitConditionally(isCompleted, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"awaitAllEvents\",\n    value: function awaitAllEvents(transaction, events) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this3 = this;\n        var foundAllEvents, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                foundAllEvents = function foundAllEvents(transactionOnNetwork) {\n                  var allEventIdentifiers = _this3.getAllTransactionEvents(transactionOnNetwork).map(function (event) {\n                    return event.identifier;\n                  });\n                  var allAreFound = events.every(function (event) {\n                    return allEventIdentifiers.includes(event);\n                  });\n                  return allAreFound;\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context5.abrupt(\"return\", _context5.sent);\n                          case 3:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionEventsNotFound();\n                };\n                return _context6.abrupt(\"return\", this.awaitConditionally(foundAllEvents, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"awaitAnyEvent\",\n    value: function awaitAnyEvent(transaction, events) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this4 = this;\n        var foundAnyEvent, doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                foundAnyEvent = function foundAnyEvent(transactionOnNetwork) {\n                  var allEventIdentifiers = _this4.getAllTransactionEvents(transactionOnNetwork).map(function (event) {\n                    return event.identifier;\n                  });\n                  var anyIsFound = events.find(function (event) {\n                    return allEventIdentifiers.includes(event);\n                  }) != undefined;\n                  return anyIsFound;\n                };\n                doFetch = function doFetch() {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n                    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            _context7.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context7.abrupt(\"return\", _context7.sent);\n                          case 3:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionEventsNotFound();\n                };\n                return _context8.abrupt(\"return\", this.awaitConditionally(foundAnyEvent, doFetch, errorProvider));\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"awaitOnCondition\",\n    value: function awaitOnCondition(transaction, condition) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this5 = this;\n        var doFetch, errorProvider;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                doFetch = function doFetch() {\n                  return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n                    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n                      while (1) {\n                        switch (_context9.prev = _context9.next) {\n                          case 0:\n                            _context9.next = 2;\n                            return this.fetcher.getTransaction(transaction.getHash().hex());\n                          case 2:\n                            return _context9.abrupt(\"return\", _context9.sent);\n                          case 3:\n                          case \"end\":\n                            return _context9.stop();\n                        }\n                      }\n                    }, _callee9, this);\n                  }));\n                };\n                errorProvider = function errorProvider() {\n                  return new errors_1.ErrExpectedTransactionStatusNotReached();\n                };\n                return _context10.abrupt(\"return\", this.awaitConditionally(condition, doFetch, errorProvider));\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"awaitConditionally\",\n    value: function awaitConditionally(isSatisfied, doFetch, createError) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var periodicTimer, timeoutTimer, stop, fetchedData, satisfied;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n                timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n                stop = false;\n                fetchedData = undefined;\n                satisfied = false;\n                timeoutTimer.start(this.timeout).finally(function () {\n                  timeoutTimer.stop();\n                  stop = true;\n                });\n              case 6:\n                if (stop) {\n                  _context11.next = 25;\n                  break;\n                }\n                _context11.next = 9;\n                return periodicTimer.start(this.pollingInterval);\n              case 9:\n                _context11.prev = 9;\n                _context11.next = 12;\n                return doFetch();\n              case 12:\n                fetchedData = _context11.sent;\n                satisfied = isSatisfied(fetchedData);\n                if (!(satisfied || stop)) {\n                  _context11.next = 16;\n                  break;\n                }\n                return _context11.abrupt(\"break\", 25);\n              case 16:\n                _context11.next = 23;\n                break;\n              case 18:\n                _context11.prev = 18;\n                _context11.t0 = _context11[\"catch\"](9);\n                logger_1.Logger.debug(\"TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.\");\n                if (_context11.t0 instanceof errors_1.Err) {\n                  _context11.next = 23;\n                  break;\n                }\n                throw _context11.t0;\n              case 23:\n                _context11.next = 6;\n                break;\n              case 25:\n                if (!timeoutTimer.isStopped()) {\n                  timeoutTimer.stop();\n                }\n                if (!(!fetchedData || !satisfied)) {\n                  _context11.next = 28;\n                  break;\n                }\n                throw createError();\n              case 28:\n                return _context11.abrupt(\"return\", fetchedData);\n              case 29:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[9, 18]]);\n      }));\n    }\n  }, {\n    key: \"getAllTransactionEvents\",\n    value: function getAllTransactionEvents(transaction) {\n      var result = _toConsumableArray(transaction.logs.events);\n      var _iterator = _createForOfIteratorHelper(transaction.contractResults.items),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var resultItem = _step.value;\n          result.push.apply(result, _toConsumableArray(resultItem.logs.events));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n  }]);\n  return TransactionWatcher;\n}();\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\nTransactionWatcher.NoopOnStatusReceived = function (_) {};\nvar TransactionFetcherWithTracing = /*#__PURE__*/function () {\n  function TransactionFetcherWithTracing(fetcher) {\n    _classCallCheck(this, TransactionFetcherWithTracing);\n    this.fetcher = fetcher;\n  }\n  _createClass(TransactionFetcherWithTracing, [{\n    key: \"getTransaction\",\n    value: function getTransaction(txHash) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                logger_1.Logger.debug(\"transactionWatcher, getTransaction(\".concat(txHash, \")\"));\n                _context12.next = 3;\n                return this.fetcher.getTransaction(txHash);\n              case 3:\n                return _context12.abrupt(\"return\", _context12.sent);\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }]);\n  return TransactionFetcherWithTracing;\n}();","map":{"version":3,"sources":["../src/transactionWatcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionWatcher = void 0;\nconst asyncTimer_1 = require(\"./asyncTimer\");\nconst logger_1 = require(\"./logger\");\nconst errors_1 = require(\"./errors\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\nclass TransactionWatcher {\n    /**\n     *\n     * @param fetcher The transaction fetcher\n     * @param pollingInterval The polling interval, in milliseconds\n     * @param timeout The timeout, in milliseconds\n     */\n    constructor(fetcher, pollingInterval = TransactionWatcher.DefaultPollingInterval, timeout = TransactionWatcher.DefaultTimeout) {\n        this.fetcher = new TransactionFetcherWithTracing(fetcher);\n        this.pollingInterval = pollingInterval;\n        this.timeout = timeout;\n    }\n    /**\n     * Waits until the transaction reaches the \"pending\" status.\n     */\n    awaitPending(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const isPending = (transaction) => transaction.status.isPending();\n            const doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(transaction.getHash().hex()); });\n            const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();\n            return this.awaitConditionally(isPending, doFetch, errorProvider);\n        });\n    }\n    /**\n      * Waits until the transaction is completely processed.\n      */\n    awaitCompleted(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const isCompleted = (transactionOnNetwork) => transactionOnNetwork.isCompleted;\n            const doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(transaction.getHash().hex()); });\n            const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();\n            return this.awaitConditionally(isCompleted, doFetch, errorProvider);\n        });\n    }\n    awaitAllEvents(transaction, events) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const foundAllEvents = (transactionOnNetwork) => {\n                const allEventIdentifiers = this.getAllTransactionEvents(transactionOnNetwork).map(event => event.identifier);\n                const allAreFound = events.every(event => allEventIdentifiers.includes(event));\n                return allAreFound;\n            };\n            const doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(transaction.getHash().hex()); });\n            const errorProvider = () => new errors_1.ErrExpectedTransactionEventsNotFound();\n            return this.awaitConditionally(foundAllEvents, doFetch, errorProvider);\n        });\n    }\n    awaitAnyEvent(transaction, events) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const foundAnyEvent = (transactionOnNetwork) => {\n                const allEventIdentifiers = this.getAllTransactionEvents(transactionOnNetwork).map(event => event.identifier);\n                const anyIsFound = events.find(event => allEventIdentifiers.includes(event)) != undefined;\n                return anyIsFound;\n            };\n            const doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(transaction.getHash().hex()); });\n            const errorProvider = () => new errors_1.ErrExpectedTransactionEventsNotFound();\n            return this.awaitConditionally(foundAnyEvent, doFetch, errorProvider);\n        });\n    }\n    awaitOnCondition(transaction, condition) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(transaction.getHash().hex()); });\n            const errorProvider = () => new errors_1.ErrExpectedTransactionStatusNotReached();\n            return this.awaitConditionally(condition, doFetch, errorProvider);\n        });\n    }\n    awaitConditionally(isSatisfied, doFetch, createError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n            const timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n            let stop = false;\n            let fetchedData = undefined;\n            let satisfied = false;\n            timeoutTimer.start(this.timeout).finally(() => {\n                timeoutTimer.stop();\n                stop = true;\n            });\n            while (!stop) {\n                yield periodicTimer.start(this.pollingInterval);\n                try {\n                    fetchedData = yield doFetch();\n                    satisfied = isSatisfied(fetchedData);\n                    if (satisfied || stop) {\n                        break;\n                    }\n                }\n                catch (error) {\n                    logger_1.Logger.debug(\"TransactionWatcher.awaitConditionally(): cannot (yet) fetch data.\");\n                    if (!(error instanceof errors_1.Err)) {\n                        throw error;\n                    }\n                }\n            }\n            if (!timeoutTimer.isStopped()) {\n                timeoutTimer.stop();\n            }\n            if (!fetchedData || !satisfied) {\n                throw createError();\n            }\n            return fetchedData;\n        });\n    }\n    getAllTransactionEvents(transaction) {\n        const result = [...transaction.logs.events];\n        for (const resultItem of transaction.contractResults.items) {\n            result.push(...resultItem.logs.events);\n        }\n        return result;\n    }\n}\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\nTransactionWatcher.NoopOnStatusReceived = (_) => { };\nclass TransactionFetcherWithTracing {\n    constructor(fetcher) {\n        this.fetcher = fetcher;\n    }\n    getTransaction(txHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger_1.Logger.debug(`transactionWatcher, getTransaction(${txHash})`);\n            return yield this.fetcher.getTransaction(txHash);\n        });\n    }\n}\n//# sourceMappingURL=transactionWatcher.js.map"]},"metadata":{},"sourceType":"script"}