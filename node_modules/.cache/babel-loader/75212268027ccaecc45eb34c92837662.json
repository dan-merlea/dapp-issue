{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnumValue = exports.EnumVariantDefinition = exports.EnumType = void 0;\nvar errors_1 = require(\"../../errors\");\nvar utils_1 = require(\"../../utils\");\nvar fields_1 = require(\"./fields\");\nvar types_1 = require(\"./types\");\nvar SimpleEnumMaxDiscriminant = 256;\nvar EnumType = /*#__PURE__*/function (_types_1$CustomType) {\n  _inherits(EnumType, _types_1$CustomType);\n  var _super = _createSuper(EnumType);\n  function EnumType(name, variants) {\n    var _this;\n    _classCallCheck(this, EnumType);\n    _this = _super.call(this, name);\n    _this.variants = [];\n    _this.variants = variants;\n    return _this;\n  }\n  _createClass(EnumType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return EnumType.ClassName;\n    }\n  }, {\n    key: \"getVariantByDiscriminant\",\n    value: function getVariantByDiscriminant(discriminant) {\n      var result = this.variants.find(function (e) {\n        return e.discriminant == discriminant;\n      });\n      utils_1.guardValueIsSet(\"variant by discriminant (\".concat(discriminant, \")\"), result);\n      return result;\n    }\n  }, {\n    key: \"getVariantByName\",\n    value: function getVariantByName(name) {\n      var result = this.variants.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSet(\"variant by name (\".concat(name, \")\"), result);\n      return result;\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      var dependencies = [];\n      var _iterator = _createForOfIteratorHelper(this.variants),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var variant = _step.value;\n          dependencies.push.apply(dependencies, _toConsumableArray(variant.getNamesOfDependencies()));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return _toConsumableArray(new Set(dependencies));\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var variants = (json.variants || []).map(function (variant) {\n        return EnumVariantDefinition.fromJSON(variant);\n      });\n      return new EnumType(json.name, variants);\n    }\n  }]);\n  return EnumType;\n}(types_1.CustomType);\nexports.EnumType = EnumType;\nEnumType.ClassName = \"EnumType\";\nvar EnumVariantDefinition = /*#__PURE__*/function () {\n  function EnumVariantDefinition(name, discriminant) {\n    var fieldsDefinitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    _classCallCheck(this, EnumVariantDefinition);\n    this.fieldsDefinitions = [];\n    utils_1.guardTrue(discriminant < SimpleEnumMaxDiscriminant, \"discriminant for simple enum should be less than \".concat(SimpleEnumMaxDiscriminant));\n    this.name = name;\n    this.discriminant = discriminant;\n    this.fieldsDefinitions = fieldsDefinitions;\n  }\n  _createClass(EnumVariantDefinition, [{\n    key: \"getFieldsDefinitions\",\n    value: function getFieldsDefinitions() {\n      return this.fieldsDefinitions;\n    }\n  }, {\n    key: \"getFieldDefinition\",\n    value: function getFieldDefinition(name) {\n      return this.fieldsDefinitions.find(function (item) {\n        return item.name == name;\n      });\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var definitions = (json.fields || []).map(function (definition) {\n        return fields_1.FieldDefinition.fromJSON(definition);\n      });\n      return new EnumVariantDefinition(json.name, json.discriminant, definitions);\n    }\n  }]);\n  return EnumVariantDefinition;\n}();\nexports.EnumVariantDefinition = EnumVariantDefinition;\nvar EnumValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(EnumValue, _types_1$TypedValue);\n  var _super2 = _createSuper(EnumValue);\n  function EnumValue(type, variant, fields) {\n    var _this2;\n    _classCallCheck(this, EnumValue);\n    _this2 = _super2.call(this, type);\n    _this2.fields = [];\n    _this2.name = variant.name;\n    _this2.discriminant = variant.discriminant;\n    _this2.fields = fields;\n    _this2.fieldsByName = new Map(fields.map(function (field) {\n      return [field.name, field];\n    }));\n    var definitions = variant.getFieldsDefinitions();\n    fields_1.Fields.checkTyping(_this2.fields, definitions);\n    return _this2;\n  }\n  _createClass(EnumValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return EnumValue.ClassName;\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.getType().equals(other.getType())) {\n        return false;\n      }\n      var selfFields = this.getFields();\n      var otherFields = other.getFields();\n      var nameIsSame = this.name == other.name;\n      var discriminantIsSame = this.discriminant == other.discriminant;\n      var fieldsAreSame = fields_1.Fields.equals(selfFields, otherFields);\n      return nameIsSame && discriminantIsSame && fieldsAreSame;\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      return this.fields;\n    }\n  }, {\n    key: \"getFieldValue\",\n    value: function getFieldValue(name) {\n      var field = this.fieldsByName.get(name);\n      if (field) {\n        return field.value.valueOf();\n      }\n      throw new errors_1.ErrMissingFieldOnEnum(name, this.getType().getName());\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var result = {\n        name: this.name,\n        fields: []\n      };\n      this.fields.forEach(function (field) {\n        return result.fields[field.name] = field.value.valueOf();\n      });\n      return result;\n    }\n  }], [{\n    key: \"fromName\",\n    value: function fromName(type, name) {\n      var variant = type.getVariantByName(name);\n      return new EnumValue(type, variant, []);\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n  }, {\n    key: \"fromDiscriminant\",\n    value: function fromDiscriminant(type, discriminant) {\n      var variant = type.getVariantByDiscriminant(discriminant);\n      return new EnumValue(type, variant, []);\n    }\n  }]);\n  return EnumValue;\n}(types_1.TypedValue);\nexports.EnumValue = EnumValue;\nEnumValue.ClassName = \"EnumValue\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/enum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EnumValue = exports.EnumVariantDefinition = exports.EnumType = void 0;\nconst errors_1 = require(\"../../errors\");\nconst utils_1 = require(\"../../utils\");\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nconst SimpleEnumMaxDiscriminant = 256;\nclass EnumType extends types_1.CustomType {\n    constructor(name, variants) {\n        super(name);\n        this.variants = [];\n        this.variants = variants;\n    }\n    getClassName() {\n        return EnumType.ClassName;\n    }\n    static fromJSON(json) {\n        let variants = (json.variants || []).map((variant) => EnumVariantDefinition.fromJSON(variant));\n        return new EnumType(json.name, variants);\n    }\n    getVariantByDiscriminant(discriminant) {\n        let result = this.variants.find((e) => e.discriminant == discriminant);\n        utils_1.guardValueIsSet(`variant by discriminant (${discriminant})`, result);\n        return result;\n    }\n    getVariantByName(name) {\n        let result = this.variants.find((e) => e.name == name);\n        utils_1.guardValueIsSet(`variant by name (${name})`, result);\n        return result;\n    }\n    getNamesOfDependencies() {\n        const dependencies = [];\n        for (const variant of this.variants) {\n            dependencies.push(...variant.getNamesOfDependencies());\n        }\n        return [...new Set(dependencies)];\n    }\n}\nexports.EnumType = EnumType;\nEnumType.ClassName = \"EnumType\";\nclass EnumVariantDefinition {\n    constructor(name, discriminant, fieldsDefinitions = []) {\n        this.fieldsDefinitions = [];\n        utils_1.guardTrue(discriminant < SimpleEnumMaxDiscriminant, `discriminant for simple enum should be less than ${SimpleEnumMaxDiscriminant}`);\n        this.name = name;\n        this.discriminant = discriminant;\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map((definition) => fields_1.FieldDefinition.fromJSON(definition));\n        return new EnumVariantDefinition(json.name, json.discriminant, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n    getFieldDefinition(name) {\n        return this.fieldsDefinitions.find(item => item.name == name);\n    }\n    getNamesOfDependencies() {\n        return fields_1.Fields.getNamesOfTypeDependencies(this.fieldsDefinitions);\n    }\n}\nexports.EnumVariantDefinition = EnumVariantDefinition;\nclass EnumValue extends types_1.TypedValue {\n    constructor(type, variant, fields) {\n        super(type);\n        this.fields = [];\n        this.name = variant.name;\n        this.discriminant = variant.discriminant;\n        this.fields = fields;\n        this.fieldsByName = new Map(fields.map(field => [field.name, field]));\n        let definitions = variant.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    getClassName() {\n        return EnumValue.ClassName;\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n    static fromName(type, name) {\n        let variant = type.getVariantByName(name);\n        return new EnumValue(type, variant, []);\n    }\n    /**\n     * Utility (named constructor) to create a simple (i.e. without fields) enum value.\n     */\n    static fromDiscriminant(type, discriminant) {\n        let variant = type.getVariantByDiscriminant(discriminant);\n        return new EnumValue(type, variant, []);\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        const nameIsSame = this.name == other.name;\n        const discriminantIsSame = this.discriminant == other.discriminant;\n        const fieldsAreSame = fields_1.Fields.equals(selfFields, otherFields);\n        return nameIsSame && discriminantIsSame && fieldsAreSame;\n    }\n    getFields() {\n        return this.fields;\n    }\n    getFieldValue(name) {\n        let field = this.fieldsByName.get(name);\n        if (field) {\n            return field.value.valueOf();\n        }\n        throw new errors_1.ErrMissingFieldOnEnum(name, this.getType().getName());\n    }\n    valueOf() {\n        let result = { name: this.name, fields: [] };\n        this.fields.forEach((field) => (result.fields[field.name] = field.value.valueOf()));\n        return result;\n    }\n}\nexports.EnumValue = EnumValue;\nEnumValue.ClassName = \"EnumValue\";\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}