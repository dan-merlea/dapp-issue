{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProvider = void 0;\nvar client_1 = __importDefault(require(\"@walletconnect/client\"));\nvar constants_1 = require(\"./constants\");\nvar logger_1 = require(\"./logger\");\nvar errors_1 = require(\"./errors\");\nvar primitives_1 = require(\"./primitives\");\nvar userAddress_1 = require(\"./userAddress\");\nvar WalletConnectProvider = /*#__PURE__*/function () {\n  function WalletConnectProvider(walletConnectBridge, onClientConnect) {\n    _classCallCheck(this, WalletConnectProvider);\n    this.address = \"\";\n    this.signature = \"\";\n    this.walletConnectBridge = walletConnectBridge;\n    this.onClientConnect = onClientConnect;\n  }\n  /**\n   * Initiates wallet connect client.\n   */\n  _createClass(WalletConnectProvider, [{\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this$walletConnector, account, _account$split, _account$split2, address, signature;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.walletConnector = new client_1.default({\n                  bridge: this.walletConnectBridge\n                });\n                this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n                this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n                this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n                if (!(this.walletConnector.connected && this.walletConnector.accounts.length)) {\n                  _context.next = 9;\n                  break;\n                }\n                _this$walletConnector = _slicedToArray(this.walletConnector.accounts, 1), account = _this$walletConnector[0];\n                _account$split = account.split(\".\"), _account$split2 = _slicedToArray(_account$split, 2), address = _account$split2[0], signature = _account$split2[1];\n                _context.next = 9;\n                return this.loginAccount(address, signature);\n              case 9:\n                return _context.abrupt(\"return\", true);\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !!this.walletConnector;\n    }\n    /**\n     * Returns true if provider is connected and a valid account is set\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var _this = this;\n      return new Promise(function (resolve, _) {\n        var _a;\n        return resolve(Boolean(_this.isInitialized() && ((_a = _this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) && _this.address));\n      });\n    }\n  }, {\n    key: \"login\",\n    value: function login() {\n      var _a, _b, _c, _d;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context2.next = 3;\n                  break;\n                }\n                _context2.next = 3;\n                return this.init();\n              case 3:\n                if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                  _context2.next = 8;\n                  break;\n                }\n                _context2.next = 6;\n                return this.walletConnector.killSession();\n              case 6:\n                logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n                return _context2.abrupt(\"return\", \"\");\n              case 8:\n                _context2.next = 10;\n                return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({\n                  chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID\n                });\n              case 10:\n                if ((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri) {\n                  _context2.next = 12;\n                  break;\n                }\n                return _context2.abrupt(\"return\", \"\");\n              case 12:\n                return _context2.abrupt(\"return\", (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri);\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context3.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n              case 3:\n                if (!this.walletConnector.connected) {\n                  _context3.next = 6;\n                  break;\n                }\n                _context3.next = 6;\n                return (_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.killSession();\n              case 6:\n                return _context3.abrupt(\"return\", true);\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Fetches the wallet connect address\n     */\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context4.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n              case 3:\n                return _context4.abrupt(\"return\", this.address);\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Fetches the wallet connect signature\n     */\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context5.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n              case 3:\n                return _context5.abrupt(\"return\", this.signature);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Method will be available once the Maiar wallet connect hook is implemented\n     * @param _\n     */\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(_) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                throw new errors_1.ErrNotImplemented();\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var address, sig;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context7.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n              case 3:\n                _context7.next = 5;\n                return this.getAddress();\n              case 5:\n                address = _context7.sent;\n                _context7.next = 8;\n                return this.walletConnector.sendCustomRequest({\n                  method: \"erd_sign\",\n                  params: this.prepareWalletConnectMessage(transaction, address)\n                });\n              case 8:\n                sig = _context7.sent;\n                if (!(!sig || !sig.signature)) {\n                  _context7.next = 12;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n                throw new Error(\"Wallet Connect could not sign the transaction\");\n              case 12:\n                transaction.applySignature(primitives_1.Signature.fromHex(sig.signature), userAddress_1.UserAddress.fromBech32(address));\n                return _context7.abrupt(\"return\", transaction);\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(transactions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _this2 = this;\n        var signedTransaction, address, params, signatures, _iterator, _step, _step$value, index, transaction;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(transactions.length === 1)) {\n                  _context8.next = 5;\n                  break;\n                }\n                _context8.next = 3;\n                return this.signTransaction(transactions[0]);\n              case 3:\n                signedTransaction = _context8.sent;\n                return _context8.abrupt(\"return\", [signedTransaction]);\n              case 5:\n                if (this.walletConnector) {\n                  _context8.next = 8;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n              case 8:\n                _context8.next = 10;\n                return this.getAddress();\n              case 10:\n                address = _context8.sent;\n                params = transactions.map(function (transaction) {\n                  return _this2.prepareWalletConnectMessage(transaction, address);\n                });\n                _context8.next = 14;\n                return this.walletConnector.sendCustomRequest({\n                  method: \"erd_batch_sign\",\n                  params: params\n                });\n              case 14:\n                signatures = _context8.sent;\n                if (!(!signatures || !Array.isArray(signatures))) {\n                  _context8.next = 18;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n                throw new Error(\"Wallet Connect could not sign the transactions\");\n              case 18:\n                if (!(transactions.length !== signatures.length)) {\n                  _context8.next = 21;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n                throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n              case 21:\n                _iterator = _createForOfIteratorHelper(transactions.entries());\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], transaction = _step$value[1];\n                    transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n                return _context8.abrupt(\"return\", transactions);\n              case 24:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Sends a custom method and params and returns the response object\n     */\n  }, {\n    key: \"sendCustomMessage\",\n    value: function sendCustomMessage(_ref) {\n      var method = _ref.method,\n        params = _ref.params;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var customMessageResponse;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context9.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n              case 3:\n                _context9.next = 5;\n                return this.walletConnector.sendCustomRequest({\n                  method: method,\n                  params: params\n                });\n              case 5:\n                customMessageResponse = _context9.sent;\n                if (customMessageResponse) {\n                  _context9.next = 9;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n                throw new Error(\"Wallet Connect could not send the message\");\n              case 9:\n                return _context9.abrupt(\"return\", customMessageResponse);\n              case 10:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(error, _ref2) {\n      var params = _ref2.params;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _params$0$accounts, account, _account$split3, _account$split4, address, signature;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!error) {\n                  _context10.next = 2;\n                  break;\n                }\n                throw error;\n              case 2:\n                if (!(!params || !params[0])) {\n                  _context10.next = 5;\n                  break;\n                }\n                logger_1.Logger.error(\"Wallet Connect missing payload\");\n                throw new Error(\"missing payload\");\n              case 5:\n                _params$0$accounts = _slicedToArray(params[0].accounts, 1), account = _params$0$accounts[0];\n                _account$split3 = account.split(\".\"), _account$split4 = _slicedToArray(_account$split3, 2), address = _account$split4[0], signature = _account$split4[1];\n                _context10.next = 9;\n                return this.loginAccount(address, signature);\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(error) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!error) {\n                  _context11.next = 2;\n                  break;\n                }\n                throw error;\n              case 2:\n                this.onClientConnect.onClientLogout();\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"loginAccount\",\n    value: function loginAccount(address, signature) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!this.addressIsValid(address)) {\n                  _context12.next = 5;\n                  break;\n                }\n                this.address = address;\n                if (signature) {\n                  this.signature = signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return _context12.abrupt(\"return\");\n              case 5:\n                logger_1.Logger.error(\"Wallet Connect invalid address \".concat(address));\n                if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                  _context12.next = 9;\n                  break;\n                }\n                _context12.next = 9;\n                return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n              case 9:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"prepareWalletConnectMessage\",\n    value: function prepareWalletConnectMessage(transaction, address) {\n      return {\n        nonce: transaction.getNonce().valueOf(),\n        from: address,\n        to: transaction.getReceiver().toString(),\n        amount: transaction.getValue().toString(),\n        gasPrice: transaction.getGasPrice().valueOf().toString(),\n        gasLimit: transaction.getGasLimit().valueOf().toString(),\n        data: Buffer.from(transaction.getData().toString().trim()).toString(),\n        chainId: transaction.getChainID().valueOf(),\n        version: transaction.getVersion().valueOf()\n      };\n    }\n  }, {\n    key: \"addressIsValid\",\n    value: function addressIsValid(destinationAddress) {\n      try {\n        var addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n        return !!addr;\n      } catch (_a) {\n        return false;\n      }\n    }\n  }]);\n  return WalletConnectProvider;\n}();\nexports.WalletConnectProvider = WalletConnectProvider;","map":{"version":3,"mappings":"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","names":["WalletConnectProvider","walletConnectBridge","onClientConnect","walletConnector","client_1","bridge","on","onConnect","bind","onDisconnect","connected","accounts","length","account","split","address","signature","loginAccount","Promise","resolve","_","Boolean","isInitialized","init","killSession","logger_1","trace","createSession","chainId","constants_1","uri","error","Error","errors_1","transaction","getAddress","sendCustomRequest","method","params","prepareWalletConnectMessage","sig","applySignature","primitives_1","fromHex","userAddress_1","fromBech32","transactions","signTransaction","signedTransaction","map","signatures","Array","isArray","entries","index","customMessageResponse","onClientLogout","addressIsValid","onClientLogin","nonce","getNonce","valueOf","from","to","getReceiver","toString","amount","getValue","gasPrice","getGasPrice","gasLimit","getGasLimit","data","Buffer","getData","trim","getChainID","version","getVersion","destinationAddress","addr","exports"],"sourceRoot":"","sources":["../src/walletConnectProvider.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}