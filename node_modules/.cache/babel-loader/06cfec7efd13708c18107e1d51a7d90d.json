{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar assets = require('@pixi/assets');\nvar BitmapFont = require('./BitmapFont.js');\nrequire('./formats/index.js');\nvar TextFormat = require('./formats/TextFormat.js');\nvar XMLStringFormat = require('./formats/XMLStringFormat.js');\nvar validExtensions = [\".xml\", \".fnt\"];\nvar loadBitmapFont = {\n  extension: {\n    type: core.ExtensionType.LoadParser,\n    priority: assets.LoaderParserPriority.Normal\n  },\n  test: function test(url) {\n    return validExtensions.includes(core.utils.path.extname(url));\n  },\n  testParse: function testParse(data) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", TextFormat.TextFormat.test(data) || XMLStringFormat.XMLStringFormat.test(data));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  parse: function parse(asset, data, loader) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var fontData, src, pages, textureUrls, i, pageFile, imagePath, loadedTextures, textures;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              fontData = TextFormat.TextFormat.test(asset) ? TextFormat.TextFormat.parse(asset) : XMLStringFormat.XMLStringFormat.parse(asset);\n              src = data.src;\n              pages = fontData.page;\n              textureUrls = [];\n              for (i = 0; i < pages.length; ++i) {\n                pageFile = pages[i].file;\n                imagePath = core.utils.path.join(core.utils.path.dirname(src), pageFile);\n                textureUrls.push(imagePath);\n              }\n              _context2.next = 7;\n              return loader.load(textureUrls);\n            case 7:\n              loadedTextures = _context2.sent;\n              textures = textureUrls.map(function (url) {\n                return loadedTextures[url];\n              });\n              return _context2.abrupt(\"return\", BitmapFont.BitmapFont.install(fontData, textures, true));\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n  load: function load(url, _options) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var response;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return core.settings.ADAPTER.fetch(url);\n            case 2:\n              response = _context3.sent;\n              return _context3.abrupt(\"return\", response.text());\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n  unload: function unload(bitmapFont) {\n    bitmapFont.destroy();\n  }\n};\ncore.extensions.add(loadBitmapFont);\nexports.loadBitmapFont = loadBitmapFont;","map":{"version":3,"sources":["../src/loadBitmapFont.ts"],"names":["ExtensionType","LoaderParserPriority","TextFormat","XMLStringFormat","utils","BitmapFont","settings","extensions"],"mappings":";;;;;;;;;;;;;AASA,IAAM,eAAA,GAAkB,CAAC,MAAA,EAAQ,MAAM,CAAA;AAGhC,IAAM,cAAiB,GAAA;EAC1B,SAAW,EAAA;IACP,IAAA,EAAMA,IAAAA,CAAAA,aAAc,CAAA,UAAA;IACpB,QAAA,EAAUC,MAAAA,CAAAA,oBAAqB,CAAA;EAAA,CACnC;EAEA,IAAA,gBAAK,GACL,EAAA;IACI,OAAO,eAAA,CAAgB,QAAS,CAAA,IAAA,CAAA,KAAA,CAAM,IAAK,CAAA,OAAA,CAAQ,GAAG,CAAC,CAAA;EAAA,CAC3D;EAEM,SAAA,qBAAU,IAChB,EAAA;IAAA;MAAA;QAAA;UAAA;YAAA;cAAA,iCACWC,UAAAA,CAAAA,UAAAA,CAAW,IAAK,CAAA,IAAI,CAAK,IAAA,eAAA,CAAA,eAAA,CAAgB,IAAA,CAAK,IAAI,CAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EAAA,CAC7D;EAEM,KAAA,iBAAM,KAAe,EAAA,IAAA,EAAiB,MAC5C,EAAA;IAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cACU,QAAA,GAA2BA,UAAAA,CAAAA,UAAW,CAAA,IAAA,CAAK,KAAK,CAAA,GAChDA,UAAAA,CAAAA,UAAW,CAAA,KAAA,CAAM,KAAK,CAAA,GACtBC,eAAAA,CAAAA,eAAgB,CAAA,KAAA,CAAM,KAAK,CAAA;cAEzB,GAAQ,GAAA,IAAA,CAAR,GAAQ;cACF,KAAU,GAAA,QAAA,CAAhB,IAAA;cACF,WAAA,GAAc,EAAC;cAErB,KAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,KAAM,CAAA,MAAA,EAAQ,EAAE,CACpC,EAAA;gBACU,QAAA,GAAW,KAAA,CAAM,CAAG,CAAA,CAAA,IAAA;gBACpB,SAAA,GAAYC,IAAAA,CAAAA,KAAAA,CAAM,IAAK,CAAA,IAAA,CAAKA,IAAAA,CAAAA,KAAAA,CAAM,IAAK,CAAA,OAAA,CAAQ,GAAG,CAAA,EAAG,QAAQ,CAAA;gBAEnE,WAAA,CAAY,IAAA,CAAK,SAAS,CAAA;cAAA;cAC9B;cAAA,OAE6B,MAAO,CAAA,IAAA,CAAK,WAAW,CAAA;YAAA;cAA9C,cAAiB;cACjB,QAAA,GAAW,WAAY,CAAA,GAAA,CAAI,UAAC,GAAA;gBAAA,OAAQ,cAAA,CAAe,GAAI,CAAA;cAAA,EAAA;cAAA,kCAEtDC,UAAAA,CAAAA,UAAW,CAAA,OAAA,CAAQ,QAAU,EAAA,QAAA,EAAU,IAAI,CAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EAAA,CACtD;EAEM,IAAK,gBAAA,GAAA,EAAa,QACxB,EAAA;IAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OAC2BC,IAAAA,CAAAA,QAAS,CAAA,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA;YAAA;cAA3C,QAAW;cAAA,kCAEV,QAAA,CAAS,IAAK,EAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EAAA,CACzB;EAEA,MAAA,kBAAO,UACP,EAAA;IACI,UAAA,CAAW,OAAQ,EAAA;EAAA;AAE3B,CAAA;AAEAC,IAAAA,CAAAA,UAAAA,CAAW,GAAA,CAAI,cAAc,CAAA","sourcesContent":["import type { Texture } from '@pixi/core';\nimport { settings, utils, extensions, ExtensionType } from '@pixi/core';\n\nimport type { LoadAsset, Loader, LoaderParser } from '@pixi/assets';\nimport { LoaderParserPriority } from '@pixi/assets';\nimport { BitmapFont } from './BitmapFont';\nimport type { BitmapFontData } from './BitmapFontData';\nimport { TextFormat, XMLStringFormat } from './formats';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(utils.path.extname(url));\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return TextFormat.test(data) || XMLStringFormat.test(data);\n    },\n\n    async parse(asset: string, data: LoadAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const fontData: BitmapFontData = TextFormat.test(asset)\n            ? TextFormat.parse(asset)\n            : XMLStringFormat.parse(asset);\n\n        const { src } = data;\n        const { page: pages } = fontData;\n        const textureUrls = [];\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            const imagePath = utils.path.join(utils.path.dirname(src), pageFile);\n\n            textureUrls.push(imagePath);\n        }\n\n        const loadedTextures = await loader.load(textureUrls) as Record<string, Texture>;\n        const textures = textureUrls.map((url) => loadedTextures[url]);\n\n        return BitmapFont.install(fontData, textures, true);\n    },\n\n    async load(url: string, _options: LoadAsset): Promise<string>\n    {\n        const response = await settings.ADAPTER.fetch(url);\n\n        return response.text();\n    },\n\n    unload(bitmapFont: BitmapFont): void\n    {\n        bitmapFont.destroy();\n    }\n} as LoaderParser<BitmapFont | string>;\n\nextensions.add(loadBitmapFont);\n"]},"metadata":{},"sourceType":"script"}