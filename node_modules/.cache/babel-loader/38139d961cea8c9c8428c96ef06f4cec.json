{"ast":null,"code":"\"use strict\";\n\nvar _construct = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/construct.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tuple = exports.TupleType = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar struct_1 = require(\"./struct\");\nvar fields_1 = require(\"./fields\");\nvar struct_2 = require(\"./struct\");\nvar TupleType = /*#__PURE__*/function (_struct_2$StructType) {\n  _inherits(TupleType, _struct_2$StructType);\n  var _super = _createSuper(TupleType);\n  function TupleType() {\n    _classCallCheck(this, TupleType);\n    for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      typeParameters[_key] = arguments[_key];\n    }\n    return _super.call(this, TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n  }\n  _createClass(TupleType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return TupleType.ClassName;\n    }\n  }], [{\n    key: \"prepareName\",\n    value: function prepareName(typeParameters) {\n      var fields = typeParameters.map(function (type) {\n        return type.toString();\n      }).join(\", \");\n      var result = \"tuple\".concat(fields.length, \"<\").concat(fields, \">\");\n      return result;\n    }\n  }, {\n    key: \"prepareFieldDefinitions\",\n    value: function prepareFieldDefinitions(typeParameters) {\n      var result = typeParameters.map(function (type, i) {\n        return new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type);\n      });\n      return result;\n    }\n  }]);\n  return TupleType;\n}(struct_2.StructType);\nexports.TupleType = TupleType;\nTupleType.ClassName = \"TupleType\";\nfunction prepareFieldName(fieldIndex) {\n  return \"field\".concat(fieldIndex);\n}\n// TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\nvar Tuple = /*#__PURE__*/function (_struct_1$Struct) {\n  _inherits(Tuple, _struct_1$Struct);\n  var _super2 = _createSuper(Tuple);\n  function Tuple(type, fields) {\n    _classCallCheck(this, Tuple);\n    return _super2.call(this, type, fields);\n  }\n  _createClass(Tuple, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return Tuple.ClassName;\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems(items) {\n      if (items.length < 1) {\n        // TODO: Define a better error.\n        throw new errors.ErrTypingSystem(\"bad tuple items\");\n      }\n      var fieldsTypes = items.map(function (item) {\n        return item.getType();\n      });\n      var tupleType = _construct(TupleType, _toConsumableArray(fieldsTypes));\n      var fields = items.map(function (item, i) {\n        return new fields_1.Field(item, prepareFieldName(i));\n      });\n      return new Tuple(tupleType, fields);\n    }\n  }]);\n  return Tuple;\n}(struct_1.Struct);\nexports.Tuple = Tuple;\nTuple.ClassName = \"Tuple\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/tuple.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAAsC,IAEzB,SAAU;EAAA;EAAA;EAGnB,qBAAqC;IAAA;IAAA,kCAAtB,cAAsB;MAAtB,cAAsB;IAAA;IAAA,yBAC3B,SAAS,CAAC,WAAW,CAAC,cAAc,CAAC,EAAE,SAAS,CAAC,uBAAuB,CAAC,cAAc,CAAC;EAClG;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,SAAS,CAAC,SAAS;IAC9B;EAAC;IAAA;IAAA,OAEO,qBAAmB,cAAsB,EAAA;MAC7C,IAAI,MAAM,GAAW,cAAc,CAAC,GAAG,CAAC,UAAA,IAAI;QAAA,OAAI,IAAI,CAAC,QAAQ,EAAE;MAAA,EAAC,CAAC,IAAI,CAAC,IAAI,CAAC;MAC3E,IAAI,MAAM,kBAAW,MAAM,CAAC,MAAM,cAAI,MAAM,MAAG;MAC/C,OAAO,MAAM;IACjB;EAAC;IAAA;IAAA,OAEO,iCAA+B,cAAsB,EAAA;MACzD,IAAI,MAAM,GAAG,cAAc,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,CAAC;QAAA,OAAK,IAAI,QAAA,CAAA,eAAe,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,uBAAuB,EAAE,IAAI,CAAC;MAAA,EAAC;MACrH,OAAO,MAAM;IACjB;EAAC;EAAA;AAAA,EApB0B,QAAA,CAAA,UAAU;AAAzC,OAAA,CAAA,SAAA,GAAA,SAAA;AACW,SAAA,CAAA,SAAS,GAAG,WAAW;AAsBlC,SAAS,gBAAgB,CAAC,UAAkB,EAAA;EACxC,sBAAe,UAAU;AAC7B;AAEA;AACA;AACA;AAAA,IACa,KAAM;EAAA;EAAA;EAGf,eAAY,IAAe,EAAE,MAAe,EAAA;IAAA;IAAA,0BAClC,IAAI,EAAE,MAAM;EACtB;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,KAAK,CAAC,SAAS;IAC1B;EAAC;IAAA;IAAA,OAED,mBAAiB,KAAmB,EAAA;MAChC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QAClB;QACA,MAAM,IAAI,MAAM,CAAC,eAAe,CAAC,iBAAiB,CAAC;MACtD;MAED,IAAI,WAAW,GAAG,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;QAAA,OAAI,IAAI,CAAC,OAAO,EAAE;MAAA,EAAC;MACnD,IAAI,SAAS,cAAO,SAAS,qBAAI,WAAW,EAAC;MAC7C,IAAI,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,UAAC,IAAI,EAAE,CAAC;QAAA,OAAK,IAAI,QAAA,CAAA,KAAK,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC;MAAA,EAAC;MAEzE,OAAO,IAAI,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC;IACvC;EAAC;EAAA;AAAA,EAtBsB,QAAA,CAAA,MAAM;AAAjC,OAAA,CAAA,KAAA,GAAA,KAAA;AACW,KAAA,CAAA,SAAS,GAAG,OAAO","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tuple = exports.TupleType = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst struct_1 = require(\"./struct\");\nconst fields_1 = require(\"./fields\");\nconst struct_2 = require(\"./struct\");\nclass TupleType extends struct_2.StructType {\n    constructor(...typeParameters) {\n        super(TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n    }\n    getClassName() {\n        return TupleType.ClassName;\n    }\n    static prepareName(typeParameters) {\n        let fields = typeParameters.map(type => type.toString()).join(\", \");\n        let result = `tuple${fields.length}<${fields}>`;\n        return result;\n    }\n    static prepareFieldDefinitions(typeParameters) {\n        let result = typeParameters.map((type, i) => new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type));\n        return result;\n    }\n}\nexports.TupleType = TupleType;\nTupleType.ClassName = \"TupleType\";\nfunction prepareFieldName(fieldIndex) {\n    return `field${fieldIndex}`;\n}\n// TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\nclass Tuple extends struct_1.Struct {\n    constructor(type, fields) {\n        super(type, fields);\n    }\n    getClassName() {\n        return Tuple.ClassName;\n    }\n    static fromItems(items) {\n        if (items.length < 1) {\n            // TODO: Define a better error.\n            throw new errors.ErrTypingSystem(\"bad tuple items\");\n        }\n        let fieldsTypes = items.map(item => item.getType());\n        let tupleType = new TupleType(...fieldsTypes);\n        let fields = items.map((item, i) => new fields_1.Field(item, prepareFieldName(i)));\n        return new Tuple(tupleType, fields);\n    }\n}\nexports.Tuple = Tuple;\nTuple.ClassName = \"Tuple\";\n//# sourceMappingURL=tuple.js.map"]},"metadata":{},"sourceType":"script"}