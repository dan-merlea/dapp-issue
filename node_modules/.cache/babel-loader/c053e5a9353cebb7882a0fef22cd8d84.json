{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar ParticleBuffer = /*#__PURE__*/function () {\n  function ParticleBuffer(properties, dynamicPropertyFlags, size) {\n    _classCallCheck(this, ParticleBuffer);\n    this.geometry = new core.Geometry();\n    this.indexBuffer = null;\n    this.size = size;\n    this.dynamicProperties = [];\n    this.staticProperties = [];\n    for (var i = 0; i < properties.length; ++i) {\n      var property = properties[i];\n      property = {\n        attributeName: property.attributeName,\n        size: property.size,\n        uploadFunction: property.uploadFunction,\n        type: property.type || core.TYPES.FLOAT,\n        offset: property.offset\n      };\n      if (dynamicPropertyFlags[i]) {\n        this.dynamicProperties.push(property);\n      } else {\n        this.staticProperties.push(property);\n      }\n    }\n    this.staticStride = 0;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.dynamicStride = 0;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this._updateID = 0;\n    this.initBuffers();\n  }\n  _createClass(ParticleBuffer, [{\n    key: \"initBuffers\",\n    value: function initBuffers() {\n      var geometry = this.geometry;\n      var dynamicOffset = 0;\n      this.indexBuffer = new core.Buffer(core.utils.createIndicesForQuads(this.size), true, true);\n      geometry.addIndex(this.indexBuffer);\n      this.dynamicStride = 0;\n      for (var i = 0; i < this.dynamicProperties.length; ++i) {\n        var property = this.dynamicProperties[i];\n        property.offset = dynamicOffset;\n        dynamicOffset += property.size;\n        this.dynamicStride += property.size;\n      }\n      var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n      this.dynamicData = new Float32Array(dynBuffer);\n      this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n      this.dynamicBuffer = new core.Buffer(this.dynamicData, false, false);\n      var staticOffset = 0;\n      this.staticStride = 0;\n      for (var _i = 0; _i < this.staticProperties.length; ++_i) {\n        var _property = this.staticProperties[_i];\n        _property.offset = staticOffset;\n        staticOffset += _property.size;\n        this.staticStride += _property.size;\n      }\n      var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n      this.staticData = new Float32Array(statBuffer);\n      this.staticDataUint32 = new Uint32Array(statBuffer);\n      this.staticBuffer = new core.Buffer(this.staticData, true, false);\n      for (var _i2 = 0; _i2 < this.dynamicProperties.length; ++_i2) {\n        var _property2 = this.dynamicProperties[_i2];\n        geometry.addAttribute(_property2.attributeName, this.dynamicBuffer, 0, _property2.type === core.TYPES.UNSIGNED_BYTE, _property2.type, this.dynamicStride * 4, _property2.offset * 4);\n      }\n      for (var _i3 = 0; _i3 < this.staticProperties.length; ++_i3) {\n        var _property3 = this.staticProperties[_i3];\n        geometry.addAttribute(_property3.attributeName, this.staticBuffer, 0, _property3.type === core.TYPES.UNSIGNED_BYTE, _property3.type, this.staticStride * 4, _property3.offset * 4);\n      }\n    }\n  }, {\n    key: \"uploadDynamic\",\n    value: function uploadDynamic(children, startIndex, amount) {\n      for (var i = 0; i < this.dynamicProperties.length; i++) {\n        var property = this.dynamicProperties[i];\n        property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);\n      }\n      this.dynamicBuffer._updateID++;\n    }\n  }, {\n    key: \"uploadStatic\",\n    value: function uploadStatic(children, startIndex, amount) {\n      for (var i = 0; i < this.staticProperties.length; i++) {\n        var property = this.staticProperties[i];\n        property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);\n      }\n      this.staticBuffer._updateID++;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.indexBuffer = null;\n      this.dynamicProperties = null;\n      this.dynamicBuffer = null;\n      this.dynamicData = null;\n      this.dynamicDataUint32 = null;\n      this.staticProperties = null;\n      this.staticBuffer = null;\n      this.staticData = null;\n      this.staticDataUint32 = null;\n      this.geometry.destroy();\n    }\n  }]);\n  return ParticleBuffer;\n}();\nexports.ParticleBuffer = ParticleBuffer;","map":{"version":3,"sources":["../src/ParticleBuffer.ts"],"names":["Geometry","TYPES","Buffer"],"mappings":"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","sourcesContent":["import { Geometry, Buffer, TYPES, utils } from '@pixi/core';\n\nimport type { Sprite } from '@pixi/sprite';\nimport type { IParticleRendererProperty } from './ParticleRenderer';\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that\n * they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleBuffer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java\n */\n\n/**\n * The particle buffer manages the static and dynamic buffers for a particle container.\n * @private\n * @memberof PIXI\n */\nexport class ParticleBuffer\n{\n    public geometry: Geometry;\n    public staticStride: number;\n    public staticBuffer: Buffer;\n    public staticData: Float32Array;\n    public staticDataUint32: Uint32Array;\n    public dynamicStride: number;\n    public dynamicBuffer: Buffer;\n    public dynamicData: Float32Array;\n    public dynamicDataUint32: Uint32Array;\n    public _updateID: number;\n\n    /** Holds the indices of the geometry (quads) to draw. */\n    indexBuffer: Buffer;\n\n    /** The number of particles the buffer can hold. */\n    private size: number;\n\n    /** A list of the properties that are dynamic. */\n    private dynamicProperties: IParticleRendererProperty[];\n\n    /** A list of the properties that are static. */\n    private staticProperties: IParticleRendererProperty[];\n\n    /**\n     * @param {object} properties - The properties to upload.\n     * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.\n     * @param {number} size - The size of the batch.\n     */\n    constructor(properties: IParticleRendererProperty[], dynamicPropertyFlags: boolean[], size: number)\n    {\n        this.geometry = new Geometry();\n\n        this.indexBuffer = null;\n\n        this.size = size;\n        this.dynamicProperties = [];\n        this.staticProperties = [];\n\n        for (let i = 0; i < properties.length; ++i)\n        {\n            let property = properties[i];\n\n            // Make copy of properties object so that when we edit the offset it doesn't\n            // change all other instances of the object literal\n            property = {\n                attributeName: property.attributeName,\n                size: property.size,\n                uploadFunction: property.uploadFunction,\n                type: property.type || TYPES.FLOAT,\n                offset: property.offset,\n            };\n\n            if (dynamicPropertyFlags[i])\n            {\n                this.dynamicProperties.push(property);\n            }\n            else\n            {\n                this.staticProperties.push(property);\n            }\n        }\n\n        this.staticStride = 0;\n        this.staticBuffer = null;\n        this.staticData = null;\n        this.staticDataUint32 = null;\n\n        this.dynamicStride = 0;\n        this.dynamicBuffer = null;\n        this.dynamicData = null;\n        this.dynamicDataUint32 = null;\n\n        this._updateID = 0;\n\n        this.initBuffers();\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    private initBuffers(): void\n    {\n        const geometry = this.geometry;\n\n        let dynamicOffset = 0;\n\n        this.indexBuffer = new Buffer(utils.createIndicesForQuads(this.size), true, true);\n        geometry.addIndex(this.indexBuffer);\n\n        this.dynamicStride = 0;\n\n        for (let i = 0; i < this.dynamicProperties.length; ++i)\n        {\n            const property = this.dynamicProperties[i];\n\n            property.offset = dynamicOffset;\n            dynamicOffset += property.size;\n            this.dynamicStride += property.size;\n        }\n\n        const dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n\n        this.dynamicData = new Float32Array(dynBuffer);\n        this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n        this.dynamicBuffer = new Buffer(this.dynamicData, false, false);\n\n        // static //\n        let staticOffset = 0;\n\n        this.staticStride = 0;\n\n        for (let i = 0; i < this.staticProperties.length; ++i)\n        {\n            const property = this.staticProperties[i];\n\n            property.offset = staticOffset;\n            staticOffset += property.size;\n            this.staticStride += property.size;\n        }\n\n        const statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n\n        this.staticData = new Float32Array(statBuffer);\n        this.staticDataUint32 = new Uint32Array(statBuffer);\n        this.staticBuffer = new Buffer(this.staticData, true, false);\n\n        for (let i = 0; i < this.dynamicProperties.length; ++i)\n        {\n            const property = this.dynamicProperties[i];\n\n            geometry.addAttribute(\n                property.attributeName,\n                this.dynamicBuffer,\n                0,\n                property.type === TYPES.UNSIGNED_BYTE,\n                property.type,\n                this.dynamicStride * 4,\n                property.offset * 4\n            );\n        }\n\n        for (let i = 0; i < this.staticProperties.length; ++i)\n        {\n            const property = this.staticProperties[i];\n\n            geometry.addAttribute(\n                property.attributeName,\n                this.staticBuffer,\n                0,\n                property.type === TYPES.UNSIGNED_BYTE,\n                property.type,\n                this.staticStride * 4,\n                property.offset * 4\n            );\n        }\n    }\n\n    /**\n     * Uploads the dynamic properties.\n     * @param children - The children to upload.\n     * @param startIndex - The index to start at.\n     * @param amount - The number to upload.\n     */\n    uploadDynamic(children: Sprite[], startIndex: number, amount: number): void\n    {\n        for (let i = 0; i < this.dynamicProperties.length; i++)\n        {\n            const property = this.dynamicProperties[i];\n\n            property.uploadFunction(children, startIndex, amount,\n                property.type === TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,\n                this.dynamicStride, property.offset);\n        }\n\n        this.dynamicBuffer._updateID++;\n    }\n\n    /**\n     * Uploads the static properties.\n     * @param children - The children to upload.\n     * @param startIndex - The index to start at.\n     * @param amount - The number to upload.\n     */\n    uploadStatic(children: Sprite[], startIndex: number, amount: number): void\n    {\n        for (let i = 0; i < this.staticProperties.length; i++)\n        {\n            const property = this.staticProperties[i];\n\n            property.uploadFunction(children, startIndex, amount,\n                property.type === TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,\n                this.staticStride, property.offset);\n        }\n\n        this.staticBuffer._updateID++;\n    }\n\n    /** Destroys the ParticleBuffer. */\n    destroy(): void\n    {\n        this.indexBuffer = null;\n\n        this.dynamicProperties = null;\n        this.dynamicBuffer = null;\n        this.dynamicData = null;\n        this.dynamicDataUint32 = null;\n\n        this.staticProperties = null;\n        this.staticBuffer = null;\n        this.staticData = null;\n        this.staticDataUint32 = null;\n        // all buffers are destroyed inside geometry\n        this.geometry.destroy();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}