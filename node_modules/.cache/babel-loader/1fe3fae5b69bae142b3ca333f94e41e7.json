{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BatchDrawCall } from './BatchDrawCall.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\nimport { BaseTexture } from '../textures/BaseTexture.mjs';\nimport { ObjectRenderer } from './ObjectRenderer.mjs';\nimport { State } from '../state/State.mjs';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer.mjs';\nimport { BatchShaderGenerator } from './BatchShaderGenerator.mjs';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader.mjs';\nimport { settings } from '@pixi/settings';\nimport { premultiplyBlendMode, nextPow2, log2, premultiplyTint } from '@pixi/utils';\nimport { ENV } from '@pixi/constants';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport defaultVertex from './texture.mjs';\nimport defaultFragment from './texture2.mjs';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nvar _BatchRenderer = /*#__PURE__*/function (_ObjectRenderer) {\n  _inherits(_BatchRenderer, _ObjectRenderer);\n  var _super = _createSuper(_BatchRenderer);\n  function _BatchRenderer(renderer) {\n    var _this;\n    _classCallCheck(this, _BatchRenderer);\n    _this = _super.call(this, renderer);\n    _this.setShaderGenerator();\n    _this.geometryClass = BatchGeometry;\n    _this.vertexSize = 6;\n    _this.state = State.for2d();\n    _this.size = settings.SPRITE_BATCH_SIZE * 4;\n    _this._vertexCount = 0;\n    _this._indexCount = 0;\n    _this._bufferedElements = [];\n    _this._bufferedTextures = [];\n    _this._bufferSize = 0;\n    _this._shader = null;\n    _this._packedGeometries = [];\n    _this._packedGeometryPoolSize = 2;\n    _this._flushId = 0;\n    _this._aBuffers = {};\n    _this._iBuffers = {};\n    _this.MAX_TEXTURES = 1;\n    _this.renderer.on(\"prerender\", _this.onPrerender, _assertThisInitialized(_this));\n    renderer.runners.contextChange.add(_assertThisInitialized(_this));\n    _this._dcIndex = 0;\n    _this._aIndex = 0;\n    _this._iIndex = 0;\n    _this._attributeBuffer = null;\n    _this._indexBuffer = null;\n    _this._tempBoundTextures = [];\n    return _this;\n  }\n  _createClass(_BatchRenderer, [{\n    key: \"setShaderGenerator\",\n    value: function setShaderGenerator() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$vertex = _ref.vertex,\n        vertex = _ref$vertex === void 0 ? _BatchRenderer.defaultVertexSrc : _ref$vertex,\n        _ref$fragment = _ref.fragment,\n        fragment = _ref$fragment === void 0 ? _BatchRenderer.defaultFragmentTemplate : _ref$fragment;\n      this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n    }\n  }, {\n    key: \"contextChange\",\n    value: function contextChange() {\n      var gl = this.renderer.gl;\n      if (settings.PREFER_ENV === ENV.WEBGL_LEGACY) {\n        this.MAX_TEXTURES = 1;\n      } else {\n        this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);\n        this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);\n      }\n      this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n      for (var i = 0; i < this._packedGeometryPoolSize; i++) {\n        this._packedGeometries[i] = new this.geometryClass();\n      }\n      this.initFlushBuffers();\n    }\n  }, {\n    key: \"initFlushBuffers\",\n    value: function initFlushBuffers() {\n      var _drawCallPool = _BatchRenderer._drawCallPool,\n        _textureArrayPool = _BatchRenderer._textureArrayPool;\n      var MAX_SPRITES = this.size / 4;\n      var MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;\n      while (_drawCallPool.length < MAX_SPRITES) {\n        _drawCallPool.push(new BatchDrawCall());\n      }\n      while (_textureArrayPool.length < MAX_TA) {\n        _textureArrayPool.push(new BatchTextureArray());\n      }\n      for (var i = 0; i < this.MAX_TEXTURES; i++) {\n        this._tempBoundTextures[i] = null;\n      }\n    }\n  }, {\n    key: \"onPrerender\",\n    value: function onPrerender() {\n      this._flushId = 0;\n    }\n  }, {\n    key: \"render\",\n    value: function render(element) {\n      if (!element._texture.valid) {\n        return;\n      }\n      if (this._vertexCount + element.vertexData.length / 2 > this.size) {\n        this.flush();\n      }\n      this._vertexCount += element.vertexData.length / 2;\n      this._indexCount += element.indices.length;\n      this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n      this._bufferedElements[this._bufferSize++] = element;\n    }\n  }, {\n    key: \"buildTexturesAndDrawCalls\",\n    value: function buildTexturesAndDrawCalls() {\n      var textures = this._bufferedTextures,\n        MAX_TEXTURES = this.MAX_TEXTURES;\n      var textureArrays = _BatchRenderer._textureArrayPool;\n      var batch = this.renderer.batch;\n      var boundTextures = this._tempBoundTextures;\n      var touch = this.renderer.textureGC.count;\n      var TICK = ++BaseTexture._globalBatch;\n      var countTexArrays = 0;\n      var texArray = textureArrays[0];\n      var start = 0;\n      batch.copyBoundTextures(boundTextures, MAX_TEXTURES);\n      for (var i = 0; i < this._bufferSize; ++i) {\n        var tex = textures[i];\n        textures[i] = null;\n        if (tex._batchEnabled === TICK) {\n          continue;\n        }\n        if (texArray.count >= MAX_TEXTURES) {\n          batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n          this.buildDrawCalls(texArray, start, i);\n          start = i;\n          texArray = textureArrays[++countTexArrays];\n          ++TICK;\n        }\n        tex._batchEnabled = TICK;\n        tex.touched = touch;\n        texArray.elements[texArray.count++] = tex;\n      }\n      if (texArray.count > 0) {\n        batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n        this.buildDrawCalls(texArray, start, this._bufferSize);\n        ++countTexArrays;\n        ++TICK;\n      }\n      for (var _i = 0; _i < boundTextures.length; _i++) {\n        boundTextures[_i] = null;\n      }\n      BaseTexture._globalBatch = TICK;\n    }\n  }, {\n    key: \"buildDrawCalls\",\n    value: function buildDrawCalls(texArray, start, finish) {\n      var elements = this._bufferedElements,\n        _attributeBuffer = this._attributeBuffer,\n        _indexBuffer = this._indexBuffer,\n        vertexSize = this.vertexSize;\n      var drawCalls = _BatchRenderer._drawCallPool;\n      var dcIndex = this._dcIndex;\n      var aIndex = this._aIndex;\n      var iIndex = this._iIndex;\n      var drawCall = drawCalls[dcIndex];\n      drawCall.start = this._iIndex;\n      drawCall.texArray = texArray;\n      for (var i = start; i < finish; ++i) {\n        var sprite = elements[i];\n        var tex = sprite._texture.baseTexture;\n        var spriteBlendMode = premultiplyBlendMode[tex.alphaMode ? 1 : 0][sprite.blendMode];\n        elements[i] = null;\n        if (start < i && drawCall.blend !== spriteBlendMode) {\n          drawCall.size = iIndex - drawCall.start;\n          start = i;\n          drawCall = drawCalls[++dcIndex];\n          drawCall.texArray = texArray;\n          drawCall.start = iIndex;\n        }\n        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n        aIndex += sprite.vertexData.length / 2 * vertexSize;\n        iIndex += sprite.indices.length;\n        drawCall.blend = spriteBlendMode;\n      }\n      if (start < finish) {\n        drawCall.size = iIndex - drawCall.start;\n        ++dcIndex;\n      }\n      this._dcIndex = dcIndex;\n      this._aIndex = aIndex;\n      this._iIndex = iIndex;\n    }\n  }, {\n    key: \"bindAndClearTexArray\",\n    value: function bindAndClearTexArray(texArray) {\n      var textureSystem = this.renderer.texture;\n      for (var j = 0; j < texArray.count; j++) {\n        textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n        texArray.elements[j] = null;\n      }\n      texArray.count = 0;\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      var packedGeometries = this._packedGeometries,\n        attributeBuffer = this._attributeBuffer,\n        indexBuffer = this._indexBuffer;\n      if (!settings.CAN_UPLOAD_SAME_BUFFER) {\n        if (this._packedGeometryPoolSize <= this._flushId) {\n          this._packedGeometryPoolSize++;\n          packedGeometries[this._flushId] = new this.geometryClass();\n        }\n        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n        this.renderer.geometry.bind(packedGeometries[this._flushId]);\n        this.renderer.geometry.updateBuffers();\n        this._flushId++;\n      } else {\n        packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n        packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n        this.renderer.geometry.updateBuffers();\n      }\n    }\n  }, {\n    key: \"drawBatches\",\n    value: function drawBatches() {\n      var dcCount = this._dcIndex;\n      var _this$renderer = this.renderer,\n        gl = _this$renderer.gl,\n        stateSystem = _this$renderer.state;\n      var drawCalls = _BatchRenderer._drawCallPool;\n      var curTexArray = null;\n      for (var i = 0; i < dcCount; i++) {\n        var _drawCalls$i = drawCalls[i],\n          texArray = _drawCalls$i.texArray,\n          type = _drawCalls$i.type,\n          size = _drawCalls$i.size,\n          start = _drawCalls$i.start,\n          blend = _drawCalls$i.blend;\n        if (curTexArray !== texArray) {\n          curTexArray = texArray;\n          this.bindAndClearTexArray(texArray);\n        }\n        this.state.blendMode = blend;\n        stateSystem.set(this.state);\n        gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._vertexCount === 0) {\n        return;\n      }\n      this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n      this._indexBuffer = this.getIndexBuffer(this._indexCount);\n      this._aIndex = 0;\n      this._iIndex = 0;\n      this._dcIndex = 0;\n      this.buildTexturesAndDrawCalls();\n      this.updateGeometry();\n      this.drawBatches();\n      this._bufferSize = 0;\n      this._vertexCount = 0;\n      this._indexCount = 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.renderer.state.set(this.state);\n      this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);\n      this.renderer.shader.bind(this._shader);\n      if (settings.CAN_UPLOAD_SAME_BUFFER) {\n        this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.flush();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i = 0; i < this._packedGeometryPoolSize; i++) {\n        if (this._packedGeometries[i]) {\n          this._packedGeometries[i].destroy();\n        }\n      }\n      this.renderer.off(\"prerender\", this.onPrerender, this);\n      this._aBuffers = null;\n      this._iBuffers = null;\n      this._packedGeometries = null;\n      this._attributeBuffer = null;\n      this._indexBuffer = null;\n      if (this._shader) {\n        this._shader.destroy();\n        this._shader = null;\n      }\n      _get(_getPrototypeOf(_BatchRenderer.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"getAttributeBuffer\",\n    value: function getAttributeBuffer(size) {\n      var roundedP2 = nextPow2(Math.ceil(size / 8));\n      var roundedSizeIndex = log2(roundedP2);\n      var roundedSize = roundedP2 * 8;\n      if (this._aBuffers.length <= roundedSizeIndex) {\n        this._iBuffers.length = roundedSizeIndex + 1;\n      }\n      var buffer = this._aBuffers[roundedSize];\n      if (!buffer) {\n        this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n      }\n      return buffer;\n    }\n  }, {\n    key: \"getIndexBuffer\",\n    value: function getIndexBuffer(size) {\n      var roundedP2 = nextPow2(Math.ceil(size / 12));\n      var roundedSizeIndex = log2(roundedP2);\n      var roundedSize = roundedP2 * 12;\n      if (this._iBuffers.length <= roundedSizeIndex) {\n        this._iBuffers.length = roundedSizeIndex + 1;\n      }\n      var buffer = this._iBuffers[roundedSizeIndex];\n      if (!buffer) {\n        this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n      }\n      return buffer;\n    }\n  }, {\n    key: \"packInterleavedGeometry\",\n    value: function packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {\n      var uint32View = attributeBuffer.uint32View,\n        float32View = attributeBuffer.float32View;\n      var packedVertices = aIndex / this.vertexSize;\n      var uvs = element.uvs;\n      var indicies = element.indices;\n      var vertexData = element.vertexData;\n      var textureId = element._texture.baseTexture._batchLocation;\n      var alpha = Math.min(element.worldAlpha, 1);\n      var argb = alpha < 1 && element._texture.baseTexture.alphaMode ? premultiplyTint(element._tintRGB, alpha) : element._tintRGB + (alpha * 255 << 24);\n      for (var i = 0; i < vertexData.length; i += 2) {\n        float32View[aIndex++] = vertexData[i];\n        float32View[aIndex++] = vertexData[i + 1];\n        float32View[aIndex++] = uvs[i];\n        float32View[aIndex++] = uvs[i + 1];\n        uint32View[aIndex++] = argb;\n        float32View[aIndex++] = textureId;\n      }\n      for (var _i2 = 0; _i2 < indicies.length; _i2++) {\n        indexBuffer[iIndex++] = packedVertices + indicies[_i2];\n      }\n    }\n  }], [{\n    key: \"defaultVertexSrc\",\n    get: function get() {\n      return defaultVertex;\n    }\n  }, {\n    key: \"defaultFragmentTemplate\",\n    get: function get() {\n      return defaultFragment;\n    }\n  }]);\n  return _BatchRenderer;\n}(ObjectRenderer);\nvar BatchRenderer = _BatchRenderer;\nBatchRenderer.extension = {\n  name: \"batch\",\n  type: ExtensionType.RendererPlugin\n};\nBatchRenderer._drawCallPool = [];\nBatchRenderer._textureArrayPool = [];\nextensions.add(BatchRenderer);\nexport { BatchRenderer };","map":{"version":3,"sources":["../../src/batch/BatchRenderer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAgDO,IAAM,cAAN;EAAA;EAAA;EAgKH,wBAAY,QACZ,EAAA;IAAA;IAAA;IACI,0BAAM,QAAQ;IAEd,MAAK,kBAAmB,EAAA;IACxB,MAAK,aAAgB,GAAA,aAAA;IACrB,MAAK,UAAa,GAAA,CAAA;IACb,MAAA,KAAA,GAAQ,KAAA,CAAM,KAAM,EAAA;IACpB,MAAA,IAAA,GAAO,QAAA,CAAS,iBAAoB,GAAA,CAAA;IACzC,MAAK,YAAe,GAAA,CAAA;IACpB,MAAK,WAAc,GAAA,CAAA;IACnB,MAAK,iBAAA,GAAoB,EAAC;IAC1B,MAAK,iBAAA,GAAoB,EAAC;IAC1B,MAAK,WAAc,GAAA,CAAA;IACnB,MAAK,OAAU,GAAA,IAAA;IACf,MAAK,iBAAA,GAAoB,EAAC;IAC1B,MAAK,uBAA0B,GAAA,CAAA;IAC/B,MAAK,QAAW,GAAA,CAAA;IAChB,MAAK,SAAA,GAAY,CAAA,CAAC;IAClB,MAAK,SAAA,GAAY,CAAA,CAAC;IAElB,MAAK,YAAe,GAAA,CAAA;IAEpB,MAAK,QAAS,CAAA,EAAA,CAAG,WAAa,EAAA,MAAK,WAAA,gCAAiB;IAC3C,QAAA,CAAA,OAAA,CAAQ,aAAc,CAAA,GAAA,+BAAQ;IAEvC,MAAK,QAAW,GAAA,CAAA;IAChB,MAAK,OAAU,GAAA,CAAA;IACf,MAAK,OAAU,GAAA,CAAA;IACf,MAAK,gBAAmB,GAAA,IAAA;IACxB,MAAK,YAAe,GAAA,IAAA;IACpB,MAAK,kBAAA,GAAqB,EAAC;IAAA;EAAA;EAC/B;IAAA;IAAA,OA0BA,8BAIA;MAAA,+EAD4C,CAAA,CAC5C;QAAA,mBAHI,MAAA;QAAA,MAAA,4BAAS,cAAc,CAAA,gBAAA;QAAA,qBACvB,QAAA;QAAA,QAAA,8BAAW,cAAc,CAAA,uBAAA;MAGzB,IAAA,CAAK,eAAkB,GAAA,IAAI,oBAAqB,CAAA,MAAA,EAAQ,QAAQ,CAAA;IAAA;EACpE;IAAA;IAAA,OAOA,yBACA;MACU,IAAA,EAAA,GAAK,IAAA,CAAK,QAAS,CAAA,EAAA;MAErB,IAAA,QAAA,CAAS,UAAe,KAAA,GAAA,CAAI,YAChC,EAAA;QACI,IAAA,CAAK,YAAe,GAAA,CAAA;MAAA,CAGxB,MAAA;QAES,IAAA,CAAA,YAAA,GAAe,IAAA,CAAK,GACrB,CAAA,EAAA,CAAG,YAAA,CAAa,EAAG,CAAA,uBAAuB,CAC1C,EAAA,QAAA,CAAS,mBAAmB,CAAA;QAGhC,IAAA,CAAK,YAAe,GAAA,4BAAA,CAChB,IAAK,CAAA,YAAA,EAAc,EAAE,CAAA;MAAA;MAG7B,IAAA,CAAK,OAAU,GAAA,IAAA,CAAK,eAAgB,CAAA,cAAA,CAAe,IAAA,CAAK,YAAY,CAAA;MAIpE,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,uBAAA,EAAyB,CAClD,EAAA,EAAA;QAEI,IAAA,CAAK,iBAAkB,CAAA,CAAA,CAAA,GAAK,IAAK,IAAA,CAAK,aAAe,EAAA;MAAA;MAGzD,IAAA,CAAK,gBAAiB,EAAA;IAAA;EAC1B;IAAA;IAAA,OAGA,4BACA;MACU,IACF,aAAA,GAEA,cAAA,CAFA,aAAA;QACA,iBAAA,GACA,cAAA,CADA,iBAAA;MAGE,IAAA,WAAA,GAAc,IAAA,CAAK,IAAO,GAAA,CAAA;MAEhC,IAAM,MAAA,GAAS,IAAK,CAAA,KAAA,CAAM,WAAc,GAAA,IAAA,CAAK,YAAY,CAAI,GAAA,CAAA;MAEtD,OAAA,aAAA,CAAc,MAAA,GAAS,WAC9B,EAAA;QACkB,aAAA,CAAA,IAAA,CAAK,IAAI,aAAA,EAAe,CAAA;MAAA;MAEnC,OAAA,iBAAA,CAAkB,MAAA,GAAS,MAClC,EAAA;QACsB,iBAAA,CAAA,IAAA,CAAK,IAAI,iBAAA,EAAmB,CAAA;MAAA;MAElD,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,YAAA,EAAc,CACvC,EAAA,EAAA;QACI,IAAA,CAAK,kBAAA,CAAmB,CAAK,CAAA,GAAA,IAAA;MAAA;IACjC;EACJ;IAAA;IAAA,OAGA,uBACA;MACI,IAAA,CAAK,QAAW,GAAA,CAAA;IAAA;EACpB;IAAA;IAAA,OAOA,gBAAO,OACP,EAAA;MACQ,IAAA,CAAC,OAAQ,CAAA,QAAA,CAAS,KACtB,EAAA;QACI;MAAA;MAGJ,IAAI,IAAA,CAAK,YAAgB,GAAA,OAAA,CAAQ,UAAA,CAAW,MAAS,GAAA,CAAA,GAAK,IAAA,CAAK,IAC/D,EAAA;QACI,IAAA,CAAK,KAAM,EAAA;MAAA;MAGV,IAAA,CAAA,YAAA,IAAgB,OAAQ,CAAA,UAAA,CAAW,MAAS,GAAA,CAAA;MAC5C,IAAA,CAAA,WAAA,IAAe,OAAA,CAAQ,OAAQ,CAAA,MAAA;MACpC,IAAA,CAAK,iBAAkB,CAAA,IAAA,CAAK,WAAe,CAAA,GAAA,OAAA,CAAQ,QAAS,CAAA,WAAA;MACvD,IAAA,CAAA,iBAAA,CAAkB,IAAA,CAAK,WAAiB,EAAA,CAAA,GAAA,OAAA;IAAA;EACjD;IAAA;IAAA,OAEA,qCACA;MACU,IACiB,QAAA,GAEnB,IAAA,CAFA,iBAAmB;QACnB,YAAA,GACA,IAAA,CADA,YAAA;MAEJ,IAAM,aAAA,GAAgB,cAAc,CAAA,iBAAA;MAC9B,IAAA,KAAA,GAAQ,IAAA,CAAK,QAAS,CAAA,KAAA;MAC5B,IAAM,aAAA,GAAgB,IAAK,CAAA,kBAAA;MACrB,IAAA,KAAA,GAAQ,IAAK,CAAA,QAAA,CAAS,SAAU,CAAA,KAAA;MAElC,IAAA,IAAA,GAAO,EAAE,WAAY,CAAA,YAAA;MACzB,IAAI,cAAiB,GAAA,CAAA;MACrB,IAAI,QAAA,GAAW,aAAc,CAAA,CAAA,CAAA;MAC7B,IAAI,KAAQ,GAAA,CAAA;MAEN,KAAA,CAAA,iBAAA,CAAkB,aAAA,EAAe,YAAY,CAAA;MAEnD,KAAA,IAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,WAAA,EAAa,EAAE,CACxC,EAAA;QACI,IAAM,GAAA,GAAM,QAAS,CAAA,CAAA,CAAA;QAErB,QAAA,CAAS,CAAK,CAAA,GAAA,IAAA;QACV,IAAA,GAAA,CAAI,aAAA,KAAkB,IAC1B,EAAA;UACI;QAAA;QAGA,IAAA,QAAA,CAAS,KAAA,IAAS,YACtB,EAAA;UACI,KAAA,CAAM,UAAW,CAAA,QAAA,EAAU,aAAe,EAAA,IAAA,EAAM,YAAY,CAAA;UACvD,IAAA,CAAA,cAAA,CAAe,QAAU,EAAA,KAAA,EAAO,CAAC,CAAA;UAC9B,KAAA,GAAA,CAAA;UACR,QAAA,GAAW,aAAA,CAAc,EAAE,cAAA,CAAA;UACzB,EAAA,IAAA;QAAA;QAGN,GAAA,CAAI,aAAgB,GAAA,IAAA;QACpB,GAAA,CAAI,OAAU,GAAA,KAAA;QACL,QAAA,CAAA,QAAA,CAAS,QAAA,CAAS,KAAW,EAAA,CAAA,GAAA,GAAA;MAAA;MAGtC,IAAA,QAAA,CAAS,KAAA,GAAQ,CACrB,EAAA;QACI,KAAA,CAAM,UAAW,CAAA,QAAA,EAAU,aAAe,EAAA,IAAA,EAAM,YAAY,CAAA;QAC5D,IAAA,CAAK,cAAe,CAAA,QAAA,EAAU,KAAO,EAAA,IAAA,CAAK,WAAW,CAAA;QACnD,EAAA,cAAA;QACA,EAAA,IAAA;MAAA;MAKN,KAAA,IAAS,EAAI,GAAA,CAAA,EAAG,EAAI,GAAA,aAAA,CAAc,MAAA,EAAQ,EAC1C,EAAA,EAAA;QACI,aAAA,CAAc,EAAK,CAAA,GAAA,IAAA;MAAA;MAEvB,WAAA,CAAY,YAAe,GAAA,IAAA;IAAA;EAC/B;IAAA;IAAA,OAQA,wBAAe,QAA6B,EAAA,KAAA,EAAe,MAC3D,EAAA;MACU,IACiB,QAAA,GAInB,IAAA,CAJA,iBAAmB;QACnB,gBAAA,GAGA,IAAA,CAHA,gBAAA;QACA,YAAA,GAEA,IAAA,CAFA,YAAA;QACA,UAAA,GACA,IAAA,CADA,UAAA;MAEJ,IAAM,SAAA,GAAY,cAAc,CAAA,aAAA;MAEhC,IAAI,OAAA,GAAU,IAAK,CAAA,QAAA;MACnB,IAAI,MAAA,GAAS,IAAK,CAAA,OAAA;MAClB,IAAI,MAAA,GAAS,IAAK,CAAA,OAAA;MAElB,IAAI,QAAA,GAAW,SAAU,CAAA,OAAA,CAAA;MAEzB,QAAA,CAAS,KAAA,GAAQ,IAAK,CAAA,OAAA;MACtB,QAAA,CAAS,QAAW,GAAA,QAAA;MAEpB,KAAA,IAAS,CAAI,GAAA,KAAA,EAAO,CAAI,GAAA,MAAA,EAAQ,EAAE,CAClC,EAAA;QACI,IAAM,MAAA,GAAS,QAAS,CAAA,CAAA,CAAA;QAClB,IAAA,GAAA,GAAM,MAAA,CAAO,QAAS,CAAA,WAAA;QAC5B,IAAM,eAAA,GAAkB,oBACpB,CAAA,GAAA,CAAI,SAAY,GAAA,CAAA,GAAI,CAAA,CAAA,CAAG,MAAO,CAAA,SAAA,CAAA;QAElC,QAAA,CAAS,CAAK,CAAA,GAAA,IAAA;QAEd,IAAI,KAAQ,GAAA,CAAA,IAAK,QAAS,CAAA,KAAA,KAAU,eACpC,EAAA;UACa,QAAA,CAAA,IAAA,GAAO,MAAA,GAAS,QAAS,CAAA,KAAA;UAC1B,KAAA,GAAA,CAAA;UACR,QAAA,GAAW,SAAA,CAAU,EAAE,OAAA,CAAA;UACvB,QAAA,CAAS,QAAW,GAAA,QAAA;UACpB,QAAA,CAAS,KAAQ,GAAA,MAAA;QAAA;QAGrB,IAAA,CAAK,uBAAwB,CAAA,MAAA,EAAQ,gBAAkB,EAAA,YAAA,EAAc,MAAA,EAAQ,MAAM,CAAA;QACzE,MAAA,IAAA,MAAA,CAAO,UAAW,CAAA,MAAA,GAAS,CAAI,GAAA,UAAA;QACzC,MAAA,IAAU,MAAA,CAAO,OAAQ,CAAA,MAAA;QAEzB,QAAA,CAAS,KAAQ,GAAA,eAAA;MAAA;MAGrB,IAAI,KAAA,GAAQ,MACZ,EAAA;QACa,QAAA,CAAA,IAAA,GAAO,MAAA,GAAS,QAAS,CAAA,KAAA;QAChC,EAAA,OAAA;MAAA;MAGN,IAAA,CAAK,QAAW,GAAA,OAAA;MAChB,IAAA,CAAK,OAAU,GAAA,MAAA;MACf,IAAA,CAAK,OAAU,GAAA,MAAA;IAAA;EACnB;IAAA;IAAA,OAMA,8BAAqB,QACrB,EAAA;MACU,IAAA,aAAA,GAAgB,IAAA,CAAK,QAAS,CAAA,OAAA;MAEpC,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,QAAA,CAAS,KAAA,EAAO,CACpC,EAAA,EAAA;QACI,aAAA,CAAc,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,CAAI,CAAA,EAAA,QAAA,CAAS,GAAA,CAAI,CAAE,CAAA,CAAA;QACxD,QAAA,CAAS,QAAA,CAAS,CAAK,CAAA,GAAA,IAAA;MAAA;MAE3B,QAAA,CAAS,KAAQ,GAAA,CAAA;IAAA;EACrB;IAAA;IAAA,OAEA,0BACA;MACU,IACiB,gBAAA,GAGnB,IAAA,CAHA,iBAAmB;QACD,eAAA,GAElB,IAAA,CAFA,gBAAkB;QACJ,WAAA,GACd,IAAA,CADA,YAAc;MAGd,IAAA,CAAC,QAAA,CAAS,sBACd,EAAA;QAEQ,IAAA,IAAA,CAAK,uBAA2B,IAAA,IAAA,CAAK,QACzC,EAAA;UACS,IAAA,CAAA,uBAAA,EAAA;UACL,gBAAA,CAAiB,IAAK,CAAA,QAAA,CAAA,GAAY,IAAK,IAAA,CAAK,aAAe,EAAA;QAAA;QAG/D,gBAAA,CAAiB,IAAK,CAAA,QAAA,CAAA,CAAU,OAAQ,CAAA,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;QAC5E,gBAAA,CAAiB,IAAK,CAAA,QAAA,CAAA,CAAU,YAAa,CAAA,MAAA,CAAO,WAAW,CAAA;QAE/D,IAAA,CAAK,QAAS,CAAA,QAAA,CAAS,IAAK,CAAA,gBAAA,CAAiB,IAAA,CAAK,QAAS,CAAA,CAAA;QACtD,IAAA,CAAA,QAAA,CAAS,QAAA,CAAS,aAAc,EAAA;QAChC,IAAA,CAAA,QAAA,EAAA;MAAA,CAGT,MAAA;QAEI,gBAAA,CAAiB,IAAK,CAAA,QAAA,CAAA,CAAU,OAAQ,CAAA,MAAA,CAAO,eAAA,CAAgB,aAAa,CAAA;QAC5E,gBAAA,CAAiB,IAAK,CAAA,QAAA,CAAA,CAAU,YAAa,CAAA,MAAA,CAAO,WAAW,CAAA;QAE1D,IAAA,CAAA,QAAA,CAAS,QAAA,CAAS,aAAc,EAAA;MAAA;IACzC;EACJ;IAAA;IAAA,OAEA,uBACA;MACI,IAAM,OAAA,GAAU,IAAK,CAAA,QAAA;MACrB,qBAAmC,IAAK,CAAA,QAAA;QAAhC,EAAA,kBAAA,EAAA;QAAW,WAAA,kBAAP,KAAO;MACnB,IAAM,SAAA,GAAY,cAAc,CAAA,aAAA;MAEhC,IAAI,WAAc,GAAA,IAAA;MAGlB,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,EAAS,CAC7B,EAAA,EAAA;QACI,mBAA+C,SAAU,CAAA,CAAA,CAAA;UAAjD,QAAU,gBAAV,QAAU;UAAA,IAAA,gBAAA,IAAA;UAAM,IAAM,gBAAN,IAAM;UAAA,KAAA,gBAAA,KAAA;UAAO,KAAA,gBAAA,KAAA;QAErC,IAAI,WAAA,KAAgB,QACpB,EAAA;UACkB,WAAA,GAAA,QAAA;UACd,IAAA,CAAK,oBAAA,CAAqB,QAAQ,CAAA;QAAA;QAGtC,IAAA,CAAK,KAAA,CAAM,SAAY,GAAA,KAAA;QACX,WAAA,CAAA,GAAA,CAAI,IAAA,CAAK,KAAK,CAAA;QAC1B,EAAA,CAAG,YAAA,CAAa,IAAM,EAAA,IAAA,EAAM,EAAG,CAAA,cAAA,EAAgB,KAAA,GAAQ,CAAC,CAAA;MAAA;IAC5D;EACJ;IAAA;IAAA,OAGA,iBACA;MACQ,IAAA,IAAA,CAAK,YAAA,KAAiB,CAC1B,EAAA;QACI;MAAA;MAGJ,IAAA,CAAK,gBAAmB,GAAA,IAAA,CAAK,kBAAmB,CAAA,IAAA,CAAK,YAAY,CAAA;MACjE,IAAA,CAAK,YAAe,GAAA,IAAA,CAAK,cAAe,CAAA,IAAA,CAAK,WAAW,CAAA;MACxD,IAAA,CAAK,OAAU,GAAA,CAAA;MACf,IAAA,CAAK,OAAU,GAAA,CAAA;MACf,IAAA,CAAK,QAAW,GAAA,CAAA;MAEhB,IAAA,CAAK,yBAA0B,EAAA;MAC/B,IAAA,CAAK,cAAe,EAAA;MACpB,IAAA,CAAK,WAAY,EAAA;MAGjB,IAAA,CAAK,WAAc,GAAA,CAAA;MACnB,IAAA,CAAK,YAAe,GAAA,CAAA;MACpB,IAAA,CAAK,WAAc,GAAA,CAAA;IAAA;EACvB;IAAA;IAAA,OAGA,iBACA;MACI,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,GAAI,CAAA,IAAA,CAAK,KAAK,CAAA;MAElC,IAAA,CAAK,QAAS,CAAA,OAAA,CAAQ,iBAAkB,CAAA,IAAA,CAAK,YAAY,CAAA;MAEzD,IAAA,CAAK,QAAS,CAAA,MAAA,CAAO,IAAK,CAAA,IAAA,CAAK,OAAO,CAAA;MAEtC,IAAI,QAAA,CAAS,sBACb,EAAA;QAEI,IAAA,CAAK,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,IAAK,CAAA,iBAAA,CAAkB,IAAA,CAAK,QAAS,CAAA,CAAA;MAAA;IACrE;EACJ;IAAA;IAAA,OAGA,gBACA;MACI,IAAA,CAAK,KAAM,EAAA;IAAA;EACf;IAAA;IAAA,OAGA,mBACA;MACI,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,uBAAA,EAAyB,CAClD,EAAA,EAAA;QACQ,IAAA,IAAA,CAAK,iBAAA,CAAkB,CAC3B,CAAA,EAAA;UACS,IAAA,CAAA,iBAAA,CAAkB,CAAA,CAAA,CAAG,OAAQ,EAAA;QAAA;MACtC;MAGJ,IAAA,CAAK,QAAS,CAAA,GAAA,CAAI,WAAa,EAAA,IAAA,CAAK,WAAA,EAAa,IAAI,CAAA;MAErD,IAAA,CAAK,SAAY,GAAA,IAAA;MACjB,IAAA,CAAK,SAAY,GAAA,IAAA;MACjB,IAAA,CAAK,iBAAoB,GAAA,IAAA;MACzB,IAAA,CAAK,gBAAmB,GAAA,IAAA;MACxB,IAAA,CAAK,YAAe,GAAA,IAAA;MAEpB,IAAI,IAAA,CAAK,OACT,EAAA;QACI,IAAA,CAAK,OAAA,CAAQ,OAAQ,EAAA;QACrB,IAAA,CAAK,OAAU,GAAA,IAAA;MAAA;MAGnB;IAAc;EAClB;IAAA;IAAA,OAOA,4BAAmB,IACnB,EAAA;MAEI,IAAM,SAAA,GAAY,QAAS,CAAA,IAAA,CAAK,IAAK,CAAA,IAAA,GAAO,CAAC,CAAC,CAAA;MACxC,IAAA,gBAAA,GAAmB,IAAA,CAAK,SAAS,CAAA;MACvC,IAAM,WAAA,GAAc,SAAY,GAAA,CAAA;MAE5B,IAAA,IAAA,CAAK,SAAU,CAAA,MAAA,IAAU,gBAC7B,EAAA;QACS,IAAA,CAAA,SAAA,CAAU,MAAA,GAAS,gBAAmB,GAAA,CAAA;MAAA;MAG3C,IAAA,MAAA,GAAS,IAAA,CAAK,SAAU,CAAA,WAAA,CAAA;MAE5B,IAAI,CAAC,MACL,EAAA;QACS,IAAA,CAAA,SAAA,CAAU,WAAA,CAAA,GAAe,MAAS,GAAA,IAAI,cAAA,CAAe,WAAc,GAAA,IAAA,CAAK,UAAA,GAAa,CAAC,CAAA;MAAA;MAGxF,OAAA,MAAA;IAAA;EACX;IAAA;IAAA,OAQA,wBAAe,IACf,EAAA;MAEI,IAAM,SAAA,GAAY,QAAS,CAAA,IAAA,CAAK,IAAK,CAAA,IAAA,GAAO,EAAE,CAAC,CAAA;MACzC,IAAA,gBAAA,GAAmB,IAAA,CAAK,SAAS,CAAA;MACvC,IAAM,WAAA,GAAc,SAAY,GAAA,EAAA;MAE5B,IAAA,IAAA,CAAK,SAAU,CAAA,MAAA,IAAU,gBAC7B,EAAA;QACS,IAAA,CAAA,SAAA,CAAU,MAAA,GAAS,gBAAmB,GAAA,CAAA;MAAA;MAG3C,IAAA,MAAA,GAAS,IAAA,CAAK,SAAU,CAAA,gBAAA,CAAA;MAE5B,IAAI,CAAC,MACL,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,gBAAA,CAAA,GAAoB,MAAS,GAAA,IAAI,WAAA,CAAY,WAAW,CAAA;MAAA;MAGpE,OAAA,MAAA;IAAA;EACX;IAAA;IAAA,OAeA,iCAAwB,OAAA,EAA4B,eAAiC,EAAA,WAAA,EACjF,MAAA,EAAgB,MACpB,EAAA;MACU,IACF,UAAA,GAEA,eAAA,CAFA,UAAA;QACA,WAAA,GACA,eAAA,CADA,WAAA;MAGE,IAAA,cAAA,GAAiB,MAAA,GAAS,IAAK,CAAA,UAAA;MACrC,IAAM,GAAA,GAAM,OAAQ,CAAA,GAAA;MACpB,IAAM,QAAA,GAAW,OAAQ,CAAA,OAAA;MACzB,IAAM,UAAA,GAAa,OAAQ,CAAA,UAAA;MACrB,IAAA,SAAA,GAAY,OAAQ,CAAA,QAAA,CAAS,WAAY,CAAA,cAAA;MAE/C,IAAM,KAAQ,GAAA,IAAA,CAAK,GAAI,CAAA,OAAA,CAAQ,UAAA,EAAY,CAAG,CAAA;MAC9C,IAAM,IAAQ,GAAA,KAAA,GAAQ,CACf,IAAA,OAAA,CAAQ,QAAA,CAAS,WAAY,CAAA,SAAA,GAC9B,eAAgB,CAAA,OAAA,CAAQ,QAAA,EAAU,KAAK,CAAA,GACvC,OAAQ,CAAA,QAAA,IAAA,KAAA,GAAoB,GAAO,IAAA,EAAA,CAAA;MAGzC,KAAA,IAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,UAAW,CAAA,MAAA,EAAQ,CAAA,IAAK,CAC5C,EAAA;QACI,WAAA,CAAY,MAAA,EAAA,CAAA,GAAY,UAAW,CAAA,CAAA,CAAA;QACvB,WAAA,CAAA,MAAA,EAAA,CAAA,GAAY,UAAA,CAAW,CAAI,GAAA,CAAA,CAAA;QACvC,WAAA,CAAY,MAAA,EAAA,CAAA,GAAY,GAAI,CAAA,CAAA,CAAA;QAChB,WAAA,CAAA,MAAA,EAAA,CAAA,GAAY,GAAA,CAAI,CAAI,GAAA,CAAA,CAAA;QAChC,UAAA,CAAW,MAAY,EAAA,CAAA,GAAA,IAAA;QACvB,WAAA,CAAY,MAAY,EAAA,CAAA,GAAA,SAAA;MAAA;MAG5B,KAAA,IAAS,GAAI,GAAA,CAAA,EAAG,GAAI,GAAA,QAAA,CAAS,MAAA,EAAQ,GACrC,EAAA,EAAA;QACgB,WAAA,CAAA,MAAA,EAAA,CAAA,GAAY,cAAA,GAAiB,QAAS,CAAA,GAAA,CAAA;MAAA;IACtD;EACJ;IAAA;IAAA,KA7eA,eACA;MACW,OAAA,aAAA;IAAA;EACX;IAAA;IAAA,KAMA,eACA;MACW,OAAA,eAAA;IAAA;EACX;EAAA;AAAA,EAlN+B,cACnC,CAusBA;AAxsBO,IAAM,aAAN,GAAA,cAAA;AAAM,aAAA,CAGF,SAA+B,GAAA;EAClC,IAAM,EAAA,OAAA;EACN,IAAA,EAAM,aAAc,CAAA;AACxB,CAAA;AAurBA,aA7rBS,CA6rBF,aAAA,GAAsC,EAAC;AAU9C,aAvsBS,CAusBF,iBAAA,GAA8C,EAAC;AAI1D,UAAA,CAAW,GAAA,CAAI,aAAa,CAAA","sourcesContent":["import { BatchDrawCall } from './BatchDrawCall';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { BaseTexture } from '../textures/BaseTexture';\nimport { ObjectRenderer } from './ObjectRenderer';\nimport { State } from '../state/State';\nimport { ViewableBuffer } from '../geometry/ViewableBuffer';\nimport { BatchShaderGenerator } from './BatchShaderGenerator';\nimport { checkMaxIfStatementsInShader } from '../shader/utils/checkMaxIfStatementsInShader';\n\nimport { settings } from '@pixi/settings';\nimport { premultiplyBlendMode, premultiplyTint, nextPow2, log2 } from '@pixi/utils';\nimport { ENV } from '@pixi/constants';\nimport { BatchGeometry } from './BatchGeometry';\n\nimport defaultVertex from './texture.vert';\nimport defaultFragment from './texture.frag';\n\nimport type { Renderer } from '../Renderer';\nimport type { Shader } from '../shader/Shader';\nimport type { Texture } from '../textures/Texture';\nimport type { BLEND_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\n/**\n * Interface for elements like Sprite, Mesh etc. for batching.\n * @memberof PIXI\n */\nexport interface IBatchableElement\n{\n    _texture: Texture;\n    vertexData: Float32Array;\n    indices: Uint16Array | Uint32Array | Array<number>;\n    uvs: Float32Array;\n    worldAlpha: number;\n    _tintRGB: number;\n    blendMode: BLEND_MODES;\n}\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * This is the default batch renderer. It buffers objects\n * with texture-based geometries and renders them in\n * batches. It uploads multiple textures to the GPU to\n * reduce to the number of draw calls.\n * @memberof PIXI\n */\nexport class BatchRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'batch',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /**\n     * The number of bufferable objects before a flush\n     * occurs automatically.\n     * @default settings.SPRITE_BATCH_SIZE * 4\n     */\n    public size: number;\n\n    /**\n     * Maximum number of textures that can be uploaded to\n     * the GPU under the current context. It is initialized\n     * properly in `this.contextChange`.\n     * @see PIXI.BatchRenderer#contextChange\n     * @readonly\n     */\n    public MAX_TEXTURES: number;\n\n    /**\n     * This is used to generate a shader that can\n     * color each vertex based on a `aTextureId`\n     * attribute that points to an texture in `uSampler`.\n     *\n     * This enables the objects with different textures\n     * to be drawn in the same draw call.\n     *\n     * You can customize your shader by creating your\n     * custom shader generator.\n     */\n    protected shaderGenerator: BatchShaderGenerator;\n\n    /**\n     * The class that represents the geometry of objects\n     * that are going to be batched with this.\n     * @member {object}\n     * @default PIXI.BatchGeometry\n     */\n    protected geometryClass: typeof BatchGeometry;\n\n    /**\n     * Size of data being buffered per vertex in the\n     * attribute buffers (in floats). By default, the\n     * batch-renderer plugin uses 6:\n     *\n     * | aVertexPosition | 2 |\n     * |-----------------|---|\n     * | aTextureCoords  | 2 |\n     * | aColor          | 1 |\n     * | aTextureId      | 1 |\n     * @default 6\n     */\n    protected vertexSize: number;\n\n    /** Total count of all vertices used by the currently buffered objects. */\n    protected _vertexCount: number;\n\n    /** Total count of all indices used by the currently buffered objects. */\n    protected _indexCount: number;\n\n    /**\n     * Buffer of objects that are yet to be rendered.\n     * @member {PIXI.DisplayObject[]}\n     */\n    protected _bufferedElements: Array<IBatchableElement>;\n\n    /**\n     * Data for texture batch builder, helps to save a bit of CPU on a pass.\n     * @member {PIXI.BaseTexture[]}\n     */\n    protected _bufferedTextures: Array<BaseTexture>;\n\n    /** Number of elements that are buffered and are waiting to be flushed. */\n    protected _bufferSize: number;\n\n    /**\n     * This shader is generated by `this.shaderGenerator`.\n     *\n     * It is generated specifically to handle the required\n     * number of textures being batched together.\n     */\n    protected _shader: Shader;\n\n    /**\n     * A flush may occur multiple times in a single\n     * frame. On iOS devices or when\n     * `settings.CAN_UPLOAD_SAME_BUFFER` is false, the\n     * batch renderer does not upload data to the same\n     * `WebGLBuffer` for performance reasons.\n     *\n     * This is the index into `packedGeometries` that points to\n     * geometry holding the most recent buffers.\n     */\n    protected _flushId: number;\n\n    /**\n     * Pool of `ViewableBuffer` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing attributes.\n     *\n     * The first buffer has a size of 8; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {PIXI.ViewableBuffer[]}\n     * @see PIXI.BatchRenderer#getAttributeBuffer\n     */\n    protected _aBuffers: Array<ViewableBuffer>;\n\n    /**\n     * Pool of `Uint16Array` objects that are sorted in\n     * order of increasing size. The flush method uses\n     * the buffer with the least size above the amount\n     * it requires. These are used for passing indices.\n     *\n     * The first buffer has a size of 12; each subsequent\n     * buffer has double capacity of its previous.\n     * @member {Uint16Array[]}\n     * @see PIXI.BatchRenderer#getIndexBuffer\n     */\n    protected _iBuffers: Array<Uint16Array>;\n    protected _dcIndex: number;\n    protected _aIndex: number;\n    protected _iIndex: number;\n    protected _attributeBuffer: ViewableBuffer;\n    protected _indexBuffer: Uint16Array;\n    protected _tempBoundTextures: BaseTexture[];\n\n    /**\n     * Pool of `this.geometryClass` geometry objects\n     * that store buffers. They are used to pass data\n     * to the shader on each draw call.\n     *\n     * These are never re-allocated again, unless a\n     * context change occurs; however, the pool may\n     * be expanded if required.\n     * @member {PIXI.Geometry[]}\n     * @see PIXI.BatchRenderer.contextChange\n     */\n    private _packedGeometries: Array<BatchGeometry>;\n\n    /**\n     * Size of `this._packedGeometries`. It can be expanded\n     * if more than `this._packedGeometryPoolSize` flushes\n     * occur in a single frame.\n     */\n    private _packedGeometryPoolSize: number;\n\n    /**\n     * This will hook onto the renderer's `contextChange`\n     * and `prerender` signals.\n     * @param {PIXI.Renderer} renderer - The renderer this works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.setShaderGenerator();\n        this.geometryClass = BatchGeometry;\n        this.vertexSize = 6;\n        this.state = State.for2d();\n        this.size = settings.SPRITE_BATCH_SIZE * 4;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n        this._bufferedElements = [];\n        this._bufferedTextures = [];\n        this._bufferSize = 0;\n        this._shader = null;\n        this._packedGeometries = [];\n        this._packedGeometryPoolSize = 2;\n        this._flushId = 0;\n        this._aBuffers = {} as any;\n        this._iBuffers = {} as any;\n\n        this.MAX_TEXTURES = 1;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n        renderer.runners.contextChange.add(this);\n\n        this._dcIndex = 0;\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n        this._tempBoundTextures = [];\n    }\n\n    /**\n     * The default vertex shader source\n     * @readonly\n     */\n    static get defaultVertexSrc(): string\n    {\n        return defaultVertex;\n    }\n\n    /**\n     * The default fragment shader source\n     * @readonly\n     */\n    static get defaultFragmentTemplate(): string\n    {\n        return defaultFragment;\n    }\n\n    /**\n     * Set the shader generator.\n     * @param {object} [options]\n     * @param {string} [options.vertex=PIXI.BatchRenderer.defaultVertexSrc] - Vertex shader source\n     * @param {string} [options.fragment=PIXI.BatchRenderer.defaultFragmentTemplate] - Fragment shader template\n     */\n    public setShaderGenerator({\n        vertex = BatchRenderer.defaultVertexSrc,\n        fragment = BatchRenderer.defaultFragmentTemplate\n    }: { vertex?: string, fragment?: string } = {}): void\n    {\n        this.shaderGenerator = new BatchShaderGenerator(vertex, fragment);\n    }\n\n    /**\n     * Handles the `contextChange` signal.\n     *\n     * It calculates `this.MAX_TEXTURES` and allocating the packed-geometry object pool.\n     */\n    contextChange(): void\n    {\n        const gl = this.renderer.gl;\n\n        if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.MAX_TEXTURES = Math.min(\n                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n                settings.SPRITE_MAX_TEXTURES);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.MAX_TEXTURES = checkMaxIfStatementsInShader(\n                this.MAX_TEXTURES, gl);\n        }\n\n        this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n\n        // we use the second shader as the first one depending on your browser\n        // may omit aTextureId as it is not used by the shader so is optimized out.\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            /* eslint-disable max-len */\n            this._packedGeometries[i] = new (this.geometryClass)();\n        }\n\n        this.initFlushBuffers();\n    }\n\n    /** Makes sure that static and dynamic flush pooled objects have correct dimensions. */\n    initFlushBuffers(): void\n    {\n        const {\n            _drawCallPool,\n            _textureArrayPool,\n        } = BatchRenderer;\n        // max draw calls\n        const MAX_SPRITES = this.size / 4;\n        // max texture arrays\n        const MAX_TA = Math.floor(MAX_SPRITES / this.MAX_TEXTURES) + 1;\n\n        while (_drawCallPool.length < MAX_SPRITES)\n        {\n            _drawCallPool.push(new BatchDrawCall());\n        }\n        while (_textureArrayPool.length < MAX_TA)\n        {\n            _textureArrayPool.push(new BatchTextureArray());\n        }\n        for (let i = 0; i < this.MAX_TEXTURES; i++)\n        {\n            this._tempBoundTextures[i] = null;\n        }\n    }\n\n    /** Handles the `prerender` signal. It ensures that flushes start from the first geometry object again. */\n    onPrerender(): void\n    {\n        this._flushId = 0;\n    }\n\n    /**\n     * Buffers the \"batchable\" object. It need not be rendered immediately.\n     * @param {PIXI.DisplayObject} element - the element to render when\n     *    using this renderer\n     */\n    render(element: IBatchableElement): void\n    {\n        if (!element._texture.valid)\n        {\n            return;\n        }\n\n        if (this._vertexCount + (element.vertexData.length / 2) > this.size)\n        {\n            this.flush();\n        }\n\n        this._vertexCount += element.vertexData.length / 2;\n        this._indexCount += element.indices.length;\n        this._bufferedTextures[this._bufferSize] = element._texture.baseTexture;\n        this._bufferedElements[this._bufferSize++] = element;\n    }\n\n    buildTexturesAndDrawCalls(): void\n    {\n        const {\n            _bufferedTextures: textures,\n            MAX_TEXTURES,\n        } = this;\n        const textureArrays = BatchRenderer._textureArrayPool;\n        const batch = this.renderer.batch;\n        const boundTextures = this._tempBoundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let TICK = ++BaseTexture._globalBatch;\n        let countTexArrays = 0;\n        let texArray = textureArrays[0];\n        let start = 0;\n\n        batch.copyBoundTextures(boundTextures, MAX_TEXTURES);\n\n        for (let i = 0; i < this._bufferSize; ++i)\n        {\n            const tex = textures[i];\n\n            textures[i] = null;\n            if (tex._batchEnabled === TICK)\n            {\n                continue;\n            }\n\n            if (texArray.count >= MAX_TEXTURES)\n            {\n                batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n                this.buildDrawCalls(texArray, start, i);\n                start = i;\n                texArray = textureArrays[++countTexArrays];\n                ++TICK;\n            }\n\n            tex._batchEnabled = TICK;\n            tex.touched = touch;\n            texArray.elements[texArray.count++] = tex;\n        }\n\n        if (texArray.count > 0)\n        {\n            batch.boundArray(texArray, boundTextures, TICK, MAX_TEXTURES);\n            this.buildDrawCalls(texArray, start, this._bufferSize);\n            ++countTexArrays;\n            ++TICK;\n        }\n\n        // Clean-up\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            boundTextures[i] = null;\n        }\n        BaseTexture._globalBatch = TICK;\n    }\n\n    /**\n     * Populating drawcalls for rendering\n     * @param texArray\n     * @param start\n     * @param finish\n     */\n    buildDrawCalls(texArray: BatchTextureArray, start: number, finish: number): void\n    {\n        const {\n            _bufferedElements: elements,\n            _attributeBuffer,\n            _indexBuffer,\n            vertexSize,\n        } = this;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let dcIndex = this._dcIndex;\n        let aIndex = this._aIndex;\n        let iIndex = this._iIndex;\n\n        let drawCall = drawCalls[dcIndex];\n\n        drawCall.start = this._iIndex;\n        drawCall.texArray = texArray;\n\n        for (let i = start; i < finish; ++i)\n        {\n            const sprite = elements[i];\n            const tex = sprite._texture.baseTexture;\n            const spriteBlendMode = premultiplyBlendMode[\n                tex.alphaMode ? 1 : 0][sprite.blendMode];\n\n            elements[i] = null;\n\n            if (start < i && drawCall.blend !== spriteBlendMode)\n            {\n                drawCall.size = iIndex - drawCall.start;\n                start = i;\n                drawCall = drawCalls[++dcIndex];\n                drawCall.texArray = texArray;\n                drawCall.start = iIndex;\n            }\n\n            this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);\n            aIndex += sprite.vertexData.length / 2 * vertexSize;\n            iIndex += sprite.indices.length;\n\n            drawCall.blend = spriteBlendMode;\n        }\n\n        if (start < finish)\n        {\n            drawCall.size = iIndex - drawCall.start;\n            ++dcIndex;\n        }\n\n        this._dcIndex = dcIndex;\n        this._aIndex = aIndex;\n        this._iIndex = iIndex;\n    }\n\n    /**\n     * Bind textures for current rendering\n     * @param texArray\n     */\n    bindAndClearTexArray(texArray: BatchTextureArray): void\n    {\n        const textureSystem = this.renderer.texture;\n\n        for (let j = 0; j < texArray.count; j++)\n        {\n            textureSystem.bind(texArray.elements[j], texArray.ids[j]);\n            texArray.elements[j] = null;\n        }\n        texArray.count = 0;\n    }\n\n    updateGeometry(): void\n    {\n        const {\n            _packedGeometries: packedGeometries,\n            _attributeBuffer: attributeBuffer,\n            _indexBuffer: indexBuffer,\n        } = this;\n\n        if (!settings.CAN_UPLOAD_SAME_BUFFER)\n        { /* Usually on iOS devices, where the browser doesn't\n            like uploads to the same buffer in a single frame. */\n            if (this._packedGeometryPoolSize <= this._flushId)\n            {\n                this._packedGeometryPoolSize++;\n                packedGeometries[this._flushId] = new (this.geometryClass)();\n            }\n\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.bind(packedGeometries[this._flushId]);\n            this.renderer.geometry.updateBuffers();\n            this._flushId++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData);\n            packedGeometries[this._flushId]._indexBuffer.update(indexBuffer);\n\n            this.renderer.geometry.updateBuffers();\n        }\n    }\n\n    drawBatches(): void\n    {\n        const dcCount = this._dcIndex;\n        const { gl, state: stateSystem } = this.renderer;\n        const drawCalls = BatchRenderer._drawCallPool;\n\n        let curTexArray = null;\n\n        // Upload textures and do the draw calls\n        for (let i = 0; i < dcCount; i++)\n        {\n            const { texArray, type, size, start, blend } = drawCalls[i];\n\n            if (curTexArray !== texArray)\n            {\n                curTexArray = texArray;\n                this.bindAndClearTexArray(texArray);\n            }\n\n            this.state.blendMode = blend;\n            stateSystem.set(this.state);\n            gl.drawElements(type, size, gl.UNSIGNED_SHORT, start * 2);\n        }\n    }\n\n    /** Renders the content _now_ and empties the current batch. */\n    flush(): void\n    {\n        if (this._vertexCount === 0)\n        {\n            return;\n        }\n\n        this._attributeBuffer = this.getAttributeBuffer(this._vertexCount);\n        this._indexBuffer = this.getIndexBuffer(this._indexCount);\n        this._aIndex = 0;\n        this._iIndex = 0;\n        this._dcIndex = 0;\n\n        this.buildTexturesAndDrawCalls();\n        this.updateGeometry();\n        this.drawBatches();\n\n        // reset elements buffer for the next flush\n        this._bufferSize = 0;\n        this._vertexCount = 0;\n        this._indexCount = 0;\n    }\n\n    /** Starts a new sprite batch. */\n    start(): void\n    {\n        this.renderer.state.set(this.state);\n\n        this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES);\n\n        this.renderer.shader.bind(this._shader);\n\n        if (settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n        }\n    }\n\n    /** Stops and flushes the current batch. */\n    stop(): void\n    {\n        this.flush();\n    }\n\n    /** Destroys this `BatchRenderer`. It cannot be used again. */\n    destroy(): void\n    {\n        for (let i = 0; i < this._packedGeometryPoolSize; i++)\n        {\n            if (this._packedGeometries[i])\n            {\n                this._packedGeometries[i].destroy();\n            }\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        this._aBuffers = null;\n        this._iBuffers = null;\n        this._packedGeometries = null;\n        this._attributeBuffer = null;\n        this._indexBuffer = null;\n\n        if (this._shader)\n        {\n            this._shader.destroy();\n            this._shader = null;\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Fetches an attribute buffer from `this._aBuffers` that can hold atleast `size` floats.\n     * @param size - minimum capacity required\n     * @returns - buffer than can hold atleast `size` floats\n     */\n    getAttributeBuffer(size: number): ViewableBuffer\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSize];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer = new ViewableBuffer(roundedSize * this.vertexSize * 4);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Fetches an index buffer from `this._iBuffers` that can\n     * have at least `size` capacity.\n     * @param size - minimum required capacity\n     * @returns - buffer that can fit `size` indices.\n     */\n    getIndexBuffer(size: number): Uint16Array\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Takes the four batching parameters of `element`, interleaves\n     * and pushes them into the batching attribute/index buffers given.\n     *\n     * It uses these properties: `vertexData` `uvs`, `textureId` and\n     * `indicies`. It also uses the \"tint\" of the base-texture, if\n     * present.\n     * @param {PIXI.DisplayObject} element - element being rendered\n     * @param attributeBuffer - attribute buffer.\n     * @param indexBuffer - index buffer\n     * @param aIndex - number of floats already in the attribute buffer\n     * @param iIndex - number of indices already in `indexBuffer`\n     */\n    packInterleavedGeometry(element: IBatchableElement, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array,\n        aIndex: number, iIndex: number): void\n    {\n        const {\n            uint32View,\n            float32View,\n        } = attributeBuffer;\n\n        const packedVertices = aIndex / this.vertexSize;\n        const uvs = element.uvs;\n        const indicies = element.indices;\n        const vertexData = element.vertexData;\n        const textureId = element._texture.baseTexture._batchLocation;\n\n        const alpha = Math.min(element.worldAlpha, 1.0);\n        const argb = (alpha < 1.0\n            && element._texture.baseTexture.alphaMode)\n            ? premultiplyTint(element._tintRGB, alpha)\n            : element._tintRGB + (alpha * 255 << 24);\n\n        // lets not worry about tint! for now..\n        for (let i = 0; i < vertexData.length; i += 2)\n        {\n            float32View[aIndex++] = vertexData[i];\n            float32View[aIndex++] = vertexData[i + 1];\n            float32View[aIndex++] = uvs[i];\n            float32View[aIndex++] = uvs[i + 1];\n            uint32View[aIndex++] = argb;\n            float32View[aIndex++] = textureId;\n        }\n\n        for (let i = 0; i < indicies.length; i++)\n        {\n            indexBuffer[iIndex++] = packedVertices + indicies[i];\n        }\n    }\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    static _drawCallPool: Array<BatchDrawCall> = [];\n\n    /**\n     * Pool of `BatchDrawCall` objects that `flush` used\n     * to create \"batches\" of the objects being rendered.\n     *\n     * These are never re-allocated again.\n     * Shared between all batch renderers because it can be only one \"flush\" working at the moment.\n     * @member {PIXI.BatchTextureArray[]}\n     */\n    static _textureArrayPool: Array<BatchTextureArray> = [];\n}\n\n// Install BatchRenderer as default\nextensions.add(BatchRenderer);\n"]},"metadata":{},"sourceType":"module"}