{"ast":null,"code":"/*!\n * @pixi/mesh-extras - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/mesh-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar mesh = require('@pixi/mesh');\nvar constants = require('@pixi/constants');\nvar core = require('@pixi/core');\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * @memberof PIXI\n */\nvar PlaneGeometry = /** @class */function (_super) {\n  __extends(PlaneGeometry, _super);\n  /**\n   * @param width - The width of the plane.\n   * @param height - The height of the plane.\n   * @param segWidth - Number of horizontal segments.\n   * @param segHeight - Number of vertical segments.\n   */\n  function PlaneGeometry(width, height, segWidth, segHeight) {\n    if (width === void 0) {\n      width = 100;\n    }\n    if (height === void 0) {\n      height = 100;\n    }\n    if (segWidth === void 0) {\n      segWidth = 10;\n    }\n    if (segHeight === void 0) {\n      segHeight = 10;\n    }\n    var _this = _super.call(this) || this;\n    _this.segWidth = segWidth;\n    _this.segHeight = segHeight;\n    _this.width = width;\n    _this.height = height;\n    _this.build();\n    return _this;\n  }\n  /**\n   * Refreshes plane coordinates\n   * @private\n   */\n  PlaneGeometry.prototype.build = function () {\n    var total = this.segWidth * this.segHeight;\n    var verts = [];\n    var uvs = [];\n    var indices = [];\n    var segmentsX = this.segWidth - 1;\n    var segmentsY = this.segHeight - 1;\n    var sizeX = this.width / segmentsX;\n    var sizeY = this.height / segmentsY;\n    for (var i = 0; i < total; i++) {\n      var x = i % this.segWidth;\n      var y = i / this.segWidth | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / segmentsX, y / segmentsY);\n    }\n    var totalSub = segmentsX * segmentsY;\n    for (var i = 0; i < totalSub; i++) {\n      var xpos = i % segmentsX;\n      var ypos = i / segmentsX | 0;\n      var value = ypos * this.segWidth + xpos;\n      var value2 = ypos * this.segWidth + xpos + 1;\n      var value3 = (ypos + 1) * this.segWidth + xpos;\n      var value4 = (ypos + 1) * this.segWidth + xpos + 1;\n      indices.push(value, value2, value3, value2, value4, value3);\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint16Array(indices);\n    // ensure that the changes are uploaded\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  };\n  return PlaneGeometry;\n}(mesh.MeshGeometry);\n\n/**\n * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n *\n * ```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * const rope = new PIXI.RopeGeometry(100, points);\n * ```\n * @memberof PIXI\n */\nvar RopeGeometry = /** @class */function (_super) {\n  __extends(RopeGeometry, _super);\n  /**\n   * @param width - The width (i.e., thickness) of the rope.\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   * @param textureScale - By default the rope texture will be stretched to match\n   *     rope length. If textureScale is positive this value will be treated as a scaling\n   *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n   *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,\n   *     then set textureScale=1 to keep the original texture pixel size.\n   *     In order to reduce alpha channel artifacts provide a larger texture and downsample -\n   *     i.e. set textureScale=0.5 to scale it down twice.\n   */\n  function RopeGeometry(width, points, textureScale) {\n    if (width === void 0) {\n      width = 200;\n    }\n    if (textureScale === void 0) {\n      textureScale = 0;\n    }\n    var _this = _super.call(this, new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6)) || this;\n    _this.points = points;\n    _this._width = width;\n    _this.textureScale = textureScale;\n    _this.build();\n    return _this;\n  }\n  Object.defineProperty(RopeGeometry.prototype, \"width\", {\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    get: function get() {\n      return this._width;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Refreshes Rope indices and uvs */\n  RopeGeometry.prototype.build = function () {\n    var points = this.points;\n    if (!points) {\n      return;\n    }\n    var vertexBuffer = this.getBuffer('aVertexPosition');\n    var uvBuffer = this.getBuffer('aTextureCoord');\n    var indexBuffer = this.getIndex();\n    // if too little points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1) {\n      return;\n    }\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    var uvs = uvBuffer.data;\n    var indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    var amount = 0;\n    var prev = points[0];\n    var textureWidth = this._width * this.textureScale;\n    var total = points.length; // - 1;\n    for (var i = 0; i < total; i++) {\n      // time to do some smart drawing!\n      var index = i * 4;\n      if (this.textureScale > 0) {\n        // calculate pixel distance from previous point\n        var dx = prev.x - points[i].x;\n        var dy = prev.y - points[i].y;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n        prev = points[i];\n        amount += distance / textureWidth;\n      } else {\n        // stretch texture\n        amount = i / (total - 1);\n      }\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    var indexCount = 0;\n    for (var i = 0; i < total - 1; i++) {\n      var index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  };\n  /** refreshes vertices of Rope mesh */\n  RopeGeometry.prototype.updateVertices = function () {\n    var points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    var lastPoint = points[0];\n    var nextPoint;\n    var perpX = 0;\n    var perpY = 0;\n    var vertices = this.buffers[0].data;\n    var total = points.length;\n    for (var i = 0; i < total; i++) {\n      var point = points[i];\n      var index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      var num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  };\n  RopeGeometry.prototype.update = function () {\n    if (this.textureScale > 0) {\n      this.build(); // we need to update UVs\n    } else {\n      this.updateVertices();\n    }\n  };\n  return RopeGeometry;\n}(mesh.MeshGeometry);\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.SimpleRope(PIXI.Texture.from(\"snake.png\"), points);\n *  ```\n * @memberof PIXI\n */\nvar SimpleRope = /** @class */function (_super) {\n  __extends(SimpleRope, _super);\n  /**\n   * @param texture - The texture to use on the rope.\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   * @param {number} textureScale - Optional. Positive values scale rope texture\n   * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n   * and downsampling here. If set to zero, texture will be stretched instead.\n   */\n  function SimpleRope(texture, points, textureScale) {\n    if (textureScale === void 0) {\n      textureScale = 0;\n    }\n    var _this = this;\n    var ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n    var meshMaterial = new mesh.MeshMaterial(texture);\n    if (textureScale > 0) {\n      // attempt to set UV wrapping, will fail on non-power of two textures\n      texture.baseTexture.wrapMode = constants.WRAP_MODES.REPEAT;\n    }\n    _this = _super.call(this, ropeGeometry, meshMaterial) || this;\n    /**\n     * re-calculate vertices by rope points each frame\n     * @member {boolean}\n     */\n    _this.autoUpdate = true;\n    return _this;\n  }\n  SimpleRope.prototype._render = function (renderer) {\n    var geometry = this.geometry;\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  return SimpleRope;\n}(mesh.Mesh);\n\n/**\n * The SimplePlane allows you to draw a texture across several points and then manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let SimplePlane = new PIXI.SimplePlane(PIXI.Texture.from(\"snake.png\"), points);\n *  ```\n * @memberof PIXI\n */\nvar SimplePlane = /** @class */function (_super) {\n  __extends(SimplePlane, _super);\n  /**\n   * @param texture - The texture to use on the SimplePlane.\n   * @param verticesX - The number of vertices in the x-axis\n   * @param verticesY - The number of vertices in the y-axis\n   */\n  function SimplePlane(texture, verticesX, verticesY) {\n    var _this = this;\n    var planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n    var meshMaterial = new mesh.MeshMaterial(core.Texture.WHITE);\n    _this = _super.call(this, planeGeometry, meshMaterial) || this;\n    // lets call the setter to ensure all necessary updates are performed\n    _this.texture = texture;\n    _this.autoResize = true;\n    return _this;\n  }\n  /**\n   * Method used for overrides, to do something in case texture frame was changed.\n   * Meshes based on plane can override it and change more details based on texture.\n   */\n  SimplePlane.prototype.textureUpdated = function () {\n    this._textureID = this.shader.texture._updateID;\n    var geometry = this.geometry;\n    var _a = this.shader.texture,\n      width = _a.width,\n      height = _a.height;\n    if (this.autoResize && (geometry.width !== width || geometry.height !== height)) {\n      geometry.width = this.shader.texture.width;\n      geometry.height = this.shader.texture.height;\n      geometry.build();\n    }\n  };\n  Object.defineProperty(SimplePlane.prototype, \"texture\", {\n    get: function get() {\n      return this.shader.texture;\n    },\n    set: function set(value) {\n      // Track texture same way sprite does.\n      // For generated meshes like NineSlicePlane it can change the geometry.\n      // Unfortunately, this method might not work if you directly change texture in material.\n      if (this.shader.texture === value) {\n        return;\n      }\n      this.shader.texture = value;\n      this._textureID = -1;\n      if (value.baseTexture.valid) {\n        this.textureUpdated();\n      } else {\n        value.once('update', this.textureUpdated, this);\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SimplePlane.prototype._render = function (renderer) {\n    if (this._textureID !== this.shader.texture._updateID) {\n      this.textureUpdated();\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  SimplePlane.prototype.destroy = function (options) {\n    this.shader.texture.off('update', this.textureUpdated, this);\n    _super.prototype.destroy.call(this, options);\n  };\n  return SimplePlane;\n}(mesh.Mesh);\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS v4, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link PIXI.Mesh}.\n * @memberof PIXI\n */\nvar SimpleMesh = /** @class */function (_super) {\n  __extends(SimpleMesh, _super);\n  /**\n   * @param texture - The texture to use\n   * @param {Float32Array} [vertices] - if you want to specify the vertices\n   * @param {Float32Array} [uvs] - if you want to specify the uvs\n   * @param {Uint16Array} [indices] - if you want to specify the indices\n   * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts\n   */\n  function SimpleMesh(texture, vertices, uvs, indices, drawMode) {\n    if (texture === void 0) {\n      texture = core.Texture.EMPTY;\n    }\n    var _this = this;\n    var geometry = new mesh.MeshGeometry(vertices, uvs, indices);\n    geometry.getBuffer('aVertexPosition').static = false;\n    var meshMaterial = new mesh.MeshMaterial(texture);\n    _this = _super.call(this, geometry, meshMaterial, null, drawMode) || this;\n    _this.autoUpdate = true;\n    return _this;\n  }\n  Object.defineProperty(SimpleMesh.prototype, \"vertices\", {\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get: function get() {\n      return this.geometry.getBuffer('aVertexPosition').data;\n    },\n    set: function set(value) {\n      this.geometry.getBuffer('aVertexPosition').data = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  SimpleMesh.prototype._render = function (renderer) {\n    if (this.autoUpdate) {\n      this.geometry.getBuffer('aVertexPosition').update();\n    }\n    _super.prototype._render.call(this, renderer);\n  };\n  return SimpleMesh;\n}(mesh.Mesh);\nvar DEFAULT_BORDER_SIZE = 10;\n/**\n * The NineSlicePlane allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n *```js\n * let Plane9 = new PIXI.NineSlicePlane(PIXI.Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);\n *  ```\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @memberof PIXI\n */\nvar NineSlicePlane = /** @class */function (_super) {\n  __extends(NineSlicePlane, _super);\n  /**\n   * @param texture - The texture to use on the NineSlicePlane.\n   * @param {number} [leftWidth=10] - size of the left vertical bar (A)\n   * @param {number} [topHeight=10] - size of the top horizontal bar (C)\n   * @param {number} [rightWidth=10] - size of the right vertical bar (B)\n   * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)\n   */\n  function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) {\n    if (leftWidth === void 0) {\n      leftWidth = DEFAULT_BORDER_SIZE;\n    }\n    if (topHeight === void 0) {\n      topHeight = DEFAULT_BORDER_SIZE;\n    }\n    if (rightWidth === void 0) {\n      rightWidth = DEFAULT_BORDER_SIZE;\n    }\n    if (bottomHeight === void 0) {\n      bottomHeight = DEFAULT_BORDER_SIZE;\n    }\n    var _this = _super.call(this, core.Texture.WHITE, 4, 4) || this;\n    _this._origWidth = texture.orig.width;\n    _this._origHeight = texture.orig.height;\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    _this._width = _this._origWidth;\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    _this._height = _this._origHeight;\n    _this._leftWidth = leftWidth;\n    _this._rightWidth = rightWidth;\n    _this._topHeight = topHeight;\n    _this._bottomHeight = bottomHeight;\n    // lets call the setter to ensure all necessary updates are performed\n    _this.texture = texture;\n    return _this;\n  }\n  NineSlicePlane.prototype.textureUpdated = function () {\n    this._textureID = this.shader.texture._updateID;\n    this._refresh();\n  };\n  Object.defineProperty(NineSlicePlane.prototype, \"vertices\", {\n    get: function get() {\n      return this.geometry.getBuffer('aVertexPosition').data;\n    },\n    set: function set(value) {\n      this.geometry.getBuffer('aVertexPosition').data = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Updates the horizontal vertices. */\n  NineSlicePlane.prototype.updateHorizontalVertices = function () {\n    var vertices = this.vertices;\n    var scale = this._getMinScale();\n    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight * scale;\n    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n  };\n  /** Updates the vertical vertices. */\n  NineSlicePlane.prototype.updateVerticalVertices = function () {\n    var vertices = this.vertices;\n    var scale = this._getMinScale();\n    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth * scale;\n    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n  };\n  /**\n   * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.\n   * @returns Smaller number of vertical and horizontal scale.\n   */\n  NineSlicePlane.prototype._getMinScale = function () {\n    var w = this._leftWidth + this._rightWidth;\n    var scaleW = this._width > w ? 1.0 : this._width / w;\n    var h = this._topHeight + this._bottomHeight;\n    var scaleH = this._height > h ? 1.0 : this._height / h;\n    var scale = Math.min(scaleW, scaleH);\n    return scale;\n  };\n  Object.defineProperty(NineSlicePlane.prototype, \"width\", {\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value) {\n      this._width = value;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"height\", {\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value) {\n      this._height = value;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"leftWidth\", {\n    /** The width of the left column. */\n    get: function get() {\n      return this._leftWidth;\n    },\n    set: function set(value) {\n      this._leftWidth = value;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"rightWidth\", {\n    /** The width of the right column. */\n    get: function get() {\n      return this._rightWidth;\n    },\n    set: function set(value) {\n      this._rightWidth = value;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"topHeight\", {\n    /** The height of the top row. */\n    get: function get() {\n      return this._topHeight;\n    },\n    set: function set(value) {\n      this._topHeight = value;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NineSlicePlane.prototype, \"bottomHeight\", {\n    /** The height of the bottom row. */\n    get: function get() {\n      return this._bottomHeight;\n    },\n    set: function set(value) {\n      this._bottomHeight = value;\n      this._refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /** Refreshes NineSlicePlane coords. All of them. */\n  NineSlicePlane.prototype._refresh = function () {\n    var texture = this.texture;\n    var uvs = this.geometry.buffers[1].data;\n    this._origWidth = texture.orig.width;\n    this._origHeight = texture.orig.height;\n    var _uvw = 1.0 / this._origWidth;\n    var _uvh = 1.0 / this._origHeight;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.updateHorizontalVertices();\n    this.updateVerticalVertices();\n    this.geometry.buffers[0].update();\n    this.geometry.buffers[1].update();\n  };\n  return NineSlicePlane;\n}(SimplePlane);\nexports.NineSlicePlane = NineSlicePlane;\nexports.PlaneGeometry = PlaneGeometry;\nexports.RopeGeometry = RopeGeometry;\nexports.SimpleMesh = SimpleMesh;\nexports.SimplePlane = SimplePlane;\nexports.SimpleRope = SimpleRope;","map":{"version":3,"mappings":"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","names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","width","height","segWidth","segHeight","_super","_this","build","PlaneGeometry","total","verts","uvs","indices","segmentsX","segmentsY","sizeX","sizeY","i","x","y","push","totalSub","xpos","ypos","value","value2","value3","value4","buffers","data","Float32Array","indexBuffer","Uint16Array","update","MeshGeometry","points","textureScale","length","_width","RopeGeometry","get","vertexBuffer","getBuffer","uvBuffer","getIndex","amount","prev","textureWidth","index","dx","dy","distance","Math","sqrt","indexCount","updateVertices","lastPoint","nextPoint","perpX","perpY","vertices","point","perpLength","num","texture","ropeGeometry","meshMaterial","MeshMaterial","baseTexture","wrapMode","WRAP_MODES","REPEAT","autoUpdate","SimpleRope","renderer","geometry","shader","_render","Mesh","verticesX","verticesY","planeGeometry","Texture","WHITE","autoResize","SimplePlane","_textureID","_updateID","set","valid","textureUpdated","once","options","off","destroy","SimpleMesh","drawMode","EMPTY","static","DEFAULT_BORDER_SIZE","NineSlicePlane","leftWidth","topHeight","rightWidth","bottomHeight","_origWidth","orig","_origHeight","_height","_leftWidth","_rightWidth","_topHeight","_bottomHeight","_refresh","scale","_getMinScale","w","scaleW","h","scaleH","min","_uvw","_uvh","updateHorizontalVertices","updateVerticalVertices"],"sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/geometry/PlaneGeometry.ts","../../src/geometry/RopeGeometry.ts","../../src/SimpleRope.ts","../../src/SimplePlane.ts","../../src/SimpleMesh.ts","../../src/NineSlicePlane.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { MeshGeometry } from '@pixi/mesh';\n\n/**\n * @memberof PIXI\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public segWidth: number;\n    public segHeight: number;\n    public width: number;\n    public height: number;\n\n    /**\n     * @param width - The width of the plane.\n     * @param height - The height of the plane.\n     * @param segWidth - Number of horizontal segments.\n     * @param segHeight - Number of vertical segments.\n     */\n    constructor(width = 100, height = 100, segWidth = 10, segHeight = 10)\n    {\n        super();\n\n        this.segWidth = segWidth;\n        this.segHeight = segHeight;\n\n        this.width = width;\n        this.height = height;\n\n        this.build();\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @private\n     */\n    build(): void\n    {\n        const total = this.segWidth * this.segHeight;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const segmentsX = this.segWidth - 1;\n        const segmentsY = this.segHeight - 1;\n\n        const sizeX = (this.width) / segmentsX;\n        const sizeY = (this.height) / segmentsY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.segWidth);\n            const y = ((i / this.segWidth) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / segmentsX, y / segmentsY);\n        }\n\n        const totalSub = segmentsX * segmentsY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % segmentsX;\n            const ypos = (i / segmentsX) | 0;\n\n            const value = (ypos * this.segWidth) + xpos;\n            const value2 = (ypos * this.segWidth) + xpos + 1;\n            const value3 = ((ypos + 1) * this.segWidth) + xpos;\n            const value4 = ((ypos + 1) * this.segWidth) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint16Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { MeshGeometry } from '@pixi/mesh';\nimport type { IPoint } from '@pixi/math';\n\n/**\n * RopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n *\n * ```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * const rope = new PIXI.RopeGeometry(100, points);\n * ```\n * @memberof PIXI\n */\nexport class RopeGeometry extends MeshGeometry\n{\n    /** An array of points that determine the rope. */\n    public points: IPoint[];\n\n    /** Rope texture scale, if zero then the rope texture is stretched. */\n    public readonly textureScale: number;\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    _width: number;\n\n    /**\n     * @param width - The width (i.e., thickness) of the rope.\n     * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n     * @param textureScale - By default the rope texture will be stretched to match\n     *     rope length. If textureScale is positive this value will be treated as a scaling\n     *     factor and the texture will preserve its aspect ratio instead. To create a tiling rope\n     *     set baseTexture.wrapMode to {@link PIXI.WRAP_MODES.REPEAT} and use a power of two texture,\n     *     then set textureScale=1 to keep the original texture pixel size.\n     *     In order to reduce alpha channel artifacts provide a larger texture and downsample -\n     *     i.e. set textureScale=0.5 to scale it down twice.\n     */\n    constructor(width = 200, points: IPoint[], textureScale = 0)\n    {\n        super(new Float32Array(points.length * 4),\n            new Float32Array(points.length * 4),\n            new Uint16Array((points.length - 1) * 6));\n\n        this.points = points;\n        this._width = width;\n        this.textureScale = textureScale;\n\n        this.build();\n    }\n\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @readonly\n     */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    /** Refreshes Rope indices and uvs */\n    private build(): void\n    {\n        const points = this.points;\n\n        if (!points) return;\n\n        const vertexBuffer = this.getBuffer('aVertexPosition');\n        const uvBuffer = this.getBuffer('aTextureCoord');\n        const indexBuffer = this.getIndex();\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (vertexBuffer.data.length / 4 !== points.length)\n        {\n            vertexBuffer.data = new Float32Array(points.length * 4);\n            uvBuffer.data = new Float32Array(points.length * 4);\n            indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n        }\n\n        const uvs = uvBuffer.data;\n        const indices = indexBuffer.data;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        let amount = 0;\n        let prev = points[0];\n        const textureWidth = this._width * this.textureScale;\n        const total = points.length; // - 1;\n\n        for (let i = 0; i < total; i++)\n        {\n            // time to do some smart drawing!\n            const index = i * 4;\n\n            if (this.textureScale > 0)\n            {\n                // calculate pixel distance from previous point\n                const dx = prev.x - points[i].x;\n                const dy = prev.y - points[i].y;\n                const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n                prev = points[i];\n                amount += distance / textureWidth;\n            }\n            else\n            {\n                // stretch texture\n                amount = i / (total - 1);\n            }\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n        }\n\n        let indexCount = 0;\n\n        for (let i = 0; i < total - 1; i++)\n        {\n            const index = i * 2;\n\n            indices[indexCount++] = index;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 2;\n\n            indices[indexCount++] = index + 2;\n            indices[indexCount++] = index + 1;\n            indices[indexCount++] = index + 3;\n        }\n\n        // ensure that the changes are uploaded\n        uvBuffer.update();\n        indexBuffer.update();\n\n        this.updateVertices();\n    }\n\n    /** refreshes vertices of Rope mesh */\n    public updateVertices(): void\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        const vertices = this.buffers[0].data;\n        const total = points.length;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n            const num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n\n            perpX /= perpLength;\n            perpY /= perpLength;\n\n            perpX *= num;\n            perpY *= num;\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n\n        this.buffers[0].update();\n    }\n\n    public update(): void\n    {\n        if (this.textureScale > 0)\n        {\n            this.build(); // we need to update UVs\n        }\n        else\n        {\n            this.updateVertices();\n        }\n    }\n}\n","import { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { WRAP_MODES } from '@pixi/constants';\nimport { RopeGeometry } from './geometry/RopeGeometry';\n\nimport type { Texture, Renderer } from '@pixi/core';\nimport type { IPoint } from '@pixi/math';\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.SimpleRope(PIXI.Texture.from(\"snake.png\"), points);\n *  ```\n * @memberof PIXI\n */\nexport class SimpleRope extends Mesh\n{\n    public autoUpdate: boolean;\n\n    /**\n     * @param texture - The texture to use on the rope.\n     * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n     * @param {number} textureScale - Optional. Positive values scale rope texture\n     * keeping its aspect ratio. You can reduce alpha channel artifacts by providing a larger texture\n     * and downsampling here. If set to zero, texture will be stretched instead.\n     */\n    constructor(texture: Texture, points: IPoint[], textureScale = 0)\n    {\n        const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n        const meshMaterial = new MeshMaterial(texture);\n\n        if (textureScale > 0)\n        {\n            // attempt to set UV wrapping, will fail on non-power of two textures\n            texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n        }\n        super(ropeGeometry, meshMaterial);\n\n        /**\n         * re-calculate vertices by rope points each frame\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        const geometry: RopeGeometry = this.geometry as any;\n\n        if (this.autoUpdate || geometry._width !== this.shader.texture.height)\n        {\n            geometry._width = this.shader.texture.height;\n            geometry.update();\n        }\n\n        super._render(renderer);\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { PlaneGeometry } from './geometry/PlaneGeometry';\n\nimport type{ Renderer } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * The SimplePlane allows you to draw a texture across several points and then manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let SimplePlane = new PIXI.SimplePlane(PIXI.Texture.from(\"snake.png\"), points);\n *  ```\n * @memberof PIXI\n */\nexport class SimplePlane extends Mesh\n{\n    /** The geometry is automatically updated when the texture size changes. */\n    public autoResize: boolean;\n\n    protected _textureID: number;\n\n    /**\n     * @param texture - The texture to use on the SimplePlane.\n     * @param verticesX - The number of vertices in the x-axis\n     * @param verticesY - The number of vertices in the y-axis\n     */\n    constructor(texture: Texture, verticesX?: number, verticesY?: number)\n    {\n        const planeGeometry = new PlaneGeometry(texture.width, texture.height, verticesX, verticesY);\n        const meshMaterial = new MeshMaterial(Texture.WHITE);\n\n        super(planeGeometry, meshMaterial);\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n        this.autoResize = true;\n    }\n\n    /**\n     * Method used for overrides, to do something in case texture frame was changed.\n     * Meshes based on plane can override it and change more details based on texture.\n     */\n    public textureUpdated(): void\n    {\n        this._textureID = this.shader.texture._updateID;\n\n        const geometry: PlaneGeometry = this.geometry as any;\n        const { width, height } = this.shader.texture;\n\n        if (this.autoResize && (geometry.width !== width || geometry.height !== height))\n        {\n            geometry.width = this.shader.texture.width;\n            geometry.height = this.shader.texture.height;\n            geometry.build();\n        }\n    }\n\n    set texture(value: Texture)\n    {\n        // Track texture same way sprite does.\n        // For generated meshes like NineSlicePlane it can change the geometry.\n        // Unfortunately, this method might not work if you directly change texture in material.\n\n        if (this.shader.texture === value)\n        {\n            return;\n        }\n\n        this.shader.texture = value;\n        this._textureID = -1;\n\n        if (value.baseTexture.valid)\n        {\n            this.textureUpdated();\n        }\n        else\n        {\n            value.once('update', this.textureUpdated, this);\n        }\n    }\n\n    get texture(): Texture\n    {\n        return this.shader.texture;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this._textureID !== this.shader.texture._updateID)\n        {\n            this.textureUpdated();\n        }\n\n        super._render(renderer);\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this.shader.texture.off('update', this.textureUpdated, this);\n        super.destroy(options);\n    }\n}\n","import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { Texture } from '@pixi/core';\n\nimport type { ITypedArray, IArrayBuffer, Renderer } from '@pixi/core';\nimport type { DRAW_MODES } from '@pixi/constants';\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS v4, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link PIXI.Mesh}.\n * @memberof PIXI\n */\nexport class SimpleMesh extends Mesh\n{\n    /** Upload vertices buffer each frame. */\n    public autoUpdate: boolean;\n\n    /**\n     * @param texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(\n        texture: Texture = Texture.EMPTY,\n        vertices?: IArrayBuffer,\n        uvs?: IArrayBuffer,\n        indices?: IArrayBuffer,\n        drawMode?: DRAW_MODES\n    )\n    {\n        const geometry = new MeshGeometry(vertices, uvs, indices);\n\n        geometry.getBuffer('aVertexPosition').static = false;\n\n        const meshMaterial = new MeshMaterial(texture);\n\n        super(geometry, meshMaterial, null, drawMode);\n\n        this.autoUpdate = true;\n    }\n\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aVertexPosition').update();\n        }\n\n        super._render(renderer);\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { SimplePlane } from './SimplePlane';\n\nimport type { ITypedArray } from '@pixi/core';\n\nconst DEFAULT_BORDER_SIZE = 10;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface NineSlicePlane extends GlobalMixins.NineSlicePlane {}\n\n/**\n * The NineSlicePlane allows you to stretch a texture using 9-slice scaling. The corners will remain unscaled (useful\n * for buttons with rounded corners for example) and the other areas will be scaled horizontally and or vertically\n *\n *```js\n * let Plane9 = new PIXI.NineSlicePlane(PIXI.Texture.from('BoxWithRoundedCorners.png'), 15, 15, 15, 15);\n *  ```\n * <pre>\n *      A                          B\n *    +---+----------------------+---+\n *  C | 1 |          2           | 3 |\n *    +---+----------------------+---+\n *    |   |                      |   |\n *    | 4 |          5           | 6 |\n *    |   |                      |   |\n *    +---+----------------------+---+\n *  D | 7 |          8           | 9 |\n *    +---+----------------------+---+\n *  When changing this objects width and/or height:\n *     areas 1 3 7 and 9 will remain unscaled.\n *     areas 2 and 8 will be stretched horizontally\n *     areas 4 and 6 will be stretched vertically\n *     area 5 will be stretched both horizontally and vertically\n * </pre>\n * @memberof PIXI\n */\nexport class NineSlicePlane extends SimplePlane\n{\n    private _origWidth: number;\n    private _origHeight: number;\n\n    /**\n     * The width of the left column (a).\n     * @private\n     */\n    _leftWidth: number;\n\n    /**\n     * The width of the right column (b)\n     * @private\n     */\n    _rightWidth: number;\n\n    /**\n     * The height of the top row (c)\n     * @private\n     */\n    _topHeight: number;\n\n    /**\n     * The height of the bottom row (d)\n     * @private\n     */\n    _bottomHeight: number;\n\n    /**\n     * @param texture - The texture to use on the NineSlicePlane.\n     * @param {number} [leftWidth=10] - size of the left vertical bar (A)\n     * @param {number} [topHeight=10] - size of the top horizontal bar (C)\n     * @param {number} [rightWidth=10] - size of the right vertical bar (B)\n     * @param {number} [bottomHeight=10] - size of the bottom horizontal bar (D)\n     */\n    constructor(\n        texture: Texture,\n        leftWidth = DEFAULT_BORDER_SIZE,\n        topHeight = DEFAULT_BORDER_SIZE,\n        rightWidth = DEFAULT_BORDER_SIZE,\n        bottomHeight = DEFAULT_BORDER_SIZE\n    )\n    {\n        super(Texture.WHITE, 4, 4);\n\n        this._origWidth = texture.orig.width;\n        this._origHeight = texture.orig.height;\n\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        this._width = this._origWidth;\n\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        this._height = this._origHeight;\n\n        this._leftWidth = leftWidth;\n        this._rightWidth = rightWidth;\n        this._topHeight = topHeight;\n        this._bottomHeight = bottomHeight;\n\n        // lets call the setter to ensure all necessary updates are performed\n        this.texture = texture;\n    }\n\n    public textureUpdated(): void\n    {\n        this._textureID = this.shader.texture._updateID;\n        this._refresh();\n    }\n\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    /** Updates the horizontal vertices. */\n    public updateHorizontalVertices(): void\n    {\n        const vertices = this.vertices;\n\n        const scale = this._getMinScale();\n\n        vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight * scale;\n        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - (this._bottomHeight * scale);\n        vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height;\n    }\n\n    /** Updates the vertical vertices. */\n    public updateVerticalVertices(): void\n    {\n        const vertices = this.vertices;\n\n        const scale = this._getMinScale();\n\n        vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth * scale;\n        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - (this._rightWidth * scale);\n        vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width;\n    }\n\n    /**\n     * Returns the smaller of a set of vertical and horizontal scale of nine slice corners.\n     * @returns Smaller number of vertical and horizontal scale.\n     */\n    private _getMinScale(): number\n    {\n        const w = this._leftWidth + this._rightWidth;\n        const scaleW = this._width > w ? 1.0 : this._width / w;\n\n        const h = this._topHeight + this._bottomHeight;\n        const scaleH = this._height > h ? 1.0 : this._height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        return scale;\n    }\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this._width = value;\n        this._refresh();\n    }\n\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n        this._refresh();\n    }\n\n    /** The width of the left column. */\n    get leftWidth(): number\n    {\n        return this._leftWidth;\n    }\n\n    set leftWidth(value: number)\n    {\n        this._leftWidth = value;\n        this._refresh();\n    }\n\n    /** The width of the right column. */\n    get rightWidth(): number\n    {\n        return this._rightWidth;\n    }\n\n    set rightWidth(value: number)\n    {\n        this._rightWidth = value;\n        this._refresh();\n    }\n\n    /** The height of the top row. */\n    get topHeight(): number\n    {\n        return this._topHeight;\n    }\n\n    set topHeight(value: number)\n    {\n        this._topHeight = value;\n        this._refresh();\n    }\n\n    /** The height of the bottom row. */\n    get bottomHeight(): number\n    {\n        return this._bottomHeight;\n    }\n\n    set bottomHeight(value: number)\n    {\n        this._bottomHeight = value;\n        this._refresh();\n    }\n\n    /** Refreshes NineSlicePlane coords. All of them. */\n    private _refresh(): void\n    {\n        const texture = this.texture;\n\n        const uvs = this.geometry.buffers[1].data;\n\n        this._origWidth = texture.orig.width;\n        this._origHeight = texture.orig.height;\n\n        const _uvw = 1.0 / this._origWidth;\n        const _uvh = 1.0 / this._origHeight;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.updateHorizontalVertices();\n        this.updateVerticalVertices();\n\n        this.geometry.buffers[0].update();\n        this.geometry.buffers[1].update();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}