{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar Program = require('./Program.js');\nvar UniformGroup = require('./UniformGroup.js');\nvar runner = require('@pixi/runner');\nvar Shader = /*#__PURE__*/function () {\n  function Shader(program, uniforms) {\n    _classCallCheck(this, Shader);\n    this.uniformBindCount = 0;\n    this.program = program;\n    if (uniforms) {\n      if (uniforms instanceof UniformGroup.UniformGroup) {\n        this.uniformGroup = uniforms;\n      } else {\n        this.uniformGroup = new UniformGroup.UniformGroup(uniforms);\n      }\n    } else {\n      this.uniformGroup = new UniformGroup.UniformGroup({});\n    }\n    this.disposeRunner = new runner.Runner(\"disposeShader\");\n  }\n  _createClass(Shader, [{\n    key: \"checkUniformExists\",\n    value: function checkUniformExists(name, group) {\n      if (group.uniforms[name]) {\n        return true;\n      }\n      for (var i in group.uniforms) {\n        var uniform = group.uniforms[i];\n        if (uniform.group) {\n          if (this.checkUniformExists(name, uniform)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.uniformGroup = null;\n      this.disposeRunner.emit(this);\n      this.disposeRunner.destroy();\n    }\n  }, {\n    key: \"uniforms\",\n    get: function get() {\n      return this.uniformGroup.uniforms;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(vertexSrc, fragmentSrc, uniforms) {\n      var program = Program.Program.from(vertexSrc, fragmentSrc);\n      return new Shader(program, uniforms);\n    }\n  }]);\n  return Shader;\n}();\nexports.Shader = Shader;","map":{"version":3,"sources":["../../src/shader/Shader.ts"],"names":["UniformGroup","Runner"],"mappings":";;;;;;;;;;IAUa,MACb;EAiBI,gBAAY,OAAA,EAAkB,QAC9B,EAAA;IAAA;IATmB,IAAA,CAAA,gBAAA,GAAA,CAAA;IAUf,IAAA,CAAK,OAAU,GAAA,OAAA;IAIf,IAAI,QACJ,EAAA;MACI,IAAI,QAAA,YAAoBA,YAAAA,CAAAA,YACxB,EAAA;QACI,IAAA,CAAK,YAAe,GAAA,QAAA;MAAA,CAGxB,MAAA;QACS,IAAA,CAAA,YAAA,GAAe,IAAIA,YAAAA,CAAAA,YAAAA,CAAa,QAAQ,CAAA;MAAA;IACjD,CAGJ,MAAA;MACI,IAAA,CAAK,YAAe,GAAA,IAAIA,YAAAA,CAAAA,YAAa,CAAA,CAAA,CAAE,CAAA;IAAA;IAGtC,IAAA,CAAA,aAAA,GAAgB,IAAIC,MAAAA,CAAAA,MAAAA,CAAO,eAAe,CAAA;EAAA;EACnD;IAAA;IAAA,OAGA,4BAAmB,IAAA,EAAc,KACjC,EAAA;MACQ,IAAA,KAAA,CAAM,QAAA,CAAS,IACnB,CAAA,EAAA;QACW,OAAA,IAAA;MAAA;MAGA,KAAA,IAAA,CAAA,IAAK,KAAA,CAAM,QACtB,EAAA;QACU,IAAA,OAAA,GAAU,KAAA,CAAM,QAAS,CAAA,CAAA,CAAA;QAE/B,IAAI,OAAA,CAAQ,KACZ,EAAA;UACI,IAAI,IAAK,CAAA,kBAAA,CAAmB,IAAM,EAAA,OAAO,CACzC,EAAA;YACW,OAAA,IAAA;UAAA;QACX;MACJ;MAGG,OAAA,KAAA;IAAA;EACX;IAAA;IAAA,OAEA,mBACA;MAGI,IAAA,CAAK,YAAe,GAAA,IAAA;MAEf,IAAA,CAAA,aAAA,CAAc,IAAA,CAAK,IAAI,CAAA;MAC5B,IAAA,CAAK,aAAA,CAAc,OAAQ,EAAA;IAAA;EAC/B;IAAA;IAAA,KAMA,eACA;MACI,OAAO,IAAA,CAAK,YAAa,CAAA,QAAA;IAAA;EAC7B;IAAA;IAAA,OASA,cAAY,SAAoB,EAAA,WAAA,EAAsB,QACtD,EAAA;MACI,IAAM,OAAU,GAAA,OAAA,CAAA,OAAA,CAAQ,IAAK,CAAA,SAAA,EAAW,WAAW,CAAA;MAE5C,OAAA,IAAI,MAAO,CAAA,OAAA,EAAS,QAAQ,CAAA;IAAA;EACvC;EAAA;AAAA","sourcesContent":["import { Program } from './Program';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { Dict } from '@pixi/utils';\nimport { Runner } from '@pixi/runner';\n\n/**\n * A helper class for shaders.\n * @memberof PIXI\n */\nexport class Shader\n{\n    /** Program that the shader uses. */\n    public program: Program;\n    public uniformGroup: UniformGroup;\n\n    /**\n     * Used internally to bind uniform buffer objects.\n     * @ignore\n     */\n    uniformBindCount = 0;\n\n    disposeRunner: Runner;\n\n    /**\n     * @param program - The program the shader will use.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(program: Program, uniforms?: Dict<any>)\n    {\n        this.program = program;\n\n        // lets see whats been passed in\n        // uniforms should be converted to a uniform group\n        if (uniforms)\n        {\n            if (uniforms instanceof UniformGroup)\n            {\n                this.uniformGroup = uniforms;\n            }\n            else\n            {\n                this.uniformGroup = new UniformGroup(uniforms);\n            }\n        }\n        else\n        {\n            this.uniformGroup = new UniformGroup({});\n        }\n\n        this.disposeRunner = new Runner('disposeShader');\n    }\n\n    // TODO move to shader system..\n    checkUniformExists(name: string, group: UniformGroup): boolean\n    {\n        if (group.uniforms[name])\n        {\n            return true;\n        }\n\n        for (const i in group.uniforms)\n        {\n            const uniform = group.uniforms[i];\n\n            if (uniform.group)\n            {\n                if (this.checkUniformExists(name, uniform))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    destroy(): void\n    {\n        // usage count on programs?\n        // remove if not used!\n        this.uniformGroup = null;\n\n        this.disposeRunner.emit(this);\n        this.disposeRunner.destroy();\n    }\n\n    /**\n     * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n     * @readonly\n     */\n    get uniforms(): Dict<any>\n    {\n        return this.uniformGroup.uniforms;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     * @returns A shiny new PixiJS shader!\n     */\n    static from(vertexSrc?: string, fragmentSrc?: string, uniforms?: Dict<any>): Shader\n    {\n        const program = Program.from(vertexSrc, fragmentSrc);\n\n        return new Shader(program, uniforms);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}