{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar buildCircle = {\n  build: function build(graphicsData) {\n    var points = graphicsData.points;\n    var x;\n    var y;\n    var dx;\n    var dy;\n    var rx;\n    var ry;\n    if (graphicsData.type === core.SHAPES.CIRC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === core.SHAPES.ELIP) {\n      var ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      var roundedRect = graphicsData.shape;\n      var halfWidth = roundedRect.width / 2;\n      var halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      points.length = 0;\n      return;\n    }\n    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n    if (m === 0) {\n      return;\n    }\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n    var j1 = 0;\n    var j2 = n * 4 + (dx ? 2 : 0) + 2;\n    var j3 = j2;\n    var j4 = m;\n    {\n      var x0 = dx + rx;\n      var y0 = dy;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      if (dy) {\n        var y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n    for (var i = 1; i < n; i++) {\n      var a = Math.PI / 2 * (i / n);\n      var _x = dx + Math.cos(a) * rx;\n      var _y = dy + Math.sin(a) * ry;\n      var _x2 = x + _x;\n      var _x3 = x - _x;\n      var _y2 = y + _y;\n      var _y3 = y - _y;\n      points[j1++] = _x2;\n      points[j1++] = _y2;\n      points[--j2] = _y2;\n      points[--j2] = _x3;\n      points[j3++] = _x3;\n      points[j3++] = _y3;\n      points[--j4] = _y3;\n      points[--j4] = _x2;\n    }\n    {\n      var _x4 = dx;\n      var _y4 = dy + ry;\n      var _x5 = x + _x4;\n      var _x6 = x - _x4;\n      var _y5 = y + _y4;\n      var _y6 = y - _y4;\n      points[j1++] = _x5;\n      points[j1++] = _y5;\n      points[--j4] = _y6;\n      points[--j4] = _x5;\n      if (dx) {\n        points[j1++] = _x6;\n        points[j1++] = _y5;\n        points[--j4] = _y6;\n        points[--j4] = _x6;\n      }\n    }\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    if (points.length === 0) {\n      return;\n    }\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var x;\n    var y;\n    if (graphicsData.type !== core.SHAPES.RREC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      var roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n    var matrix = graphicsData.matrix;\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n    for (var i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]);\n      indices.push(vertPos++, center, vertPos);\n    }\n    indices.push(center + 1, center, vertPos);\n  }\n};\nexports.buildCircle = buildCircle;","map":{"version":3,"sources":["../../src/utils/buildCircle.ts"],"names":[],"mappings":"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","sourcesContent":["// for type only\nimport { SHAPES } from '@pixi/core';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/core';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            points.length = 0;\n\n            return;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n"]},"metadata":{},"sourceType":"script"}