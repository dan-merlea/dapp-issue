{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar dictionary_1 = require(\"./dictionary\");\nvar transform_1 = require(\"./transform\");\nvar regex_1 = require(\"./regex\");\nvar utils_1 = require(\"./utils\");\nvar list = function list(input) {\n  var found = [];\n  var result = null;\n  var _loop_1 = function _loop_1() {\n    var start = result.index;\n    var end = start + result[0].length;\n    var string = result[0];\n    // ### trailing slashes problem\n    /**\n     * This is a quick and dirty fix for a problem that could be probably fixed with\n     * slight modification in the regex.\n     * The problem is that the library doesn't count the trailing slashes as part\n     * of the URL, unless there were multiple trailing slashes.\n     */\n    if (input.charAt(end) === \"/\") {\n      string = string + input.charAt(end);\n      end++;\n    }\n    // ### Parenthesis problem\n    /**\n            As we're using the \\b to tokenize the URL, sometimes the parenthesis are part of the URL\n            and sometimes they are actually the last part, this makes the tokenization stops just\n            before them.\n            To fix this, we calculate how many parenthesis are open and how many are closed inside\n            the URL and based on the number we should be able to know whether the aforementioned\n            parenthesis character is part of the URL or not\n        */\n    if (dictionary_1.closingParenthesis.indexOf(input.charAt(end)) > -1) {\n      dictionary_1.parenthesis.forEach(function (str) {\n        var opening = str.charAt(0);\n        var closing = str.charAt(1);\n        if (utils_1.checkParenthesis(opening, closing, string, input.charAt(end))) {\n          string = string + input.charAt(end);\n          end++;\n        }\n      });\n    }\n    // ### HTML problem 1\n    /**\n            checking whether the token is already inside an HTML element by seeing if it's\n            preceded by an HTML attribute that would hold a url (e.g. scr, cite ...etc)\n        */\n    if (['\"\"', \"''\", \"()\"].indexOf(input.charAt(start - 1) + input.charAt(end)) !== -1) {\n      if (utils_1.isInsideAttribute(input.substring(start - utils_1.maximumAttrLength - 15, start))) {\n        return \"continue\";\n      }\n    }\n    // ### HTML problem 2\n    /**\n            Checking whether the token is the content of an actual anchor\n            e.g. <a href=\"https://something.com\">click to go to something.com and have fun</a>\n        */\n    if (input.substring(end, input.length).indexOf(\"</a>\") > -1 && input.substring(0, start).indexOf(\"<a\") > -1 && utils_1.isInsideAnchorTag(string, input, end)) {\n      return \"continue\";\n    }\n    if (result[regex_1.iidxes.isURL]) {\n      var path = (result[regex_1.iidxes.url.path] || \"\") + (result[regex_1.iidxes.url.secondPartOfPath] || \"\") || undefined;\n      var protocol = result[regex_1.iidxes.url.protocol1] || result[regex_1.iidxes.url.protocol2] || result[regex_1.iidxes.url.protocol3];\n      found.push({\n        start: start,\n        end: end,\n        string: string,\n        isURL: true,\n        protocol: protocol,\n        port: result[regex_1.iidxes.url.port],\n        ipv4: result[regex_1.iidxes.url.ipv4Confirmation] ? result[regex_1.iidxes.url.ipv4] : undefined,\n        ipv6: result[regex_1.iidxes.url.ipv6],\n        host: result[regex_1.iidxes.url.byProtocol] ? undefined : (result[regex_1.iidxes.url.protocolWithDomain] || \"\").substr((protocol || \"\").length),\n        confirmedByProtocol: !!result[regex_1.iidxes.url.byProtocol],\n        path: result[regex_1.iidxes.url.byProtocol] ? undefined : path,\n        query: result[regex_1.iidxes.url.query] || undefined,\n        fragment: result[regex_1.iidxes.url.fragment] || undefined\n      });\n    } else if (result[regex_1.iidxes.isFile]) {\n      var filePath = string.substr(8);\n      found.push({\n        start: start,\n        end: end,\n        string: string,\n        isFile: true,\n        protocol: result[regex_1.iidxes.file.protocol],\n        filename: result[regex_1.iidxes.file.fileName],\n        filePath: filePath,\n        fileDirectory: filePath.substr(0, filePath.length - result[regex_1.iidxes.file.fileName].length)\n      });\n    } else if (result[regex_1.iidxes.isEmail]) {\n      found.push({\n        start: start,\n        end: end,\n        string: string,\n        isEmail: true,\n        local: result[regex_1.iidxes.email.local],\n        protocol: result[regex_1.iidxes.email.protocol],\n        host: result[regex_1.iidxes.email.host]\n      });\n    } else {\n      found.push({\n        start: start,\n        end: end,\n        string: string\n      });\n    }\n  };\n  while ((result = regex_1.finalRegex.exec(input)) !== null) {\n    _loop_1();\n  }\n  return found;\n};\nvar anchorme = function anchorme(arg) {\n  var _a = typeof arg === \"string\" ? {\n      input: arg,\n      options: undefined,\n      extensions: undefined\n    } : arg,\n    input = _a.input,\n    options = _a.options,\n    extensions = _a.extensions;\n  if (extensions) {\n    for (var index = 0; index < extensions.length; index++) {\n      var extension = extensions[index];\n      input = input.replace(extension.test, extension.transform);\n    }\n  }\n  var found = list(input);\n  var newStr = \"\";\n  // the following code isn't very intuitive nor human readable\n  // but faster than others\n  for (var index = 0; index < found.length; index++) {\n    newStr = (newStr ? newStr : index === 0 ? input.substring(0, found[index].start) : \"\") + transform_1.transform(found[index], options) + (found[index + 1] ? input.substring(found[index].end, found[index + 1].start) : input.substring(found[index].end));\n  }\n  return newStr ? newStr : input;\n};\nanchorme.list = function (input) {\n  return list(input);\n};\nanchorme.validate = {\n  ip: function ip(input) {\n    return regex_1.ipRegex.test(input);\n  },\n  email: function email(input) {\n    return regex_1.emailRegex.test(input);\n  },\n  file: function file(input) {\n    return regex_1.fileRegex.test(input);\n  },\n  url: function url(input) {\n    return regex_1.urlRegex.test(input) || regex_1.ipRegex.test(input);\n  }\n};\nexports.default = anchorme;","map":null,"metadata":{},"sourceType":"script"}