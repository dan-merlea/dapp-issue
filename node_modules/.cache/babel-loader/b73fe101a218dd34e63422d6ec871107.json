{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nvar codec_1 = require(\"./codec\");\nvar composite_1 = require(\"./typesystem/composite\");\nvar variadic_1 = require(\"./typesystem/variadic\");\nvar algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nvar Codec = new codec_1.BinaryCodec();\nvar ArgSerializer = /*#__PURE__*/function () {\n  function ArgSerializer() {\n    _classCallCheck(this, ArgSerializer);\n  }\n  _createClass(ArgSerializer, [{\n    key: \"stringToValues\",\n    value:\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    function stringToValues(joinedString, parameters) {\n      var buffers = this.stringToBuffers(joinedString);\n      var values = this.buffersToValues(buffers, parameters);\n      return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n  }, {\n    key: \"stringToBuffers\",\n    value: function stringToBuffers(joinedString) {\n      // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n      return joinedString.split(exports.ArgumentsSeparator).map(function (item) {\n        return Buffer.from(item, \"hex\");\n      });\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n  }, {\n    key: \"buffersToValues\",\n    value: function buffersToValues(buffers, parameters) {\n      // TODO: Refactor, split (function is quite complex).\n      buffers = buffers || [];\n      var values = [];\n      var bufferIndex = 0;\n      var numBuffers = buffers.length;\n      for (var i = 0; i < parameters.length; i++) {\n        var parameter = parameters[i];\n        var type = parameter.type;\n        var value = readValue(type);\n        values.push(value);\n      }\n      // This is a recursive function.\n      function readValue(type) {\n        // TODO: Use matchers.\n        if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\n          var typedValue = readValue(type.getFirstTypeParameter());\n          return new algebraic_1.OptionalValue(type, typedValue);\n        } else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\n          var typedValues = [];\n          while (!hasReachedTheEnd()) {\n            typedValues.push(readValue(type.getFirstTypeParameter()));\n          }\n          return new variadic_1.VariadicValue(type, typedValues);\n        } else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\n          var _typedValues = [];\n          var _iterator = _createForOfIteratorHelper(type.getTypeParameters()),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var typeParameter = _step.value;\n              _typedValues.push(readValue(typeParameter));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return new composite_1.CompositeValue(type, _typedValues);\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var _typedValue = decodeNextBuffer(type);\n          return _typedValue;\n        }\n      }\n      function decodeNextBuffer(type) {\n        if (hasReachedTheEnd()) {\n          return null;\n        }\n        var buffer = buffers[bufferIndex++];\n        var decodedValue = Codec.decodeTopLevel(buffer, type);\n        return decodedValue;\n      }\n      function hasReachedTheEnd() {\n        return bufferIndex >= numBuffers;\n      }\n      return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n  }, {\n    key: \"valuesToString\",\n    value: function valuesToString(values) {\n      var strings = this.valuesToStrings(values);\n      var argumentsString = strings.join(exports.ArgumentsSeparator);\n      var count = strings.length;\n      return {\n        argumentsString: argumentsString,\n        count: count\n      };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n  }, {\n    key: \"valuesToStrings\",\n    value: function valuesToStrings(values) {\n      var buffers = this.valuesToBuffers(values);\n      var strings = buffers.map(function (buffer) {\n        return buffer.toString(\"hex\");\n      });\n      return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n  }, {\n    key: \"valuesToBuffers\",\n    value: function valuesToBuffers(values) {\n      // TODO: Refactor, split (function is quite complex).\n      var buffers = [];\n      var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      function handleValue(value) {\n        // TODO: Use matchers.\n        if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\n          var valueAsOptional = value;\n          if (valueAsOptional.isSet()) {\n            handleValue(valueAsOptional.getTypedValue());\n          }\n        } else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\n          var valueAsVariadic = value;\n          var _iterator3 = _createForOfIteratorHelper(valueAsVariadic.getItems()),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var item = _step3.value;\n              handleValue(item);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\n          var valueAsComposite = value;\n          var _iterator4 = _createForOfIteratorHelper(valueAsComposite.getItems()),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _item = _step4.value;\n              handleValue(_item);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var buffer = Codec.encodeTopLevel(value);\n          buffers.push(buffer);\n        }\n      }\n      return buffers;\n    }\n  }]);\n  return ArgSerializer;\n}();\nexports.ArgSerializer = ArgSerializer;","map":null,"metadata":{},"sourceType":"script"}