{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource.mjs';\nimport { settings } from '@pixi/settings';\nvar _SVGResource = /*#__PURE__*/function (_BaseImageResource) {\n  _inherits(_SVGResource, _BaseImageResource);\n  var _super = _createSuper(_SVGResource);\n  function _SVGResource(sourceBase64, options) {\n    var _this;\n    _classCallCheck(this, _SVGResource);\n    options = options || {};\n    _this = _super.call(this, settings.ADAPTER.createCanvas());\n    _this._width = 0;\n    _this._height = 0;\n    _this.svg = sourceBase64;\n    _this.scale = options.scale || 1;\n    _this._overrideWidth = options.width;\n    _this._overrideHeight = options.height;\n    _this._resolve = null;\n    _this._crossorigin = options.crossorigin;\n    _this._load = null;\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  _createClass(_SVGResource, [{\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n      if (this._load) {\n        return this._load;\n      }\n      this._load = new Promise(function (resolve) {\n        _this2._resolve = function () {\n          _this2.resize(_this2.source.width, _this2.source.height);\n          resolve(_this2);\n        };\n        if (_SVGResource.SVG_XML.test(_this2.svg.trim())) {\n          if (!btoa) {\n            throw new Error(\"Your browser doesn't support base64 conversions.\");\n          }\n          _this2.svg = \"data:image/svg+xml;base64,\".concat(btoa(unescape(encodeURIComponent(_this2.svg))));\n        }\n        _this2._loadSvg();\n      });\n      return this._load;\n    }\n  }, {\n    key: \"_loadSvg\",\n    value: function _loadSvg() {\n      var _this3 = this;\n      var tempImage = new Image();\n      BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n      tempImage.src = this.svg;\n      tempImage.onerror = function (event) {\n        if (!_this3._resolve) {\n          return;\n        }\n        tempImage.onerror = null;\n        _this3.onError.emit(event);\n      };\n      tempImage.onload = function () {\n        if (!_this3._resolve) {\n          return;\n        }\n        var svgWidth = tempImage.width;\n        var svgHeight = tempImage.height;\n        if (!svgWidth || !svgHeight) {\n          throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n        }\n        var width = svgWidth * _this3.scale;\n        var height = svgHeight * _this3.scale;\n        if (_this3._overrideWidth || _this3._overrideHeight) {\n          width = _this3._overrideWidth || _this3._overrideHeight / svgHeight * svgWidth;\n          height = _this3._overrideHeight || _this3._overrideWidth / svgWidth * svgHeight;\n        }\n        width = Math.round(width);\n        height = Math.round(height);\n        var canvas = _this3.source;\n        canvas.width = width;\n        canvas.height = height;\n        canvas._pixiId = \"canvas_\".concat(uid());\n        canvas.getContext(\"2d\").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n        _this3._resolve();\n        _this3._resolve = null;\n      };\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(_SVGResource.prototype), \"dispose\", this).call(this);\n      this._resolve = null;\n      this._crossorigin = null;\n    }\n  }], [{\n    key: \"getSize\",\n    value: function getSize(svgString) {\n      var sizeMatch = _SVGResource.SVG_SIZE.exec(svgString);\n      var size = {};\n      if (sizeMatch) {\n        size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n        size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n      }\n      return size;\n    }\n  }, {\n    key: \"test\",\n    value: function test(source, extension) {\n      return extension === \"svg\" || typeof source === \"string\" && source.startsWith(\"data:image/svg+xml\") || typeof source === \"string\" && _SVGResource.SVG_XML.test(source);\n    }\n  }]);\n  return _SVGResource;\n}(BaseImageResource);\nvar SVGResource = _SVGResource;\nSVGResource.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\nSVGResource.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i;\nexport { SVGResource };","map":{"version":3,"sources":["../../../src/textures/resources/SVGResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { uid } from '@pixi/utils';\nimport { BaseImageResource } from './BaseImageResource';\nimport { settings } from '@pixi/settings';\n\nimport type { ISize } from '@pixi/math';\nimport type { ICanvas } from '@pixi/settings';\n\nexport interface ISVGResourceOptions\n{\n    source?: string;\n    scale?: number;\n    width?: number;\n    height?: number;\n    autoLoad?: boolean;\n    crossorigin?: boolean | string;\n}\n/**\n * Resource type for SVG elements and graphics.\n * @memberof PIXI\n */\nexport class SVGResource extends BaseImageResource\n{\n    /** Base64 encoded SVG element or URL for SVG file. */\n    public readonly svg: string;\n\n    /** The source scale to apply when rasterizing on load. */\n    public readonly scale: number;\n\n    /** A width override for rasterization on load. */\n    public readonly _overrideWidth: number;\n\n    /** A height override for rasterization on load. */\n    public readonly _overrideHeight: number;\n\n    /** Call when completely loaded. */\n    private _resolve: () => void;\n\n    /** Promise when loading */\n    private _load: Promise<SVGResource>;\n\n    /** Cross origin value to use */\n    private _crossorigin?: boolean | string;\n\n    /**\n     * @param sourceBase64 - Base64 encoded SVG element or URL for SVG file.\n     * @param {object} [options] - Options to use\n     * @param {number} [options.scale=1] - Scale to apply to SVG. Overridden by...\n     * @param {number} [options.width] - Rasterize SVG this wide. Aspect ratio preserved if height not specified.\n     * @param {number} [options.height] - Rasterize SVG this high. Aspect ratio preserved if width not specified.\n     * @param {boolean} [options.autoLoad=true] - Start loading right away.\n     */\n    constructor(sourceBase64: string, options?: ISVGResourceOptions)\n    {\n        options = options || {};\n\n        super(settings.ADAPTER.createCanvas());\n        this._width = 0;\n        this._height = 0;\n\n        this.svg = sourceBase64;\n        this.scale = options.scale || 1;\n        this._overrideWidth = options.width;\n        this._overrideHeight = options.height;\n\n        this._resolve = null;\n        this._crossorigin = options.crossorigin;\n        this._load = null;\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    load(): Promise<SVGResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            // Save this until after load is finished\n            this._resolve = (): void =>\n            {\n                this.resize(this.source.width, this.source.height);\n                resolve(this);\n            };\n\n            // Convert SVG inline string to data-uri\n            if (SVGResource.SVG_XML.test(this.svg.trim()))\n            {\n                if (!btoa)\n                {\n                    throw new Error('Your browser doesn\\'t support base64 conversions.');\n                }\n                (this as any).svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;\n            }\n\n            this._loadSvg();\n        });\n\n        return this._load;\n    }\n\n    /** Loads an SVG image from `imageUrl` or `data URL`. */\n    private _loadSvg(): void\n    {\n        const tempImage = new Image();\n\n        BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);\n        tempImage.src = this.svg;\n\n        tempImage.onerror = (event): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            tempImage.onerror = null;\n            this.onError.emit(event);\n        };\n\n        tempImage.onload = (): void =>\n        {\n            if (!this._resolve)\n            {\n                return;\n            }\n\n            const svgWidth = tempImage.width;\n            const svgHeight = tempImage.height;\n\n            if (!svgWidth || !svgHeight)\n            {\n                throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');\n            }\n\n            // Set render size\n            let width = svgWidth * this.scale;\n            let height = svgHeight * this.scale;\n\n            if (this._overrideWidth || this._overrideHeight)\n            {\n                width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth;\n                height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight;\n            }\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // Create a canvas element\n            const canvas = this.source as ICanvas;\n\n            canvas.width = width;\n            canvas.height = height;\n            (canvas as any)._pixiId = `canvas_${uid()}`;\n\n            // Draw the Svg to the canvas\n            canvas\n                .getContext('2d')\n                .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);\n\n            this._resolve();\n            this._resolve = null;\n        };\n    }\n\n    /**\n     * Get size from an svg string using a regular expression.\n     * @param svgString - a serialized svg element\n     * @returns - image extension\n     */\n    static getSize(svgString?: string): ISize\n    {\n        const sizeMatch = SVGResource.SVG_SIZE.exec(svgString);\n        const size: any = {};\n\n        if (sizeMatch)\n        {\n            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));\n            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));\n        }\n\n        return size;\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        super.dispose();\n        this._resolve = null;\n        this._crossorigin = null;\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} - If the source is a SVG source or data file\n     */\n    static test(source: unknown, extension?: string): boolean\n    {\n        // url file extension is SVG\n        return extension === 'svg'\n            // source is SVG data-uri\n            || (typeof source === 'string' && source.startsWith('data:image/svg+xml'))\n            // source is SVG inline\n            || (typeof source === 'string' && SVGResource.SVG_XML.test(source));\n    }\n\n    /**\n     * Regular expression for SVG XML document.\n     * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n     * @readonly\n     */\n    static SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m;\n\n    /**\n     * Regular expression for SVG size.\n     * @example &lt;svg width=\"100\" height=\"100\"&gt;&lt;/svg&gt;\n     * @readonly\n     */\n    static SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i; // eslint-disable-line max-len\n}\n"]},"metadata":{},"sourceType":"module"}