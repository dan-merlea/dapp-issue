{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar sprite = require('@pixi/sprite');\nvar tempPoint = new core.Point();\nvar TilingSprite = /*#__PURE__*/function (_sprite$Sprite) {\n  _inherits(TilingSprite, _sprite$Sprite);\n  var _super = _createSuper(TilingSprite);\n  function TilingSprite(texture) {\n    var _this;\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    _classCallCheck(this, TilingSprite);\n    _this = _super.call(this, texture);\n    _this.tileTransform = new core.Transform();\n    _this._width = width;\n    _this._height = height;\n    _this.uvMatrix = _this.texture.uvMatrix || new core.TextureMatrix(texture);\n    _this.pluginName = \"tilingSprite\";\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  _createClass(TilingSprite, [{\n    key: \"clampMargin\",\n    get: function get() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function set(value) {\n      this.uvMatrix.clampMargin = value;\n      this.uvMatrix.update(true);\n    }\n  }, {\n    key: \"tileScale\",\n    get: function get() {\n      return this.tileTransform.scale;\n    },\n    set: function set(value) {\n      this.tileTransform.scale.copyFrom(value);\n    }\n  }, {\n    key: \"tilePosition\",\n    get: function get() {\n      return this.tileTransform.position;\n    },\n    set: function set(value) {\n      this.tileTransform.position.copyFrom(value);\n    }\n  }, {\n    key: \"_onTextureUpdate\",\n    value: function _onTextureUpdate() {\n      if (this.uvMatrix) {\n        this.uvMatrix.texture = this._texture;\n      }\n      this._cachedTint = 16777215;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      var texture = this._texture;\n      if (!texture || !texture.valid) {\n        return;\n      }\n      this.tileTransform.updateLocalTransform();\n      this.uvMatrix.update();\n      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n      renderer.plugins[this.pluginName].render(this);\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      var minX = this._width * -this._anchor._x;\n      var minY = this._height * -this._anchor._y;\n      var maxX = this._width * (1 - this._anchor._x);\n      var maxY = this._height * (1 - this._anchor._y);\n      this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds(rect) {\n      if (this.children.length === 0) {\n        this._bounds.minX = this._width * -this._anchor._x;\n        this._bounds.minY = this._height * -this._anchor._y;\n        this._bounds.maxX = this._width * (1 - this._anchor._x);\n        this._bounds.maxY = this._height * (1 - this._anchor._y);\n        if (!rect) {\n          if (!this._localBoundsRect) {\n            this._localBoundsRect = new core.Rectangle();\n          }\n          rect = this._localBoundsRect;\n        }\n        return this._bounds.getRectangle(rect);\n      }\n      return _get(_getPrototypeOf(TilingSprite.prototype), \"getLocalBounds\", this).call(this, rect);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      this.worldTransform.applyInverse(point, tempPoint);\n      var width = this._width;\n      var height = this._height;\n      var x1 = -width * this.anchor._x;\n      if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n        var y1 = -height * this.anchor._y;\n        if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      _get(_getPrototypeOf(TilingSprite.prototype), \"destroy\", this).call(this, options);\n      this.tileTransform = null;\n      this.uvMatrix = null;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value) {\n      this._width = value;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value) {\n      this._height = value;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(source, options) {\n      var texture = source instanceof core.Texture ? source : core.Texture.from(source, options);\n      return new TilingSprite(texture, options.width, options.height);\n    }\n  }]);\n  return TilingSprite;\n}(sprite.Sprite);\nexports.TilingSprite = TilingSprite;","map":{"version":3,"sources":["../src/TilingSprite.ts"],"names":["Point","Sprite","Transform","TextureMatrix","Rectangle","Texture"],"mappings":";;;;;;;;;;;;;AAKA,IAAM,SAAA,GAAY,IAAIA,IAAAA,CAAAA,KAAM,EAAA;AAAA,IASf,YAAA;EAAA;EAAA;EAyBT,sBAAY,OAAA,EACZ;IAAA;IAAA,IAD8B,KAAQ,uEAAA,GAAA;IAAA,IAAK,MAAA,uEAAS,GACpD;IAAA;IACI,0BAAM,OAAO;IAER,MAAA,aAAA,GAAgB,IAAIE,IAAAA,CAAAA,SAAU,EAAA;IAGnC,MAAK,MAAS,GAAA,KAAA;IAGd,MAAK,OAAU,GAAA,MAAA;IAEf,MAAK,QAAA,GAAW,MAAK,OAAA,CAAQ,QAAY,IAAA,IAAIC,IAAAA,CAAAA,aAAAA,CAAc,OAAO,CAAA;IAOlE,MAAK,UAAa,GAAA,cAAA;IAElB,MAAK,eAAkB,GAAA,KAAA;IAAA;EAAA;EAC3B;IAAA;IAAA,KAOA,eACA;MACI,OAAO,IAAA,CAAK,QAAS,CAAA,WAAA;IAAA,CACzB;IAAA,KAEA,aAAgB,KAChB,EAAA;MACI,IAAA,CAAK,QAAA,CAAS,WAAc,GAAA,KAAA;MACvB,IAAA,CAAA,QAAA,CAAS,MAAA,CAAO,IAAI,CAAA;IAAA;EAC7B;IAAA;IAAA,KAGA,eACA;MACI,OAAO,IAAA,CAAK,aAAc,CAAA,KAAA;IAAA,CAC9B;IAAA,KAEA,aAAc,KACd,EAAA;MACS,IAAA,CAAA,aAAA,CAAc,KAAM,CAAA,QAAA,CAAS,KAAe,CAAA;IAAA;EACrD;IAAA;IAAA,KAGA,eACA;MACI,OAAO,IAAA,CAAK,aAAc,CAAA,QAAA;IAAA,CAC9B;IAAA,KAEA,aAAiB,KACjB,EAAA;MACS,IAAA,CAAA,aAAA,CAAc,QAAS,CAAA,QAAA,CAAS,KAAe,CAAA;IAAA;EACxD;IAAA;IAAA,OAKA,4BACA;MACI,IAAI,IAAA,CAAK,QACT,EAAA;QACS,IAAA,CAAA,QAAA,CAAS,OAAA,GAAU,IAAK,CAAA,QAAA;MAAA;MAEjC,IAAA,CAAK,WAAc,GAAA,QAAA;IAAA;EACvB;IAAA;IAAA,OAMU,iBAAQ,QAClB,EAAA;MAEI,IAAM,OAAA,GAAU,IAAK,CAAA,QAAA;MAErB,IAAI,CAAC,OAAA,IAAW,CAAC,OAAA,CAAQ,KACzB,EAAA;QACI;MAAA;MAGJ,IAAA,CAAK,aAAA,CAAc,oBAAqB,EAAA;MACxC,IAAA,CAAK,QAAA,CAAS,MAAO,EAAA;MAErB,QAAA,CAAS,KAAM,CAAA,iBAAA,CAAkB,QAAS,CAAA,OAAA,CAAQ,IAAA,CAAK,UAAW,CAAA,CAAA;MAClE,QAAA,CAAS,OAAQ,CAAA,IAAA,CAAK,UAAY,CAAA,CAAA,MAAA,CAAO,IAAI,CAAA;IAAA;EACjD;IAAA;IAAA,OAGA,4BACA;MACI,IAAM,IAAO,GAAA,IAAA,CAAK,MAAS,GAAA,CAAC,IAAA,CAAK,OAAQ,CAAA,EAAA;MACzC,IAAM,IAAO,GAAA,IAAA,CAAK,OAAU,GAAA,CAAC,IAAA,CAAK,OAAQ,CAAA,EAAA;MAC1C,IAAM,IAAO,GAAA,IAAA,CAAK,MAAU,IAAA,CAAA,GAAI,IAAA,CAAK,OAAQ,CAAA,EAAA,CAAA;MAC7C,IAAM,IAAO,GAAA,IAAA,CAAK,OAAW,IAAA,CAAA,GAAI,IAAA,CAAK,OAAQ,CAAA,EAAA,CAAA;MAE9C,IAAA,CAAK,OAAA,CAAQ,QAAS,CAAA,IAAA,CAAK,SAAA,EAAW,IAAM,EAAA,IAAA,EAAM,IAAA,EAAM,IAAI,CAAA;IAAA;EAChE;IAAA;IAAA,OAOO,wBAAe,IACtB,EAAA;MAEQ,IAAA,IAAA,CAAK,QAAS,CAAA,MAAA,KAAW,CAC7B,EAAA;QACI,IAAA,CAAK,OAAA,CAAQ,IAAO,GAAA,IAAA,CAAK,MAAS,GAAA,CAAC,IAAA,CAAK,OAAQ,CAAA,EAAA;QAChD,IAAA,CAAK,OAAA,CAAQ,IAAO,GAAA,IAAA,CAAK,OAAU,GAAA,CAAC,IAAA,CAAK,OAAQ,CAAA,EAAA;QACjD,IAAA,CAAK,OAAA,CAAQ,IAAO,GAAA,IAAA,CAAK,MAAU,IAAA,CAAA,GAAI,IAAA,CAAK,OAAQ,CAAA,EAAA,CAAA;QACpD,IAAA,CAAK,OAAA,CAAQ,IAAO,GAAA,IAAA,CAAK,OAAW,IAAA,CAAA,GAAI,IAAA,CAAK,OAAQ,CAAA,EAAA,CAAA;QAErD,IAAI,CAAC,IACL,EAAA;UACQ,IAAA,CAAC,IAAA,CAAK,gBACV,EAAA;YACS,IAAA,CAAA,gBAAA,GAAmB,IAAIC,IAAAA,CAAAA,SAAU,EAAA;UAAA;UAG1C,IAAA,GAAO,IAAK,CAAA,gBAAA;QAAA;QAGT,OAAA,IAAA,CAAK,OAAQ,CAAA,YAAA,CAAa,IAAI,CAAA;MAAA;MAGzC,OAAO,sEAAqB,IAAK,CAAA,IAAA,EAAM,IAAI,CAAA;IAAA;EAC/C;IAAA;IAAA,OAOO,uBAAc,KACrB,EAAA;MACS,IAAA,CAAA,cAAA,CAAe,YAAa,CAAA,KAAA,EAAO,SAAS,CAAA;MAEjD,IAAM,KAAA,GAAQ,IAAK,CAAA,MAAA;MACnB,IAAM,MAAA,GAAS,IAAK,CAAA,OAAA;MACpB,IAAM,EAAK,GAAA,CAAC,KAAQ,GAAA,IAAA,CAAK,MAAO,CAAA,EAAA;MAEhC,IAAI,SAAA,CAAU,CAAK,IAAA,EAAA,IAAM,SAAU,CAAA,CAAA,GAAI,EAAA,GAAK,KAC5C,EAAA;QACI,IAAM,EAAK,GAAA,CAAC,MAAS,GAAA,IAAA,CAAK,MAAO,CAAA,EAAA;QAEjC,IAAI,SAAA,CAAU,CAAK,IAAA,EAAA,IAAM,SAAU,CAAA,CAAA,GAAI,EAAA,GAAK,MAC5C,EAAA;UACW,OAAA,IAAA;QAAA;MACX;MAGG,OAAA,KAAA;IAAA;EACX;IAAA;IAAA,OAWO,iBAAQ,OACf,EAAA;MACI,0EAAc,OAAO;MAErB,IAAA,CAAK,aAAgB,GAAA,IAAA;MACrB,IAAA,CAAK,QAAW,GAAA,IAAA;IAAA;EACpB;IAAA;IAAA,KA0BA,eACA;MACI,OAAO,IAAK,CAAA,MAAA;IAAA,CAChB;IAAA,KAEA,aAAU,KACV,EAAA;MACI,IAAA,CAAK,MAAS,GAAA,KAAA;IAAA;EAClB;IAAA;IAAA,KAGA,eACA;MACI,OAAO,IAAK,CAAA,OAAA;IAAA,CAChB;IAAA,KAEA,aAAW,KACX,EAAA;MACI,IAAA,CAAK,OAAU,GAAA,KAAA;IAAA;EACnB;IAAA;IAAA,OAjCA,cAAY,MAAA,EAAiC,OAC7C,EAAA;MACI,IAAM,OAAA,GAAW,MAAkB,YAAA,IAAA,CAAA,OAAA,GAC7B,MAAA,GACAC,IAAAA,CAAAA,OAAQ,CAAA,IAAA,CAAK,MAAA,EAAQ,OAAO,CAAA;MAElC,OAAO,IAAI,YACP,CAAA,OAAA,EACA,OAAQ,CAAA,KAAA,EACR,OAAA,CAAQ,MACZ,CAAA;IAAA;EACJ;EAAA;AAAA,EAlO8BJ,MAAAA,CAAAA,MAClC","sourcesContent":["import { Point, Rectangle, Transform, Texture, TextureMatrix } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport type { IPoint, IPointData, ISize, ObservablePoint, Renderer, IBaseTextureOptions, TextureSource } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\nconst tempPoint = new Point();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface TilingSprite extends GlobalMixins.TilingSprite {}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @memberof PIXI\n */\nexport class TilingSprite extends Sprite\n{\n    /** Tile transform */\n    public tileTransform: Transform;\n\n    /** Matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space. */\n    public uvMatrix: TextureMatrix;\n\n    /**\n     * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in\n     * local space.\n     *\n     * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without\n     * this, the top-left corner always gets the (0, 0) texture coordinate.\n     * @default false\n     */\n    public uvRespectAnchor: boolean;\n\n    /**\n     * Note: The wrap mode of the texture is forced to REPEAT on render if the size of the texture\n     * is a power of two, the texture's wrap mode is CLAMP, and the texture hasn't been bound yet.\n     * @param texture - The texture of the tiling sprite.\n     * @param width - The width of the tiling sprite.\n     * @param height - The height of the tiling sprite.\n     */\n    constructor(texture: Texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        this.tileTransform = new Transform();\n\n        // The width of the tiling sprite\n        this._width = width;\n\n        // The height of the tiling sprite\n        this._height = height;\n\n        this.uvMatrix = this.texture.uvMatrix || new TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' method.\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin(): number\n    {\n        return this.uvMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this.uvMatrix.clampMargin = value;\n        this.uvMatrix.update(true);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value: IPointData)\n    {\n        this.tileTransform.scale.copyFrom(value as IPoint);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value: ObservablePoint)\n    {\n        this.tileTransform.position.copyFrom(value as IPoint);\n    }\n\n    /**\n     * @protected\n     */\n    protected _onTextureUpdate(): void\n    {\n        if (this.uvMatrix)\n        {\n            this.uvMatrix.texture = this._texture;\n        }\n        this._cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvMatrix.update();\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /** Updates the bounds of the tiling sprite. */\n    protected _calculateBounds(): void\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     * @param rect - Optional output rectangle.\n     * @returns The bounds.\n     */\n    public getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     * @param point - The point to check.\n     * @returns Whether or not the sprite contains the point.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvMatrix = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {number} options.width - required width of the tiling sprite\n     * @param {number} options.height - required height of the tiling sprite\n     * @returns {PIXI.TilingSprite} The newly created texture\n     */\n    static from(source: TextureSource | Texture, options: ISize & IBaseTextureOptions): TilingSprite\n    {\n        const texture = (source instanceof Texture)\n            ? source\n            : Texture.from(source, options);\n\n        return new TilingSprite(\n            texture,\n            options.width,\n            options.height\n        );\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get width(): number\n    {\n        return this._width;\n    }\n\n    set width(value: number)\n    {\n        this._width = value;\n    }\n\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get height(): number\n    {\n        return this._height;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}