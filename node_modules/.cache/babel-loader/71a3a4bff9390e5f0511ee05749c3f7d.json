{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { MASK_TYPES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nvar MaskData = /*#__PURE__*/function () {\n  function MaskData() {\n    var maskObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, MaskData);\n    this.type = MASK_TYPES.NONE;\n    this.autoDetect = true;\n    this.maskObject = maskObject || null;\n    this.pooled = false;\n    this.isMaskData = true;\n    this.resolution = null;\n    this.multisample = settings.FILTER_MULTISAMPLE;\n    this.enabled = true;\n    this.colorMask = 15;\n    this._filters = null;\n    this._stencilCounter = 0;\n    this._scissorCounter = 0;\n    this._scissorRect = null;\n    this._scissorRectLocal = null;\n    this._colorMask = 15;\n    this._target = null;\n  }\n  _createClass(MaskData, [{\n    key: \"filter\",\n    get: function get() {\n      return this._filters ? this._filters[0] : null;\n    },\n    set: function set(value) {\n      if (value) {\n        if (this._filters) {\n          this._filters[0] = value;\n        } else {\n          this._filters = [value];\n        }\n      } else {\n        this._filters = null;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.pooled) {\n        this.maskObject = null;\n        this.type = MASK_TYPES.NONE;\n        this.autoDetect = true;\n      }\n      this._target = null;\n      this._scissorRectLocal = null;\n    }\n  }, {\n    key: \"copyCountersOrReset\",\n    value: function copyCountersOrReset(maskAbove) {\n      if (maskAbove) {\n        this._stencilCounter = maskAbove._stencilCounter;\n        this._scissorCounter = maskAbove._scissorCounter;\n        this._scissorRect = maskAbove._scissorRect;\n      } else {\n        this._stencilCounter = 0;\n        this._scissorCounter = 0;\n        this._scissorRect = null;\n      }\n    }\n  }]);\n  return MaskData;\n}();\nexport { MaskData };","map":{"version":3,"sources":["../../src/mask/MaskData.ts"],"names":[],"mappings":";;;;IAwBa,QACb;EA2FI,oBACA;IAAA,IADY,UAAA,uEAA0B,IACtC;IAAA;IACI,IAAA,CAAK,IAAA,GAAO,UAAW,CAAA,IAAA;IACvB,IAAA,CAAK,UAAa,GAAA,IAAA;IAClB,IAAA,CAAK,UAAA,GAAa,UAAc,IAAA,IAAA;IAChC,IAAA,CAAK,MAAS,GAAA,KAAA;IACd,IAAA,CAAK,UAAa,GAAA,IAAA;IAClB,IAAA,CAAK,UAAa,GAAA,IAAA;IAClB,IAAA,CAAK,WAAA,GAAc,QAAS,CAAA,kBAAA;IAC5B,IAAA,CAAK,OAAU,GAAA,IAAA;IACf,IAAA,CAAK,SAAY,GAAA,EAAA;IACjB,IAAA,CAAK,QAAW,GAAA,IAAA;IAChB,IAAA,CAAK,eAAkB,GAAA,CAAA;IACvB,IAAA,CAAK,eAAkB,GAAA,CAAA;IACvB,IAAA,CAAK,YAAe,GAAA,IAAA;IACpB,IAAA,CAAK,iBAAoB,GAAA,IAAA;IACzB,IAAA,CAAK,UAAa,GAAA,EAAA;IAClB,IAAA,CAAK,OAAU,GAAA,IAAA;EAAA;EACnB;IAAA;IAAA,KAOA,eACA;MACI,OAAO,IAAK,CAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAS,CAAK,CAAA,GAAA,IAAA;IAAA,CAC9C;IAAA,KAEA,aAAW,KACX,EAAA;MACI,IAAI,KACJ,EAAA;QACI,IAAI,IAAA,CAAK,QACT,EAAA;UACI,IAAA,CAAK,QAAA,CAAS,CAAK,CAAA,GAAA,KAAA;QAAA,CAGvB,MAAA;UACS,IAAA,CAAA,QAAA,GAAW,CAAC,KAAK,CAAA;QAAA;MAC1B,CAGJ,MAAA;QACI,IAAA,CAAK,QAAW,GAAA,IAAA;MAAA;IACpB;EACJ;IAAA;IAAA,OAGA,iBACA;MACI,IAAI,IAAA,CAAK,MACT,EAAA;QACI,IAAA,CAAK,UAAa,GAAA,IAAA;QAElB,IAAA,CAAK,IAAA,GAAO,UAAW,CAAA,IAAA;QAEvB,IAAA,CAAK,UAAa,GAAA,IAAA;MAAA;MAGtB,IAAA,CAAK,OAAU,GAAA,IAAA;MACf,IAAA,CAAK,iBAAoB,GAAA,IAAA;IAAA;EAC7B;IAAA;IAAA,OAMA,6BAAoB,SACpB,EAAA;MACI,IAAI,SACJ,EAAA;QACI,IAAA,CAAK,eAAA,GAAkB,SAAU,CAAA,eAAA;QACjC,IAAA,CAAK,eAAA,GAAkB,SAAU,CAAA,eAAA;QACjC,IAAA,CAAK,YAAA,GAAe,SAAU,CAAA,YAAA;MAAA,CAGlC,MAAA;QACI,IAAA,CAAK,eAAkB,GAAA,CAAA;QACvB,IAAA,CAAK,eAAkB,GAAA,CAAA;QACvB,IAAA,CAAK,YAAe,GAAA,IAAA;MAAA;IACxB;EACJ;EAAA;AAAA","sourcesContent":["import { MASK_TYPES } from '@pixi/constants';\nimport { settings } from '@pixi/settings';\nimport type { ISpriteMaskFilter } from '@pixi/core';\n\nimport type { COLOR_MASK_BITS, MSAA_QUALITY } from '@pixi/constants';\nimport type { Rectangle, Matrix } from '@pixi/math';\nimport type { IFilterTarget } from '../filters/IFilterTarget';\nimport type { Renderer } from '../Renderer';\n\nexport interface IMaskTarget extends IFilterTarget\n{\n    renderable: boolean;\n    isSprite?: boolean;\n    worldTransform: Matrix;\n    isFastRect?(): boolean;\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle;\n    render(renderer: Renderer): void;\n}\n/**\n * Component for masked elements.\n *\n * Holds mask mode and temporary data about current mask.\n * @memberof PIXI\n */\nexport class MaskData\n{\n    /** Mask type */\n    public type: MASK_TYPES;\n\n    /**\n     * Whether we know the mask type beforehand\n     * @default true\n     */\n    public autoDetect: boolean;\n\n    /**\n     * Which element we use to mask\n     * @member {PIXI.DisplayObject}\n     */\n    public maskObject: IMaskTarget;\n\n    /** Whether it belongs to MaskSystem pool */\n    public pooled: boolean;\n\n    /** Indicator of the type (always true for {@link MaskData} objects) */\n    public isMaskData: boolean;// webdoc crashes if the type is true because reasons... (will fix)\n\n    /**\n     * Resolution of the sprite mask filter.\n     * If set to `null` or `0`, the resolution of the current render target is used.\n     * @default null\n     */\n    public resolution: number;\n\n    /**\n     * Number of samples of the sprite mask filter.\n     * If set to `null`, the sample count of the current render target is used.\n     * @default PIXI.settings.FILTER_MULTISAMPLE\n     */\n    public multisample: MSAA_QUALITY;\n\n    /** If enabled is true the mask is applied, if false it will not. */\n    public enabled: boolean;\n\n    /** Color mask. */\n    public colorMask: COLOR_MASK_BITS;\n\n    /**\n     * The sprite mask filter wrapped in an array.\n     * @private\n     */\n    _filters: ISpriteMaskFilter[];\n\n    /**\n     * Stencil counter above the mask in stack\n     * @private\n     */\n    _stencilCounter: number;\n\n    /**\n     * Scissor counter above the mask in stack\n     * @private\n     */\n    _scissorCounter: number;\n\n    /**\n     * Scissor operation above the mask in stack.\n     * Null if _scissorCounter is zero, rectangle instance if positive.\n     * @private\n     */\n    _scissorRect: Rectangle;\n\n    /**\n     * pre-computed scissor rect\n     * does become _scissorRect when mask is actually pushed\n     * @private\n     */\n    _scissorRectLocal: Rectangle;\n\n    /**\n     * pre-computed color mask\n     * @private\n     */\n    _colorMask: number;\n\n    /**\n     * Targeted element. Temporary variable set by MaskSystem\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    _target: IMaskTarget;\n\n    /**\n     * Create MaskData\n     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n     */\n    constructor(maskObject: IMaskTarget = null)\n    {\n        this.type = MASK_TYPES.NONE;\n        this.autoDetect = true;\n        this.maskObject = maskObject || null;\n        this.pooled = false;\n        this.isMaskData = true;\n        this.resolution = null;\n        this.multisample = settings.FILTER_MULTISAMPLE;\n        this.enabled = true;\n        this.colorMask = 0xf;\n        this._filters = null;\n        this._stencilCounter = 0;\n        this._scissorCounter = 0;\n        this._scissorRect = null;\n        this._scissorRectLocal = null;\n        this._colorMask = 0xf;\n        this._target = null;\n    }\n\n    /**\n     * The sprite mask filter.\n     * If set to `null`, the default sprite mask filter is used.\n     * @default null\n     */\n    get filter(): ISpriteMaskFilter\n    {\n        return this._filters ? this._filters[0] : null;\n    }\n\n    set filter(value: ISpriteMaskFilter)\n    {\n        if (value)\n        {\n            if (this._filters)\n            {\n                this._filters[0] = value;\n            }\n            else\n            {\n                this._filters = [value];\n            }\n        }\n        else\n        {\n            this._filters = null;\n        }\n    }\n\n    /** Resets the mask data after popMask(). */\n    reset(): void\n    {\n        if (this.pooled)\n        {\n            this.maskObject = null;\n\n            this.type = MASK_TYPES.NONE;\n\n            this.autoDetect = true;\n        }\n\n        this._target = null;\n        this._scissorRectLocal = null;\n    }\n\n    /**\n     * Copies counters from maskData above, called from pushMask().\n     * @param maskAbove\n     */\n    copyCountersOrReset(maskAbove?: MaskData): void\n    {\n        if (maskAbove)\n        {\n            this._stencilCounter = maskAbove._stencilCounter;\n            this._scissorCounter = maskAbove._scissorCounter;\n            this._scissorRect = maskAbove._scissorRect;\n        }\n        else\n        {\n            this._stencilCounter = 0;\n            this._scissorCounter = 0;\n            this._scissorRect = null;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}