{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeExpressionParser = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar types_1 = require(\"./types\");\nvar jsonHandler = require(\"json-duplicate-key-handle\");\nvar TypeExpressionParser = /*#__PURE__*/function () {\n  function TypeExpressionParser() {\n    _classCallCheck(this, TypeExpressionParser);\n  }\n  _createClass(TypeExpressionParser, [{\n    key: \"parse\",\n    value: function parse(expression) {\n      var root = this.doParse(expression);\n      var rootKeys = Object.keys(root);\n      if (rootKeys.length != 1) {\n        throw new errors.ErrTypingSystem(\"bad type expression: \".concat(expression));\n      }\n      var name = rootKeys[0];\n      var type = this.nodeToType(name, root[name]);\n      return type;\n    }\n  }, {\n    key: \"doParse\",\n    value: function doParse(expression) {\n      var jsoned = this.getJsonedString(expression);\n      try {\n        return jsonHandler.parse(jsoned);\n      } catch (error) {\n        throw new errors.ErrTypingSystem(\"cannot parse type expression: \".concat(expression, \". internal json: \").concat(jsoned, \".\"));\n      }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n  }, {\n    key: \"getJsonedString\",\n    value: function getJsonedString(expression) {\n      var jsoned = \"\";\n      for (var i = 0; i < expression.length; i++) {\n        var char = expression.charAt(i);\n        var previousChar = expression.charAt(i - 1);\n        var nextChar = expression.charAt(i + 1);\n        if (char == \"<\") {\n          jsoned += \": {\";\n        } else if (char == \">\") {\n          if (previousChar != \">\") {\n            jsoned += \": {} }\";\n          } else {\n            jsoned += \"}\";\n          }\n        } else if (char == \",\") {\n          if (nextChar == \">\") {\n            // Skip superfluous comma\n          } else if (previousChar == \">\") {\n            jsoned += \",\";\n          } else {\n            jsoned += \": {},\";\n          }\n        } else {\n          jsoned += char;\n        }\n      }\n      // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n      var symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n      var tokens = jsoned\n      // Hack for Safari compatibility, where we can't use negative lookbehind\n      .replace(/utf\\-8\\sstring/ig, \"utf-8-string\").split(symbolsRegex).filter(function (token) {\n        return token;\n      });\n      jsoned = tokens.map(function (token) {\n        return symbolsRegex.test(token) ? token : \"\\\"\".concat(token, \"\\\"\");\n      }).map(function (token) {\n        return token.replace(/utf\\-8\\-string/ig, \"utf-8 string\");\n      }).join(\"\");\n      if (tokens.length == 1) {\n        // Workaround for simple, non-generic types.\n        return \"{\".concat(jsoned, \": {}}\");\n      }\n      return \"{\".concat(jsoned, \"}\");\n    }\n  }, {\n    key: \"nodeToType\",\n    value: function nodeToType(name, node) {\n      var _this = this;\n      if (name.charAt(name.length - 1) === \"1\") {\n        name = name.slice(0, -1);\n      }\n      var typeParameters = Object.keys(node).map(function (key) {\n        return _this.nodeToType(key, node[key]);\n      });\n      return new types_1.Type(name, typeParameters);\n    }\n  }]);\n  return TypeExpressionParser;\n}();\nexports.TypeExpressionParser = TypeExpressionParser;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/typeExpressionParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeExpressionParser = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst types_1 = require(\"./types\");\nvar jsonHandler = require(\"json-duplicate-key-handle\");\nclass TypeExpressionParser {\n    parse(expression) {\n        let root = this.doParse(expression);\n        let rootKeys = Object.keys(root);\n        if (rootKeys.length != 1) {\n            throw new errors.ErrTypingSystem(`bad type expression: ${expression}`);\n        }\n        let name = rootKeys[0];\n        let type = this.nodeToType(name, root[name]);\n        return type;\n    }\n    doParse(expression) {\n        let jsoned = this.getJsonedString(expression);\n        try {\n            return jsonHandler.parse(jsoned);\n        }\n        catch (error) {\n            throw new errors.ErrTypingSystem(`cannot parse type expression: ${expression}. internal json: ${jsoned}.`);\n        }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n    getJsonedString(expression) {\n        let jsoned = \"\";\n        for (var i = 0; i < expression.length; i++) {\n            let char = expression.charAt(i);\n            let previousChar = expression.charAt(i - 1);\n            let nextChar = expression.charAt(i + 1);\n            if (char == \"<\") {\n                jsoned += \": {\";\n            }\n            else if (char == \">\") {\n                if (previousChar != \">\") {\n                    jsoned += \": {} }\";\n                }\n                else {\n                    jsoned += \"}\";\n                }\n            }\n            else if (char == \",\") {\n                if (nextChar == \">\") {\n                    // Skip superfluous comma\n                }\n                else if (previousChar == \">\") {\n                    jsoned += \",\";\n                }\n                else {\n                    jsoned += \": {},\";\n                }\n            }\n            else {\n                jsoned += char;\n            }\n        }\n        // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n        let symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n        let tokens = jsoned\n            // Hack for Safari compatibility, where we can't use negative lookbehind\n            .replace(/utf\\-8\\sstring/ig, \"utf-8-string\")\n            .split(symbolsRegex)\n            .filter((token) => token);\n        jsoned = tokens.map((token) => (symbolsRegex.test(token) ? token : `\"${token}\"`))\n            .map((token) => token.replace(/utf\\-8\\-string/ig, \"utf-8 string\"))\n            .join(\"\");\n        if (tokens.length == 1) {\n            // Workaround for simple, non-generic types.\n            return `{${jsoned}: {}}`;\n        }\n        return `{${jsoned}}`;\n    }\n    nodeToType(name, node) {\n        if (name.charAt(name.length - 1) === \"1\") {\n            name = name.slice(0, -1);\n        }\n        let typeParameters = Object.keys(node).map((key) => this.nodeToType(key, node[key]));\n        return new types_1.Type(name, typeParameters);\n    }\n}\nexports.TypeExpressionParser = TypeExpressionParser;\n//# sourceMappingURL=typeExpressionParser.js.map"]},"metadata":{},"sourceType":"script"}