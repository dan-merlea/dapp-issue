{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar MaskData = require('./MaskData.js');\nvar SpriteMaskFilter = require('../filters/spriteMask/SpriteMaskFilter.js');\nvar constants = require('@pixi/constants');\nvar extensions = require('@pixi/extensions');\nvar MaskSystem = /*#__PURE__*/function () {\n  function MaskSystem(renderer) {\n    _classCallCheck(this, MaskSystem);\n    this.renderer = renderer;\n    this.enableScissor = true;\n    this.alphaMaskPool = [];\n    this.maskDataPool = [];\n    this.maskStack = [];\n    this.alphaMaskIndex = 0;\n  }\n  _createClass(MaskSystem, [{\n    key: \"setMaskStack\",\n    value: function setMaskStack(maskStack) {\n      this.maskStack = maskStack;\n      this.renderer.scissor.setMaskStack(maskStack);\n      this.renderer.stencil.setMaskStack(maskStack);\n    }\n  }, {\n    key: \"push\",\n    value: function push(target, maskDataOrTarget) {\n      var maskData = maskDataOrTarget;\n      if (!maskData.isMaskData) {\n        var d = this.maskDataPool.pop() || new MaskData.MaskData();\n        d.pooled = true;\n        d.maskObject = maskDataOrTarget;\n        maskData = d;\n      }\n      var maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n      maskData.copyCountersOrReset(maskAbove);\n      maskData._colorMask = maskAbove ? maskAbove._colorMask : 15;\n      if (maskData.autoDetect) {\n        this.detect(maskData);\n      }\n      maskData._target = target;\n      if (maskData.type !== constants.MASK_TYPES.SPRITE) {\n        this.maskStack.push(maskData);\n      }\n      if (maskData.enabled) {\n        switch (maskData.type) {\n          case constants.MASK_TYPES.SCISSOR:\n            this.renderer.scissor.push(maskData);\n            break;\n          case constants.MASK_TYPES.STENCIL:\n            this.renderer.stencil.push(maskData);\n            break;\n          case constants.MASK_TYPES.SPRITE:\n            maskData.copyCountersOrReset(null);\n            this.pushSpriteMask(maskData);\n            break;\n          case constants.MASK_TYPES.COLOR:\n            this.pushColorMask(maskData);\n            break;\n          default:\n            break;\n        }\n      }\n      if (maskData.type === constants.MASK_TYPES.SPRITE) {\n        this.maskStack.push(maskData);\n      }\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(target) {\n      var maskData = this.maskStack.pop();\n      if (!maskData || maskData._target !== target) {\n        return;\n      }\n      if (maskData.enabled) {\n        switch (maskData.type) {\n          case constants.MASK_TYPES.SCISSOR:\n            this.renderer.scissor.pop(maskData);\n            break;\n          case constants.MASK_TYPES.STENCIL:\n            this.renderer.stencil.pop(maskData.maskObject);\n            break;\n          case constants.MASK_TYPES.SPRITE:\n            this.popSpriteMask(maskData);\n            break;\n          case constants.MASK_TYPES.COLOR:\n            this.popColorMask(maskData);\n            break;\n          default:\n            break;\n        }\n      }\n      maskData.reset();\n      if (maskData.pooled) {\n        this.maskDataPool.push(maskData);\n      }\n      if (this.maskStack.length !== 0) {\n        var maskCurrent = this.maskStack[this.maskStack.length - 1];\n        if (maskCurrent.type === constants.MASK_TYPES.SPRITE && maskCurrent._filters) {\n          maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n        }\n      }\n    }\n  }, {\n    key: \"detect\",\n    value: function detect(maskData) {\n      var maskObject = maskData.maskObject;\n      if (!maskObject) {\n        maskData.type = constants.MASK_TYPES.COLOR;\n      } else if (maskObject.isSprite) {\n        maskData.type = constants.MASK_TYPES.SPRITE;\n      } else if (this.enableScissor && this.renderer.scissor.testScissor(maskData)) {\n        maskData.type = constants.MASK_TYPES.SCISSOR;\n      } else {\n        maskData.type = constants.MASK_TYPES.STENCIL;\n      }\n    }\n  }, {\n    key: \"pushSpriteMask\",\n    value: function pushSpriteMask(maskData) {\n      var maskObject = maskData.maskObject;\n      var target = maskData._target;\n      var alphaMaskFilter = maskData._filters;\n      if (!alphaMaskFilter) {\n        alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n        if (!alphaMaskFilter) {\n          alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter.SpriteMaskFilter()];\n        }\n      }\n      var renderer = this.renderer;\n      var renderTextureSystem = renderer.renderTexture;\n      var resolution;\n      var multisample;\n      if (renderTextureSystem.current) {\n        var _maskData$multisample;\n        var renderTexture = renderTextureSystem.current;\n        resolution = maskData.resolution || renderTexture.resolution;\n        multisample = (_maskData$multisample = maskData.multisample) !== null && _maskData$multisample !== void 0 ? _maskData$multisample : renderTexture.multisample;\n      } else {\n        var _maskData$multisample2;\n        resolution = maskData.resolution || renderer.resolution;\n        multisample = (_maskData$multisample2 = maskData.multisample) !== null && _maskData$multisample2 !== void 0 ? _maskData$multisample2 : renderer.multisample;\n      }\n      alphaMaskFilter[0].resolution = resolution;\n      alphaMaskFilter[0].multisample = multisample;\n      alphaMaskFilter[0].maskSprite = maskObject;\n      var stashFilterArea = target.filterArea;\n      target.filterArea = maskObject.getBounds(true);\n      renderer.filter.push(target, alphaMaskFilter);\n      target.filterArea = stashFilterArea;\n      if (!maskData._filters) {\n        this.alphaMaskIndex++;\n      }\n    }\n  }, {\n    key: \"popSpriteMask\",\n    value: function popSpriteMask(maskData) {\n      this.renderer.filter.pop();\n      if (maskData._filters) {\n        maskData._filters[0].maskSprite = null;\n      } else {\n        this.alphaMaskIndex--;\n        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n      }\n    }\n  }, {\n    key: \"pushColorMask\",\n    value: function pushColorMask(maskData) {\n      var currColorMask = maskData._colorMask;\n      var nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n      if (nextColorMask !== currColorMask) {\n        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n      }\n    }\n  }, {\n    key: \"popColorMask\",\n    value: function popColorMask(maskData) {\n      var currColorMask = maskData._colorMask;\n      var nextColorMask = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n      if (nextColorMask !== currColorMask) {\n        this.renderer.gl.colorMask((nextColorMask & 1) !== 0, (nextColorMask & 2) !== 0, (nextColorMask & 4) !== 0, (nextColorMask & 8) !== 0);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }]);\n  return MaskSystem;\n}();\nMaskSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"mask\"\n};\nextensions.extensions.add(MaskSystem);\nexports.MaskSystem = MaskSystem;","map":{"version":3,"sources":["../../src/mask/MaskSystem.ts"],"names":["ExtensionType","MaskData","MASK_TYPES","SpriteMaskFilter","extensions"],"mappings":"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","sourcesContent":["import { MaskData } from './MaskData';\nimport { SpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter';\nimport { MASK_TYPES } from '@pixi/constants';\n\nimport type { ISystem } from '../system/ISystem';\nimport type { IMaskTarget } from './MaskData';\nimport type { Renderer } from '../Renderer';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\n/**\n * System plugin to the renderer to manage masks.\n *\n * There are three built-in types of masking:\n * **Scissor Masking**: Scissor masking discards pixels that are outside of a rectangle called the scissor box. It is\n *  the most performant as the scissor test is inexpensive. However, it can only be used when the mask is rectangular.\n * **Stencil Masking**: Stencil masking discards pixels that don't overlap with the pixels rendered into the stencil\n *  buffer. It is the next fastest option as it does not require rendering into a separate framebuffer. However, it does\n *  cause the mask to be rendered **twice** for each masking operation; hence, minimize the rendering cost of your masks.\n * **Sprite Mask Filtering**: Sprite mask filtering discards pixels based on the red channel of the sprite-mask's\n *  texture. (Generally, the masking texture is grayscale). Using advanced techniques, you might be able to embed this\n *  type of masking in a custom shader - and hence, bypassing the masking system fully for performance wins.\n *\n * The best type of masking is auto-detected when you `push` one. To use scissor masking, you must pass in a `Graphics`\n * object with just a rectangle drawn.\n *\n * ## Mask Stacks\n *\n * In the scene graph, masks can be applied recursively, i.e. a mask can be applied during a masking operation. The mask\n * stack stores the currently applied masks in order. Each {@link PIXI.BaseRenderTexture} holds its own mask stack, i.e.\n * when you switch render-textures, the old masks only applied when you switch back to rendering to the old render-target.\n * @memberof PIXI\n */\nexport class MaskSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'mask',\n    };\n\n    /**\n     * Flag to enable scissor masking.\n     * @default true\n     */\n    public enableScissor: boolean;\n\n    /** Pool of used sprite mask filters. */\n    protected readonly alphaMaskPool: Array<SpriteMaskFilter[]>;\n\n    /**\n     * Current index of alpha mask pool.\n     * @default 0\n     * @readonly\n     */\n    protected alphaMaskIndex: number;\n\n    /** Pool of mask data. */\n    private readonly maskDataPool: Array<MaskData>;\n    private maskStack: Array<MaskData>;\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.enableScissor = true;\n        this.alphaMaskPool = [];\n        this.maskDataPool = [];\n\n        this.maskStack = [];\n        this.alphaMaskIndex = 0;\n    }\n\n    /**\n     * Changes the mask stack that is used by this System.\n     * @param maskStack - The mask stack\n     */\n    setMaskStack(maskStack: Array<MaskData>): void\n    {\n        this.maskStack = maskStack;\n        this.renderer.scissor.setMaskStack(maskStack);\n        this.renderer.stencil.setMaskStack(maskStack);\n    }\n\n    /**\n     * Enables the mask and appends it to the current mask stack.\n     *\n     * NOTE: The batch renderer should be flushed beforehand to prevent pending renders from being masked.\n     * @param {PIXI.DisplayObject} target - Display Object to push the mask to\n     * @param {PIXI.MaskData|PIXI.Sprite|PIXI.Graphics|PIXI.DisplayObject} maskDataOrTarget - The masking data.\n     */\n    push(target: IMaskTarget, maskDataOrTarget: MaskData | IMaskTarget): void\n    {\n        let maskData = maskDataOrTarget as MaskData;\n\n        if (!maskData.isMaskData)\n        {\n            const d = this.maskDataPool.pop() || new MaskData();\n\n            d.pooled = true;\n            d.maskObject = maskDataOrTarget as IMaskTarget;\n            maskData = d;\n        }\n\n        const maskAbove = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n\n        maskData.copyCountersOrReset(maskAbove);\n        maskData._colorMask = maskAbove ? maskAbove._colorMask : 0xf;\n\n        if (maskData.autoDetect)\n        {\n            this.detect(maskData);\n        }\n\n        maskData._target = target;\n\n        if (maskData.type !== MASK_TYPES.SPRITE)\n        {\n            this.maskStack.push(maskData);\n        }\n\n        if (maskData.enabled)\n        {\n            switch (maskData.type)\n            {\n                case MASK_TYPES.SCISSOR:\n                    this.renderer.scissor.push(maskData);\n                    break;\n                case MASK_TYPES.STENCIL:\n                    this.renderer.stencil.push(maskData);\n                    break;\n                case MASK_TYPES.SPRITE:\n                    maskData.copyCountersOrReset(null);\n                    this.pushSpriteMask(maskData);\n                    break;\n                case MASK_TYPES.COLOR:\n                    this.pushColorMask(maskData);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        if (maskData.type === MASK_TYPES.SPRITE)\n        {\n            this.maskStack.push(maskData);\n        }\n    }\n\n    /**\n     * Removes the last mask from the mask stack and doesn't return it.\n     *\n     * NOTE: The batch renderer should be flushed beforehand to render the masked contents before the mask is removed.\n     * @param {PIXI.IMaskTarget} target - Display Object to pop the mask from\n     */\n    pop(target: IMaskTarget): void\n    {\n        const maskData = this.maskStack.pop();\n\n        if (!maskData || maskData._target !== target)\n        {\n            // TODO: add an assert when we have it\n\n            return;\n        }\n\n        if (maskData.enabled)\n        {\n            switch (maskData.type)\n            {\n                case MASK_TYPES.SCISSOR:\n                    this.renderer.scissor.pop(maskData);\n                    break;\n                case MASK_TYPES.STENCIL:\n                    this.renderer.stencil.pop(maskData.maskObject);\n                    break;\n                case MASK_TYPES.SPRITE:\n                    this.popSpriteMask(maskData);\n                    break;\n                case MASK_TYPES.COLOR:\n                    this.popColorMask(maskData);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        maskData.reset();\n\n        if (maskData.pooled)\n        {\n            this.maskDataPool.push(maskData);\n        }\n\n        if (this.maskStack.length !== 0)\n        {\n            const maskCurrent = this.maskStack[this.maskStack.length - 1];\n\n            if (maskCurrent.type === MASK_TYPES.SPRITE && maskCurrent._filters)\n            {\n                maskCurrent._filters[0].maskSprite = maskCurrent.maskObject;\n            }\n        }\n    }\n\n    /**\n     * Sets type of MaskData based on its maskObject.\n     * @param maskData\n     */\n    detect(maskData: MaskData): void\n    {\n        const maskObject = maskData.maskObject;\n\n        if (!maskObject)\n        {\n            maskData.type = MASK_TYPES.COLOR;\n        }\n        else if (maskObject.isSprite)\n        {\n            maskData.type = MASK_TYPES.SPRITE;\n        }\n        else if (this.enableScissor && this.renderer.scissor.testScissor(maskData))\n        {\n            maskData.type = MASK_TYPES.SCISSOR;\n        }\n        else\n        {\n            maskData.type = MASK_TYPES.STENCIL;\n        }\n    }\n\n    /**\n     * Applies the Mask and adds it to the current filter stack.\n     * @param maskData - Sprite to be used as the mask.\n     */\n    pushSpriteMask(maskData: MaskData): void\n    {\n        const { maskObject } = maskData;\n        const target = maskData._target;\n        let alphaMaskFilter = maskData._filters;\n\n        if (!alphaMaskFilter)\n        {\n            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];\n\n            if (!alphaMaskFilter)\n            {\n                alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter()];\n            }\n        }\n\n        const renderer = this.renderer;\n        const renderTextureSystem = renderer.renderTexture;\n\n        let resolution;\n        let multisample;\n\n        if (renderTextureSystem.current)\n        {\n            const renderTexture = renderTextureSystem.current;\n\n            resolution = maskData.resolution || renderTexture.resolution;\n            multisample = maskData.multisample ?? renderTexture.multisample;\n        }\n        else\n        {\n            resolution = maskData.resolution || renderer.resolution;\n            multisample = maskData.multisample ?? renderer.multisample;\n        }\n\n        alphaMaskFilter[0].resolution = resolution;\n        alphaMaskFilter[0].multisample = multisample;\n        alphaMaskFilter[0].maskSprite = maskObject;\n\n        const stashFilterArea = target.filterArea;\n\n        target.filterArea = maskObject.getBounds(true);\n        renderer.filter.push(target, alphaMaskFilter);\n        target.filterArea = stashFilterArea;\n\n        if (!maskData._filters)\n        {\n            this.alphaMaskIndex++;\n        }\n    }\n\n    /**\n     * Removes the last filter from the filter stack and doesn't return it.\n     * @param maskData - Sprite to be used as the mask.\n     */\n    popSpriteMask(maskData: MaskData): void\n    {\n        this.renderer.filter.pop();\n\n        if (maskData._filters)\n        {\n            maskData._filters[0].maskSprite = null;\n        }\n        else\n        {\n            this.alphaMaskIndex--;\n            this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null;\n        }\n    }\n\n    /**\n     * Pushes the color mask.\n     * @param maskData - The mask data\n     */\n    pushColorMask(maskData: MaskData): void\n    {\n        const currColorMask = maskData._colorMask;\n        const nextColorMask = maskData._colorMask = currColorMask & maskData.colorMask;\n\n        if (nextColorMask !== currColorMask)\n        {\n            this.renderer.gl.colorMask(\n                (nextColorMask & 0x1) !== 0,\n                (nextColorMask & 0x2) !== 0,\n                (nextColorMask & 0x4) !== 0,\n                (nextColorMask & 0x8) !== 0\n            );\n        }\n    }\n\n    /**\n     * Pops the color mask.\n     * @param maskData - The mask data\n     */\n    popColorMask(maskData: MaskData): void\n    {\n        const currColorMask = maskData._colorMask;\n        const nextColorMask = this.maskStack.length > 0\n            ? this.maskStack[this.maskStack.length - 1]._colorMask : 0xf;\n\n        if (nextColorMask !== currColorMask)\n        {\n            this.renderer.gl.colorMask(\n                (nextColorMask & 0x1) !== 0,\n                (nextColorMask & 0x2) !== 0,\n                (nextColorMask & 0x4) !== 0,\n                (nextColorMask & 0x8) !== 0\n            );\n        }\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(MaskSystem);\n"]},"metadata":{},"sourceType":"script"}