{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _construct = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/construct.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeMapper = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar address_1 = require(\"./address\");\nvar boolean_1 = require(\"./boolean\");\nvar bytes_1 = require(\"./bytes\");\nvar composite_1 = require(\"./composite\");\nvar enum_1 = require(\"./enum\");\nvar generic_1 = require(\"./generic\");\nvar h256_1 = require(\"./h256\");\nvar numerical_1 = require(\"./numerical\");\nvar struct_1 = require(\"./struct\");\nvar fields_1 = require(\"./fields\");\nvar tokenIdentifier_1 = require(\"./tokenIdentifier\");\nvar variadic_1 = require(\"./variadic\");\nvar algebraic_1 = require(\"./algebraic\");\nvar genericArray_1 = require(\"./genericArray\");\nvar string_1 = require(\"./string\");\nvar tuple_1 = require(\"./tuple\");\nvar codeMetadata_1 = require(\"./codeMetadata\");\nvar nothing_1 = require(\"./nothing\");\nvar TypeMapper = /*#__PURE__*/function () {\n  function TypeMapper() {\n    var learnedTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, TypeMapper);\n    this.openTypesFactories = new Map([[\"Option\", function () {\n      return new generic_1.OptionType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"List\", function () {\n      return new generic_1.ListType(arguments.length <= 0 ? undefined : arguments[0]);\n    }],\n    // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n    [\"VarArgs\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"MultiResultVec\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"variadic\", function () {\n      return new variadic_1.VariadicType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalArg\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"optional\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"OptionalResult\", function () {\n      return new algebraic_1.OptionalType(arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"multi\", function () {\n      for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n        typeParameters[_key] = arguments[_key];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"MultiArg\", function () {\n      for (var _len2 = arguments.length, typeParameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        typeParameters[_key2] = arguments[_key2];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"MultiResult\", function () {\n      for (var _len3 = arguments.length, typeParameters = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        typeParameters[_key3] = arguments[_key3];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }], [\"multi\", function () {\n      for (var _len4 = arguments.length, typeParameters = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        typeParameters[_key4] = arguments[_key4];\n      }\n      return _construct(composite_1.CompositeType, typeParameters);\n    }],\n    // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n    [\"tuple\", function () {\n      for (var _len5 = arguments.length, typeParameters = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        typeParameters[_key5] = arguments[_key5];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple2\", function () {\n      for (var _len6 = arguments.length, typeParameters = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        typeParameters[_key6] = arguments[_key6];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple3\", function () {\n      for (var _len7 = arguments.length, typeParameters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        typeParameters[_key7] = arguments[_key7];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple4\", function () {\n      for (var _len8 = arguments.length, typeParameters = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        typeParameters[_key8] = arguments[_key8];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple5\", function () {\n      for (var _len9 = arguments.length, typeParameters = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        typeParameters[_key9] = arguments[_key9];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple6\", function () {\n      for (var _len10 = arguments.length, typeParameters = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        typeParameters[_key10] = arguments[_key10];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple7\", function () {\n      for (var _len11 = arguments.length, typeParameters = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        typeParameters[_key11] = arguments[_key11];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }], [\"tuple8\", function () {\n      for (var _len12 = arguments.length, typeParameters = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        typeParameters[_key12] = arguments[_key12];\n      }\n      return _construct(tuple_1.TupleType, typeParameters);\n    }],\n    // Known-length arrays.\n    // TODO: Handle these in typeExpressionParser!\n    [\"array20\", function () {\n      return new genericArray_1.ArrayVecType(20, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array32\", function () {\n      return new genericArray_1.ArrayVecType(32, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array46\", function () {\n      return new genericArray_1.ArrayVecType(46, arguments.length <= 0 ? undefined : arguments[0]);\n    }], [\"array64\", function () {\n      return new genericArray_1.ArrayVecType(64, arguments.length <= 0 ? undefined : arguments[0]);\n    }]]);\n    // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).\n    this.closedTypesMap = new Map([[\"u8\", new numerical_1.U8Type()], [\"u16\", new numerical_1.U16Type()], [\"u32\", new numerical_1.U32Type()], [\"u64\", new numerical_1.U64Type()], [\"U64\", new numerical_1.U64Type()], [\"BigUint\", new numerical_1.BigUIntType()], [\"i8\", new numerical_1.I8Type()], [\"i16\", new numerical_1.I16Type()], [\"i32\", new numerical_1.I32Type()], [\"i64\", new numerical_1.I64Type()], [\"Bigint\", new numerical_1.BigIntType()], [\"BigInt\", new numerical_1.BigIntType()], [\"bool\", new boolean_1.BooleanType()], [\"bytes\", new bytes_1.BytesType()], [\"Address\", new address_1.AddressType()], [\"H256\", new h256_1.H256Type()], [\"utf-8 string\", new string_1.StringType()], [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()], [\"EgldOrEsdtTokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()], [\"CodeMetadata\", new codeMetadata_1.CodeMetadataType()], [\"nothing\", new nothing_1.NothingType()], [\"AsyncCall\", new nothing_1.NothingType()]]);\n    this.learnedTypesMap = new Map();\n    // Boostrap from previously learned types, if any.\n    var _iterator = _createForOfIteratorHelper(learnedTypes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        this.learnedTypesMap.set(type.getName(), type);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  _createClass(TypeMapper, [{\n    key: \"mapType\",\n    value: function mapType(type) {\n      var mappedType = this.mapRecursiveType(type);\n      if (mappedType) {\n        // We do not learn generic types (that also have type parameters)\n        if (!mappedType.isGenericType()) {\n          this.learnType(mappedType);\n        }\n        return mappedType;\n      }\n      throw new errors.ErrTypingSystem(\"Cannot map the type \\\"\".concat(type.getName(), \"\\\" to a known type\"));\n    }\n  }, {\n    key: \"mapRecursiveType\",\n    value: function mapRecursiveType(type) {\n      var isGeneric = type.isGenericType();\n      var previouslyLearnedType = this.learnedTypesMap.get(type.getName());\n      if (previouslyLearnedType) {\n        return previouslyLearnedType;\n      }\n      var knownClosedType = this.closedTypesMap.get(type.getName());\n      if (knownClosedType) {\n        return knownClosedType;\n      }\n      if (type.hasExactClass(enum_1.EnumType.ClassName)) {\n        // This will call mapType() recursively, for all the enum variant fields.\n        return this.mapEnumType(type);\n      }\n      if (type.hasExactClass(struct_1.StructType.ClassName)) {\n        // This will call mapType() recursively, for all the struct's fields.\n        return this.mapStructType(type);\n      }\n      if (isGeneric) {\n        // This will call mapType() recursively, for all the type parameters.\n        return this.mapGenericType(type);\n      }\n      return null;\n    }\n  }, {\n    key: \"learnType\",\n    value: function learnType(type) {\n      this.learnedTypesMap.delete(type.getName());\n      this.learnedTypesMap.set(type.getName(), type);\n    }\n  }, {\n    key: \"mapStructType\",\n    value: function mapStructType(type) {\n      var mappedFields = this.mappedFields(type.getFieldsDefinitions());\n      var mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n      return mappedStruct;\n    }\n  }, {\n    key: \"mapEnumType\",\n    value: function mapEnumType(type) {\n      var _this = this;\n      var variants = type.variants.map(function (variant) {\n        return new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, _this.mappedFields(variant.getFieldsDefinitions()));\n      });\n      var mappedEnum = new enum_1.EnumType(type.getName(), variants);\n      return mappedEnum;\n    }\n  }, {\n    key: \"mappedFields\",\n    value: function mappedFields(definitions) {\n      var _this2 = this;\n      return definitions.map(function (definition) {\n        return new fields_1.FieldDefinition(definition.name, definition.description, _this2.mapType(definition.type));\n      });\n    }\n  }, {\n    key: \"mapGenericType\",\n    value: function mapGenericType(type) {\n      var _this3 = this;\n      var typeParameters = type.getTypeParameters();\n      var mappedTypeParameters = typeParameters.map(function (item) {\n        return _this3.mapType(item);\n      });\n      var factory = this.openTypesFactories.get(type.getName());\n      if (!factory) {\n        throw new errors.ErrTypingSystem(\"Cannot map the generic type \\\"\".concat(type.getName(), \"\\\" to a known type\"));\n      }\n      return factory.apply(void 0, _toConsumableArray(mappedTypeParameters));\n    }\n  }]);\n  return TypeMapper;\n}();\nexports.TypeMapper = TypeMapper;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/typeMapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeMapper = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst address_1 = require(\"./address\");\nconst boolean_1 = require(\"./boolean\");\nconst bytes_1 = require(\"./bytes\");\nconst composite_1 = require(\"./composite\");\nconst enum_1 = require(\"./enum\");\nconst generic_1 = require(\"./generic\");\nconst h256_1 = require(\"./h256\");\nconst numerical_1 = require(\"./numerical\");\nconst struct_1 = require(\"./struct\");\nconst fields_1 = require(\"./fields\");\nconst tokenIdentifier_1 = require(\"./tokenIdentifier\");\nconst variadic_1 = require(\"./variadic\");\nconst algebraic_1 = require(\"./algebraic\");\nconst genericArray_1 = require(\"./genericArray\");\nconst string_1 = require(\"./string\");\nconst tuple_1 = require(\"./tuple\");\nconst codeMetadata_1 = require(\"./codeMetadata\");\nconst nothing_1 = require(\"./nothing\");\nclass TypeMapper {\n    constructor(learnedTypes = []) {\n        this.openTypesFactories = new Map([\n            [\"Option\", (...typeParameters) => new generic_1.OptionType(typeParameters[0])],\n            [\"List\", (...typeParameters) => new generic_1.ListType(typeParameters[0])],\n            // For the following open generics, we use a slightly different typing than the one defined by elrond-wasm-rs (temporary workaround).\n            [\"VarArgs\", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],\n            [\"MultiResultVec\", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],\n            [\"variadic\", (...typeParameters) => new variadic_1.VariadicType(typeParameters[0])],\n            [\"OptionalArg\", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],\n            [\"optional\", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],\n            [\"OptionalResult\", (...typeParameters) => new algebraic_1.OptionalType(typeParameters[0])],\n            [\"multi\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            [\"MultiArg\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            [\"MultiResult\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            [\"multi\", (...typeParameters) => new composite_1.CompositeType(...typeParameters)],\n            // Perhaps we can adjust the ABI generator to only output \"tuple\", instead of \"tupleN\"?\n            [\"tuple\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple2\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple3\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple4\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple5\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple6\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple7\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            [\"tuple8\", (...typeParameters) => new tuple_1.TupleType(...typeParameters)],\n            // Known-length arrays.\n            // TODO: Handle these in typeExpressionParser!\n            [\"array20\", (...typeParameters) => new genericArray_1.ArrayVecType(20, typeParameters[0])],\n            [\"array32\", (...typeParameters) => new genericArray_1.ArrayVecType(32, typeParameters[0])],\n            [\"array46\", (...typeParameters) => new genericArray_1.ArrayVecType(46, typeParameters[0])],\n            [\"array64\", (...typeParameters) => new genericArray_1.ArrayVecType(64, typeParameters[0])],\n        ]);\n        // For closed types, we hold actual type instances instead of type constructors / factories (no type parameters needed).\n        this.closedTypesMap = new Map([\n            [\"u8\", new numerical_1.U8Type()],\n            [\"u16\", new numerical_1.U16Type()],\n            [\"u32\", new numerical_1.U32Type()],\n            [\"u64\", new numerical_1.U64Type()],\n            [\"U64\", new numerical_1.U64Type()],\n            [\"BigUint\", new numerical_1.BigUIntType()],\n            [\"i8\", new numerical_1.I8Type()],\n            [\"i16\", new numerical_1.I16Type()],\n            [\"i32\", new numerical_1.I32Type()],\n            [\"i64\", new numerical_1.I64Type()],\n            [\"Bigint\", new numerical_1.BigIntType()],\n            [\"BigInt\", new numerical_1.BigIntType()],\n            [\"bool\", new boolean_1.BooleanType()],\n            [\"bytes\", new bytes_1.BytesType()],\n            [\"Address\", new address_1.AddressType()],\n            [\"H256\", new h256_1.H256Type()],\n            [\"utf-8 string\", new string_1.StringType()],\n            [\"TokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()],\n            [\"EgldOrEsdtTokenIdentifier\", new tokenIdentifier_1.TokenIdentifierType()],\n            [\"CodeMetadata\", new codeMetadata_1.CodeMetadataType()],\n            [\"nothing\", new nothing_1.NothingType()],\n            [\"AsyncCall\", new nothing_1.NothingType()]\n        ]);\n        this.learnedTypesMap = new Map();\n        // Boostrap from previously learned types, if any.\n        for (const type of learnedTypes) {\n            this.learnedTypesMap.set(type.getName(), type);\n        }\n    }\n    mapType(type) {\n        let mappedType = this.mapRecursiveType(type);\n        if (mappedType) {\n            // We do not learn generic types (that also have type parameters)\n            if (!mappedType.isGenericType()) {\n                this.learnType(mappedType);\n            }\n            return mappedType;\n        }\n        throw new errors.ErrTypingSystem(`Cannot map the type \"${type.getName()}\" to a known type`);\n    }\n    mapRecursiveType(type) {\n        let isGeneric = type.isGenericType();\n        let previouslyLearnedType = this.learnedTypesMap.get(type.getName());\n        if (previouslyLearnedType) {\n            return previouslyLearnedType;\n        }\n        let knownClosedType = this.closedTypesMap.get(type.getName());\n        if (knownClosedType) {\n            return knownClosedType;\n        }\n        if (type.hasExactClass(enum_1.EnumType.ClassName)) {\n            // This will call mapType() recursively, for all the enum variant fields.\n            return this.mapEnumType(type);\n        }\n        if (type.hasExactClass(struct_1.StructType.ClassName)) {\n            // This will call mapType() recursively, for all the struct's fields.\n            return this.mapStructType(type);\n        }\n        if (isGeneric) {\n            // This will call mapType() recursively, for all the type parameters.\n            return this.mapGenericType(type);\n        }\n        return null;\n    }\n    learnType(type) {\n        this.learnedTypesMap.delete(type.getName());\n        this.learnedTypesMap.set(type.getName(), type);\n    }\n    mapStructType(type) {\n        let mappedFields = this.mappedFields(type.getFieldsDefinitions());\n        let mappedStruct = new struct_1.StructType(type.getName(), mappedFields);\n        return mappedStruct;\n    }\n    mapEnumType(type) {\n        let variants = type.variants.map((variant) => new enum_1.EnumVariantDefinition(variant.name, variant.discriminant, this.mappedFields(variant.getFieldsDefinitions())));\n        let mappedEnum = new enum_1.EnumType(type.getName(), variants);\n        return mappedEnum;\n    }\n    mappedFields(definitions) {\n        return definitions.map((definition) => new fields_1.FieldDefinition(definition.name, definition.description, this.mapType(definition.type)));\n    }\n    mapGenericType(type) {\n        let typeParameters = type.getTypeParameters();\n        let mappedTypeParameters = typeParameters.map((item) => this.mapType(item));\n        let factory = this.openTypesFactories.get(type.getName());\n        if (!factory) {\n            throw new errors.ErrTypingSystem(`Cannot map the generic type \"${type.getName()}\" to a known type`);\n        }\n        return factory(...mappedTypeParameters);\n    }\n}\nexports.TypeMapper = TypeMapper;\n//# sourceMappingURL=typeMapper.js.map"]},"metadata":{},"sourceType":"script"}