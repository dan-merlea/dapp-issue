{"ast":null,"code":"var buildRectangle = {\n  build: function build(graphicsData) {\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    if (!(width >= 0 && height >= 0)) {\n      return;\n    }\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    if (points.length === 0) {\n      return;\n    }\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\nexport { buildRectangle };","map":{"version":3,"sources":["../../src/utils/buildRectangle.ts"],"names":[],"mappings":"AAaO,IAAM,cAAqC,GAAA;EAE9C,KAAA,iBAAM,YACN,EAAA;IAII,IAAM,QAAA,GAAW,YAAa,CAAA,KAAA;IAC9B,IAAM,CAAA,GAAI,QAAS,CAAA,CAAA;IACnB,IAAM,CAAA,GAAI,QAAS,CAAA,CAAA;IACnB,IAAM,KAAA,GAAQ,QAAS,CAAA,KAAA;IACvB,IAAM,MAAA,GAAS,QAAS,CAAA,MAAA;IAExB,IAAM,MAAA,GAAS,YAAa,CAAA,MAAA;IAE5B,MAAA,CAAO,MAAS,GAAA,CAAA;IAEhB,IAAI,EAAE,KAAA,IAAS,CAAK,IAAA,MAAA,IAAU,CAC9B,CAAA,EAAA;MACI;IAAA;IAGJ,MAAA,CAAO,IAAK,CAAA,CAAA,EAAG,CACX,EAAA,CAAA,GAAI,KAAO,EAAA,CAAA,EACX,CAAI,GAAA,KAAA,EAAO,CAAI,GAAA,MAAA,EACf,CAAG,EAAA,CAAA,GAAI,MAAM,CAAA;EAAA,CACrB;EAEA,WAAA,uBAAY,YAAA,EAAc,gBAC1B,EAAA;IACI,IAAM,MAAA,GAAS,YAAa,CAAA,MAAA;IAC5B,IAAM,KAAA,GAAQ,gBAAiB,CAAA,MAAA;IAE3B,IAAA,MAAA,CAAO,MAAA,KAAW,CACtB,EAAA;MACI;IAAA;IAGE,IAAA,OAAA,GAAU,KAAA,CAAM,MAAS,GAAA,CAAA;IAE/B,KAAA,CAAM,IAAA,CAAK,MAAO,CAAA,CAAA,CAAA,EAAI,MAAO,CAAA,CAAA,CAAA,EACzB,MAAA,CAAO,CAAI,CAAA,EAAA,MAAA,CAAO,CAClB,CAAA,EAAA,MAAA,CAAO,CAAA,CAAA,EAAI,MAAO,CAAA,CAAA,CAAA,EAClB,MAAO,CAAA,CAAA,CAAA,EAAI,MAAA,CAAO,CAAE,CAAA,CAAA;IAExB,gBAAA,CAAiB,OAAQ,CAAA,IAAA,CAAK,OAAS,EAAA,OAAA,GAAU,CAAG,EAAA,OAAA,GAAU,CAC1D,EAAA,OAAA,GAAU,CAAG,EAAA,OAAA,GAAU,CAAG,EAAA,OAAA,GAAU,CAAC,CAAA;EAAA;AAEjD,CAAA","sourcesContent":["import type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Rectangle } from '@pixi/core';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        if (!(width >= 0 && height >= 0))\n        {\n            return;\n        }\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n"]},"metadata":{},"sourceType":"module"}