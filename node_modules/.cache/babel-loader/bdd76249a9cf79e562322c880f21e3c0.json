{"ast":null,"code":"import { Point, SHAPES } from '@pixi/core';\nimport { LINE_CAP, LINE_JOIN, GRAPHICS_CURVES } from '../const.mjs';\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  var ix = x - nx * innerWeight;\n  var iy = y - ny * innerWeight;\n  var ox = x + nx * outerWeight;\n  var oy = y + ny * outerWeight;\n  var exx;\n  var eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  var eix = ix + exx;\n  var eiy = iy + eyy;\n  var eox = ox + exx;\n  var eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  var cx2p0x = sx - cx;\n  var cy2p0y = sy - cy;\n  var angle0 = Math.atan2(cx2p0x, cy2p0y);\n  var angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  var startAngle = angle0;\n  var angleDiff = angle1 - angle0;\n  var absAngleDiff = Math.abs(angleDiff);\n  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  var angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (var _i = 1, _angle = startAngle; _i < segCount; _i++, _angle += angleInc) {\n      verts.push(cx + Math.sin(_angle) * radius, cy + Math.cos(_angle) * radius);\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  var style = graphicsData.lineStyle;\n  var firstPoint = new Point(points[0], points[1]);\n  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  var verts = graphicsGeometry.points;\n  var length = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2;\n  var width = style.width / 2;\n  var widthSquared = width * width;\n  var miterLimitSquared = style.miterLimit * style.miterLimit;\n  var x0 = points[0];\n  var y0 = points[1];\n  var x1 = points[2];\n  var y1 = points[3];\n  var x2 = 0;\n  var y2 = 0;\n  var perpx = -(y0 - y1);\n  var perpy = x0 - x1;\n  var perp1x = 0;\n  var perp1y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment;\n  var innerWeight = (1 - ratio) * 2;\n  var outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n  for (var i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    var dx0 = x1 - x0;\n    var dy0 = y0 - y1;\n    var dx1 = x1 - x2;\n    var dy1 = y2 - y1;\n    var dot = dx0 * dx1 + dy0 * dy1;\n    var cross = dy0 * dx1 - dy1 * dx0;\n    var clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (dot >= 0) {\n        if (style.join === LINE_JOIN.ROUND) {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * outerWeight, y1 - perp1y * outerWeight);\n        verts.push(x1 + perp1x * innerWeight, y1 + perp1y * innerWeight);\n      }\n      continue;\n    }\n    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    var px = (dx0 * c2 - dx1 * c1) / cross;\n    var py = (dy1 * c1 - dy0 * c2) / cross;\n    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    var imx = x1 + (px - x1) * innerWeight;\n    var imy = y1 + (py - y1) * innerWeight;\n    var omx = x1 - (px - x1) * outerWeight;\n    var omy = y1 - (py - y1) * outerWeight;\n    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    var insideWeight = clockwise ? innerWeight : outerWeight;\n    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    var insideMiterOk = pdist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise) {\n          indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n        } else {\n          indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n        }\n      } else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n  var indices = graphicsGeometry.indices;\n  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n  for (var _i2 = indexStart; _i2 < indexCount + indexStart - 2; ++_i2) {\n    x0 = verts[_i2 * 2];\n    y0 = verts[_i2 * 2 + 1];\n    x1 = verts[(_i2 + 1) * 2];\n    y1 = verts[(_i2 + 1) * 2 + 1];\n    x2 = verts[(_i2 + 2) * 2];\n    y2 = verts[(_i2 + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(_i2, _i2 + 1, _i2 + 2);\n  }\n}\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  if (points.length === 0) return;\n  var verts = graphicsGeometry.points;\n  var indices = graphicsGeometry.indices;\n  var length = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\nexport { buildLine };","map":{"version":3,"sources":["../../src/utils/buildLine.ts"],"names":[],"mappings":"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","sourcesContent":["import { Point, SHAPES } from '@pixi/core';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\nimport { LINE_JOIN, LINE_CAP, GRAPHICS_CURVES } from '../const';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -GRAPHICS_CURVES.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === LINE_JOIN.MITER && pdist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}