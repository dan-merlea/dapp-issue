{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\nvar utils_1 = require(\"../../utils\");\nvar collections_1 = require(\"./collections\");\nvar types_1 = require(\"./types\");\n// TODO: Move to a new file, \"genericOption.ts\"\nvar OptionType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(OptionType, _types_1$Type);\n  var _super = _createSuper(OptionType);\n  function OptionType(typeParameter) {\n    _classCallCheck(this, OptionType);\n    return _super.call(this, \"Option\", [typeParameter]);\n  }\n  _createClass(OptionType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionType.ClassName;\n    }\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      if (!type.hasExactClass(OptionType.ClassName)) {\n        return false;\n      }\n      var invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n      var fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n      return invariantTypeParameters || fakeCovarianceToNull;\n    }\n  }]);\n  return OptionType;\n}(types_1.Type);\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\";\n// TODO: Move to a new file, \"genericList.ts\"\nvar ListType = /*#__PURE__*/function (_types_1$Type2) {\n  _inherits(ListType, _types_1$Type2);\n  var _super2 = _createSuper(ListType);\n  function ListType(typeParameter) {\n    _classCallCheck(this, ListType);\n    return _super2.call(this, \"List\", [typeParameter]);\n  }\n  _createClass(ListType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return ListType.ClassName;\n    }\n  }]);\n  return ListType;\n}(types_1.Type);\nexports.ListType = ListType;\nListType.ClassName = \"ListType\";\n// TODO: Move to a new file, \"genericOption.ts\"\nvar OptionValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(OptionValue, _types_1$TypedValue);\n  var _super3 = _createSuper(OptionValue);\n  function OptionValue(type) {\n    var _this;\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, OptionValue);\n    _this = _super3.call(this, type);\n    // TODO: assert value is of type type.getFirstTypeParameter()\n    _this.value = value;\n    return _this;\n  }\n  _createClass(OptionValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionValue.ClassName;\n    }\n    /**\n     * Creates an OptionValue, as a missing option argument.\n     */\n  }, {\n    key: \"isSet\",\n    value: function isSet() {\n      return this.value ? true : false;\n    }\n  }, {\n    key: \"getTypedValue\",\n    value: function getTypedValue() {\n      utils_1.guardValueIsSet(\"value\", this.value);\n      return this.value;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value ? this.value.valueOf() : null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var _a;\n      return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n  }], [{\n    key: \"newMissing\",\n    value: function newMissing() {\n      var type = new OptionType(new types_1.NullType());\n      return new OptionValue(type);\n    }\n  }, {\n    key: \"newMissingTyped\",\n    value: function newMissingTyped(type) {\n      return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n  }, {\n    key: \"newProvided\",\n    value: function newProvided(typedValue) {\n      var type = new OptionType(typedValue.getType());\n      return new OptionValue(type, typedValue);\n    }\n  }]);\n  return OptionValue;\n}(types_1.TypedValue);\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\";\n// TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\nvar List = /*#__PURE__*/function (_types_1$TypedValue2) {\n  _inherits(List, _types_1$TypedValue2);\n  var _super4 = _createSuper(List);\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  function List(type, items) {\n    var _this2;\n    _classCallCheck(this, List);\n    _this2 = _super4.call(this, type);\n    // TODO: assert items are of type type.getFirstTypeParameter()\n    _this2.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    return _this2;\n  }\n  _createClass(List, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return List.ClassName;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.backingCollection.getLength();\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.backingCollection.getItems();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.backingCollection.valueOf();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.backingCollection.equals(other.backingCollection);\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems(items) {\n      if (items.length == 0) {\n        return new List(new types_1.TypePlaceholder(), []);\n      }\n      var typeParameter = items[0].getType();\n      var listType = new ListType(typeParameter);\n      return new List(listType, items);\n    }\n  }]);\n  return List;\n}(types_1.TypedValue);\nexports.List = List;\nList.ClassName = \"List\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/generic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\nconst utils_1 = require(\"../../utils\");\nconst collections_1 = require(\"./collections\");\nconst types_1 = require(\"./types\");\n// TODO: Move to a new file, \"genericOption.ts\"\nclass OptionType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"Option\", [typeParameter]);\n    }\n    getClassName() {\n        return OptionType.ClassName;\n    }\n    isAssignableFrom(type) {\n        if (!(type.hasExactClass(OptionType.ClassName))) {\n            return false;\n        }\n        let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n        let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n        return invariantTypeParameters || fakeCovarianceToNull;\n    }\n}\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\";\n// TODO: Move to a new file, \"genericList.ts\"\nclass ListType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"List\", [typeParameter]);\n    }\n    getClassName() {\n        return ListType.ClassName;\n    }\n}\nexports.ListType = ListType;\nListType.ClassName = \"ListType\";\n// TODO: Move to a new file, \"genericOption.ts\"\nclass OptionValue extends types_1.TypedValue {\n    constructor(type, value = null) {\n        super(type);\n        // TODO: assert value is of type type.getFirstTypeParameter()\n        this.value = value;\n    }\n    getClassName() {\n        return OptionValue.ClassName;\n    }\n    /**\n     * Creates an OptionValue, as a missing option argument.\n     */\n    static newMissing() {\n        let type = new OptionType(new types_1.NullType());\n        return new OptionValue(type);\n    }\n    static newMissingTyped(type) {\n        return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n    static newProvided(typedValue) {\n        let type = new OptionType(typedValue.getType());\n        return new OptionValue(type, typedValue);\n    }\n    isSet() {\n        return this.value ? true : false;\n    }\n    getTypedValue() {\n        utils_1.guardValueIsSet(\"value\", this.value);\n        return this.value;\n    }\n    valueOf() {\n        return this.value ? this.value.valueOf() : null;\n    }\n    equals(other) {\n        var _a;\n        return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n}\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\";\n// TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\nclass List extends types_1.TypedValue {\n    /**\n     *\n     * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n     * @param items the items, having the type type.getFirstTypeParameter()\n     */\n    constructor(type, items) {\n        super(type);\n        // TODO: assert items are of type type.getFirstTypeParameter()\n        this.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    }\n    getClassName() {\n        return List.ClassName;\n    }\n    static fromItems(items) {\n        if (items.length == 0) {\n            return new List(new types_1.TypePlaceholder(), []);\n        }\n        let typeParameter = items[0].getType();\n        let listType = new ListType(typeParameter);\n        return new List(listType, items);\n    }\n    getLength() {\n        return this.backingCollection.getLength();\n    }\n    getItems() {\n        return this.backingCollection.getItems();\n    }\n    valueOf() {\n        return this.backingCollection.valueOf();\n    }\n    equals(other) {\n        return this.backingCollection.equals(other.backingCollection);\n    }\n}\nexports.List = List;\nList.ClassName = \"List\";\n//# sourceMappingURL=generic.js.map"]},"metadata":{},"sourceType":"script"}