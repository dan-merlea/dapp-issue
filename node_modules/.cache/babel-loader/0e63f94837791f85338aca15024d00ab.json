{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar mesh = require('@pixi/mesh');\nvar core = require('@pixi/core');\nvar SimpleMesh = /*#__PURE__*/function (_mesh$Mesh) {\n  _inherits(SimpleMesh, _mesh$Mesh);\n  var _super = _createSuper(SimpleMesh);\n  function SimpleMesh() {\n    var _this;\n    var texture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : core.Texture.EMPTY;\n    var vertices = arguments.length > 1 ? arguments[1] : undefined;\n    var uvs = arguments.length > 2 ? arguments[2] : undefined;\n    var indices = arguments.length > 3 ? arguments[3] : undefined;\n    var drawMode = arguments.length > 4 ? arguments[4] : undefined;\n    _classCallCheck(this, SimpleMesh);\n    var geometry = new mesh.MeshGeometry(vertices, uvs, indices);\n    geometry.getBuffer(\"aVertexPosition\").static = false;\n    var meshMaterial = new mesh.MeshMaterial(texture);\n    _this = _super.call(this, geometry, meshMaterial, null, drawMode);\n    _this.autoUpdate = true;\n    return _this;\n  }\n  _createClass(SimpleMesh, [{\n    key: \"vertices\",\n    get: function get() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function set(value) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = value;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      if (this.autoUpdate) {\n        this.geometry.getBuffer(\"aVertexPosition\").update();\n      }\n      _get(_getPrototypeOf(SimpleMesh.prototype), \"_render\", this).call(this, renderer);\n    }\n  }]);\n  return SimpleMesh;\n}(mesh.Mesh);\nexports.SimpleMesh = SimpleMesh;","map":{"version":3,"sources":["../src/SimpleMesh.ts"],"names":["Mesh","MeshGeometry","MeshMaterial"],"mappings":";;;;;;;;;;;;;IAUa,UAAA;EAAA;EAAA;EAYT,sBAOA;IAAA;IAAA,IANI,OAAmB,uEAAA,IAAA,CAAA,OAAA,CAAQ,KAAA;IAAA,IAC3B,QACA;IAAA,IAAA,GAAA;IAAA,IACA,OAAA;IAAA,IACA,QAEJ;IAAA;IACI,IAAM,QAAW,GAAA,IAAIC,IAAAA,CAAAA,YAAa,CAAA,QAAA,EAAU,GAAA,EAAK,OAAO,CAAA;IAE/C,QAAA,CAAA,SAAA,CAAU,iBAAiB,CAAA,CAAE,MAAS,GAAA,KAAA;IAEzC,IAAA,YAAA,GAAe,IAAIC,IAAAA,CAAAA,YAAAA,CAAa,OAAO,CAAA;IAEvC,0BAAA,QAAA,EAAU,YAAc,EAAA,IAAA,EAAM,QAAQ;IAE5C,MAAK,UAAa,GAAA,IAAA;IAAA;EAAA;EACtB;IAAA;IAAA,KAMA,eACA;MACI,OAAO,IAAK,CAAA,QAAA,CAAS,SAAU,CAAA,iBAAiB,CAAE,CAAA,IAAA;IAAA,CACtD;IAAA,KACA,aAAa,KACb,EAAA;MACI,IAAA,CAAK,QAAS,CAAA,SAAA,CAAU,iBAAiB,CAAA,CAAE,IAAO,GAAA,KAAA;IAAA;EACtD;IAAA;IAAA,OAEA,iBAAQ,QACR,EAAA;MACI,IAAI,IAAA,CAAK,UACT,EAAA;QACI,IAAA,CAAK,QAAS,CAAA,SAAA,CAAU,iBAAiB,CAAA,CAAE,MAAO,EAAA;MAAA;MAGtD,wEAAc,QAAQ;IAAA;EAC1B;EAAA;AAAA,EApD4BF,IAAAA,CAAAA,IAChC","sourcesContent":["import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';\nimport { Texture } from '@pixi/core';\n\nimport type { DRAW_MODES, ITypedArray, IArrayBuffer, Renderer } from '@pixi/core';\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS v4, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link PIXI.Mesh}.\n * @memberof PIXI\n */\nexport class SimpleMesh extends Mesh\n{\n    /** Upload vertices buffer each frame. */\n    public autoUpdate: boolean;\n\n    /**\n     * @param texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param drawMode - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(\n        texture: Texture = Texture.EMPTY,\n        vertices?: IArrayBuffer,\n        uvs?: IArrayBuffer,\n        indices?: IArrayBuffer,\n        drawMode?: DRAW_MODES\n    )\n    {\n        const geometry = new MeshGeometry(vertices, uvs, indices);\n\n        geometry.getBuffer('aVertexPosition').static = false;\n\n        const meshMaterial = new MeshMaterial(texture);\n\n        super(geometry, meshMaterial, null, drawMode);\n\n        this.autoUpdate = true;\n    }\n\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get vertices(): ITypedArray\n    {\n        return this.geometry.getBuffer('aVertexPosition').data;\n    }\n    set vertices(value: ITypedArray)\n    {\n        this.geometry.getBuffer('aVertexPosition').data = value;\n    }\n\n    _render(renderer: Renderer): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aVertexPosition').update();\n        }\n\n        super._render(renderer);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}