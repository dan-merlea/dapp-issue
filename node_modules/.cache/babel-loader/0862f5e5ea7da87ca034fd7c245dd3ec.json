{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { GRAPHICS_CURVES } from '../const.mjs';\nvar BezierUtils = /*#__PURE__*/function () {\n  function BezierUtils() {\n    _classCallCheck(this, BezierUtils);\n  }\n  _createClass(BezierUtils, null, [{\n    key: \"curveLength\",\n    value: function curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n      var n = 10;\n      var result = 0;\n      var t = 0;\n      var t2 = 0;\n      var t3 = 0;\n      var nt = 0;\n      var nt2 = 0;\n      var nt3 = 0;\n      var x = 0;\n      var y = 0;\n      var dx = 0;\n      var dy = 0;\n      var prevX = fromX;\n      var prevY = fromY;\n      for (var i = 1; i <= n; ++i) {\n        t = i / n;\n        t2 = t * t;\n        t3 = t2 * t;\n        nt = 1 - t;\n        nt2 = nt * nt;\n        nt3 = nt2 * nt;\n        x = nt3 * fromX + 3 * nt2 * t * cpX + 3 * nt * t2 * cpX2 + t3 * toX;\n        y = nt3 * fromY + 3 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n        dx = prevX - x;\n        dy = prevY - y;\n        prevX = x;\n        prevY = y;\n        result += Math.sqrt(dx * dx + dy * dy);\n      }\n      return result;\n    }\n  }, {\n    key: \"curveTo\",\n    value: function curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {\n      var fromX = points[points.length - 2];\n      var fromY = points[points.length - 1];\n      points.length -= 2;\n      var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n      var dt = 0;\n      var dt2 = 0;\n      var dt3 = 0;\n      var t2 = 0;\n      var t3 = 0;\n      points.push(fromX, fromY);\n      for (var i = 1, j = 0; i <= n; ++i) {\n        j = i / n;\n        dt = 1 - j;\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n        t2 = j * j;\n        t3 = t2 * j;\n        points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n      }\n    }\n  }]);\n  return BezierUtils;\n}();\nexport { BezierUtils };","map":{"version":3,"sources":["../../src/utils/BezierUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @returns - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}