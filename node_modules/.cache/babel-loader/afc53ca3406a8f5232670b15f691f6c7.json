{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar display = require('@pixi/display');\nvar text = require('@pixi/text');\nvar CountLimiter = require('./CountLimiter.js');\nfunction findMultipleBaseTextures(item, queue) {\n  var _item$_textures;\n  var result = false;\n  if (item !== null && item !== void 0 && (_item$_textures = item._textures) !== null && _item$_textures !== void 0 && _item$_textures.length) {\n    for (var i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof core.Texture) {\n        var baseTexture = item._textures[i].baseTexture;\n        if (!queue.includes(baseTexture)) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof core.BaseTexture) {\n    var texture = item.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof core.Texture) {\n    var texture = item._texture.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction drawText(_helper, item) {\n  if (item instanceof text.Text) {\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof text.TextStyle) {\n    var font = item.toFontString();\n    text.TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\nfunction findText(item, queue) {\n  if (item instanceof text.Text) {\n    if (!queue.includes(item.style)) {\n      queue.push(item.style);\n    }\n    if (!queue.includes(item)) {\n      queue.push(item);\n    }\n    var texture = item._texture.baseTexture;\n    if (!queue.includes(texture)) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\nfunction findTextStyle(item, queue) {\n  if (item instanceof text.TextStyle) {\n    if (!queue.includes(item)) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\nvar BasePrepare = /*#__PURE__*/function () {\n  function BasePrepare(renderer) {\n    var _this = this;\n    _classCallCheck(this, BasePrepare);\n    this.limiter = new CountLimiter.CountLimiter(core.settings.UPLOADS_PER_FRAME);\n    this.renderer = renderer;\n    this.uploadHookHelper = null;\n    this.queue = [];\n    this.addHooks = [];\n    this.uploadHooks = [];\n    this.completes = [];\n    this.ticking = false;\n    this.delayedTick = function () {\n      if (!_this.queue) {\n        return;\n      }\n      _this.prepareItems();\n    };\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  _createClass(BasePrepare, [{\n    key: \"upload\",\n    value: function upload(item) {\n      var _this2 = this;\n      return new Promise(function (resolve) {\n        if (item) {\n          _this2.add(item);\n        }\n        if (_this2.queue.length) {\n          _this2.completes.push(resolve);\n          if (!_this2.ticking) {\n            _this2.ticking = true;\n            core.Ticker.system.addOnce(_this2.tick, _this2, core.UPDATE_PRIORITY.UTILITY);\n          }\n        } else {\n          resolve();\n        }\n      });\n    }\n  }, {\n    key: \"tick\",\n    value: function tick() {\n      setTimeout(this.delayedTick, 0);\n    }\n  }, {\n    key: \"prepareItems\",\n    value: function prepareItems() {\n      this.limiter.beginFrame();\n      while (this.queue.length && this.limiter.allowedToUpload()) {\n        var item = this.queue[0];\n        var uploaded = false;\n        if (item && !item._destroyed) {\n          for (var i = 0, len = this.uploadHooks.length; i < len; i++) {\n            if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n              this.queue.shift();\n              uploaded = true;\n              break;\n            }\n          }\n        }\n        if (!uploaded) {\n          this.queue.shift();\n        }\n      }\n      if (!this.queue.length) {\n        this.ticking = false;\n        var completes = this.completes.slice(0);\n        this.completes.length = 0;\n        for (var _i = 0, _len = completes.length; _i < _len; _i++) {\n          completes[_i]();\n        }\n      } else {\n        core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n      }\n    }\n  }, {\n    key: \"registerFindHook\",\n    value: function registerFindHook(addHook) {\n      if (addHook) {\n        this.addHooks.push(addHook);\n      }\n      return this;\n    }\n  }, {\n    key: \"registerUploadHook\",\n    value: function registerUploadHook(uploadHook) {\n      if (uploadHook) {\n        this.uploadHooks.push(uploadHook);\n      }\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      for (var i = 0, len = this.addHooks.length; i < len; i++) {\n        if (this.addHooks[i](item, this.queue)) {\n          break;\n        }\n      }\n      if (item instanceof display.Container) {\n        for (var _i2 = item.children.length - 1; _i2 >= 0; _i2--) {\n          this.add(item.children[_i2]);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.ticking) {\n        core.Ticker.system.remove(this.tick, this);\n      }\n      this.ticking = false;\n      this.addHooks = null;\n      this.uploadHooks = null;\n      this.renderer = null;\n      this.completes = null;\n      this.queue = null;\n      this.limiter = null;\n      this.uploadHookHelper = null;\n    }\n  }]);\n  return BasePrepare;\n}();\nexports.BasePrepare = BasePrepare;","map":{"version":3,"sources":["../src/BasePrepare.ts"],"names":["Texture","BaseTexture","Text","TextStyle","CountLimiter","UPDATE_PRIORITY","Container"],"mappings":"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","sourcesContent":["import { Ticker, UPDATE_PRIORITY, settings, Texture, BaseTexture } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\nimport { Container } from '@pixi/display';\nimport { Text, TextStyle, TextMetrics } from '@pixi/text';\nimport { CountLimiter } from './CountLimiter';\nimport type { IRenderer } from '@pixi/core';\n\ninterface IArrowFunction\n{\n    (): void;\n}\ninterface IUploadHook\n{\n    (helper: IRenderer | BasePrepare, item: IDisplayObjectExtended): boolean;\n}\n\ninterface IFindHook\n{\n    (item: any, queue: Array<any>): boolean;\n}\n\nexport interface IDisplayObjectExtended extends DisplayObject\n{\n    _textures?: Array<Texture>;\n    _texture?: Texture;\n    style?: TextStyle | Partial<TextStyle>;\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item: IDisplayObjectExtended, queue: Array<any>): boolean\n{\n    let result = false;\n\n    // Objects with multiple textures\n    if (item?._textures?.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (!queue.includes(baseTexture))\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Texture.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item: Texture, queue: Array<any>): boolean\n{\n    if (item.baseTexture instanceof BaseTexture)\n    {\n        const texture = item.baseTexture;\n\n        if (!queue.includes(texture))\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.Texture object was found.\n */\nfunction findTexture(item: IDisplayObjectExtended, queue: Array<any>): boolean\n{\n    if (item._texture && item._texture instanceof Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (!queue.includes(texture))\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n * @private\n * @param _helper - Not used by this upload handler\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction drawText(_helper: IRenderer | BasePrepare, item: IDisplayObjectExtended): boolean\n{\n    if (item instanceof Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n * @private\n * @param _helper - Not used by this upload handler\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction calculateTextStyle(_helper: IRenderer | BasePrepare, item: IDisplayObjectExtended): boolean\n{\n    if (item instanceof TextStyle)\n    {\n        const font = item.toFontString();\n\n        TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns if a PIXI.Text object was found.\n */\nfunction findText(item: IDisplayObjectExtended, queue: Array<any>): boolean\n{\n    if (item instanceof Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (!queue.includes(item.style))\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (!queue.includes(item))\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (!queue.includes(texture))\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item: TextStyle, queue: Array<any>): boolean\n{\n    if (item instanceof TextStyle)\n    {\n        if (!queue.includes(item))\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *     // Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n * });\n * @abstract\n * @memberof PIXI\n */\nexport class BasePrepare\n{\n    /**\n     * The limiter to be used to control how quickly items are prepared.\n     * @type {PIXI.CountLimiter|PIXI.TimeLimiter}\n     */\n    private limiter: CountLimiter;\n\n    /** Reference to the renderer. */\n    protected renderer: IRenderer;\n\n    /**\n     * The only real difference between CanvasPrepare and Prepare is what they pass\n     * to upload hooks. That different parameter is stored here.\n     */\n    protected uploadHookHelper: any;\n\n    /** Collection of items to uploads at once. */\n    protected queue: Array<any>;\n\n    /**\n     * Collection of additional hooks for finding assets.\n     * @type {Array<Function>}\n     */\n    public addHooks: Array<any>;\n\n    /**\n     * Collection of additional hooks for processing assets.\n     * @type {Array<Function>}\n     */\n    public uploadHooks: Array<any>;\n\n    /**\n     * Callback to call after completed.\n     * @type {Array<Function>}\n     */\n    public completes: Array<any>;\n\n    /**\n     * If prepare is ticking (running).\n     * @type {boolean}\n     */\n    public ticking: boolean;\n\n    /**\n     * 'bound' call for prepareItems().\n     * @type {Function}\n     */\n    private delayedTick: IArrowFunction;\n\n    /**\n     * @param {PIXI.IRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: IRenderer)\n    {\n        this.limiter = new CountLimiter(settings.UPLOADS_PER_FRAME);\n        this.renderer = renderer;\n        this.uploadHookHelper = null;\n        this.queue = [];\n        this.addHooks = [];\n        this.uploadHooks = [];\n        this.completes = [];\n        this.ticking = false;\n        this.delayedTick = (): void =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     * @method PIXI.BasePrepare#upload\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} [item] -\n     *        Container or display object to search for items to upload or the items to upload themselves,\n     *        or optionally ommitted, if items have been added using {@link PIXI.BasePrepare#add `prepare.add`}.\n     */\n    upload(item?: IDisplayObjectExtended | Container | BaseTexture | Texture): Promise<void>\n    {\n        return new Promise((resolve) =>\n        {\n            // If a display object, search for items\n            // that we could upload\n            if (item)\n            {\n                this.add(item as IDisplayObjectExtended | Container | BaseTexture | Texture);\n            }\n\n            // Get the items for upload from the display\n            if (this.queue.length)\n            {\n                this.completes.push(resolve);\n\n                if (!this.ticking)\n                {\n                    this.ticking = true;\n                    Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n                }\n            }\n            else\n            {\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * Handle tick update\n     * @private\n     */\n    tick(): void\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     * @private\n     */\n    prepareItems(): void\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            Ticker.system.addOnce(this.tick, this, UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @returns Instance of plugin for chaining.\n     */\n    registerFindHook(addHook: IFindHook): this\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @returns Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook: IUploadHook): this\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @returns Instance of plugin for chaining.\n     */\n    add(item: IDisplayObjectExtended | Container | BaseTexture | Texture): this\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get children recursively\n        if (item instanceof Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /** Destroys the plugin, don't use after this. */\n    destroy(): void\n    {\n        if (this.ticking)\n        {\n            Ticker.system.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}