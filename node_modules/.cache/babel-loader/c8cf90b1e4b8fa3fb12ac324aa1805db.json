{"ast":null,"code":"import _toConsumableArray from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { extensions, ExtensionType } from '@pixi/core';\nimport { BackgroundLoader } from './BackgroundLoader.mjs';\nimport { Cache } from './cache/Cache.mjs';\nimport { Loader } from './loader/Loader.mjs';\nimport { Resolver } from './resolver/Resolver.mjs';\nimport { convertToList } from './utils/convertToList.mjs';\nimport { isSingleItem } from './utils/isSingleItem.mjs';\nvar AssetsClass = /*#__PURE__*/function () {\n  function AssetsClass() {\n    _classCallCheck(this, AssetsClass);\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  _createClass(AssetsClass, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _options$texturePrefe, _options$texturePrefe2, _options$texturePrefe3;\n        var options,\n          manifest,\n          resolutionPref,\n          resolution,\n          formats,\n          _options$texturePrefe4,\n          formatPref,\n          _iterator,\n          _step,\n          detection,\n          _iterator2,\n          _step2,\n          _detection,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                if (!this._initialized) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 3:\n                this._initialized = true;\n                if (options.basePath) {\n                  this.resolver.basePath = options.basePath;\n                }\n                if (!options.manifest) {\n                  _context.next = 12;\n                  break;\n                }\n                manifest = options.manifest;\n                if (!(typeof manifest === \"string\")) {\n                  _context.next = 11;\n                  break;\n                }\n                _context.next = 10;\n                return this.load(manifest);\n              case 10:\n                manifest = _context.sent;\n              case 11:\n                this.resolver.addManifest(manifest);\n              case 12:\n                resolutionPref = (_options$texturePrefe = (_options$texturePrefe2 = options.texturePreference) === null || _options$texturePrefe2 === void 0 ? void 0 : _options$texturePrefe2.resolution) !== null && _options$texturePrefe !== void 0 ? _options$texturePrefe : 1;\n                resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n                formats = [];\n                if (!((_options$texturePrefe3 = options.texturePreference) !== null && _options$texturePrefe3 !== void 0 && _options$texturePrefe3.format)) {\n                  _context.next = 41;\n                  break;\n                }\n                formatPref = (_options$texturePrefe4 = options.texturePreference) === null || _options$texturePrefe4 === void 0 ? void 0 : _options$texturePrefe4.format;\n                formats = typeof formatPref === \"string\" ? [formatPref] : formatPref;\n                _iterator = _createForOfIteratorHelper(this._detections);\n                _context.prev = 19;\n                _iterator.s();\n              case 21:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 31;\n                  break;\n                }\n                detection = _step.value;\n                _context.next = 25;\n                return detection.test();\n              case 25:\n                if (_context.sent) {\n                  _context.next = 29;\n                  break;\n                }\n                _context.next = 28;\n                return detection.remove(formats);\n              case 28:\n                formats = _context.sent;\n              case 29:\n                _context.next = 21;\n                break;\n              case 31:\n                _context.next = 36;\n                break;\n              case 33:\n                _context.prev = 33;\n                _context.t0 = _context[\"catch\"](19);\n                _iterator.e(_context.t0);\n              case 36:\n                _context.prev = 36;\n                _iterator.f();\n                return _context.finish(36);\n              case 39:\n                _context.next = 62;\n                break;\n              case 41:\n                _iterator2 = _createForOfIteratorHelper(this._detections);\n                _context.prev = 42;\n                _iterator2.s();\n              case 44:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 54;\n                  break;\n                }\n                _detection = _step2.value;\n                _context.next = 48;\n                return _detection.test();\n              case 48:\n                if (!_context.sent) {\n                  _context.next = 52;\n                  break;\n                }\n                _context.next = 51;\n                return _detection.add(formats);\n              case 51:\n                formats = _context.sent;\n              case 52:\n                _context.next = 44;\n                break;\n              case 54:\n                _context.next = 59;\n                break;\n              case 56:\n                _context.prev = 56;\n                _context.t1 = _context[\"catch\"](42);\n                _iterator2.e(_context.t1);\n              case 59:\n                _context.prev = 59;\n                _iterator2.f();\n                return _context.finish(59);\n              case 62:\n                this.resolver.prefer({\n                  params: {\n                    format: formats,\n                    resolution: resolution\n                  }\n                });\n              case 63:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[19, 33, 36, 39], [42, 56, 59, 62]]);\n      }));\n      function init() {\n        return _init.apply(this, arguments);\n      }\n      return init;\n    }()\n  }, {\n    key: \"add\",\n    value: function add(keysIn, assetsIn, data) {\n      this.resolver.add(keysIn, assetsIn, data);\n    }\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(urls, onProgress) {\n        var _this = this;\n        var singleAsset, urlArray, resolveResults, out;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._initialized) {\n                  _context2.next = 3;\n                  break;\n                }\n                _context2.next = 3;\n                return this.init();\n              case 3:\n                singleAsset = isSingleItem(urls);\n                urlArray = convertToList(urls).map(function (url) {\n                  if (typeof url !== \"string\") {\n                    _this.resolver.add(url.src, url);\n                    return url.src;\n                  }\n                  return url;\n                });\n                resolveResults = this.resolver.resolve(urlArray);\n                _context2.next = 8;\n                return this._mapLoadToResolve(resolveResults, onProgress);\n              case 8:\n                out = _context2.sent;\n                return _context2.abrupt(\"return\", singleAsset ? out[urlArray[0]] : out);\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function load(_x, _x2) {\n        return _load.apply(this, arguments);\n      }\n      return load;\n    }()\n  }, {\n    key: \"addBundle\",\n    value: function addBundle(bundleId, assets) {\n      this.resolver.addBundle(bundleId, assets);\n    }\n  }, {\n    key: \"loadBundle\",\n    value: function () {\n      var _loadBundle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(bundleIds, onProgress) {\n        var _this2 = this;\n        var singleAsset, resolveResults, out, keys, count, total, _onProgress, promises;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this._initialized) {\n                  _context3.next = 3;\n                  break;\n                }\n                _context3.next = 3;\n                return this.init();\n              case 3:\n                singleAsset = false;\n                if (typeof bundleIds === \"string\") {\n                  singleAsset = true;\n                  bundleIds = [bundleIds];\n                }\n                resolveResults = this.resolver.resolveBundle(bundleIds);\n                out = {};\n                keys = Object.keys(resolveResults);\n                count = 0;\n                total = 0;\n                _onProgress = function _onProgress() {\n                  onProgress === null || onProgress === void 0 ? void 0 : onProgress(++count / total);\n                };\n                promises = keys.map(function (bundleId) {\n                  var resolveResult = resolveResults[bundleId];\n                  total += Object.keys(resolveResult).length;\n                  return _this2._mapLoadToResolve(resolveResult, _onProgress).then(function (resolveResult2) {\n                    out[bundleId] = resolveResult2;\n                  });\n                });\n                _context3.next = 14;\n                return Promise.all(promises);\n              case 14:\n                return _context3.abrupt(\"return\", singleAsset ? out[bundleIds[0]] : out);\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function loadBundle(_x3, _x4) {\n        return _loadBundle.apply(this, arguments);\n      }\n      return loadBundle;\n    }()\n  }, {\n    key: \"backgroundLoad\",\n    value: function () {\n      var _backgroundLoad = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(urls) {\n        var resolveResults;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this._initialized) {\n                  _context4.next = 3;\n                  break;\n                }\n                _context4.next = 3;\n                return this.init();\n              case 3:\n                if (typeof urls === \"string\") {\n                  urls = [urls];\n                }\n                resolveResults = this.resolver.resolve(urls);\n                this._backgroundLoader.add(Object.values(resolveResults));\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function backgroundLoad(_x5) {\n        return _backgroundLoad.apply(this, arguments);\n      }\n      return backgroundLoad;\n    }()\n  }, {\n    key: \"backgroundLoadBundle\",\n    value: function () {\n      var _backgroundLoadBundle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(bundleIds) {\n        var _this3 = this;\n        var resolveResults;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this._initialized) {\n                  _context5.next = 3;\n                  break;\n                }\n                _context5.next = 3;\n                return this.init();\n              case 3:\n                if (typeof bundleIds === \"string\") {\n                  bundleIds = [bundleIds];\n                }\n                resolveResults = this.resolver.resolveBundle(bundleIds);\n                Object.values(resolveResults).forEach(function (resolveResult) {\n                  _this3._backgroundLoader.add(Object.values(resolveResult));\n                });\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function backgroundLoadBundle(_x6) {\n        return _backgroundLoadBundle.apply(this, arguments);\n      }\n      return backgroundLoadBundle;\n    }()\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.resolver.reset();\n      this.loader.reset();\n      this.cache.reset();\n      this._initialized = false;\n    }\n  }, {\n    key: \"get\",\n    value: function get(keys) {\n      if (typeof keys === \"string\") {\n        return Cache.get(keys);\n      }\n      var assets = {};\n      for (var i = 0; i < keys.length; i++) {\n        assets[i] = Cache.get(keys[i]);\n      }\n      return assets;\n    }\n  }, {\n    key: \"_mapLoadToResolve\",\n    value: function () {\n      var _mapLoadToResolve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolveResults, onProgress) {\n        var resolveArray, resolveKeys, loadedAssets, out;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                resolveArray = Object.values(resolveResults);\n                resolveKeys = Object.keys(resolveResults);\n                this._backgroundLoader.active = false;\n                _context6.next = 5;\n                return this.loader.load(resolveArray, onProgress);\n              case 5:\n                loadedAssets = _context6.sent;\n                this._backgroundLoader.active = true;\n                out = {};\n                resolveArray.forEach(function (resolveResult, i) {\n                  var asset = loadedAssets[resolveResult.src];\n                  var keys = [resolveResult.src];\n                  if (resolveResult.alias) {\n                    keys.push.apply(keys, _toConsumableArray(resolveResult.alias));\n                  }\n                  out[resolveKeys[i]] = asset;\n                  Cache.set(keys, asset);\n                });\n                return _context6.abrupt(\"return\", out);\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function _mapLoadToResolve(_x7, _x8) {\n        return _mapLoadToResolve2.apply(this, arguments);\n      }\n      return _mapLoadToResolve;\n    }()\n  }, {\n    key: \"unload\",\n    value: function () {\n      var _unload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(urls) {\n        var urlArray, resolveResults;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this._initialized) {\n                  _context7.next = 3;\n                  break;\n                }\n                _context7.next = 3;\n                return this.init();\n              case 3:\n                urlArray = convertToList(urls).map(function (url) {\n                  return typeof url !== \"string\" ? url.src : url;\n                });\n                resolveResults = this.resolver.resolve(urlArray);\n                _context7.next = 7;\n                return this._unloadFromResolved(resolveResults);\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function unload(_x9) {\n        return _unload.apply(this, arguments);\n      }\n      return unload;\n    }()\n  }, {\n    key: \"unloadBundle\",\n    value: function () {\n      var _unloadBundle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(bundleIds) {\n        var _this4 = this;\n        var resolveResults, promises;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (this._initialized) {\n                  _context8.next = 3;\n                  break;\n                }\n                _context8.next = 3;\n                return this.init();\n              case 3:\n                bundleIds = convertToList(bundleIds);\n                resolveResults = this.resolver.resolveBundle(bundleIds);\n                promises = Object.keys(resolveResults).map(function (bundleId) {\n                  return _this4._unloadFromResolved(resolveResults[bundleId]);\n                });\n                _context8.next = 8;\n                return Promise.all(promises);\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function unloadBundle(_x10) {\n        return _unloadBundle.apply(this, arguments);\n      }\n      return unloadBundle;\n    }()\n  }, {\n    key: \"_unloadFromResolved\",\n    value: function () {\n      var _unloadFromResolved2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(resolveResult) {\n        var resolveArray;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                resolveArray = Object.values(resolveResult);\n                resolveArray.forEach(function (resolveResult2) {\n                  Cache.remove(resolveResult2.src);\n                });\n                _context9.next = 4;\n                return this.loader.unload(resolveArray);\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n      function _unloadFromResolved(_x11) {\n        return _unloadFromResolved2.apply(this, arguments);\n      }\n      return _unloadFromResolved;\n    }()\n  }, {\n    key: \"detections\",\n    get: function get() {\n      return this._detections;\n    }\n  }]);\n  return AssetsClass;\n}();\nvar Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nexport { Assets, AssetsClass };","map":{"version":3,"sources":["../src/Assets.ts"],"names":[],"mappings":"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","sourcesContent":["import { extensions, ExtensionType } from '@pixi/core';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport type { FormatDetectionParser } from './detections';\nimport type {\n    LoadAsset,\n    LoaderParser\n} from './loader';\nimport { Loader } from './loader/Loader';\nimport type { PreferOrder, ResolveAsset, ResolverBundle, ResolverManifest, ResolveURLParser } from './resolver';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Initialization options object for Asset Class.\n * @memberof PIXI\n */\nexport interface AssetInitOptions\n{\n    // basic...\n    /** a base path for any assets loaded */\n    basePath?: string;\n    /**\n     * a manifest to tell the asset loader upfront what all your assets are\n     * this can be the manifest object itself, or a URL to the manifest.\n     */\n    manifest?: string | ResolverManifest;\n    /**\n     * optional preferences for which textures preferences you have when resolving assets\n     * for example you might set the resolution to 0.5 if the user is on a rubbish old phone\n     * or you might set the resolution to 2 if the user is on a retina display\n     */\n    texturePreference?: {\n        /** the resolution order you prefer, can be an array (priority order - first is prefered) or a single resolutions  */\n        resolution?: number | number[];\n        /** the formats you prefer, by default this will be:  ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: string | string[];\n    };\n\n    // advanced users can add custom parsers and and preferences for how things are resolved\n    /** loader options to configure the loader with, currently only parsers! */\n    loader?: {\n        /** custom parsers can be added here, for example something that could load a sound or a 3D model */\n        parsers?: LoaderParser[];\n        // more...\n    };\n    /** resolver specific options */\n    resolver?: {\n        /**\n         * a list of urlParsers, these can read the URL and pick put the various options.\n         * for example there is a texture URL parser that picks our resolution and file format.\n         * You can add custom ways to read URLs and extract information here.\n         */\n        urlParsers?: ResolveURLParser[];\n        /**\n         * a list of preferOrders that let the resolver know which asset to pick.\n         * already built-in we have a texture preferOrders that let the resolve know which asset to prefer\n         * if it has multiple assets to pick from (resolution/formats etc)\n         */\n        preferOrders?: PreferOrder[];\n    };\n}\n\n/**\n * A one stop shop for all Pixi resource management!\n * Super modern and easy to use, with enough flexibility to customize and do what you need!\n * @memberof PIXI\n * @namespace Assets\n *\n * Only one Asset Class exists accessed via the Global Asset object.\n *\n * It has four main responsibilities:\n * 1. Allows users to map URLs to keys and resolve them according to the user's browser capabilities\n * 2. Loads the resources and transforms them into assets that developers understand.\n * 3. Caches the assets and provides a way to access them.\n * 4. Allow developers to unload assets and clear the cache.\n *\n * It also has a few advanced features:\n * 1. Allows developers to provide a manifest upfront of all assets and help manage them via 'bundles'.\n * 2. Allows users to background load assets. Shortening (or eliminating) load times and improving UX. With this feature,\n * in-game loading bars can be a thing of the past!\n *\n * ### Assets Loading\n *\n * Do not be afraid to load things multiple times - under the hood, it will NEVER load anything more than once.\n *\n * For example:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * promise1 = Assets.load('bunny.png')\n * promise2 = Assets.load('bunny.png')\n *\n * // promise1 === promise2\n * ```\n *\n * Here both promises will be the same. Once resolved... Forever resolved! It makes for really easy resource management!\n *\n * Out of the box it supports the following files:\n * - textures (avif, webp, png, jpg, gif)\n * - sprite sheets (json)\n * - bitmap fonts (xml, fnt, txt)\n * - web fonts (ttf, woff, woff2)\n * - json files (json)\n * - text files (txt)\n *\n * More types can be added fairly easily by creating additional loader parsers.\n *\n * ### Textures\n * - Textures are loaded as ImageBitmap on a worker thread where possible.\n * Leading to much less janky load + parse times.\n * - By default, we will prefer to load AVIF and WebP image files if you specify them.\n * But if the browser doesn't support AVIF or WebP we will fall back to png and jpg.\n * - Textures can also be accessed via Texture.from(...) and now use this asset manager under the hood!\n * - Don't worry if you set preferences for textures that don't exist (for example you prefer 2x resolutions images\n *  but only 1x is available for that texture, the Asset manager will pick that up as a fallback automatically)\n *\n * #### Sprite sheets\n * - It's hard to know what resolution a sprite sheet is without loading it first, to address this\n * there is a naming convention we have added that will let Pixi understand the image format and resolution\n * of the spritesheet via its file name:\n *\n * `my-spritesheet{resolution}.{imageFormat}.json`\n *\n * For example:\n *\n * `my-spritesheet@2x.webp.json` // 2x resolution, WebP sprite sheet\n * `my-spritesheet@0.5x.png.json` // 0.5x resolution, png sprite sheet\n *\n * This is optional! You can just load a sprite sheet as normal.\n * This is only useful if you have a bunch of different res / formatted spritesheets.\n *\n * ### Fonts\n * Web fonts will be loaded with all weights.\n * It is possible to load only specific weights by doing the following:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Load specific weights..\n * await Assets.load({\n *     data: {\n *         weights: ['normal'], // Only loads the weight\n *     },\n *     src: `outfit.woff2`,\n * });\n *\n * // Load everything...\n * await Assets.load(`outfit.woff2`);\n * ```\n *\n * ### Background Loading\n * Background loading will load stuff for you passively behind the scenes. To minimize jank,\n * it will only load one asset at a time. As soon as a developer calls `Assets.load(...)` the\n * background loader is paused and requested assets are loaded as a priority.\n * Don't worry if something is in there that's already loaded, it will just get skipped!\n *\n * You still need to call `Assets.load(...)` to get an asset that has been loaded in the background.\n * It's just that this promise will resolve instantly if the asset\n * has already been loaded.\n *\n * ### Manifest and Bundles\n * - Manifest is a JSON file that contains a list of all assets and their properties.\n * - Bundles are a way to group assets together.\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * // Manifest Example\n * const manifest = {\n *     bundles: [\n *         {\n *             name: 'load-screen',\n *             assets: [\n *                 {\n *                     name: 'background',\n *                     srcs: 'sunset.png',\n *                 },\n *                 {\n *                     name: 'bar',\n *                     srcs: 'load-bar.{png,webp}',\n *                 },\n *             ],\n *         },\n *         {\n *             name: 'game-screen',\n *             assets: [\n *                 {\n *                     name: 'character',\n *                     srcs: 'robot.png',\n *                 },\n *                 {\n *                     name: 'enemy',\n *                     srcs: 'bad-guy.png',\n *                 },\n *             ],\n *         },\n *     ]\n * };\n *\n * await Asset.init({ manifest });\n *\n * // Load a bundle...\n * loadScreenAssets = await Assets.loadBundle('load-screen');\n * // Load another bundle...\n * gameScreenAssets = await Assets.loadBundle('game-screen');\n * ```\n * @example\n * import { Assets } from 'pixi.js';\n *\n * const bunny = await Assets.load('bunny.png');\n */\nexport class AssetsClass\n{\n    /** the resolver to map various urls */\n    public resolver: Resolver;\n    /**\n     * The loader, loads stuff!\n     * @type {PIXI.AssetLoader}\n     */\n    public loader: Loader;\n    /**\n     * The global cache of all assets within PixiJS\n     * @type {PIXI.Cache}\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Best practice is to call this function before any loading commences\n     * Initiating is the best time to add any customization to the way things are loaded.\n     *\n     * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n     * @param options - options to initialize the Asset manager with\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            console.warn('[Assets]AssetManager already initialized, did you load before calling this Asset.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<ResolverManifest>(manifest) as ResolverManifest;\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref =  options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        let formats: string[] = [];\n\n        if (options.texturePreference?.format)\n        {\n            const formatPref = options.texturePreference?.format;\n\n            formats = (typeof formatPref === 'string') ? [formatPref] : formatPref;\n\n            // we should remove any formats that are not supported by the browser\n            for (const detection of this._detections)\n            {\n                if (!await detection.test())\n                {\n                    formats = await detection.remove(formats);\n                }\n            }\n        }\n        else\n        {\n            // we should add any formats that are supported by the browser\n            for (const detection of this._detections)\n            {\n                if (await detection.test())\n                {\n                    formats = await detection.add(formats);\n                }\n            }\n        }\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n    }\n\n    /**\n     * Allows you to specify how to resolve any assets load requests.\n     * There are a few ways to add things here as shown below:\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Simple\n     * Assets.add('bunnyBooBoo', 'bunny.png');\n     * const bunny = await Assets.load('bunnyBooBoo');\n     *\n     * // Multiple keys:\n     * Assets.add(['burger', 'chicken'], 'bunny.png');\n     *\n     * const bunny = await Assets.load('burger');\n     * const bunny2 = await Assets.load('chicken');\n     *\n     * // passing options to to the object\n     * Assets.add(\n     *     'bunnyBooBooSmooth',\n     *     'bunny{png,webp}',\n     *     { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n     * );\n     *\n     * // Multiple assets\n     *\n     * // The following all do the same thing:\n     *\n     * Assets.add('bunnyBooBoo', 'bunny{png,webp}');\n     *\n     * Assets.add('bunnyBooBoo', [\n     *     'bunny.png',\n     *     'bunny.webp',\n     * ]);\n     *\n     * Assets.add('bunnyBooBoo', [\n     *     {\n     *         format: 'png',\n     *         src: 'bunny.png',\n     *     },\n     *     {\n     *         format: 'webp',\n     *         src: 'bunny.webp',\n     *     },\n     * ]);\n     *\n     * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n     * @param keysIn - the key or keys that you will reference when loading this asset\n     * @param assetsIn - the asset or assets that will be chosen from when loading via the specified key\n     * @param data - asset-specific data that will be passed to the loaders\n     * - Useful if you want to initiate loaded objects with specific data\n     */\n    public add(keysIn: string | string[], assetsIn: string | (ResolveAsset | string)[], data?: unknown): void\n    {\n        this.resolver.add(keysIn, assetsIn, data);\n    }\n\n    /**\n     * Loads your assets! You pass in a key or URL and it will return a promise that\n     * resolves to the loaded asset. If multiple assets a requested, it will return a hash of assets.\n     *\n     * Don't worry about loading things multiple times, behind the scenes assets are only ever loaded\n     * once and the same promise reused behind the scenes so you can safely call this function multiple\n     * times with the same key and it will always return the same asset.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * Assets.add('thumper', 'bunny.png');\n     * Assets.add('chicko', 'chicken.png');\n     *\n     * // Load multiple assets:\n     * const textures = await Assets.load(['thumper', 'chicko']); // => {thumper: Texture, chicko: Texture}\n     * @param urls - the urls to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage\n     * (0.0 - 1.0) of the assets loaded.\n     * @returns - the assets that were loaded, either a single asset or a hash of assets\n     */\n    public async load<T=any>(\n        urls: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: ProgressCallback,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray = convertToList<ResolveAsset>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    this.resolver.add(url.src as string, url);\n\n                    return url.src;\n                }\n\n                return url;\n            });\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can load them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const assets = await Assets.loadBundle('animals');\n     * @param bundleId - the id of the bundle to add\n     * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: ResolverBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Bundles are a way to load multiple assets at once.\n     * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n     * you can also add bundles via `addBundle`\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'background',\n     *                     srcs: 'sunset.png',\n     *                 },\n     *                 {\n     *                     name: 'bar',\n     *                     srcs: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     name: 'character',\n     *                     srcs: 'robot.png',\n     *                 },\n     *                 {\n     *                     name: 'enemy',\n     *                     srcs: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * await Asset.init({ manifest });\n     *\n     * // Load a bundle...\n     * loadScreenAssets = await Assets.loadBundle('load-screen');\n     * // Load another bundle...\n     * gameScreenAssets = await Assets.loadBundle('game-screen');\n     * @param bundleIds - the bundle id or ids to load\n     * @param onProgress - optional function that is called when progress on asset loading is made.\n     * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n     * of the assets loaded.\n     * @returns all the bundles assets or a hash of assets for each bundle specified\n     */\n    public async loadBundle(bundleIds: string | string[], onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let count = 0;\n        let total = 0;\n        const _onProgress = () =>\n        {\n            onProgress?.(++count / total);\n        };\n        const promises = keys.map((bundleId) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n\n            total += Object.keys(resolveResult).length;\n\n            return this._mapLoadToResolve(resolveResult, _onProgress)\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n     * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n     *\n     * An example of this might be that you would background load game assets after your inital load.\n     * then when you got to actually load your game screen assets when a player goes to the game - the loading\n     * would already have stared or may even be complete, saving you having to show an interim load bar.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.backgroundLoad('bunny.png');\n     *\n     * // later on in your app...\n     * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n     * @param urls - the url / urls you want to background load\n     */\n    public async backgroundLoad(urls: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n     * this can only be used if the loader has been initiated with a manifest\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *                 name: 'load-screen',\n     *                 assets: [...],\n     *             },\n     *             ...\n     *         ],\n     *     },\n     * });\n     *\n     * Assets.backgroundLoadBundle('load-screen');\n     *\n     * // Later on in your app...\n     * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n     * @param bundleIds - the bundleId / bundleIds you want to background load\n     */\n    public async backgroundLoadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. If the asset has not yet been loaded,\n     * it will return undefined. So it's on you! When in doubt just use `Assets.load` instead.\n     * (Remember, the loader will never load things more than once!)\n     * @param keys - The key or keys for the assets that you want to access\n     * @returns - The assets or hash of assets requested\n     */\n    public get<T=any>(keys: string | string[]): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param onProgress - the progress callback\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolveAsset | Record<string, ResolveAsset>,\n        onProgress?: ProgressCallback\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = Object.values(resolveResults);\n        const resolveKeys = Object.keys(resolveResults);\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load(resolveArray, onProgress);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult, i) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            out[resolveKeys[i]] = asset;\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n     * this will make sure to destroy any assets and release them from memory.\n     * Once unloaded, you will need to load the asset again.\n     *\n     * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n     *\n     * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n     * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * // Load a URL:\n     * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n     *\n     * await Assets.unload('http://some.url.com/image.png')\n     *\n     * // myImageTexture will be destroyed now.\n     *\n     * // Unload multiple assets:\n     * const textures = await Assets.unload(['thumper', 'chicko']);\n     * @param urls - the urls to unload\n     */\n    public async unload(\n        urls: string | string[] | LoadAsset | LoadAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | LoadAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Bundles are a way to manage multiple assets at once.\n     * this will unload all files in a bundle.\n     *\n     * once a bundle has been unloaded, you need to load it again to have access to the assets.\n     * @example\n     * import { Assets } from 'pixi.js';\n     *\n     * Assets.addBundle({\n     *     'thumper': 'http://some.url.com/thumper.png',\n     * })\n     *\n     * const assets = await Assets.loadBundle('thumper');\n     *\n     * // Now to unload...\n     *\n     * await Assets.unloadBundle('thumper');\n     *\n     * // All assets in the assets object will now have been destroyed and purged from the cache\n     * @param bundleIds - the bundle id or ids to unload\n     */\n    public async unloadBundle(bundleIds: string | string[]): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolveAsset | Record<string, ResolveAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /** All the detection parsers currently added to the Assets class. */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n}\n\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\n"]},"metadata":{},"sourceType":"module"}