{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NativeSerializer = void 0;\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar typesystem_1 = require(\"./typesystem\");\nvar argumentErrorContext_1 = require(\"./argumentErrorContext\");\nvar typesystem_2 = require(\"./typesystem\");\nvar address_1 = require(\"../address\");\nvar errors_1 = require(\"../errors\");\nvar utils_codec_1 = require(\"../utils.codec\");\nvar NativeSerializer;\n(function (NativeSerializer) {\n  /**\n   * Interprets a set of native javascript values into a set of typed values, given parameter definitions.\n   */\n  function nativeToTypedValues(args, endpoint) {\n    args = args || [];\n    assertNotTypedValues(args);\n    args = handleVariadicArgsAndRePack(args, endpoint);\n    var parameters = endpoint.input;\n    var values = [];\n    for (var i = 0; i < parameters.length; i++) {\n      var parameter = parameters[i];\n      var errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);\n      var value = convertToTypedValue(args[i], parameter.type, errorContext);\n      values.push(value);\n    }\n    return values;\n  }\n  NativeSerializer.nativeToTypedValues = nativeToTypedValues;\n  function assertNotTypedValues(args) {\n    for (var i = 0; i < args.length; i++) {\n      var arg = args[i];\n      if (arg && arg.belongsToTypesystem) {\n        throw new errors_1.ErrTypeInferenceSystemRequiresRegularJavascriptObjects(i);\n      }\n    }\n  }\n  function handleVariadicArgsAndRePack(args, endpoint) {\n    var parameters = endpoint.input;\n    var _getArgumentsCardinal = getArgumentsCardinality(parameters),\n      min = _getArgumentsCardinal.min,\n      max = _getArgumentsCardinal.max,\n      variadic = _getArgumentsCardinal.variadic;\n    if (!(min <= args.length && args.length <= max)) {\n      throw new errors_1.ErrInvalidArgument(\"Wrong number of arguments for endpoint \".concat(endpoint.name, \": expected between \").concat(min, \" and \").concat(max, \" arguments, have \").concat(args.length));\n    }\n    if (variadic) {\n      var lastArgIndex = parameters.length - 1;\n      var lastArg = args.slice(lastArgIndex);\n      args[lastArgIndex] = lastArg;\n    }\n    return args;\n  }\n  // A function may have one of the following formats:\n  // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }\n  // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }\n  // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }\n  function getArgumentsCardinality(parameters) {\n    var reversed = _toConsumableArray(parameters).reverse(); // keep the original unchanged\n    var min = parameters.length;\n    var max = parameters.length;\n    var variadic = false;\n    if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {\n      max = Infinity;\n      variadic = true;\n    }\n    var _iterator = _createForOfIteratorHelper(reversed),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var parameter = _step.value;\n        if (parameter.type.getCardinality().isSingular()) {\n          break;\n        }\n        min -= 1;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return {\n      min: min,\n      max: max,\n      variadic: variadic\n    };\n  }\n  function convertToTypedValue(native, type, errorContext) {\n    if (type instanceof typesystem_1.OptionType) {\n      return toOptionValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_1.OptionalType) {\n      return toOptionalValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_1.VariadicType) {\n      return toVariadicValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_1.CompositeType) {\n      return toCompositeValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_1.TupleType) {\n      return toTupleValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_2.StructType) {\n      return toStructValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_1.ListType) {\n      return toListValue(native, type, errorContext);\n    }\n    if (type instanceof typesystem_1.PrimitiveType) {\n      return toPrimitive(native, type, errorContext);\n    }\n    errorContext.throwError(\"convertToTypedValue: unhandled type \".concat(type));\n  }\n  function toOptionValue(native, type, errorContext) {\n    if (native == null) {\n      return typesystem_1.OptionValue.newMissing();\n    }\n    var converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n    return typesystem_1.OptionValue.newProvided(converted);\n  }\n  function toOptionalValue(native, type, errorContext) {\n    if (native == null) {\n      return new typesystem_1.OptionalValue(type);\n    }\n    var converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n    return new typesystem_1.OptionalValue(type, converted);\n  }\n  function toVariadicValue(native, type, errorContext) {\n    if (native == null) {\n      native = [];\n    }\n    if (native.map === undefined) {\n      errorContext.convertError(native, \"Variadic\");\n    }\n    var converted = native.map(function (item) {\n      return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n    });\n    return new typesystem_1.VariadicValue(type, converted);\n  }\n  function toListValue(native, type, errorContext) {\n    if (native.map === undefined) {\n      errorContext.convertError(native, \"List\");\n    }\n    var converted = native.map(function (item) {\n      return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n    });\n    return new typesystem_1.List(type, converted);\n  }\n  function toCompositeValue(native, type, errorContext) {\n    var typedValues = [];\n    var typeParameters = type.getTypeParameters();\n    errorContext.guardSameLength(native, typeParameters);\n    for (var i = 0; i < typeParameters.length; i++) {\n      typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));\n    }\n    return new typesystem_1.CompositeValue(type, typedValues);\n  }\n  function toTupleValue(native, type, errorContext) {\n    var typedValues = [];\n    var fields = type.getFieldsDefinitions();\n    errorContext.guardSameLength(native, fields);\n    for (var i = 0; i < fields.length; i++) {\n      typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));\n    }\n    return typesystem_2.Tuple.fromItems(typedValues);\n  }\n  function toStructValue(native, type, errorContext) {\n    var structFieldValues = [];\n    var fields = type.getFieldsDefinitions();\n    for (var i = 0; i < fields.length; i++) {\n      var fieldName = fields[i].name;\n      errorContext.guardHasField(native, fieldName);\n      var fieldNativeValue = native[fieldName];\n      var fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);\n      structFieldValues.push(new typesystem_2.Field(fieldTypedValue, fieldName));\n    }\n    return new typesystem_2.Struct(type, structFieldValues);\n  }\n  function toPrimitive(native, type, errorContext) {\n    if (type instanceof typesystem_1.NumericalType) {\n      var number = new bignumber_js_1.default(native);\n      return convertNumericalType(number, type, errorContext);\n    }\n    if (type instanceof typesystem_1.BytesType) {\n      return convertNativeToBytesValue(native, errorContext);\n    }\n    if (type instanceof typesystem_1.AddressType) {\n      return new typesystem_1.AddressValue(convertNativeToAddress(native, errorContext));\n    }\n    if (type instanceof typesystem_1.BooleanType) {\n      return new typesystem_1.BooleanValue(native);\n    }\n    if (type instanceof typesystem_1.TokenIdentifierType) {\n      return new typesystem_1.TokenIdentifierValue(convertNativeToString(native, errorContext));\n    }\n    errorContext.throwError(\"(function: toPrimitive) unsupported type \".concat(type));\n  }\n  function convertNativeToBytesValue(native, errorContext) {\n    var innerValue = native.valueOf();\n    if (native === undefined) {\n      errorContext.convertError(native, \"BytesValue\");\n    }\n    if (native instanceof Buffer) {\n      return new typesystem_1.BytesValue(native);\n    }\n    if (typeof native === \"string\") {\n      return typesystem_1.BytesValue.fromUTF8(native);\n    }\n    if (innerValue instanceof Buffer) {\n      return new typesystem_1.BytesValue(innerValue);\n    }\n    if (typeof innerValue === \"number\") {\n      return typesystem_1.BytesValue.fromHex(utils_codec_1.numberToPaddedHex(innerValue));\n    }\n    errorContext.convertError(native, \"BytesValue\");\n  }\n  function convertNativeToString(native, errorContext) {\n    if (native === undefined) {\n      errorContext.convertError(native, \"Buffer\");\n    }\n    if (native instanceof Buffer) {\n      return native.toString();\n    }\n    if (typeof native === \"string\") {\n      return native;\n    }\n    errorContext.convertError(native, \"Buffer\");\n  }\n  function convertNativeToAddress(native, errorContext) {\n    if (native.bech32) {\n      return native;\n    }\n    if (native.getAddress) {\n      return native.getAddress();\n    }\n    switch (native.constructor) {\n      case Buffer:\n      case String:\n        return new address_1.Address(native);\n      default:\n        errorContext.convertError(native, \"Address\");\n    }\n  }\n  NativeSerializer.convertNativeToAddress = convertNativeToAddress;\n  function convertNumericalType(number, type, errorContext) {\n    switch (type.constructor) {\n      case typesystem_1.U8Type:\n        return new typesystem_1.U8Value(number);\n      case typesystem_1.I8Type:\n        return new typesystem_1.I8Value(number);\n      case typesystem_1.U16Type:\n        return new typesystem_1.U16Value(number);\n      case typesystem_1.I16Type:\n        return new typesystem_1.I16Value(number);\n      case typesystem_1.U32Type:\n        return new typesystem_1.U32Value(number);\n      case typesystem_1.I32Type:\n        return new typesystem_1.I32Value(number);\n      case typesystem_1.U64Type:\n        return new typesystem_1.U64Value(number);\n      case typesystem_1.I64Type:\n        return new typesystem_1.I64Value(number);\n      case typesystem_1.BigUIntType:\n        return new typesystem_1.BigUIntValue(number);\n      case typesystem_1.BigIntType:\n        return new typesystem_1.BigIntValue(number);\n      default:\n        errorContext.unhandledType(\"convertNumericalType\", type);\n    }\n  }\n})(NativeSerializer = exports.NativeSerializer || (exports.NativeSerializer = {}));","map":{"version":3,"sources":["../../src/smartcontracts/nativeSerializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NativeSerializer = void 0;\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst typesystem_1 = require(\"./typesystem\");\nconst argumentErrorContext_1 = require(\"./argumentErrorContext\");\nconst typesystem_2 = require(\"./typesystem\");\nconst address_1 = require(\"../address\");\nconst errors_1 = require(\"../errors\");\nconst utils_codec_1 = require(\"../utils.codec\");\nvar NativeSerializer;\n(function (NativeSerializer) {\n    /**\n     * Interprets a set of native javascript values into a set of typed values, given parameter definitions.\n     */\n    function nativeToTypedValues(args, endpoint) {\n        args = args || [];\n        assertNotTypedValues(args);\n        args = handleVariadicArgsAndRePack(args, endpoint);\n        let parameters = endpoint.input;\n        let values = [];\n        for (let i = 0; i < parameters.length; i++) {\n            let parameter = parameters[i];\n            let errorContext = new argumentErrorContext_1.ArgumentErrorContext(endpoint.name, i, parameter);\n            let value = convertToTypedValue(args[i], parameter.type, errorContext);\n            values.push(value);\n        }\n        return values;\n    }\n    NativeSerializer.nativeToTypedValues = nativeToTypedValues;\n    function assertNotTypedValues(args) {\n        for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            if (arg && arg.belongsToTypesystem) {\n                throw new errors_1.ErrTypeInferenceSystemRequiresRegularJavascriptObjects(i);\n            }\n        }\n    }\n    function handleVariadicArgsAndRePack(args, endpoint) {\n        let parameters = endpoint.input;\n        let { min, max, variadic } = getArgumentsCardinality(parameters);\n        if (!(min <= args.length && args.length <= max)) {\n            throw new errors_1.ErrInvalidArgument(`Wrong number of arguments for endpoint ${endpoint.name}: expected between ${min} and ${max} arguments, have ${args.length}`);\n        }\n        if (variadic) {\n            let lastArgIndex = parameters.length - 1;\n            let lastArg = args.slice(lastArgIndex);\n            args[lastArgIndex] = lastArg;\n        }\n        return args;\n    }\n    // A function may have one of the following formats:\n    // f(arg1, arg2, optional<arg3>, optional<arg4>) returns { min: 2, max: 4, variadic: false }\n    // f(arg1, variadic<bytes>) returns { min: 1, max: Infinity, variadic: true }\n    // f(arg1, arg2, optional<arg3>, arg4, optional<arg5>, variadic<bytes>) returns { min: 2, max: Infinity, variadic: true }\n    function getArgumentsCardinality(parameters) {\n        let reversed = [...parameters].reverse(); // keep the original unchanged\n        let min = parameters.length;\n        let max = parameters.length;\n        let variadic = false;\n        if (reversed.length > 0 && reversed[0].type.getCardinality().isComposite()) {\n            max = Infinity;\n            variadic = true;\n        }\n        for (let parameter of reversed) {\n            if (parameter.type.getCardinality().isSingular()) {\n                break;\n            }\n            min -= 1;\n        }\n        return { min, max, variadic };\n    }\n    function convertToTypedValue(native, type, errorContext) {\n        if (type instanceof typesystem_1.OptionType) {\n            return toOptionValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.OptionalType) {\n            return toOptionalValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.VariadicType) {\n            return toVariadicValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.CompositeType) {\n            return toCompositeValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.TupleType) {\n            return toTupleValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_2.StructType) {\n            return toStructValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.ListType) {\n            return toListValue(native, type, errorContext);\n        }\n        if (type instanceof typesystem_1.PrimitiveType) {\n            return toPrimitive(native, type, errorContext);\n        }\n        errorContext.throwError(`convertToTypedValue: unhandled type ${type}`);\n    }\n    function toOptionValue(native, type, errorContext) {\n        if (native == null) {\n            return typesystem_1.OptionValue.newMissing();\n        }\n        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n        return typesystem_1.OptionValue.newProvided(converted);\n    }\n    function toOptionalValue(native, type, errorContext) {\n        if (native == null) {\n            return new typesystem_1.OptionalValue(type);\n        }\n        let converted = convertToTypedValue(native, type.getFirstTypeParameter(), errorContext);\n        return new typesystem_1.OptionalValue(type, converted);\n    }\n    function toVariadicValue(native, type, errorContext) {\n        if (native == null) {\n            native = [];\n        }\n        if (native.map === undefined) {\n            errorContext.convertError(native, \"Variadic\");\n        }\n        let converted = native.map(function (item) {\n            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n        });\n        return new typesystem_1.VariadicValue(type, converted);\n    }\n    function toListValue(native, type, errorContext) {\n        if (native.map === undefined) {\n            errorContext.convertError(native, \"List\");\n        }\n        let converted = native.map(function (item) {\n            return convertToTypedValue(item, type.getFirstTypeParameter(), errorContext);\n        });\n        return new typesystem_1.List(type, converted);\n    }\n    function toCompositeValue(native, type, errorContext) {\n        let typedValues = [];\n        let typeParameters = type.getTypeParameters();\n        errorContext.guardSameLength(native, typeParameters);\n        for (let i = 0; i < typeParameters.length; i++) {\n            typedValues.push(convertToTypedValue(native[i], typeParameters[i], errorContext));\n        }\n        return new typesystem_1.CompositeValue(type, typedValues);\n    }\n    function toTupleValue(native, type, errorContext) {\n        let typedValues = [];\n        const fields = type.getFieldsDefinitions();\n        errorContext.guardSameLength(native, fields);\n        for (let i = 0; i < fields.length; i++) {\n            typedValues.push(convertToTypedValue(native[i], fields[i].type, errorContext));\n        }\n        return typesystem_2.Tuple.fromItems(typedValues);\n    }\n    function toStructValue(native, type, errorContext) {\n        let structFieldValues = [];\n        const fields = type.getFieldsDefinitions();\n        for (let i = 0; i < fields.length; i++) {\n            const fieldName = fields[i].name;\n            errorContext.guardHasField(native, fieldName);\n            const fieldNativeValue = native[fieldName];\n            const fieldTypedValue = convertToTypedValue(fieldNativeValue, fields[i].type, errorContext);\n            structFieldValues.push(new typesystem_2.Field(fieldTypedValue, fieldName));\n        }\n        return new typesystem_2.Struct(type, structFieldValues);\n    }\n    function toPrimitive(native, type, errorContext) {\n        if (type instanceof typesystem_1.NumericalType) {\n            let number = new bignumber_js_1.default(native);\n            return convertNumericalType(number, type, errorContext);\n        }\n        if (type instanceof typesystem_1.BytesType) {\n            return convertNativeToBytesValue(native, errorContext);\n        }\n        if (type instanceof typesystem_1.AddressType) {\n            return new typesystem_1.AddressValue(convertNativeToAddress(native, errorContext));\n        }\n        if (type instanceof typesystem_1.BooleanType) {\n            return new typesystem_1.BooleanValue(native);\n        }\n        if (type instanceof typesystem_1.TokenIdentifierType) {\n            return new typesystem_1.TokenIdentifierValue(convertNativeToString(native, errorContext));\n        }\n        errorContext.throwError(`(function: toPrimitive) unsupported type ${type}`);\n    }\n    function convertNativeToBytesValue(native, errorContext) {\n        const innerValue = native.valueOf();\n        if (native === undefined) {\n            errorContext.convertError(native, \"BytesValue\");\n        }\n        if (native instanceof Buffer) {\n            return new typesystem_1.BytesValue(native);\n        }\n        if (typeof native === \"string\") {\n            return typesystem_1.BytesValue.fromUTF8(native);\n        }\n        if (innerValue instanceof Buffer) {\n            return new typesystem_1.BytesValue(innerValue);\n        }\n        if (typeof innerValue === \"number\") {\n            return typesystem_1.BytesValue.fromHex(utils_codec_1.numberToPaddedHex(innerValue));\n        }\n        errorContext.convertError(native, \"BytesValue\");\n    }\n    function convertNativeToString(native, errorContext) {\n        if (native === undefined) {\n            errorContext.convertError(native, \"Buffer\");\n        }\n        if (native instanceof Buffer) {\n            return native.toString();\n        }\n        if (typeof native === \"string\") {\n            return native;\n        }\n        errorContext.convertError(native, \"Buffer\");\n    }\n    function convertNativeToAddress(native, errorContext) {\n        if (native.bech32) {\n            return native;\n        }\n        if (native.getAddress) {\n            return native.getAddress();\n        }\n        switch (native.constructor) {\n            case Buffer:\n            case String:\n                return new address_1.Address(native);\n            default:\n                errorContext.convertError(native, \"Address\");\n        }\n    }\n    NativeSerializer.convertNativeToAddress = convertNativeToAddress;\n    function convertNumericalType(number, type, errorContext) {\n        switch (type.constructor) {\n            case typesystem_1.U8Type:\n                return new typesystem_1.U8Value(number);\n            case typesystem_1.I8Type:\n                return new typesystem_1.I8Value(number);\n            case typesystem_1.U16Type:\n                return new typesystem_1.U16Value(number);\n            case typesystem_1.I16Type:\n                return new typesystem_1.I16Value(number);\n            case typesystem_1.U32Type:\n                return new typesystem_1.U32Value(number);\n            case typesystem_1.I32Type:\n                return new typesystem_1.I32Value(number);\n            case typesystem_1.U64Type:\n                return new typesystem_1.U64Value(number);\n            case typesystem_1.I64Type:\n                return new typesystem_1.I64Value(number);\n            case typesystem_1.BigUIntType:\n                return new typesystem_1.BigUIntValue(number);\n            case typesystem_1.BigIntType:\n                return new typesystem_1.BigIntValue(number);\n            default:\n                errorContext.unhandledType(\"convertNumericalType\", type);\n        }\n    }\n})(NativeSerializer = exports.NativeSerializer || (exports.NativeSerializer = {}));\n//# sourceMappingURL=nativeSerializer.js.map"]},"metadata":{},"sourceType":"script"}