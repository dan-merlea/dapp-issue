{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NumericalBinaryCodec = void 0;\nvar typesystem_1 = require(\"../typesystem\");\nvar utils_1 = require(\"./utils\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nvar NumericalBinaryCodec = /*#__PURE__*/function () {\n  function NumericalBinaryCodec() {\n    _classCallCheck(this, NumericalBinaryCodec);\n  }\n  _createClass(NumericalBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var offset = 0;\n      var length = type.sizeInBytes;\n      if (!length) {\n        // Size of type is not known: arbitrary-size big integer.\n        // Therefore, we must read the length from the header.\n        offset = constants_1.SizeOfU32;\n        length = buffer.readUInt32BE(0);\n      }\n      var payload = buffer.slice(offset, offset + length);\n      var result = this.decodeTopLevel(payload, type);\n      var decodedLength = length + offset;\n      return [result, decodedLength];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var payload = utils_1.cloneBuffer(buffer);\n      var empty = buffer.length == 0;\n      if (empty) {\n        return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n      }\n      var isPositive = !type.withSign || utils_1.isMsbZero(payload);\n      if (isPositive) {\n        var _value = utils_1.bufferToBigInt(payload);\n        return new typesystem_1.NumericalValue(type, _value);\n      }\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n      utils_1.flipBufferBitsInPlace(payload);\n      var value = utils_1.bufferToBigInt(payload);\n      var negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n      var negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n      return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(primitive) {\n      if (primitive.sizeInBytes) {\n        return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n      }\n      // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n      var buffer = this.encodeTopLevel(primitive);\n      var length = Buffer.alloc(constants_1.SizeOfU32);\n      length.writeUInt32BE(buffer.length);\n      return Buffer.concat([length, buffer]);\n    }\n  }, {\n    key: \"encodeNestedFixedSize\",\n    value: function encodeNestedFixedSize(primitive, size) {\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(size, 0x00);\n      }\n      if (!primitive.withSign) {\n        var _buffer = utils_1.bigIntToBuffer(primitive.value);\n        var _paddingBytes = Buffer.alloc(size - _buffer.length, 0x00);\n        return Buffer.concat([_paddingBytes, _buffer]);\n      }\n      if (primitive.value.isPositive()) {\n        var _buffer2 = utils_1.bigIntToBuffer(primitive.value);\n        // Fix ambiguity if any\n        if (utils_1.isMsbOne(_buffer2)) {\n          _buffer2 = utils_1.prependByteToBuffer(_buffer2, 0x00);\n        }\n        var _paddingBytes2 = Buffer.alloc(size - _buffer2.length, 0x00);\n        return Buffer.concat([_paddingBytes2, _buffer2]);\n      }\n      // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer);\n      // Fix ambiguity if any\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n      var paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n      return Buffer.concat([paddingBytes, buffer]);\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(primitive) {\n      var withSign = primitive.withSign;\n      // Nothing or Zero:\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(0);\n      }\n      // I don't care about the sign:\n      if (!withSign) {\n        return utils_1.bigIntToBuffer(primitive.value);\n      }\n      return this.encodePrimitive(primitive);\n    }\n  }, {\n    key: \"encodePrimitive\",\n    value: function encodePrimitive(primitive) {\n      // Positive:\n      if (primitive.value.isPositive()) {\n        var _buffer3 = utils_1.bigIntToBuffer(primitive.value);\n        // Fix ambiguity if any\n        if (utils_1.isMsbOne(_buffer3)) {\n          _buffer3 = utils_1.prependByteToBuffer(_buffer3, 0x00);\n        }\n        return _buffer3;\n      }\n      // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer);\n      // Fix ambiguity if any\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n      return buffer;\n    }\n  }]);\n  return NumericalBinaryCodec;\n}();\nexports.NumericalBinaryCodec = NumericalBinaryCodec;","map":null,"metadata":{},"sourceType":"script"}