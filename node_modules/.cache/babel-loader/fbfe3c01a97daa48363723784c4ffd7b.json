{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionalValue = exports.OptionalType = void 0;\nvar utils_1 = require(\"../../utils\");\nvar types_1 = require(\"./types\");\n/**\n * An optional is an algebraic type. It holds zero or one values.\n */\nvar OptionalType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(OptionalType, _types_1$Type);\n  var _super = _createSuper(OptionalType);\n  function OptionalType(typeParameter) {\n    _classCallCheck(this, OptionalType);\n    return _super.call(this, \"Optional\", [typeParameter], types_1.TypeCardinality.variable(1));\n  }\n  _createClass(OptionalType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionalType.ClassName;\n    }\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      if (!type.hasExactClass(OptionalType.ClassName)) {\n        return false;\n      }\n      var invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n      var fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n      return invariantTypeParameters || fakeCovarianceToNull;\n    }\n  }]);\n  return OptionalType;\n}(types_1.Type);\nexports.OptionalType = OptionalType;\nOptionalType.ClassName = \"OptionalType\";\nvar OptionalValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(OptionalValue, _types_1$TypedValue);\n  var _super2 = _createSuper(OptionalValue);\n  function OptionalValue(type) {\n    var _this;\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, OptionalValue);\n    _this = _super2.call(this, type);\n    // TODO: assert value is of type type.getFirstTypeParameter()\n    _this.value = value;\n    return _this;\n  }\n  _createClass(OptionalValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionalValue.ClassName;\n    }\n    /**\n     * Creates an OptionalValue, as not provided (missing).\n     */\n  }, {\n    key: \"isSet\",\n    value: function isSet() {\n      return this.value ? true : false;\n    }\n  }, {\n    key: \"getTypedValue\",\n    value: function getTypedValue() {\n      utils_1.guardValueIsSet(\"value\", this.value);\n      return this.value;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value ? this.value.valueOf() : null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var _a;\n      return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n  }], [{\n    key: \"newMissing\",\n    value: function newMissing() {\n      var type = new OptionalType(new types_1.NullType());\n      return new OptionalValue(type);\n    }\n  }]);\n  return OptionalValue;\n}(types_1.TypedValue);\nexports.OptionalValue = OptionalValue;\nOptionalValue.ClassName = \"OptionalValue\";","map":null,"metadata":{},"sourceType":"script"}