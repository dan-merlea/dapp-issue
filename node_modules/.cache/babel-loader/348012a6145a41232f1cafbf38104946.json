{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Resource } from './Resource.mjs';\nimport { BaseTexture } from '../BaseTexture.mjs';\nimport { autoDetectResource } from './autoDetectResource.mjs';\nvar AbstractMultiResource = /*#__PURE__*/function (_Resource) {\n  _inherits(AbstractMultiResource, _Resource);\n  var _super = _createSuper(AbstractMultiResource);\n  function AbstractMultiResource(length, options) {\n    var _this;\n    _classCallCheck(this, AbstractMultiResource);\n    var _ref = options || {},\n      width = _ref.width,\n      height = _ref.height;\n    _this = _super.call(this, width, height);\n    _this.items = [];\n    _this.itemDirtyIds = [];\n    for (var i = 0; i < length; i++) {\n      var partTexture = new BaseTexture();\n      _this.items.push(partTexture);\n      _this.itemDirtyIds.push(-2);\n    }\n    _this.length = length;\n    _this._load = null;\n    _this.baseTexture = null;\n    return _this;\n  }\n  _createClass(AbstractMultiResource, [{\n    key: \"initFromArray\",\n    value: function initFromArray(resources, options) {\n      for (var i = 0; i < this.length; i++) {\n        if (!resources[i]) {\n          continue;\n        }\n        if (resources[i].castToBaseTexture) {\n          this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n        } else if (resources[i] instanceof Resource) {\n          this.addResourceAt(resources[i], i);\n        } else {\n          this.addResourceAt(autoDetectResource(resources[i], options), i);\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0, len = this.length; i < len; i++) {\n        this.items[i].destroy();\n      }\n      this.items = null;\n      this.itemDirtyIds = null;\n      this._load = null;\n    }\n  }, {\n    key: \"addResourceAt\",\n    value: function addResourceAt(resource, index) {\n      if (!this.items[index]) {\n        throw new Error(\"Index \".concat(index, \" is out of bounds\"));\n      }\n      if (resource.valid && !this.valid) {\n        this.resize(resource.width, resource.height);\n      }\n      this.items[index].setResource(resource);\n      return this;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(baseTexture) {\n      if (this.baseTexture !== null) {\n        throw new Error(\"Only one base texture per TextureArray is allowed\");\n      }\n      _get(_getPrototypeOf(AbstractMultiResource.prototype), \"bind\", this).call(this, baseTexture);\n      for (var i = 0; i < this.length; i++) {\n        this.items[i].parentTextureArray = baseTexture;\n        this.items[i].on(\"update\", baseTexture.update, baseTexture);\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(baseTexture) {\n      _get(_getPrototypeOf(AbstractMultiResource.prototype), \"unbind\", this).call(this, baseTexture);\n      for (var i = 0; i < this.length; i++) {\n        this.items[i].parentTextureArray = null;\n        this.items[i].off(\"update\", baseTexture.update, baseTexture);\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n      if (this._load) {\n        return this._load;\n      }\n      var resources = this.items.map(function (item) {\n        return item.resource;\n      }).filter(function (item) {\n        return item;\n      });\n      var promises = resources.map(function (item) {\n        return item.load();\n      });\n      this._load = Promise.all(promises).then(function () {\n        var _this2$items$ = _this2.items[0],\n          realWidth = _this2$items$.realWidth,\n          realHeight = _this2$items$.realHeight;\n        _this2.resize(realWidth, realHeight);\n        return Promise.resolve(_this2);\n      });\n      return this._load;\n    }\n  }]);\n  return AbstractMultiResource;\n}(Resource);\nexport { AbstractMultiResource };","map":{"version":3,"sources":["../../../src/textures/resources/AbstractMultiResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { Resource } from './Resource';\nimport { BaseTexture } from '../BaseTexture';\nimport type { ISize } from '@pixi/math';\nimport type { IAutoDetectOptions } from './autoDetectResource';\nimport { autoDetectResource } from './autoDetectResource';\n\n/**\n * Resource that can manage several resource (items) inside.\n * All resources need to have the same pixel size.\n * Parent class for CubeResource and ArrayResource\n * @memberof PIXI\n */\nexport abstract class AbstractMultiResource extends Resource\n{\n    /** Number of elements in array. */\n    readonly length: number;\n\n    /**\n     * Collection of partial baseTextures that correspond to resources.\n     * @readonly\n     */\n    items: Array<BaseTexture>;\n\n    /**\n     * Dirty IDs for each part.\n     * @readonly\n     */\n    itemDirtyIds: Array<number>;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** Bound baseTexture, there can only be one. */\n    baseTexture: BaseTexture;\n\n    /**\n     * @param length\n     * @param options - Options to for Resource constructor\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(length: number, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        super(width, height);\n\n        this.items = [];\n        this.itemDirtyIds = [];\n\n        for (let i = 0; i < length; i++)\n        {\n            const partTexture = new BaseTexture();\n\n            this.items.push(partTexture);\n            // -2 - first run of texture array upload\n            // -1 - texture item was allocated\n            // >=0 - texture item uploaded , in sync with items[i].dirtyId\n            this.itemDirtyIds.push(-2);\n        }\n\n        this.length = length;\n        this._load = null;\n        this.baseTexture = null;\n    }\n\n    /**\n     * Used from ArrayResource and CubeResource constructors.\n     * @param resources - Can be resources, image elements, canvas, etc. ,\n     *  length should be same as constructor length\n     * @param options - Detect options for resources\n     */\n    protected initFromArray(resources: Array<any>, options?: IAutoDetectOptions): void\n    {\n        for (let i = 0; i < this.length; i++)\n        {\n            if (!resources[i])\n            {\n                continue;\n            }\n            if (resources[i].castToBaseTexture)\n            {\n                this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n            }\n            else if (resources[i] instanceof Resource)\n            {\n                this.addResourceAt(resources[i], i);\n            }\n            else\n            {\n                this.addResourceAt(autoDetectResource(resources[i], options), i);\n            }\n        }\n    }\n\n    /** Destroy this BaseImageResource. */\n    dispose(): void\n    {\n        for (let i = 0, len = this.length; i < len; i++)\n        {\n            this.items[i].destroy();\n        }\n        this.items = null;\n        this.itemDirtyIds = null;\n        this._load = null;\n    }\n\n    /**\n     * Set a baseTexture by ID\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    abstract addBaseTextureAt(baseTexture: BaseTexture, index: number): this;\n\n    /**\n     * Set a resource by ID\n     * @param resource\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addResourceAt(resource: Resource, index: number): this\n    {\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        // Inherit the first resource dimensions\n        if (resource.valid && !this.valid)\n        {\n            this.resize(resource.width, resource.height);\n        }\n\n        this.items[index].setResource(resource);\n\n        return this;\n    }\n\n    /**\n     * Set the parent base texture.\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        if (this.baseTexture !== null)\n        {\n            throw new Error('Only one base texture per TextureArray is allowed');\n        }\n        super.bind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = baseTexture;\n            this.items[i].on('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Unset the parent base texture.\n     * @param baseTexture\n     */\n    unbind(baseTexture: BaseTexture): void\n    {\n        super.unbind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = null;\n            this.items[i].off('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Load all the resources simultaneously\n     * @returns - When load is resolved\n     */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const resources = this.items.map((item) => item.resource).filter((item) => item);\n\n        // TODO: also implement load part-by-part strategy\n        const promises = resources.map((item) => item.load());\n\n        this._load = Promise.all(promises)\n            .then(() =>\n            {\n                const { realWidth, realHeight } = this.items[0];\n\n                this.resize(realWidth, realHeight);\n\n                return Promise.resolve(this);\n            }\n            );\n\n        return this._load;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}