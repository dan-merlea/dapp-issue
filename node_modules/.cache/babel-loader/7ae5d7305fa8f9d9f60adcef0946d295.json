{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar BlobResource = /*#__PURE__*/function (_core$BufferResource) {\n  _inherits(BlobResource, _core$BufferResource);\n  var _super = _createSuper(BlobResource);\n  function BlobResource(source) {\n    var _data2;\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      width: 1,\n      height: 1,\n      autoLoad: true\n    };\n    _classCallCheck(this, BlobResource);\n    var origin;\n    var data;\n    if (typeof source === \"string\") {\n      origin = source;\n      data = new Uint8Array();\n    } else {\n      origin = null;\n      data = source;\n    }\n    _this = _super.call(this, data, options);\n    _this.origin = origin;\n    _this.buffer = data ? new core.ViewableBuffer(data) : null;\n    if (_this.origin && options.autoLoad !== false) {\n      _this.load();\n    }\n    if ((_data2 = data) !== null && _data2 !== void 0 && _data2.length) {\n      _this.loaded = true;\n      _this.onBlobLoaded(_this.buffer.rawBinaryData);\n    }\n    return _this;\n  }\n  _createClass(BlobResource, [{\n    key: \"onBlobLoaded\",\n    value: function onBlobLoaded(_data) {}\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var response, blob, arrayBuffer;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return fetch(this.origin);\n              case 2:\n                response = _context.sent;\n                _context.next = 5;\n                return response.blob();\n              case 5:\n                blob = _context.sent;\n                _context.next = 8;\n                return blob.arrayBuffer();\n              case 8:\n                arrayBuffer = _context.sent;\n                this.data = new Uint32Array(arrayBuffer);\n                this.buffer = new core.ViewableBuffer(arrayBuffer);\n                this.loaded = true;\n                this.onBlobLoaded(arrayBuffer);\n                this.update();\n                return _context.abrupt(\"return\", this);\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function load() {\n        return _load.apply(this, arguments);\n      }\n      return load;\n    }()\n  }]);\n  return BlobResource;\n}(core.BufferResource);\nexports.BlobResource = BlobResource;","map":{"version":3,"sources":["../../src/resources/BlobResource.ts"],"names":["BufferResource","ViewableBuffer"],"mappings":";;;;;;;;;;;;IAgBsB,YAAA;EAAA;EAAA;EAclB,sBAAY,MACR,EACJ;IAAA;IAAA;IAAA,IADI,OAAA,uEAAwB;MAAE,KAAA,EAAO,CAAA;MAAG,MAAQ,EAAA,CAAA;MAAG,QAAU,EAAA;IAAA,CAC7D;IAAA;IACQ,IAAA,MAAA;IACA,IAAA,IAAA;IAEA,IAAA,OAAO,MAAA,KAAW,QACtB,EAAA;MACa,MAAA,GAAA,MAAA;MACT,IAAA,GAAO,IAAI,UAAW,EAAA;IAAA,CAG1B,MAAA;MACa,MAAA,GAAA,IAAA;MACF,IAAA,GAAA,MAAA;IAAA;IAGX,0BAAM,IAAA,EAAM,OAAO;IAMnB,MAAK,MAAS,GAAA,MAAA;IAOd,MAAK,MAAS,GAAA,IAAA,GAAO,IAAIC,IAAAA,CAAAA,cAAAA,CAAe,IAAI,CAAI,GAAA,IAAA;IAGhD,IAAI,MAAK,MAAA,IAAU,OAAQ,CAAA,QAAA,KAAa,KACxC,EAAA;MACI,MAAK,IAAK,EAAA;IAAA;IAEd,cAAI,IAAA,mCAAA,OAAM,MACV,EAAA;MACI,MAAK,MAAS,GAAA,IAAA;MACT,MAAA,YAAA,CAAa,MAAK,MAAA,CAAO,aAAa,CAAA;IAAA;IAC/C;EAAA;EACJ;IAAA;IAAA,OAEU,sBAAa,KACvB,EAAA,CAAA;EAEA;IAAA;IAAA;MAAA,uEAGA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAE2B,KAAM,CAAA,IAAA,CAAK,MAAM,CAAA;cAAA;gBAAlC,QAAW;gBAAA;gBAAA,OACE,QAAA,CAAS,IAAK,EAAA;cAAA;gBAA3B,IAAA;gBAAA;gBAAA,OACoB,IAAA,CAAK,WAAY,EAAA;cAAA;gBAArC,WAAA;gBAED,IAAA,CAAA,IAAA,GAAO,IAAI,WAAA,CAAY,WAAW,CAAA;gBAClC,IAAA,CAAA,MAAA,GAAS,IAAIA,IAAAA,CAAAA,cAAAA,CAAe,WAAW,CAAA;gBAC5C,IAAA,CAAK,MAAS,GAAA,IAAA;gBAEd,IAAA,CAAK,YAAA,CAAa,WAAW,CAAA;gBAC7B,IAAA,CAAK,MAAO,EAAA;gBAAA,iCAEL,IAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACX;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA,EA9EuCD,IAAAA,CAAAA,cAC3C","sourcesContent":["import type { Resource } from '@pixi/core';\nimport { ViewableBuffer, BufferResource } from '@pixi/core';\n\ninterface IBlobOptions\n{\n    autoLoad?: boolean;\n    width: number;\n    height: number;\n}\n\n/**\n * Resource that fetches texture data over the network and stores it in a buffer.\n * @class\n * @extends PIXI.Resource\n * @memberof PIXI\n */\nexport abstract class BlobResource extends BufferResource\n{\n    protected origin: string;\n    protected buffer: ViewableBuffer;\n    protected loaded: boolean;\n\n    /**\n     * @param {string} source - the URL of the texture file\n     * @param {PIXI.IBlobOptions} options\n     * @param {boolean}[options.autoLoad] - whether to fetch the data immediately;\n     *  you can fetch it later via {@link BlobResource#load}\n     * @param {boolean}[options.width] - the width in pixels.\n     * @param {boolean}[options.height] - the height in pixels.\n     */\n    constructor(source: string | Uint8Array | Uint32Array | Float32Array,\n        options: IBlobOptions = { width: 1, height: 1, autoLoad: true })\n    {\n        let origin: string;\n        let data: Uint8Array | Uint32Array | Float32Array;\n\n        if (typeof source === 'string')\n        {\n            origin = source;\n            data = new Uint8Array();\n        }\n        else\n        {\n            origin = null;\n            data = source;\n        }\n\n        super(data, options);\n\n        /**\n         * The URL of the texture file\n         * @member {string}\n         */\n        this.origin = origin;\n\n        /**\n         * The viewable buffer on the data\n         * @member {ViewableBuffer}\n         */\n        // HINT: BlobResource allows \"null\" sources, assuming the child class provides an alternative\n        this.buffer = data ? new ViewableBuffer(data) : null;\n\n        // Allow autoLoad = \"undefined\" still load the resource by default\n        if (this.origin && options.autoLoad !== false)\n        {\n            this.load();\n        }\n        if (data?.length)\n        {\n            this.loaded = true;\n            this.onBlobLoaded(this.buffer.rawBinaryData);\n        }\n    }\n\n    protected onBlobLoaded(_data: ArrayBuffer): void\n    {\n        // TODO: Override this method\n    }\n\n    /** Loads the blob */\n    async load(): Promise<Resource>\n    {\n        const response = await fetch(this.origin);\n        const blob = await response.blob();\n        const arrayBuffer = await blob.arrayBuffer();\n\n        this.data = new Uint32Array(arrayBuffer);\n        this.buffer = new ViewableBuffer(arrayBuffer);\n        this.loaded = true;\n\n        this.onBlobLoaded(arrayBuffer);\n        this.update();\n\n        return this;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}