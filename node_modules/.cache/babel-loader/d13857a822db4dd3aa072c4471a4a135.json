{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nvar codec_1 = require(\"./codec\");\nvar composite_1 = require(\"./typesystem/composite\");\nvar variadic_1 = require(\"./typesystem/variadic\");\nvar algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nvar Codec = new codec_1.BinaryCodec();\nvar ArgSerializer = /*#__PURE__*/function () {\n  function ArgSerializer() {\n    _classCallCheck(this, ArgSerializer);\n  }\n  _createClass(ArgSerializer, [{\n    key: \"stringToValues\",\n    value:\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    function stringToValues(joinedString, parameters) {\n      var buffers = this.stringToBuffers(joinedString);\n      var values = this.buffersToValues(buffers, parameters);\n      return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n  }, {\n    key: \"stringToBuffers\",\n    value: function stringToBuffers(joinedString) {\n      // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n      return joinedString.split(exports.ArgumentsSeparator).map(function (item) {\n        return Buffer.from(item, \"hex\");\n      });\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n  }, {\n    key: \"buffersToValues\",\n    value: function buffersToValues(buffers, parameters) {\n      // TODO: Refactor, split (function is quite complex).\n      buffers = buffers || [];\n      var values = [];\n      var bufferIndex = 0;\n      var numBuffers = buffers.length;\n      for (var i = 0; i < parameters.length; i++) {\n        var parameter = parameters[i];\n        var type = parameter.type;\n        var value = readValue(type);\n        values.push(value);\n      }\n      // This is a recursive function.\n      function readValue(type) {\n        // TODO: Use matchers.\n        if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\n          var typedValue = readValue(type.getFirstTypeParameter());\n          return new algebraic_1.OptionalValue(type, typedValue);\n        } else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\n          var typedValues = [];\n          while (!hasReachedTheEnd()) {\n            typedValues.push(readValue(type.getFirstTypeParameter()));\n          }\n          return new variadic_1.VariadicValue(type, typedValues);\n        } else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\n          var _typedValues = [];\n          var _iterator = _createForOfIteratorHelper(type.getTypeParameters()),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var typeParameter = _step.value;\n              _typedValues.push(readValue(typeParameter));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return new composite_1.CompositeValue(type, _typedValues);\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var _typedValue = decodeNextBuffer(type);\n          return _typedValue;\n        }\n      }\n      function decodeNextBuffer(type) {\n        if (hasReachedTheEnd()) {\n          return null;\n        }\n        var buffer = buffers[bufferIndex++];\n        var decodedValue = Codec.decodeTopLevel(buffer, type);\n        return decodedValue;\n      }\n      function hasReachedTheEnd() {\n        return bufferIndex >= numBuffers;\n      }\n      return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n  }, {\n    key: \"valuesToString\",\n    value: function valuesToString(values) {\n      var strings = this.valuesToStrings(values);\n      var argumentsString = strings.join(exports.ArgumentsSeparator);\n      var count = strings.length;\n      return {\n        argumentsString: argumentsString,\n        count: count\n      };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n  }, {\n    key: \"valuesToStrings\",\n    value: function valuesToStrings(values) {\n      var buffers = this.valuesToBuffers(values);\n      var strings = buffers.map(function (buffer) {\n        return buffer.toString(\"hex\");\n      });\n      return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n  }, {\n    key: \"valuesToBuffers\",\n    value: function valuesToBuffers(values) {\n      // TODO: Refactor, split (function is quite complex).\n      var buffers = [];\n      var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      function handleValue(value) {\n        // TODO: Use matchers.\n        if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\n          var valueAsOptional = value;\n          if (valueAsOptional.isSet()) {\n            handleValue(valueAsOptional.getTypedValue());\n          }\n        } else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\n          var valueAsVariadic = value;\n          var _iterator3 = _createForOfIteratorHelper(valueAsVariadic.getItems()),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var item = _step3.value;\n              handleValue(item);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\n          var valueAsComposite = value;\n          var _iterator4 = _createForOfIteratorHelper(valueAsComposite.getItems()),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _item = _step4.value;\n              handleValue(_item);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var buffer = Codec.encodeTopLevel(value);\n          buffers.push(buffer);\n        }\n      }\n      return buffers;\n    }\n  }]);\n  return ArgSerializer;\n}();\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"sources":["../../src/smartcontracts/argSerializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nconst codec_1 = require(\"./codec\");\nconst composite_1 = require(\"./typesystem/composite\");\nconst variadic_1 = require(\"./typesystem/variadic\");\nconst algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nconst Codec = new codec_1.BinaryCodec();\nclass ArgSerializer {\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    stringToValues(joinedString, parameters) {\n        let buffers = this.stringToBuffers(joinedString);\n        let values = this.buffersToValues(buffers, parameters);\n        return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n    stringToBuffers(joinedString) {\n        // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n        return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n    buffersToValues(buffers, parameters) {\n        // TODO: Refactor, split (function is quite complex).\n        buffers = buffers || [];\n        let values = [];\n        let bufferIndex = 0;\n        let numBuffers = buffers.length;\n        for (let i = 0; i < parameters.length; i++) {\n            let parameter = parameters[i];\n            let type = parameter.type;\n            let value = readValue(type);\n            values.push(value);\n        }\n        // This is a recursive function.\n        function readValue(type) {\n            // TODO: Use matchers.\n            if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\n                let typedValue = readValue(type.getFirstTypeParameter());\n                return new algebraic_1.OptionalValue(type, typedValue);\n            }\n            else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\n                let typedValues = [];\n                while (!hasReachedTheEnd()) {\n                    typedValues.push(readValue(type.getFirstTypeParameter()));\n                }\n                return new variadic_1.VariadicValue(type, typedValues);\n            }\n            else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\n                let typedValues = [];\n                for (const typeParameter of type.getTypeParameters()) {\n                    typedValues.push(readValue(typeParameter));\n                }\n                return new composite_1.CompositeValue(type, typedValues);\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let typedValue = decodeNextBuffer(type);\n                return typedValue;\n            }\n        }\n        function decodeNextBuffer(type) {\n            if (hasReachedTheEnd()) {\n                return null;\n            }\n            let buffer = buffers[bufferIndex++];\n            let decodedValue = Codec.decodeTopLevel(buffer, type);\n            return decodedValue;\n        }\n        function hasReachedTheEnd() {\n            return bufferIndex >= numBuffers;\n        }\n        return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n    valuesToString(values) {\n        let strings = this.valuesToStrings(values);\n        let argumentsString = strings.join(exports.ArgumentsSeparator);\n        let count = strings.length;\n        return { argumentsString, count };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n    valuesToStrings(values) {\n        let buffers = this.valuesToBuffers(values);\n        let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n        return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n    valuesToBuffers(values) {\n        // TODO: Refactor, split (function is quite complex).\n        let buffers = [];\n        for (const value of values) {\n            handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n        function handleValue(value) {\n            // TODO: Use matchers.\n            if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\n                let valueAsOptional = value;\n                if (valueAsOptional.isSet()) {\n                    handleValue(valueAsOptional.getTypedValue());\n                }\n            }\n            else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\n                let valueAsVariadic = value;\n                for (const item of valueAsVariadic.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\n                let valueAsComposite = value;\n                for (const item of valueAsComposite.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let buffer = Codec.encodeTopLevel(value);\n                buffers.push(buffer);\n            }\n        }\n        return buffers;\n    }\n}\nexports.ArgSerializer = ArgSerializer;\n//# sourceMappingURL=argSerializer.js.map"]},"metadata":{},"sourceType":"script"}