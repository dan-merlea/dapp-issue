{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\nimport { Point, utils } from '@pixi/core';\nvar PROPAGATION_LIMIT = 2048;\nvar tempHitLocation = new Point();\nvar tempLocalMapping = new Point();\nvar EventBoundary = /*#__PURE__*/function () {\n  function EventBoundary(rootTarget) {\n    _classCallCheck(this, EventBoundary);\n    this.dispatch = new utils.EventEmitter();\n    this.moveOnAll = false;\n    this.mappingState = {\n      trackingData: {}\n    };\n    this.eventPool = /* @__PURE__ */new Map();\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  _createClass(EventBoundary, [{\n    key: \"addEventMapping\",\n    value: function addEventMapping(type, fn) {\n      if (!this.mappingTable[type]) {\n        this.mappingTable[type] = [];\n      }\n      this.mappingTable[type].push({\n        fn: fn,\n        priority: 0\n      });\n      this.mappingTable[type].sort(function (a, b) {\n        return a.priority - b.priority;\n      });\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(e, type) {\n      e.propagationStopped = false;\n      e.propagationImmediatelyStopped = false;\n      this.propagate(e, type);\n      this.dispatch.emit(type || e.type, e);\n    }\n  }, {\n    key: \"mapEvent\",\n    value: function mapEvent(e) {\n      if (!this.rootTarget) {\n        return;\n      }\n      var mappers = this.mappingTable[e.type];\n      if (mappers) {\n        for (var i = 0, j = mappers.length; i < j; i++) {\n          mappers[i].fn(e);\n        }\n      } else {\n        console.warn(\"[EventBoundary]: Event mapping not defined for \".concat(e.type));\n      }\n    }\n  }, {\n    key: \"hitTest\",\n    value: function hitTest(x, y) {\n      var invertedPath = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);\n      return invertedPath && invertedPath[0];\n    }\n  }, {\n    key: \"propagate\",\n    value: function propagate(e, type) {\n      if (!e.target) {\n        return;\n      }\n      var composedPath = e.composedPath();\n      e.eventPhase = e.CAPTURING_PHASE;\n      for (var i = 0, j = composedPath.length - 1; i < j; i++) {\n        e.currentTarget = composedPath[i];\n        this.notifyTarget(e, type);\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n      }\n      e.eventPhase = e.AT_TARGET;\n      e.currentTarget = e.target;\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n      e.eventPhase = e.BUBBLING_PHASE;\n      for (var _i = composedPath.length - 2; _i >= 0; _i--) {\n        e.currentTarget = composedPath[_i];\n        this.notifyTarget(e, type);\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n      }\n    }\n  }, {\n    key: \"all\",\n    value: function all(e, type) {\n      var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.rootTarget;\n      e.eventPhase = e.BUBBLING_PHASE;\n      var children = target.children;\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          this.all(e, type, children[i]);\n        }\n      }\n      e.currentTarget = target;\n      this.notifyTarget(e, type);\n    }\n  }, {\n    key: \"propagationPath\",\n    value: function propagationPath(target) {\n      var propagationPath = [target];\n      for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n        if (!target.parent) {\n          throw new Error(\"Cannot find propagation path to disconnected target\");\n        }\n        propagationPath.push(target.parent);\n        target = target.parent;\n      }\n      propagationPath.reverse();\n      return propagationPath;\n    }\n  }, {\n    key: \"hitTestRecursive\",\n    value: function hitTestRecursive(currentTarget, interactive, location, testFn, pruneFn) {\n      if (!currentTarget || !currentTarget.visible) {\n        return null;\n      }\n      if (pruneFn(currentTarget, location)) {\n        return null;\n      }\n      if (currentTarget.interactiveChildren && currentTarget.children) {\n        var children = currentTarget.children;\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i];\n          var nestedHit = this.hitTestRecursive(child, interactive || child.interactive, location, testFn, pruneFn);\n          if (nestedHit) {\n            if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n              continue;\n            }\n            if (nestedHit.length > 0 || currentTarget.interactive) {\n              nestedHit.push(currentTarget);\n            }\n            return nestedHit;\n          }\n        }\n      }\n      if (interactive && testFn(currentTarget, location)) {\n        return currentTarget.interactive ? [currentTarget] : [];\n      }\n      return null;\n    }\n  }, {\n    key: \"hitPruneFn\",\n    value: function hitPruneFn(displayObject, location) {\n      if (displayObject.hitArea) {\n        displayObject.worldTransform.applyInverse(location, tempLocalMapping);\n        if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n          return true;\n        }\n      }\n      if (displayObject._mask) {\n        var _maskObject$containsP;\n        var maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n        if (maskObject && !((_maskObject$containsP = maskObject.containsPoint) !== null && _maskObject$containsP !== void 0 && _maskObject$containsP.call(maskObject, location))) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hitTestFn\",\n    value: function hitTestFn(displayObject, location) {\n      if (displayObject.hitArea) {\n        return true;\n      }\n      if (displayObject.containsPoint) {\n        return displayObject.containsPoint(location);\n      }\n      return false;\n    }\n  }, {\n    key: \"notifyTarget\",\n    value: function notifyTarget(e, type) {\n      var _type;\n      type = (_type = type) !== null && _type !== void 0 ? _type : e.type;\n      var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? \"\".concat(type, \"capture\") : type;\n      this.notifyListeners(e, key);\n      if (e.eventPhase === e.AT_TARGET) {\n        this.notifyListeners(e, type);\n      }\n    }\n  }, {\n    key: \"mapPointerDown\",\n    value: function mapPointerDown(from) {\n      if (!(from instanceof FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var e = this.createPointerEvent(from);\n      this.dispatchEvent(e, \"pointerdown\");\n      if (e.pointerType === \"touch\") {\n        this.dispatchEvent(e, \"touchstart\");\n      } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n        var isRightButton = e.button === 2;\n        this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      trackingData.pressTargetsByButton[from.button] = e.composedPath();\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapPointerMove\",\n    value: function mapPointerMove(from) {\n      if (!(from instanceof FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var e = this.createPointerEvent(from);\n      var isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n      var trackingData = this.trackingData(from.pointerId);\n      var outTarget = this.findMountedTarget(trackingData.overTargets);\n      if (trackingData.overTargets && outTarget !== e.target) {\n        var outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n        var outEvent = this.createPointerEvent(from, outType, outTarget);\n        this.dispatchEvent(outEvent, \"pointerout\");\n        if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n        if (!e.composedPath().includes(outTarget)) {\n          var leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n          leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n          while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n            leaveEvent.currentTarget = leaveEvent.target;\n            this.notifyTarget(leaveEvent);\n            if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n            leaveEvent.target = leaveEvent.target.parent;\n          }\n          this.freeEvent(leaveEvent);\n        }\n        this.freeEvent(outEvent);\n      }\n      if (outTarget !== e.target) {\n        var overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n        var overEvent = this.clonePointerEvent(e, overType);\n        this.dispatchEvent(overEvent, \"pointerover\");\n        if (isMouse) this.dispatchEvent(overEvent, \"mouseover\");\n        var overTargetAncestor = outTarget === null || outTarget === void 0 ? void 0 : outTarget.parent;\n        while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n          if (overTargetAncestor === e.target) break;\n          overTargetAncestor = overTargetAncestor.parent;\n        }\n        var didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n        if (didPointerEnter) {\n          var enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n          enterEvent.eventPhase = enterEvent.AT_TARGET;\n          while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n            enterEvent.currentTarget = enterEvent.target;\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n            enterEvent.target = enterEvent.target.parent;\n          }\n          this.freeEvent(enterEvent);\n        }\n        this.freeEvent(overEvent);\n      }\n      var propagationMethod = this.moveOnAll ? \"all\" : \"dispatchEvent\";\n      this[propagationMethod](e, \"pointermove\");\n      if (e.pointerType === \"touch\") this[propagationMethod](e, \"touchmove\");\n      if (isMouse) {\n        var _e$target;\n        this[propagationMethod](e, \"mousemove\");\n        this.cursor = (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.cursor;\n      }\n      trackingData.overTargets = e.composedPath();\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapPointerOver\",\n    value: function mapPointerOver(from) {\n      var _e$target2;\n      if (!(from instanceof FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      var e = this.createPointerEvent(from);\n      var isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n      this.dispatchEvent(e, \"pointerover\");\n      if (isMouse) this.dispatchEvent(e, \"mouseover\");\n      if (e.pointerType === \"mouse\") this.cursor = (_e$target2 = e.target) === null || _e$target2 === void 0 ? void 0 : _e$target2.cursor;\n      var enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n      enterEvent.eventPhase = enterEvent.AT_TARGET;\n      while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n        enterEvent.currentTarget = enterEvent.target;\n        this.notifyTarget(enterEvent);\n        if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n        enterEvent.target = enterEvent.target.parent;\n      }\n      trackingData.overTargets = e.composedPath();\n      this.freeEvent(e);\n      this.freeEvent(enterEvent);\n    }\n  }, {\n    key: \"mapPointerOut\",\n    value: function mapPointerOut(from) {\n      if (!(from instanceof FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      if (trackingData.overTargets) {\n        var isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n        var outTarget = this.findMountedTarget(trackingData.overTargets);\n        var outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n        this.dispatchEvent(outEvent);\n        if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n        var leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        trackingData.overTargets = null;\n        this.freeEvent(outEvent);\n        this.freeEvent(leaveEvent);\n      }\n      this.cursor = null;\n    }\n  }, {\n    key: \"mapPointerUp\",\n    value: function mapPointerUp(from) {\n      if (!(from instanceof FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var now = performance.now();\n      var e = this.createPointerEvent(from);\n      this.dispatchEvent(e, \"pointerup\");\n      if (e.pointerType === \"touch\") {\n        this.dispatchEvent(e, \"touchend\");\n      } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n        var isRightButton = e.button === 2;\n        this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      var pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n      var clickTarget = pressTarget;\n      if (pressTarget && !e.composedPath().includes(pressTarget)) {\n        var currentTarget = pressTarget;\n        while (currentTarget && !e.composedPath().includes(currentTarget)) {\n          e.currentTarget = currentTarget;\n          this.notifyTarget(e, \"pointerupoutside\");\n          if (e.pointerType === \"touch\") {\n            this.notifyTarget(e, \"touchendoutside\");\n          } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n            var _isRightButton = e.button === 2;\n            this.notifyTarget(e, _isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n          }\n          currentTarget = currentTarget.parent;\n        }\n        delete trackingData.pressTargetsByButton[from.button];\n        clickTarget = currentTarget;\n      }\n      if (clickTarget) {\n        var clickEvent = this.clonePointerEvent(e, \"click\");\n        clickEvent.target = clickTarget;\n        clickEvent.path = null;\n        if (!trackingData.clicksByButton[from.button]) {\n          trackingData.clicksByButton[from.button] = {\n            clickCount: 0,\n            target: clickEvent.target,\n            timeStamp: now\n          };\n        }\n        var clickHistory = trackingData.clicksByButton[from.button];\n        if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n          ++clickHistory.clickCount;\n        } else {\n          clickHistory.clickCount = 1;\n        }\n        clickHistory.target = clickEvent.target;\n        clickHistory.timeStamp = now;\n        clickEvent.detail = clickHistory.clickCount;\n        if (clickEvent.pointerType === \"mouse\") {\n          this.dispatchEvent(clickEvent, \"click\");\n        } else if (clickEvent.pointerType === \"touch\") {\n          this.dispatchEvent(clickEvent, \"tap\");\n        }\n        this.dispatchEvent(clickEvent, \"pointertap\");\n        this.freeEvent(clickEvent);\n      }\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapPointerUpOutside\",\n    value: function mapPointerUpOutside(from) {\n      if (!(from instanceof FederatedPointerEvent)) {\n        console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n        return;\n      }\n      var trackingData = this.trackingData(from.pointerId);\n      var pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n      var e = this.createPointerEvent(from);\n      if (pressTarget) {\n        var currentTarget = pressTarget;\n        while (currentTarget) {\n          e.currentTarget = currentTarget;\n          this.notifyTarget(e, \"pointerupoutside\");\n          if (e.pointerType === \"touch\") {\n            this.notifyTarget(e, \"touchendoutside\");\n          } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n            this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n          }\n          currentTarget = currentTarget.parent;\n        }\n        delete trackingData.pressTargetsByButton[from.button];\n      }\n      this.freeEvent(e);\n    }\n  }, {\n    key: \"mapWheel\",\n    value: function mapWheel(from) {\n      if (!(from instanceof FederatedWheelEvent)) {\n        console.warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n        return;\n      }\n      var wheelEvent = this.createWheelEvent(from);\n      this.dispatchEvent(wheelEvent);\n      this.freeEvent(wheelEvent);\n    }\n  }, {\n    key: \"findMountedTarget\",\n    value: function findMountedTarget(propagationPath) {\n      if (!propagationPath) {\n        return null;\n      }\n      var currentTarget = propagationPath[0];\n      for (var i = 1; i < propagationPath.length; i++) {\n        if (propagationPath[i].parent === currentTarget) {\n          currentTarget = propagationPath[i];\n        } else {\n          break;\n        }\n      }\n      return currentTarget;\n    }\n  }, {\n    key: \"createPointerEvent\",\n    value: function createPointerEvent(from, type, target) {\n      var event = this.allocateEvent(FederatedPointerEvent);\n      this.copyPointerData(from, event);\n      this.copyMouseData(from, event);\n      this.copyData(from, event);\n      event.nativeEvent = from.nativeEvent;\n      event.originalEvent = from;\n      event.target = target !== null && target !== void 0 ? target : this.hitTest(event.global.x, event.global.y);\n      if (typeof type === \"string\") {\n        event.type = type;\n      }\n      return event;\n    }\n  }, {\n    key: \"createWheelEvent\",\n    value: function createWheelEvent(from) {\n      var event = this.allocateEvent(FederatedWheelEvent);\n      this.copyWheelData(from, event);\n      this.copyMouseData(from, event);\n      this.copyData(from, event);\n      event.nativeEvent = from.nativeEvent;\n      event.originalEvent = from;\n      event.target = this.hitTest(event.global.x, event.global.y);\n      return event;\n    }\n  }, {\n    key: \"clonePointerEvent\",\n    value: function clonePointerEvent(from, type) {\n      var event = this.allocateEvent(FederatedPointerEvent);\n      event.nativeEvent = from.nativeEvent;\n      event.originalEvent = from.originalEvent;\n      this.copyPointerData(from, event);\n      this.copyMouseData(from, event);\n      this.copyData(from, event);\n      event.target = from.target;\n      event.path = from.composedPath().slice();\n      event.type = type !== null && type !== void 0 ? type : event.type;\n      return event;\n    }\n  }, {\n    key: \"copyWheelData\",\n    value: function copyWheelData(from, to) {\n      to.deltaMode = from.deltaMode;\n      to.deltaX = from.deltaX;\n      to.deltaY = from.deltaY;\n      to.deltaZ = from.deltaZ;\n    }\n  }, {\n    key: \"copyPointerData\",\n    value: function copyPointerData(from, to) {\n      if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n      to.pointerId = from.pointerId;\n      to.width = from.width;\n      to.height = from.height;\n      to.isPrimary = from.isPrimary;\n      to.pointerType = from.pointerType;\n      to.pressure = from.pressure;\n      to.tangentialPressure = from.tangentialPressure;\n      to.tiltX = from.tiltX;\n      to.tiltY = from.tiltY;\n      to.twist = from.twist;\n    }\n  }, {\n    key: \"copyMouseData\",\n    value: function copyMouseData(from, to) {\n      if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n      to.altKey = from.altKey;\n      to.button = from.button;\n      to.buttons = from.buttons;\n      to.client.copyFrom(from.client);\n      to.ctrlKey = from.ctrlKey;\n      to.metaKey = from.metaKey;\n      to.movement.copyFrom(from.movement);\n      to.screen.copyFrom(from.screen);\n      to.global.copyFrom(from.global);\n    }\n  }, {\n    key: \"copyData\",\n    value: function copyData(from, to) {\n      to.isTrusted = from.isTrusted;\n      to.srcElement = from.srcElement;\n      to.timeStamp = performance.now();\n      to.type = from.type;\n      to.detail = from.detail;\n      to.view = from.view;\n      to.which = from.which;\n      to.layer.copyFrom(from.layer);\n      to.page.copyFrom(from.page);\n    }\n  }, {\n    key: \"trackingData\",\n    value: function trackingData(id) {\n      if (!this.mappingState.trackingData[id]) {\n        this.mappingState.trackingData[id] = {\n          pressTargetsByButton: {},\n          clicksByButton: {},\n          overTarget: null\n        };\n      }\n      return this.mappingState.trackingData[id];\n    }\n  }, {\n    key: \"allocateEvent\",\n    value: function allocateEvent(constructor) {\n      if (!this.eventPool.has(constructor)) {\n        this.eventPool.set(constructor, []);\n      }\n      var event = this.eventPool.get(constructor).pop() || new constructor(this);\n      event.eventPhase = event.NONE;\n      event.currentTarget = null;\n      event.path = null;\n      event.target = null;\n      return event;\n    }\n  }, {\n    key: \"freeEvent\",\n    value: function freeEvent(event) {\n      if (event.manager !== this) throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n      var constructor = event.constructor;\n      if (!this.eventPool.has(constructor)) {\n        this.eventPool.set(constructor, []);\n      }\n      this.eventPool.get(constructor).push(event);\n    }\n  }, {\n    key: \"notifyListeners\",\n    value: function notifyListeners(e, type) {\n      var listeners = e.currentTarget._events[type];\n      if (!listeners) return;\n      if (\"fn\" in listeners) {\n        listeners.fn.call(listeners.context, e);\n      } else {\n        for (var i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n          listeners[i].fn.call(listeners[i].context, e);\n        }\n      }\n    }\n  }]);\n  return EventBoundary;\n}();\nexport { EventBoundary };","map":{"version":3,"sources":["../src/EventBoundary.ts"],"names":[],"mappings":"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","sourcesContent":["import { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\nimport { Point, utils } from '@pixi/core';\n\nimport type { Cursor, FederatedEventTarget } from './FederatedEventTarget';\nimport type { DisplayObject } from '@pixi/display';\nimport type { FederatedEvent } from './FederatedEvent';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * The tracking data for each pointer held in the state of an {@link PIXI.EventBoundary}.\n *\n * ```ts\n * pressTargetsByButton: {\n *     [id: number]: FederatedEventTarget[];\n * };\n * clicksByButton: {\n *     [id: number]: {\n *         clickCount: number;\n *         target: FederatedEventTarget;\n *         timeStamp: number;\n *     };\n * };\n * overTargets: FederatedEventTarget[];\n * ```\n * @typedef {object} TrackingData\n * @property {Record.<number, PIXI.FederatedEventTarget>} pressTargetsByButton - The pressed display objects'\n *  propagation paths by each button of the pointer.\n * @property {Record.<number, object>} clicksByButton - Holds clicking data for each button of the pointer.\n * @property {PIXI.DisplayObject[]} overTargets - The DisplayObject propagation path over which the pointer is hovering.\n * @memberof PIXI\n */\ntype TrackingData = {\n    pressTargetsByButton: {\n        [id: number]: FederatedEventTarget[];\n    };\n    clicksByButton: {\n        [id: number]: {\n            clickCount: number;\n            target: FederatedEventTarget;\n            timeStamp: number;\n        }\n    };\n    overTargets: FederatedEventTarget[];\n};\n\n/**\n * Internal storage of event listeners in EventEmitter.\n * @ignore\n */\ntype EmitterListeners = Record<string,\n| Array<{ fn(...args: any[]): any, context: any }>\n| { fn(...args: any[]): any, context: any }\n>;\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link PIXI.EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link PIXI.EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link PIXI.FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from '@pixi/display';\n * import { EventBoundary } from '@pixi/events';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends DisplayObject\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof PIXI\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     *\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: DisplayObject;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: utils.EventEmitter = new utils.EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all DisplayObjects.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link PIXI.EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see PIXI.EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see PIXI.EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see PIXI.EventBoundary#allocateEvent\n     * @see PIXI.EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: DisplayObject)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e\n     * @param type\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n        }\n    }\n\n    /**\n     * Finds the DisplayObject that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x\n     * @param y\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): DisplayObject\n    {\n        const invertedPath = this.hitTestRecursive(\n            this.rootTarget,\n            this.rootTarget.interactive,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@link e} to all display objects. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `pointermove` legacy mode.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param target\n     */\n    public all(e: FederatedEvent, type?: string, target: FederatedEventTarget = this.rootTarget): void\n    {\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const children = target.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this.all(e, type, children[i]);\n            }\n        }\n\n        e.currentTarget = target;\n        this.notifyTarget(e, type);\n    }\n\n    /**\n     * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target\n     */\n    public propagationPath(target: FederatedEventTarget): FederatedEventTarget[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The DisplayObject that is to be hit tested.\n     * @param interactive - Flags whether `currentTarget` or one of its parents are interactive.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the display object.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: DisplayObject,\n        interactive: boolean,\n        location: Point,\n        testFn: (object: DisplayObject, pt: Point) => boolean,\n        pruneFn?: (object: DisplayObject, pt: Point) => boolean,\n    ): DisplayObject[]\n    {\n        if (!currentTarget || !currentTarget.visible)\n        {\n            return null;\n        }\n\n        // Attempt to prune this DisplayObject and its subtree as an optimization.\n        if (pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as DisplayObject;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    interactive || child.interactive,\n                    location,\n                    testFn,\n                    pruneFn,\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    if (nestedHit.length > 0 || currentTarget.interactive)\n                    {\n                        nestedHit.push(currentTarget);\n                    }\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        // Finally, hit test this DisplayObject itself.\n        if (interactive && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return currentTarget.interactive ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Checks whether the display object or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}\n     * and {@link PIXI.DisplayObject._mask} for pruning.\n     * @param displayObject\n     * @param location\n     */\n    protected hitPruneFn(displayObject: DisplayObject, location: Point): boolean\n    {\n        if (displayObject.hitArea)\n        {\n            displayObject.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (displayObject._mask)\n        {\n            const maskObject = ((displayObject._mask as any).isMaskData\n                ? (displayObject._mask as any).maskObject : displayObject._mask);\n\n            if (maskObject && !maskObject.containsPoint?.(location))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the display object passes hit testing for the given location.\n     * @param displayObject\n     * @param location\n     * @returns - Whether `displayObject` passes hit testing for `location`.\n     */\n    protected hitTestFn(displayObject: DisplayObject, location: Point): boolean\n    {\n        // If the display object failed pruning with a hitArea, then it must pass it.\n        if (displayObject.hitArea)\n        {\n            return true;\n        }\n\n        if ((displayObject as any).containsPoint)\n        {\n            return (displayObject as any).containsPoint(location) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     * @param e - The event passed to the target.\n     * @param type\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        type = type ?? e.type;\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this.notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this.notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered DisplayObject is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const propagationMethod = this.moveOnAll ? 'all' : 'dispatchEvent';\n\n        // Then pointermove\n        this[propagationMethod](e, 'pointermove');\n\n        if (e.pointerType === 'touch') this[propagationMethod](e, 'touchmove');\n\n        if (isMouse)\n        {\n            this[propagationMethod](e, 'mousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`, and `click`/`pointertap` events,\n     * in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                this.dispatchEvent(clickEvent, 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the {@code EventBoundary}'s\n     * root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            console.warn('EventBoundary cannot map a non-pointer event as a pointer event');\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            console.warn('EventBoundary cannot map a non-wheel event as a wheel event');\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: FederatedEventTarget[]): FederatedEventTarget\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: FederatedEventTarget\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target ?? this.hitTest(event.global.x, event.global.y) as FederatedEventTarget;\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from\n     * @param to\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from\n     * @param to\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + global\n     * @param from\n     * @param to\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n\n        to.screen.copyFrom(from.screen);\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n\n/**\n * Fired when a mouse button (usually a mouse left-button) is pressed on the display.\n * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousedown\n * @param {PIXI.FederatedPointerEvent} event - The mousedown event.\n */\n\n/**\n * Capture phase equivalent of {@code mousedown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousedowncapture\n * @param {PIXI.FederatedPointerEvent} event - The capture phase mousedown.\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightdown\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightdown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightdowncapture\n * @param {PIXI.FederatedPointerEvent} event - The rightdowncapture event.\n */\n\n/**\n * Fired when a pointer device button (usually a mouse left-button) is released over the display\n * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is released\n * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * A {@code click} event fires after the {@code pointerdown} and {@code pointerup} events, in that\n * order. If the mouse is moved over another DisplayObject after the {@code pointerdown} event, the\n * {@code click} event is fired on the most specific common ancestor of the two target DisplayObjects.\n *\n * The {@code detail} property of the event is the number of clicks that occurred within a 200ms\n * window of each other upto the current click. For example, it will be {@code 2} for a double click.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#click\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code click}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#clickcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event follows the semantics of {@code click}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightclick\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightclick}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightclickcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button (usually a mouse left-button) is released outside the\n * display object that initially registered a\n * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event is specific to the Federated Events API. It does not have a capture phase, unlike most of the\n * other events. It only bubbles to the most specific ancestor of the targets of the corresponding {@code pointerdown}\n * and {@code pointerup} events, i.e. the target of the {@code click} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device secondary button (usually a mouse right-button) is released\n * outside the display object that initially registered a\n * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code rightupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#rightupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device (usually a mouse) is moved while over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousemove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mousemove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mousemovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device (usually a mouse) is moved onto the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseover\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseover}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseovercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the mouse pointer is moved over a DisplayObject and its descendant's hit testing boundaries.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseenter\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseenter}\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseentercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device (usually a mouse) is moved off the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This may be fired on a DisplayObject that was removed from the scene graph immediately after\n * a {@code mouseover} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseout\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code mouseout}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseoutcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the mouse pointer exits a DisplayObject and its descendants.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseleave\n * @param {PIXI.FederatedPointerEvent} event\n */\n\n/**\n * Capture phase equivalent of {@code mouseleave}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#mouseleavecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is pressed on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerdown\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerdown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerdowncapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is released over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the operating system cancels a pointer event.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointercancel\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointercancel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointercancelcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is pressed and released on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointertap\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointertap}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointertapcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device button is released outside the display object that initially\n * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event is specific to the Federated Events API. It does not have a capture phase, unlike most of the\n * other events. It only bubbles to the most specific ancestor of the targets of the corresponding {@code pointerdown}\n * and {@code pointerup} events, i.e. the target of the {@code click} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device is moved while over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointermove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointermove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointermovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device is moved onto the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerover\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerover}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerovercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the pointer is moved over a DisplayObject and its descendant's hit testing boundaries.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerenter\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerenter}\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerentercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a pointer device is moved off the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerout\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code pointerout}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointeroutcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the pointer leaves the hit testing boundaries of a DisplayObject and its descendants.\n *\n * This event notifies only the target and does not bubble.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerleave\n * @param {PIXI.FederatedPointerEvent} event - The `pointerleave` event.\n */\n\n/**\n * Capture phase equivalent of {@code pointerleave}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#pointerleavecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is placed on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchstart\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchstart}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchstartcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is removed from the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchend\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchend}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchendcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when the operating system cancels a touch.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchcancel\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchcancel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchcancelcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is placed and removed from the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#tap\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code tap}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#tapcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is removed outside of the display object that initially\n * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchendoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchendoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchendoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a touch point is moved along the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchmove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Capture phase equivalent of {@code touchmove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#touchmovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */\n\n/**\n * Fired when a the user scrolls with the mouse cursor over a DisplayObject.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#wheel\n * @type {PIXI.FederatedWheelEvent}\n */\n\n/**\n * Capture phase equivalent of {@code wheel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n * @event PIXI.DisplayObject#wheelcapture\n * @type {PIXI.FederatedWheelEvent}\n */\n"]},"metadata":{},"sourceType":"module"}