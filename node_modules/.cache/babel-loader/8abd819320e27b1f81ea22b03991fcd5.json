{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nrequire('./index.js');\nvar uniformParsers = require('./uniformParsers.js');\nvar mapSize = require('./mapSize.js');\nfunction uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {\n  _renderer.buffer.update(buffer);\n}\nvar UBO_TO_SINGLE_SETTERS = {\n  float: \"\\n        data[offset] = v;\\n    \",\n  vec2: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n    \",\n  vec3: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n\\n    \",\n  vec4: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n        data[offset+3] = v[3];\\n    \",\n  mat2: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n\\n        data[offset+4] = v[2];\\n        data[offset+5] = v[3];\\n    \",\n  mat3: \"\\n        data[offset] = v[0];\\n        data[offset+1] = v[1];\\n        data[offset+2] = v[2];\\n\\n        data[offset + 4] = v[3];\\n        data[offset + 5] = v[4];\\n        data[offset + 6] = v[5];\\n\\n        data[offset + 8] = v[6];\\n        data[offset + 9] = v[7];\\n        data[offset + 10] = v[8];\\n    \",\n  mat4: \"\\n        for(var i = 0; i < 16; i++)\\n        {\\n            data[offset + i] = v[i];\\n        }\\n    \"\n};\nvar GLSL_TO_STD40_SIZE = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction createUBOElements(uniformData) {\n  var uboElements = uniformData.map(function (data) {\n    return {\n      data: data,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  });\n  var size = 0;\n  var chunkSize = 0;\n  var offset = 0;\n  for (var i = 0; i < uboElements.length; i++) {\n    var uboElement = uboElements[i];\n    size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, 16) * uboElement.data.size;\n    }\n    uboElement.dataLen = size;\n    if (chunkSize % size !== 0 && chunkSize < 16) {\n      var lineUpValue = chunkSize % size % 16;\n      chunkSize += lineUpValue;\n      offset += lineUpValue;\n    }\n    if (chunkSize + size > 16) {\n      offset = Math.ceil(offset / 16) * 16;\n      uboElement.offset = offset;\n      offset += size;\n      chunkSize = size;\n    } else {\n      uboElement.offset = offset;\n      chunkSize += size;\n      offset += size;\n    }\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return {\n    uboElements: uboElements,\n    size: offset\n  };\n}\nfunction getUBOData(uniforms, uniformData) {\n  var usedUniformDatas = [];\n  for (var i in uniforms) {\n    if (uniformData[i]) {\n      usedUniformDatas.push(uniformData[i]);\n    }\n  }\n  usedUniformDatas.sort(function (a, b) {\n    return a.index - b.index;\n  });\n  return usedUniformDatas;\n}\nfunction generateUniformBufferSync(group, uniformData) {\n  if (!group.autoManage) {\n    return {\n      size: 0,\n      syncFunc: uboUpdate\n    };\n  }\n  var usedUniformDatas = getUBOData(group.uniforms, uniformData);\n  var _createUBOElements = createUBOElements(usedUniformDatas),\n    uboElements = _createUBOElements.uboElements,\n    size = _createUBOElements.size;\n  var funcFragments = [\"\\n    var v = null;\\n    var v2 = null;\\n    var cv = null;\\n    var t = 0;\\n    var gl = renderer.gl\\n    var index = 0;\\n    var data = buffer.data;\\n    \"];\n  for (var i = 0; i < uboElements.length; i++) {\n    var uboElement = uboElements[i];\n    var uniform = group.uniforms[uboElement.data.name];\n    var name = uboElement.data.name;\n    var parsed = false;\n    for (var j = 0; j < uniformParsers.uniformParsers.length; j++) {\n      var uniformParser = uniformParsers.uniformParsers[j];\n      if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {\n        funcFragments.push(\"offset = \".concat(uboElement.offset / 4, \";\"), uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        var size2 = mapSize.mapSize(uboElement.data.type);\n        var rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n        var elementSize = size2 / rowSize;\n        var remainder = (4 - elementSize % 4) % 4;\n        funcFragments.push(\"\\n                cv = ud.\".concat(name, \".value;\\n                v = uv.\").concat(name, \";\\n                offset = \").concat(uboElement.offset / 4, \";\\n\\n                t = 0;\\n\\n                for(var i=0; i < \").concat(uboElement.data.size * rowSize, \"; i++)\\n                {\\n                    for(var j = 0; j < \").concat(elementSize, \"; j++)\\n                    {\\n                        data[offset++] = v[t++];\\n                    }\\n                    offset += \").concat(remainder, \";\\n                }\\n\\n                \"));\n      } else {\n        var template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n        funcFragments.push(\"\\n                cv = ud.\".concat(name, \".value;\\n                v = uv.\").concat(name, \";\\n                offset = \").concat(uboElement.offset / 4, \";\\n                \").concat(template, \";\\n                \"));\n      }\n    }\n  }\n  funcFragments.push(\"\\n       renderer.buffer.update(buffer);\\n    \");\n  return {\n    size: size,\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", funcFragments.join(\"\\n\"))\n  };\n}\nexports.createUBOElements = createUBOElements;\nexports.generateUniformBufferSync = generateUniformBufferSync;\nexports.getUBOData = getUBOData;","map":{"version":3,"sources":["../../../src/shader/utils/generateUniformBufferSync.ts"],"names":["uniformParsers"],"mappings":"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","sourcesContent":["import type { Dict } from '@pixi/utils';\nimport { mapSize } from '../utils';\nimport type { IUniformData } from '../Program';\nimport type { UniformGroup } from '../UniformGroup';\nimport { uniformParsers } from './uniformParsers';\nimport type { Renderer } from '../../Renderer';\nimport type { Buffer } from '../../geometry/Buffer';\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n\nfunction uboUpdate(_ud: any, _uv: any, _renderer: Renderer, _syncData: any, buffer: Buffer): void\n{\n    _renderer.buffer.update(buffer);\n}\n\n// cv = CachedValue\n// v = value\n// ud = uniformData\n// uv = uniformValue\n// l = location\nconst UBO_TO_SINGLE_SETTERS: Dict<string> = {\n    float: `\n        data[offset] = v;\n    `,\n    vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n    vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n    vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n    mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n    mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n    mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n};\n\nconst GLSL_TO_STD40_SIZE: Dict<number> = {\n    float:  4,\n    vec2:   8,\n    vec3:   12,\n    vec4:   16,\n\n    int:      4,\n    ivec2:    8,\n    ivec3:    12,\n    ivec4:    16,\n\n    uint:     4,\n    uvec2:    8,\n    uvec3:    12,\n    uvec4:    16,\n\n    bool:     4,\n    bvec2:    8,\n    bvec3:    12,\n    bvec4:    16,\n\n    mat2:     16 * 2,\n    mat3:     16 * 3,\n    mat4:     16 * 4,\n};\n\ninterface UBOElement\n{\n    data: IUniformData\n    offset: number,\n    dataLen: number,\n    dirty: number\n}\n\n/**\n * logic originally from here: https://github.com/sketchpunk/FunWithWebGL2/blob/master/lesson_022/Shaders.js\n * rewrote it, but this was a great starting point to get a solid understanding of whats going on :)\n * @ignore\n * @param uniformData\n */\nexport function createUBOElements(uniformData: IUniformData[]): {uboElements: UBOElement[], size: number}\n{\n    const uboElements: UBOElement[] = uniformData.map((data: IUniformData) =>\n        ({\n            data,\n            offset: 0,\n            dataLen: 0,\n            dirty: 0\n        }));\n\n    let size = 0;\n    let chunkSize = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = GLSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, 16) * uboElement.data.size;\n        }\n\n        uboElement.dataLen = size;\n\n        // add some size offset..\n        // must align to the nearest 16 bytes or internally nearest round size\n\n        if (chunkSize % size !== 0 && chunkSize < 16)\n        {\n            // diff required to line up..\n            const lineUpValue = (chunkSize % size) % 16;\n\n            chunkSize += lineUpValue;\n            offset += lineUpValue;\n        }\n\n        if ((chunkSize + size) > 16)\n        {\n            offset = Math.ceil(offset / 16) * 16;\n            uboElement.offset = offset;\n            offset += size;\n            chunkSize = size;\n        }\n        else\n        {\n            uboElement.offset = offset;\n            chunkSize += size;\n            offset += size;\n        }\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\nexport function getUBOData(uniforms: Dict<any>, uniformData: Dict<any>): any[]\n{\n    const usedUniformDatas = [];\n\n    // build..\n    for (const i in uniforms)\n    {\n        if (uniformData[i])\n        {\n            usedUniformDatas.push(uniformData[i]);\n        }\n    }\n\n    // sort them out by index!\n    usedUniformDatas.sort((a, b) => a.index - b.index);\n\n    return usedUniformDatas;\n}\n\nexport function generateUniformBufferSync(\n    group: UniformGroup,\n    uniformData: Dict<any>\n): {size: number, syncFunc: UniformsSyncCallback}\n{\n    if (!group.autoManage)\n    {\n        // if the group is nott automatically managed, we don't need to generate a special function for it...\n        return { size: 0, syncFunc: uboUpdate };\n    }\n\n    const usedUniformDatas = getUBOData(group.uniforms, uniformData);\n\n    const { uboElements, size } = createUBOElements(usedUniformDatas);\n\n    const funcFragments = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `];\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n        const uniform = group.uniforms[uboElement.data.name];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform))\n            {\n                funcFragments.push(\n                    `offset = ${uboElement.offset / 4};`,\n                    uniformParsers[j].codeUbo(uboElement.data.name, uniform));\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                const size =  mapSize(uboElement.data.type);\n                const rowSize = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n                const elementSize = size / rowSize;\n                const remainder = (4 - (elementSize % 4)) % 4;\n\n                funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n\n                t = 0;\n\n                for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n                {\n                    for(var j = 0; j < ${elementSize}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${remainder};\n                }\n\n                `);\n            }\n            else\n            {\n                const template = UBO_TO_SINGLE_SETTERS[uboElement.data.type];\n\n                funcFragments.push(`\n                cv = ud.${name}.value;\n                v = uv.${name};\n                offset = ${uboElement.offset / 4};\n                ${template};\n                `);\n            }\n        }\n    }\n\n    funcFragments.push(`\n       renderer.buffer.update(buffer);\n    `);\n\n    return {\n        size,\n        // eslint-disable-next-line no-new-func\n        syncFunc: new Function(\n            'ud',\n            'uv',\n            'renderer',\n            'syncData',\n            'buffer',\n            funcFragments.join('\\n')\n        ) as UniformsSyncCallback\n    };\n}\n"]},"metadata":{},"sourceType":"script"}