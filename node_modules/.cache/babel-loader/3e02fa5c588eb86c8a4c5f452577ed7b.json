{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar typesystem_1 = require(\"../typesystem\");\nvar utils_1 = require(\"../../utils\");\nvar option_1 = require(\"./option\");\nvar primitive_1 = require(\"./primitive\");\nvar list_1 = require(\"./list\");\nvar struct_1 = require(\"./struct\");\nvar enum_1 = require(\"./enum\");\nvar tuple_1 = require(\"./tuple\");\nvar arrayVec_1 = require(\"./arrayVec\");\nvar BinaryCodec = /*#__PURE__*/function () {\n  function BinaryCodec() {\n    var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, BinaryCodec);\n    this.constraints = constraints || new BinaryCodecConstraints();\n    this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n    this.listCodec = new list_1.ListBinaryCodec(this);\n    this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n    this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n    this.structCodec = new struct_1.StructBinaryCodec(this);\n    this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n    this.enumCodec = new enum_1.EnumBinaryCodec(this);\n  }\n  _createClass(BinaryCodec, [{\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var _this = this;\n      this.constraints.checkBufferLength(buffer);\n      var typedValue = typesystem_1.onTypeSelect(type, {\n        onOption: function onOption() {\n          return _this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter());\n        },\n        onList: function onList() {\n          return _this.listCodec.decodeTopLevel(buffer, type);\n        },\n        onArray: function onArray() {\n          return _this.arrayCodec.decodeTopLevel(buffer, type);\n        },\n        onPrimitive: function onPrimitive() {\n          return _this.primitiveCodec.decodeTopLevel(buffer, type);\n        },\n        onStruct: function onStruct() {\n          return _this.structCodec.decodeTopLevel(buffer, type);\n        },\n        onTuple: function onTuple() {\n          return _this.tupleCodec.decodeTopLevel(buffer, type);\n        },\n        onEnum: function onEnum() {\n          return _this.enumCodec.decodeTopLevel(buffer, type);\n        }\n      });\n      return typedValue;\n    }\n  }, {\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var _this2 = this;\n      this.constraints.checkBufferLength(buffer);\n      var _typesystem_1$onTypeS = typesystem_1.onTypeSelect(type, {\n          onOption: function onOption() {\n            return _this2.optionCodec.decodeNested(buffer, type.getFirstTypeParameter());\n          },\n          onList: function onList() {\n            return _this2.listCodec.decodeNested(buffer, type);\n          },\n          onArray: function onArray() {\n            return _this2.arrayCodec.decodeNested(buffer, type);\n          },\n          onPrimitive: function onPrimitive() {\n            return _this2.primitiveCodec.decodeNested(buffer, type);\n          },\n          onStruct: function onStruct() {\n            return _this2.structCodec.decodeNested(buffer, type);\n          },\n          onTuple: function onTuple() {\n            return _this2.tupleCodec.decodeNested(buffer, type);\n          },\n          onEnum: function onEnum() {\n            return _this2.enumCodec.decodeNested(buffer, type);\n          }\n        }),\n        _typesystem_1$onTypeS2 = _slicedToArray(_typesystem_1$onTypeS, 2),\n        typedResult = _typesystem_1$onTypeS2[0],\n        decodedLength = _typesystem_1$onTypeS2[1];\n      return [typedResult, decodedLength];\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(typedValue) {\n      var _this3 = this;\n      utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n      return typesystem_1.onTypedValueSelect(typedValue, {\n        onPrimitive: function onPrimitive() {\n          return _this3.primitiveCodec.encodeNested(typedValue);\n        },\n        onOption: function onOption() {\n          return _this3.optionCodec.encodeNested(typedValue);\n        },\n        onList: function onList() {\n          return _this3.listCodec.encodeNested(typedValue);\n        },\n        onArray: function onArray() {\n          return _this3.arrayCodec.encodeNested(typedValue);\n        },\n        onStruct: function onStruct() {\n          return _this3.structCodec.encodeNested(typedValue);\n        },\n        onTuple: function onTuple() {\n          return _this3.tupleCodec.encodeNested(typedValue);\n        },\n        onEnum: function onEnum() {\n          return _this3.enumCodec.encodeNested(typedValue);\n        }\n      });\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(typedValue) {\n      var _this4 = this;\n      utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n      return typesystem_1.onTypedValueSelect(typedValue, {\n        onPrimitive: function onPrimitive() {\n          return _this4.primitiveCodec.encodeTopLevel(typedValue);\n        },\n        onOption: function onOption() {\n          return _this4.optionCodec.encodeTopLevel(typedValue);\n        },\n        onList: function onList() {\n          return _this4.listCodec.encodeTopLevel(typedValue);\n        },\n        onArray: function onArray() {\n          return _this4.arrayCodec.encodeTopLevel(typedValue);\n        },\n        onStruct: function onStruct() {\n          return _this4.structCodec.encodeTopLevel(typedValue);\n        },\n        onTuple: function onTuple() {\n          return _this4.tupleCodec.encodeTopLevel(typedValue);\n        },\n        onEnum: function onEnum() {\n          return _this4.enumCodec.encodeTopLevel(typedValue);\n        }\n      });\n    }\n  }]);\n  return BinaryCodec;\n}();\nexports.BinaryCodec = BinaryCodec;\nvar BinaryCodecConstraints = /*#__PURE__*/function () {\n  function BinaryCodecConstraints(init) {\n    _classCallCheck(this, BinaryCodecConstraints);\n    this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n    this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n  }\n  _createClass(BinaryCodecConstraints, [{\n    key: \"checkBufferLength\",\n    value: function checkBufferLength(buffer) {\n      if (buffer.length > this.maxBufferLength) {\n        throw new errors.ErrCodec(\"Buffer too large: \".concat(buffer.length, \" > \").concat(this.maxBufferLength));\n      }\n    }\n    /**\n     * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n     */\n  }, {\n    key: \"checkListLength\",\n    value: function checkListLength(length) {\n      if (length > this.maxListLength) {\n        throw new errors.ErrCodec(\"List too large: \".concat(length, \" > \").concat(this.maxListLength));\n      }\n    }\n  }]);\n  return BinaryCodecConstraints;\n}();\nexports.BinaryCodecConstraints = BinaryCodecConstraints;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/binary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"../../utils\");\nconst option_1 = require(\"./option\");\nconst primitive_1 = require(\"./primitive\");\nconst list_1 = require(\"./list\");\nconst struct_1 = require(\"./struct\");\nconst enum_1 = require(\"./enum\");\nconst tuple_1 = require(\"./tuple\");\nconst arrayVec_1 = require(\"./arrayVec\");\nclass BinaryCodec {\n    constructor(constraints = null) {\n        this.constraints = constraints || new BinaryCodecConstraints();\n        this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n        this.listCodec = new list_1.ListBinaryCodec(this);\n        this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n        this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n        this.structCodec = new struct_1.StructBinaryCodec(this);\n        this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n        this.enumCodec = new enum_1.EnumBinaryCodec(this);\n    }\n    decodeTopLevel(buffer, type) {\n        this.constraints.checkBufferLength(buffer);\n        let typedValue = typesystem_1.onTypeSelect(type, {\n            onOption: () => this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter()),\n            onList: () => this.listCodec.decodeTopLevel(buffer, type),\n            onArray: () => this.arrayCodec.decodeTopLevel(buffer, type),\n            onPrimitive: () => this.primitiveCodec.decodeTopLevel(buffer, type),\n            onStruct: () => this.structCodec.decodeTopLevel(buffer, type),\n            onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),\n            onEnum: () => this.enumCodec.decodeTopLevel(buffer, type),\n        });\n        return typedValue;\n    }\n    decodeNested(buffer, type) {\n        this.constraints.checkBufferLength(buffer);\n        let [typedResult, decodedLength] = typesystem_1.onTypeSelect(type, {\n            onOption: () => this.optionCodec.decodeNested(buffer, type.getFirstTypeParameter()),\n            onList: () => this.listCodec.decodeNested(buffer, type),\n            onArray: () => this.arrayCodec.decodeNested(buffer, type),\n            onPrimitive: () => this.primitiveCodec.decodeNested(buffer, type),\n            onStruct: () => this.structCodec.decodeNested(buffer, type),\n            onTuple: () => this.tupleCodec.decodeNested(buffer, type),\n            onEnum: () => this.enumCodec.decodeNested(buffer, type),\n        });\n        return [typedResult, decodedLength];\n    }\n    encodeNested(typedValue) {\n        utils_1.guardTrue(typedValue\n            .getType()\n            .getCardinality()\n            .isSingular(), \"singular cardinality, thus encodable type\");\n        return typesystem_1.onTypedValueSelect(typedValue, {\n            onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),\n            onOption: () => this.optionCodec.encodeNested(typedValue),\n            onList: () => this.listCodec.encodeNested(typedValue),\n            onArray: () => this.arrayCodec.encodeNested(typedValue),\n            onStruct: () => this.structCodec.encodeNested(typedValue),\n            onTuple: () => this.tupleCodec.encodeNested(typedValue),\n            onEnum: () => this.enumCodec.encodeNested(typedValue),\n        });\n    }\n    encodeTopLevel(typedValue) {\n        utils_1.guardTrue(typedValue\n            .getType()\n            .getCardinality()\n            .isSingular(), \"singular cardinality, thus encodable type\");\n        return typesystem_1.onTypedValueSelect(typedValue, {\n            onPrimitive: () => this.primitiveCodec.encodeTopLevel(typedValue),\n            onOption: () => this.optionCodec.encodeTopLevel(typedValue),\n            onList: () => this.listCodec.encodeTopLevel(typedValue),\n            onArray: () => this.arrayCodec.encodeTopLevel(typedValue),\n            onStruct: () => this.structCodec.encodeTopLevel(typedValue),\n            onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),\n            onEnum: () => this.enumCodec.encodeTopLevel(typedValue),\n        });\n    }\n}\nexports.BinaryCodec = BinaryCodec;\nclass BinaryCodecConstraints {\n    constructor(init) {\n        this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n        this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n    }\n    checkBufferLength(buffer) {\n        if (buffer.length > this.maxBufferLength) {\n            throw new errors.ErrCodec(`Buffer too large: ${buffer.length} > ${this.maxBufferLength}`);\n        }\n    }\n    /**\n     * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n     */\n    checkListLength(length) {\n        if (length > this.maxListLength) {\n            throw new errors.ErrCodec(`List too large: ${length} > ${this.maxListLength}`);\n        }\n    }\n}\nexports.BinaryCodecConstraints = BinaryCodecConstraints;\n//# sourceMappingURL=binary.js.map"]},"metadata":{},"sourceType":"script"}