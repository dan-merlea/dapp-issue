{"ast":null,"code":"import _classCallCheck from\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";/**\n * A class used to parse Tiled maps from JSON.\n */export var Map=/*#__PURE__*/function(){// Constructor\nfunction Map(data,fixedTileSize){var margin=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;var spacing=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;_classCallCheck(this,Map);this.margin=0;this.spacing=0;this.imageName='';// The image to slice up\nthis.tilesets={};this.collisions=[];this.spawners=[];this.layers=[];if(!data){throw Error('Map does not exist');}this.mapWidthUnits=data.width;this.mapHeightUnits=data.height;this.fixedTileSize=fixedTileSize;this.margin=margin;this.spacing=spacing;this.computeTileSets(data.tilesets);this.computeCollisions(data.layers);this.computeSpawners(data.layers);this.computeLayers(data.layers);}// Methods\n_createClass(Map,[{key:\"computeTileSets\",value:function computeTileSets(tilesets){var _this=this;if(!tilesets||!tilesets.length){return;}// We only take the first tileset\nvar foundTileset=tilesets[0];var offset=foundTileset.firstgid;// There is an offset needed to compute tileId in layers\nthis.imageName=foundTileset.image;// Compute the position of each sprite into the image\nvar tileWidth=foundTileset.tilewidth;var tileHeight=foundTileset.tileheight;var imageWidthInUnits=foundTileset.imagewidth/tileWidth;var col=0;var row=0;var x;var y;for(var i=0;i<foundTileset.tilecount;i++){var tileId=i+offset;x=col*(tileWidth+this.spacing)+this.margin;y=row*(tileHeight+this.spacing)+this.margin;this.tilesets[tileId]={tileId:tileId,minX:x,minY:y,maxX:x+tileWidth,maxY:y+tileHeight};col++;if(col===imageWidthInUnits){col=0;row++;}}// Compute special tiles\nfoundTileset.tiles.forEach(function(tile){var tileId=tile.id+offset;// Compute animated tiles\nif(tile.animation&&tile.animation.length>0){var animationId=tileId;var foundTile=_this.tilesets[animationId];if(foundTile){_this.tilesets[animationId].tileIds=tile.animation.map(function(frame){return frame.tileid+offset;});}}// Compute special tiles\nif(tile.type){_this.tilesets[tileId].type=tile.type;}});}},{key:\"computeCollisions\",value:function computeCollisions(layers){var foundLayer=layers.find(function(layer){return layer.name==='collisions';});if(!foundLayer){console.log('ERROR: Could not find the collisions layer');return;}this.collisions=this.parseLayer(foundLayer.data);}},{key:\"computeSpawners\",value:function computeSpawners(layers){var foundLayer=layers.find(function(layer){return layer.name==='spawners';});if(!foundLayer){return;}this.spawners=this.parseLayer(foundLayer.data);}},{key:\"computeLayers\",value:function computeLayers(layers){var _this2=this;if(!layers||!layers.length){return;}layers.forEach(function(layer){_this2.layers.push({name:layer.name,tiles:_this2.parseLayer(layer.data)});});}},{key:\"parseLayer\",value:function parseLayer(data){var _this3=this;if(!data||!data.length){return[];}var col=0;var row=0;var x=0;var y=0;var tileWidth=this.fixedTileSize;var tileHeight=this.fixedTileSize;var tiles=[];data.forEach(function(tileId){if(tileId!==0){var foundTile=_this3.tilesets[tileId];x=col*tileWidth;y=row*tileHeight;// Set the tile\ntiles.push(Object.assign({tileId:tileId,minX:x,minY:y,maxX:x+tileWidth,maxY:y+tileHeight},foundTile.type&&{type:foundTile.type}));}col++;// Jump to new line\nif(col===_this3.widthInUnits){col=0;row++;}});return tiles;}// Getters\n},{key:\"widthInUnits\",get:function get(){return this.mapWidthUnits;}},{key:\"heightInUnits\",get:function get(){return this.mapHeightUnits;}},{key:\"widthInPixels\",get:function get(){return this.mapWidthUnits*this.fixedTileSize;}},{key:\"heightInPixels\",get:function get(){return this.mapHeightUnits*this.fixedTileSize;}}]);return Map;}();","map":null,"metadata":{},"sourceType":"module"}