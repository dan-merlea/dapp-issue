{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\nfunction wrapU2FTransportError(originalError, message, id) {\n  var err = new TransportError(message, id); // $FlowFixMe\n\n  err.originalError = originalError;\n  return err;\n}\nfunction wrapApdu(apdu, key) {\n  var result = Buffer.alloc(apdu.length);\n  for (var i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n} // Convert from normal to web-safe, strip trailing \"=\"s\n\nvar webSafe64 = function webSafe64(base64) {\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}; // Convert from web-safe to normal, add trailing \"=\"s\n\nvar normal64 = function normal64(base64) {\n  return base64.replace(/-/g, \"+\").replace(/_/g, \"/\") + \"==\".substring(0, 3 * base64.length % 4);\n};\nfunction attemptExchange(apdu, timeoutMillis, scrambleKey, unwrap) {\n  var keyHandle = wrapApdu(apdu, scrambleKey);\n  var challenge = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  var signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then(function (response) {\n    var signatureData = response.signatureData;\n    if (typeof signatureData === \"string\") {\n      var data = Buffer.from(normal64(signatureData), \"base64\");\n      var result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\nvar transportInstances = [];\nfunction emitDisconnect() {\n  transportInstances.forEach(function (t) {\n    return t.emit(\"disconnect\");\n  });\n  transportInstances = [];\n}\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nvar TransportU2F = /*#__PURE__*/function (_Transport) {\n  _inherits(TransportU2F, _Transport);\n  var _super = _createSuper(TransportU2F);\n  function TransportU2F() {\n    var _this;\n    _classCallCheck(this, TransportU2F);\n    _this = _super.call(this);\n    _this.scrambleKey = void 0;\n    _this.unwrap = true;\n    transportInstances.push(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  _createClass(TransportU2F, [{\n    key: \"exchange\",\n    value: function () {\n      var _exchange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(apdu) {\n        var isU2FError;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return attemptExchange(apdu, this.exchangeTimeout, this.scrambleKey, this.unwrap);\n              case 3:\n                return _context.abrupt(\"return\", _context.sent);\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                isU2FError = typeof _context.t0.metaData === \"object\";\n                if (!isU2FError) {\n                  _context.next = 14;\n                  break;\n                }\n                if (isTimeoutU2FError(_context.t0)) {\n                  emitDisconnect();\n                } // the wrapping make error more usable and \"printable\" to the end user.\n                throw wrapU2FTransportError(_context.t0, \"Failed to sign with Ledger device: U2F \" + _context.t0.metaData.type, \"U2F_\" + _context.t0.metaData.code);\n              case 14:\n                throw _context.t0;\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n      function exchange(_x) {\n        return _exchange.apply(this, arguments);\n      }\n      return exchange;\n    }()\n    /**\n     */\n  }, {\n    key: \"setScrambleKey\",\n    value: function setScrambleKey(scrambleKey) {\n      this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n    }\n    /**\n     */\n  }, {\n    key: \"setUnwrap\",\n    value: function setUnwrap(unwrap) {\n      this.unwrap = unwrap;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // u2f have no way to clean things up\n      return Promise.resolve();\n    }\n  }], [{\n    key: \"open\",\n    value:\n    /*\n     */\n    /*\n     */\n    /**\n     * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n     */\n    function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_) {\n        var _openTimeout,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _openTimeout = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 5000;\n                return _context2.abrupt(\"return\", new TransportU2F());\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function open(_x2) {\n        return _open.apply(this, arguments);\n      }\n      return open;\n    }()\n  }]);\n  return TransportU2F;\n}(Transport);\nexport { TransportU2F as default };\nTransportU2F.isSupported = isSupported;\nTransportU2F.list = function () {\n  return (\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then(function (supported) {\n      return supported ? [null] : [];\n    })\n  );\n};\nTransportU2F.listen = function (observer) {\n  var unsubscribed = false;\n  isSupported().then(function (supported) {\n    if (unsubscribed) return;\n    if (supported) {\n      observer.next({\n        type: \"add\",\n        descriptor: null\n      });\n      observer.complete();\n    } else {\n      observer.error(new TransportError(\"U2F browser support is needed for Ledger. \" + \"Please use Chrome, Opera or Firefox with a U2F extension. \" + \"Also make sure you're on an HTTPS connection\", \"U2FNotSupported\"));\n    }\n  });\n  return {\n    unsubscribe: function unsubscribe() {\n      unsubscribed = true;\n    }\n  };\n};","map":{"version":3,"mappings":"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","names":["sign","isSupported","Transport","log","TransportError","wrapU2FTransportError","originalError","message","id","err","wrapApdu","apdu","key","result","Buffer","alloc","length","i","webSafe64","base64","replace","normal64","substring","attemptExchange","timeoutMillis","scrambleKey","unwrap","keyHandle","challenge","from","signRequest","version","toString","appId","location","origin","then","response","signatureData","data","slice","transportInstances","emitDisconnect","forEach","t","emit","isTimeoutU2FError","u2fError","metaData","code","TransportU2F","constructor","push","exchangeTimeout","isU2FError","e","type","setScrambleKey","setUnwrap","close","Promise","resolve","_","_openTimeout","list","supported","listen","observer","unsubscribed","next","descriptor","complete","error","unsubscribe"],"sources":["../src/TransportU2F.js"],"sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportError } from \"@ledgerhq/errors\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  scrambleKey: Buffer,\n  unwrap: boolean\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin,\n  };\n  log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n  return sign(signRequest, timeoutMillis / 1000).then((response) => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      let result;\n      if (!unwrap) {\n        result = data;\n      } else {\n        result = data.slice(5);\n      }\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach((t) => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  /*\n   */\n  static list = (): * =>\n    // this transport is not discoverable but we are going to guess if it is here with isSupported()\n    isSupported().then((supported) => (supported ? [null] : []));\n\n  /*\n   */\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then((supported) => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      },\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  unwrap: boolean = true;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.scrambleKey,\n        this.unwrap\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   */\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  /**\n   */\n  setUnwrap(unwrap: boolean) {\n    this.unwrap = unwrap;\n  }\n\n  close(): Promise<void> {\n    // u2f have no way to clean things up\n    return Promise.resolve();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}