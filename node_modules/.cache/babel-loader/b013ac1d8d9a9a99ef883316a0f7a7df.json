{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListBinaryCodec = void 0;\nvar typesystem_1 = require(\"../typesystem\");\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"List\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nvar ListBinaryCodec = /*#__PURE__*/function () {\n  function ListBinaryCodec(binaryCodec) {\n    _classCallCheck(this, ListBinaryCodec);\n    this.binaryCodec = binaryCodec;\n  }\n  _createClass(ListBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var typeParameter = type.getFirstTypeParameter();\n      var result = [];\n      var numItems = buffer.readUInt32BE(0);\n      this.binaryCodec.constraints.checkListLength(numItems);\n      var originalBuffer = buffer;\n      var offset = constants_1.SizeOfU32;\n      buffer = originalBuffer.slice(offset);\n      for (var i = 0; i < numItems; i++) {\n        var _this$binaryCodec$dec = this.binaryCodec.decodeNested(buffer, typeParameter),\n          _this$binaryCodec$dec2 = _slicedToArray(_this$binaryCodec$dec, 2),\n          decoded = _this$binaryCodec$dec2[0],\n          decodedLength = _this$binaryCodec$dec2[1];\n        result.push(decoded);\n        offset += decodedLength;\n        buffer = originalBuffer.slice(offset);\n      }\n      return [new typesystem_1.List(type, result), offset];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var typeParameter = type.getFirstTypeParameter();\n      var result = [];\n      var originalBuffer = buffer;\n      var offset = 0;\n      while (buffer.length > 0) {\n        var _this$binaryCodec$dec3 = this.binaryCodec.decodeNested(buffer, typeParameter),\n          _this$binaryCodec$dec4 = _slicedToArray(_this$binaryCodec$dec3, 2),\n          decoded = _this$binaryCodec$dec4[0],\n          decodedLength = _this$binaryCodec$dec4[1];\n        result.push(decoded);\n        offset += decodedLength;\n        buffer = originalBuffer.slice(offset);\n        this.binaryCodec.constraints.checkListLength(result.length);\n      }\n      return new typesystem_1.List(type, result);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(list) {\n      this.binaryCodec.constraints.checkListLength(list.getLength());\n      var lengthBuffer = Buffer.alloc(constants_1.SizeOfU32);\n      lengthBuffer.writeUInt32BE(list.getLength());\n      var itemsBuffers = [];\n      var _iterator = _createForOfIteratorHelper(list.getItems()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          var itemBuffer = this.binaryCodec.encodeNested(item);\n          itemsBuffers.push(itemBuffer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var buffer = Buffer.concat([lengthBuffer].concat(itemsBuffers));\n      return buffer;\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(list) {\n      this.binaryCodec.constraints.checkListLength(list.getLength());\n      var itemsBuffers = [];\n      var _iterator2 = _createForOfIteratorHelper(list.getItems()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          var itemBuffer = this.binaryCodec.encodeNested(item);\n          itemsBuffers.push(itemBuffer);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var buffer = Buffer.concat(itemsBuffers);\n      return buffer;\n    }\n  }]);\n  return ListBinaryCodec;\n}();\nexports.ListBinaryCodec = ListBinaryCodec;","map":{"version":3,"mappings":"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","names":["ListBinaryCodec","binaryCodec","buffer","type","typeParameter","getFirstTypeParameter","result","numItems","readUInt32BE","constraints","checkListLength","originalBuffer","offset","constants_1","slice","i","decodeNested","decoded","decodedLength","push","typesystem_1","length","list","getLength","lengthBuffer","Buffer","alloc","writeUInt32BE","itemsBuffers","getItems","item","itemBuffer","encodeNested","concat","exports"],"sourceRoot":"","sources":["../../../src/smartcontracts/codec/list.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}