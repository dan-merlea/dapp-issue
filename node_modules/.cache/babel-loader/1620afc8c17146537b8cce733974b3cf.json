{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar typesystem_1 = require(\"../typesystem\");\nvar utils_1 = require(\"../../utils\");\nvar option_1 = require(\"./option\");\nvar primitive_1 = require(\"./primitive\");\nvar list_1 = require(\"./list\");\nvar struct_1 = require(\"./struct\");\nvar enum_1 = require(\"./enum\");\nvar tuple_1 = require(\"./tuple\");\nvar arrayVec_1 = require(\"./arrayVec\");\nvar BinaryCodec = /*#__PURE__*/function () {\n  function BinaryCodec() {\n    var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    _classCallCheck(this, BinaryCodec);\n    this.constraints = constraints || new BinaryCodecConstraints();\n    this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n    this.listCodec = new list_1.ListBinaryCodec(this);\n    this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n    this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n    this.structCodec = new struct_1.StructBinaryCodec(this);\n    this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n    this.enumCodec = new enum_1.EnumBinaryCodec(this);\n  }\n  _createClass(BinaryCodec, [{\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var _this = this;\n      this.constraints.checkBufferLength(buffer);\n      var typedValue = typesystem_1.onTypeSelect(type, {\n        onOption: function onOption() {\n          return _this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter());\n        },\n        onList: function onList() {\n          return _this.listCodec.decodeTopLevel(buffer, type);\n        },\n        onArray: function onArray() {\n          return _this.arrayCodec.decodeTopLevel(buffer, type);\n        },\n        onPrimitive: function onPrimitive() {\n          return _this.primitiveCodec.decodeTopLevel(buffer, type);\n        },\n        onStruct: function onStruct() {\n          return _this.structCodec.decodeTopLevel(buffer, type);\n        },\n        onTuple: function onTuple() {\n          return _this.tupleCodec.decodeTopLevel(buffer, type);\n        },\n        onEnum: function onEnum() {\n          return _this.enumCodec.decodeTopLevel(buffer, type);\n        }\n      });\n      return typedValue;\n    }\n  }, {\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var _this2 = this;\n      this.constraints.checkBufferLength(buffer);\n      var _typesystem_1$onTypeS = typesystem_1.onTypeSelect(type, {\n          onOption: function onOption() {\n            return _this2.optionCodec.decodeNested(buffer, type.getFirstTypeParameter());\n          },\n          onList: function onList() {\n            return _this2.listCodec.decodeNested(buffer, type);\n          },\n          onArray: function onArray() {\n            return _this2.arrayCodec.decodeNested(buffer, type);\n          },\n          onPrimitive: function onPrimitive() {\n            return _this2.primitiveCodec.decodeNested(buffer, type);\n          },\n          onStruct: function onStruct() {\n            return _this2.structCodec.decodeNested(buffer, type);\n          },\n          onTuple: function onTuple() {\n            return _this2.tupleCodec.decodeNested(buffer, type);\n          },\n          onEnum: function onEnum() {\n            return _this2.enumCodec.decodeNested(buffer, type);\n          }\n        }),\n        _typesystem_1$onTypeS2 = _slicedToArray(_typesystem_1$onTypeS, 2),\n        typedResult = _typesystem_1$onTypeS2[0],\n        decodedLength = _typesystem_1$onTypeS2[1];\n      return [typedResult, decodedLength];\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(typedValue) {\n      var _this3 = this;\n      utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n      return typesystem_1.onTypedValueSelect(typedValue, {\n        onPrimitive: function onPrimitive() {\n          return _this3.primitiveCodec.encodeNested(typedValue);\n        },\n        onOption: function onOption() {\n          return _this3.optionCodec.encodeNested(typedValue);\n        },\n        onList: function onList() {\n          return _this3.listCodec.encodeNested(typedValue);\n        },\n        onArray: function onArray() {\n          return _this3.arrayCodec.encodeNested(typedValue);\n        },\n        onStruct: function onStruct() {\n          return _this3.structCodec.encodeNested(typedValue);\n        },\n        onTuple: function onTuple() {\n          return _this3.tupleCodec.encodeNested(typedValue);\n        },\n        onEnum: function onEnum() {\n          return _this3.enumCodec.encodeNested(typedValue);\n        }\n      });\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(typedValue) {\n      var _this4 = this;\n      utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n      return typesystem_1.onTypedValueSelect(typedValue, {\n        onPrimitive: function onPrimitive() {\n          return _this4.primitiveCodec.encodeTopLevel(typedValue);\n        },\n        onOption: function onOption() {\n          return _this4.optionCodec.encodeTopLevel(typedValue);\n        },\n        onList: function onList() {\n          return _this4.listCodec.encodeTopLevel(typedValue);\n        },\n        onArray: function onArray() {\n          return _this4.arrayCodec.encodeTopLevel(typedValue);\n        },\n        onStruct: function onStruct() {\n          return _this4.structCodec.encodeTopLevel(typedValue);\n        },\n        onTuple: function onTuple() {\n          return _this4.tupleCodec.encodeTopLevel(typedValue);\n        },\n        onEnum: function onEnum() {\n          return _this4.enumCodec.encodeTopLevel(typedValue);\n        }\n      });\n    }\n  }]);\n  return BinaryCodec;\n}();\nexports.BinaryCodec = BinaryCodec;\nvar BinaryCodecConstraints = /*#__PURE__*/function () {\n  function BinaryCodecConstraints(init) {\n    _classCallCheck(this, BinaryCodecConstraints);\n    this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n    this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n  }\n  _createClass(BinaryCodecConstraints, [{\n    key: \"checkBufferLength\",\n    value: function checkBufferLength(buffer) {\n      if (buffer.length > this.maxBufferLength) {\n        throw new errors.ErrCodec(\"Buffer too large: \".concat(buffer.length, \" > \").concat(this.maxBufferLength));\n      }\n    }\n    /**\n     * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n     */\n  }, {\n    key: \"checkListLength\",\n    value: function checkListLength(length) {\n      if (length > this.maxListLength) {\n        throw new errors.ErrCodec(\"List too large: \".concat(length, \" > \").concat(this.maxListLength));\n      }\n    }\n  }]);\n  return BinaryCodecConstraints;\n}();\nexports.BinaryCodecConstraints = BinaryCodecConstraints;","map":null,"metadata":{},"sourceType":"script"}