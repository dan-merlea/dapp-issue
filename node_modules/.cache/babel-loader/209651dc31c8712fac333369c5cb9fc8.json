{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Point, Polygon, State, settings, DRAW_MODES } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshBatchUvs } from './MeshBatchUvs.mjs';\nvar tempPoint = new Point();\nvar tempPolygon = new Polygon();\nvar _Mesh = /*#__PURE__*/function (_Container) {\n  _inherits(_Mesh, _Container);\n  var _super = _createSuper(_Mesh);\n  function _Mesh(geometry, shader, state) {\n    var _this;\n    var drawMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DRAW_MODES.TRIANGLES;\n    _classCallCheck(this, _Mesh);\n    _this = _super.call(this);\n    _this.geometry = geometry;\n    _this.shader = shader;\n    _this.state = state || State.for2d();\n    _this.drawMode = drawMode;\n    _this.start = 0;\n    _this.size = 0;\n    _this.uvs = null;\n    _this.indices = null;\n    _this.vertexData = new Float32Array(1);\n    _this.vertexDirty = -1;\n    _this._transformID = -1;\n    _this._roundPixels = settings.ROUND_PIXELS;\n    _this.batchUvs = null;\n    return _this;\n  }\n  _createClass(_Mesh, [{\n    key: \"geometry\",\n    get: function get() {\n      return this._geometry;\n    },\n    set: function set(value) {\n      if (this._geometry === value) {\n        return;\n      }\n      if (this._geometry) {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0) {\n          this._geometry.dispose();\n        }\n      }\n      this._geometry = value;\n      if (this._geometry) {\n        this._geometry.refCount++;\n      }\n      this.vertexDirty = -1;\n    }\n  }, {\n    key: \"uvBuffer\",\n    get: function get() {\n      return this.geometry.buffers[1];\n    }\n  }, {\n    key: \"verticesBuffer\",\n    get: function get() {\n      return this.geometry.buffers[0];\n    }\n  }, {\n    key: \"material\",\n    get: function get() {\n      return this.shader;\n    },\n    set: function set(value) {\n      this.shader = value;\n    }\n  }, {\n    key: \"blendMode\",\n    get: function get() {\n      return this.state.blendMode;\n    },\n    set: function set(value) {\n      this.state.blendMode = value;\n    }\n  }, {\n    key: \"roundPixels\",\n    get: function get() {\n      return this._roundPixels;\n    },\n    set: function set(value) {\n      if (this._roundPixels !== value) {\n        this._transformID = -1;\n      }\n      this._roundPixels = value;\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return \"tint\" in this.shader ? this.shader.tint : null;\n    },\n    set: function set(value) {\n      this.shader.tint = value;\n    }\n  }, {\n    key: \"texture\",\n    get: function get() {\n      return \"texture\" in this.shader ? this.shader.texture : null;\n    },\n    set: function set(value) {\n      this.shader.texture = value;\n    }\n  }, {\n    key: \"_render\",\n    value: function _render(renderer) {\n      var vertices = this.geometry.buffers[0].data;\n      var shader = this.shader;\n      if (shader.batchable && this.drawMode === DRAW_MODES.TRIANGLES && vertices.length < _Mesh.BATCHABLE_SIZE * 2) {\n        this._renderToBatch(renderer);\n      } else {\n        this._renderDefault(renderer);\n      }\n    }\n  }, {\n    key: \"_renderDefault\",\n    value: function _renderDefault(renderer) {\n      var shader = this.shader;\n      shader.alpha = this.worldAlpha;\n      if (shader.update) {\n        shader.update();\n      }\n      renderer.batch.flush();\n      shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n      renderer.shader.bind(shader);\n      renderer.state.set(this.state);\n      renderer.geometry.bind(this.geometry, shader);\n      renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n  }, {\n    key: \"_renderToBatch\",\n    value: function _renderToBatch(renderer) {\n      var geometry = this.geometry;\n      var shader = this.shader;\n      if (shader.uvMatrix) {\n        shader.uvMatrix.update();\n        this.calculateUvs();\n      }\n      this.calculateVertices();\n      this.indices = geometry.indexBuffer.data;\n      this._tintRGB = shader._tintRGB;\n      this._texture = shader.texture;\n      var pluginName = this.material.pluginName;\n      renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n      renderer.plugins[pluginName].render(this);\n    }\n  }, {\n    key: \"calculateVertices\",\n    value: function calculateVertices() {\n      var geometry = this.geometry;\n      var verticesBuffer = geometry.buffers[0];\n      var vertices = verticesBuffer.data;\n      var vertexDirtyId = verticesBuffer._updateID;\n      if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {\n        return;\n      }\n      this._transformID = this.transform._worldID;\n      if (this.vertexData.length !== vertices.length) {\n        this.vertexData = new Float32Array(vertices.length);\n      }\n      var wt = this.transform.worldTransform;\n      var a = wt.a;\n      var b = wt.b;\n      var c = wt.c;\n      var d = wt.d;\n      var tx = wt.tx;\n      var ty = wt.ty;\n      var vertexData = this.vertexData;\n      for (var i = 0; i < vertexData.length / 2; i++) {\n        var x = vertices[i * 2];\n        var y = vertices[i * 2 + 1];\n        vertexData[i * 2] = a * x + c * y + tx;\n        vertexData[i * 2 + 1] = b * x + d * y + ty;\n      }\n      if (this._roundPixels) {\n        var resolution = settings.RESOLUTION;\n        for (var _i = 0; _i < vertexData.length; ++_i) {\n          vertexData[_i] = Math.round((vertexData[_i] * resolution | 0) / resolution);\n        }\n      }\n      this.vertexDirty = vertexDirtyId;\n    }\n  }, {\n    key: \"calculateUvs\",\n    value: function calculateUvs() {\n      var geomUvs = this.geometry.buffers[1];\n      var shader = this.shader;\n      if (!shader.uvMatrix.isSimple) {\n        if (!this.batchUvs) {\n          this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n        }\n        this.batchUvs.update();\n        this.uvs = this.batchUvs.data;\n      } else {\n        this.uvs = geomUvs.data;\n      }\n    }\n  }, {\n    key: \"_calculateBounds\",\n    value: function _calculateBounds() {\n      this.calculateVertices();\n      this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      if (!this.getBounds().contains(point.x, point.y)) {\n        return false;\n      }\n      this.worldTransform.applyInverse(point, tempPoint);\n      var vertices = this.geometry.getBuffer(\"aVertexPosition\").data;\n      var points = tempPolygon.points;\n      var indices = this.geometry.getIndex().data;\n      var len = indices.length;\n      var step = this.drawMode === 4 ? 3 : 1;\n      for (var i = 0; i + 2 < len; i += step) {\n        var ind0 = indices[i] * 2;\n        var ind1 = indices[i + 1] * 2;\n        var ind2 = indices[i + 2] * 2;\n        points[0] = vertices[ind0];\n        points[1] = vertices[ind0 + 1];\n        points[2] = vertices[ind1];\n        points[3] = vertices[ind1 + 1];\n        points[4] = vertices[ind2];\n        points[5] = vertices[ind2 + 1];\n        if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      _get(_getPrototypeOf(_Mesh.prototype), \"destroy\", this).call(this, options);\n      if (this._cachedTexture) {\n        this._cachedTexture.destroy();\n        this._cachedTexture = null;\n      }\n      this.geometry = null;\n      this.shader = null;\n      this.state = null;\n      this.uvs = null;\n      this.indices = null;\n      this.vertexData = null;\n    }\n  }]);\n  return _Mesh;\n}(Container);\nvar Mesh = _Mesh;\nMesh.BATCHABLE_SIZE = 100;\nexport { Mesh };","map":{"version":3,"sources":["../src/Mesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { State, DRAW_MODES, settings, Point, Polygon } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { MeshBatchUvs } from './MeshBatchUvs';\n\nimport type { MeshMaterial } from './MeshMaterial';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { BLEND_MODES, IPointData, Texture, Renderer, Geometry, Buffer, Shader } from '@pixi/core';\n\nconst tempPoint = new Point();\nconst tempPolygon = new Polygon();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Mesh extends GlobalMixins.Mesh {}\n\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL visuals you can think of.\n * This class assumes a certain level of WebGL knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof PIXI\n */\nexport class Mesh<T extends Shader = MeshMaterial> extends Container\n{\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     * @type {PIXI.Shader|PIXI.MeshMaterial}\n     */\n    public shader: T;\n\n    /**\n     * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    public state: State;\n\n    /** The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants. */\n    public drawMode: DRAW_MODES;\n\n    /**\n     * Typically the index of the IndexBuffer where to start drawing.\n     * @default 0\n     */\n    public start: number;\n\n    /**\n     * How much of the geometry to draw, by default `0` renders everything.\n     * @default 0\n     */\n    public size: number;\n\n    private _geometry: Geometry;\n\n    /** This is the caching layer used by the batcher. */\n    private vertexData: Float32Array;\n\n    /** If geometry is changed used to decide to re-transform the vertexData. */\n    private vertexDirty: number;\n    private _transformID: number;\n\n    /** Internal roundPixels field. */\n    private _roundPixels: boolean;\n\n    /** Batched UV's are cached for atlas textures. */\n    private batchUvs: MeshBatchUvs;\n\n    // Internal-only properties\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    uvs: Float32Array;\n\n    /**\n     * These are used as easy access for batching.\n     * @private\n     */\n    indices: Uint16Array;\n    _tintRGB: number;\n    _texture: Texture;\n\n    /**\n     * @param geometry - The geometry the mesh will use.\n     * @param {PIXI.MeshMaterial} shader - The shader the mesh will use.\n     * @param state - The state that the WebGL context is required to be in to render the mesh\n     *        if no state is provided, uses {@link PIXI.State.for2d} to create a 2D state for PixiJS.\n     * @param drawMode - The drawMode, can be any of the {@link PIXI.DRAW_MODES} constants.\n     */\n    constructor(geometry: Geometry, shader: T, state?: State, drawMode: DRAW_MODES = DRAW_MODES.TRIANGLES)\n    {\n        super();\n\n        this.geometry = geometry;\n        this.shader = shader;\n        this.state = state || State.for2d();\n        this.drawMode = drawMode;\n        this.start = 0;\n        this.size = 0;\n\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = new Float32Array(1);\n        this.vertexDirty = -1;\n\n        this._transformID = -1;\n        this._roundPixels = settings.ROUND_PIXELS;\n        this.batchUvs = null;\n    }\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    get geometry(): Geometry\n    {\n        return this._geometry;\n    }\n\n    set geometry(value: Geometry)\n    {\n        if (this._geometry === value)\n        {\n            return;\n        }\n\n        if (this._geometry)\n        {\n            this._geometry.refCount--;\n\n            if (this._geometry.refCount === 0)\n            {\n                this._geometry.dispose();\n            }\n        }\n\n        this._geometry = value;\n\n        if (this._geometry)\n        {\n            this._geometry.refCount++;\n        }\n\n        this.vertexDirty = -1;\n    }\n\n    /**\n     * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n     * @readonly\n     */\n    get uvBuffer(): Buffer\n    {\n        return this.geometry.buffers[1];\n    }\n\n    /**\n     * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n     * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n     * @readonly\n     */\n    get verticesBuffer(): Buffer\n    {\n        return this.geometry.buffers[0];\n    }\n\n    /** Alias for {@link PIXI.Mesh#shader}. */\n    set material(value: T)\n    {\n        this.shader = value;\n    }\n\n    get material(): T\n    {\n        return this.shader;\n    }\n\n    /**\n     * The blend mode to be applied to the Mesh. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL;\n     */\n    set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default false\n     */\n    set roundPixels(value: boolean)\n    {\n        if (this._roundPixels !== value)\n        {\n            this._transformID = -1;\n        }\n        this._roundPixels = value;\n    }\n\n    get roundPixels(): boolean\n    {\n        return this._roundPixels;\n    }\n\n    /**\n     * The multiply tint applied to the Mesh. This is a hex value. A value of\n     * `0xFFFFFF` will remove any tint effect.\n     *\n     * Null for non-MeshMaterial shaders\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        return 'tint' in this.shader ? (this.shader as unknown as MeshMaterial).tint : null;\n    }\n\n    set tint(value: number)\n    {\n        (this.shader as unknown as MeshMaterial).tint = value;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    get texture(): Texture\n    {\n        return 'texture' in this.shader ? (this.shader as unknown as MeshMaterial).texture : null;\n    }\n\n    set texture(value: Texture)\n    {\n        (this.shader as unknown as MeshMaterial).texture = value;\n    }\n\n    /**\n     * Standard renderer draw.\n     * @param renderer - Instance to renderer.\n     */\n    protected _render(renderer: Renderer): void\n    {\n        // set properties for batching..\n        // TODO could use a different way to grab verts?\n        const vertices = this.geometry.buffers[0].data;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        // TODO benchmark check for attribute size..\n        if (\n            shader.batchable\n            && this.drawMode === DRAW_MODES.TRIANGLES\n            && vertices.length < Mesh.BATCHABLE_SIZE * 2\n        )\n        {\n            this._renderToBatch(renderer);\n        }\n        else\n        {\n            this._renderDefault(renderer);\n        }\n    }\n\n    /**\n     * Standard non-batching way of rendering.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderDefault(renderer: Renderer): void\n    {\n        const shader = this.shader as unknown as MeshMaterial;\n\n        shader.alpha = this.worldAlpha;\n        if (shader.update)\n        {\n            shader.update();\n        }\n\n        renderer.batch.flush();\n\n        // bind and sync uniforms..\n        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);\n        renderer.shader.bind(shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // bind the geometry...\n        renderer.geometry.bind(this.geometry, shader);\n\n        // then render it\n        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }\n\n    /**\n     * Rendering by using the Batch system.\n     * @param renderer - Instance to renderer.\n     */\n    protected _renderToBatch(renderer: Renderer): void\n    {\n        const geometry = this.geometry;\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (shader.uvMatrix)\n        {\n            shader.uvMatrix.update();\n            this.calculateUvs();\n        }\n\n        // set properties for batching..\n        this.calculateVertices();\n        this.indices = geometry.indexBuffer.data as Uint16Array;\n        this._tintRGB = shader._tintRGB;\n        this._texture = shader.texture;\n\n        const pluginName = (this.material as unknown as MeshMaterial).pluginName;\n\n        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);\n        renderer.plugins[pluginName].render(this);\n    }\n\n    /** Updates vertexData field based on transform and vertices. */\n    public calculateVertices(): void\n    {\n        const geometry = this.geometry;\n        const verticesBuffer = geometry.buffers[0];\n        const vertices = verticesBuffer.data;\n        const vertexDirtyId = verticesBuffer._updateID;\n\n        if (vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID)\n        {\n            return;\n        }\n\n        this._transformID = this.transform._worldID;\n\n        if (this.vertexData.length !== vertices.length)\n        {\n            this.vertexData = new Float32Array(vertices.length);\n        }\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const vertexData = this.vertexData;\n\n        for (let i = 0; i < vertexData.length / 2; i++)\n        {\n            const x = vertices[(i * 2)];\n            const y = vertices[(i * 2) + 1];\n\n            vertexData[(i * 2)] = (a * x) + (c * y) + tx;\n            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;\n        }\n\n        if (this._roundPixels)\n        {\n            const resolution = settings.RESOLUTION;\n\n            for (let i = 0; i < vertexData.length; ++i)\n            {\n                vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);\n            }\n        }\n\n        this.vertexDirty = vertexDirtyId;\n    }\n\n    /** Updates uv field based on from geometry uv's or batchUvs. */\n    public calculateUvs(): void\n    {\n        const geomUvs = this.geometry.buffers[1];\n        const shader = this.shader as unknown as MeshMaterial;\n\n        if (!shader.uvMatrix.isSimple)\n        {\n            if (!this.batchUvs)\n            {\n                this.batchUvs = new MeshBatchUvs(geomUvs, shader.uvMatrix);\n            }\n            this.batchUvs.update();\n            this.uvs = this.batchUvs.data;\n        }\n        else\n        {\n            this.uvs = geomUvs.data as Float32Array;\n        }\n    }\n\n    /**\n     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.\n     */\n    protected _calculateBounds(): void\n    {\n        this.calculateVertices();\n\n        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.\n     * @param point - The point to test.\n     * @returns - The result of the test.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.geometry.getBuffer('aVertexPosition').data;\n\n        const points = tempPolygon.points;\n        const indices =  this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.drawMode === 4 ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        if (this._cachedTexture)\n        {\n            this._cachedTexture.destroy();\n            this._cachedTexture = null;\n        }\n\n        this.geometry = null;\n        this.shader = null;\n        this.state = null;\n        this.uvs = null;\n        this.indices = null;\n        this.vertexData = null;\n    }\n\n    /** The maximum number of vertices to consider batchable. Generally, the complexity of the geometry. */\n    public static BATCHABLE_SIZE = 100;\n}\n"]},"metadata":{},"sourceType":"module"}