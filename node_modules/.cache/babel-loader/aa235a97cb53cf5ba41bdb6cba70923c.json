{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { GLBuffer } from './GLBuffer.mjs';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nvar BufferSystem = /*#__PURE__*/function () {\n  function BufferSystem(renderer) {\n    _classCallCheck(this, BufferSystem);\n    this.renderer = renderer;\n    this.managedBuffers = {};\n    this.boundBufferBases = {};\n  }\n  _createClass(BufferSystem, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }, {\n    key: \"contextChange\",\n    value: function contextChange() {\n      this.disposeAll(true);\n      this.gl = this.renderer.gl;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(buffer) {\n      var gl = this.gl,\n        CONTEXT_UID = this.CONTEXT_UID;\n      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      gl.bindBuffer(buffer.type, glBuffer.buffer);\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(type) {\n      var gl = this.gl;\n      gl.bindBuffer(type, null);\n    }\n  }, {\n    key: \"bindBufferBase\",\n    value: function bindBufferBase(buffer, index) {\n      var gl = this.gl,\n        CONTEXT_UID = this.CONTEXT_UID;\n      if (this.boundBufferBases[index] !== buffer) {\n        var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n        this.boundBufferBases[index] = buffer;\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n      }\n    }\n  }, {\n    key: \"bindBufferRange\",\n    value: function bindBufferRange(buffer, index, offset) {\n      var gl = this.gl,\n        CONTEXT_UID = this.CONTEXT_UID;\n      offset = offset || 0;\n      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n  }, {\n    key: \"update\",\n    value: function update(buffer) {\n      var gl = this.gl,\n        CONTEXT_UID = this.CONTEXT_UID;\n      var glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n      if (buffer._updateID === glBuffer.updateID) {\n        return;\n      }\n      glBuffer.updateID = buffer._updateID;\n      gl.bindBuffer(buffer.type, glBuffer.buffer);\n      if (glBuffer.byteLength >= buffer.data.byteLength) {\n        gl.bufferSubData(buffer.type, 0, buffer.data);\n      } else {\n        var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n        glBuffer.byteLength = buffer.data.byteLength;\n        gl.bufferData(buffer.type, buffer.data, drawType);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose(buffer, contextLost) {\n      if (!this.managedBuffers[buffer.id]) {\n        return;\n      }\n      delete this.managedBuffers[buffer.id];\n      var glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n      var gl = this.gl;\n      buffer.disposeRunner.remove(this);\n      if (!glBuffer) {\n        return;\n      }\n      if (!contextLost) {\n        gl.deleteBuffer(glBuffer.buffer);\n      }\n      delete buffer._glBuffers[this.CONTEXT_UID];\n    }\n  }, {\n    key: \"disposeAll\",\n    value: function disposeAll(contextLost) {\n      var all = Object.keys(this.managedBuffers);\n      for (var i = 0; i < all.length; i++) {\n        this.dispose(this.managedBuffers[all[i]], contextLost);\n      }\n    }\n  }, {\n    key: \"createGLBuffer\",\n    value: function createGLBuffer(buffer) {\n      var CONTEXT_UID = this.CONTEXT_UID,\n        gl = this.gl;\n      buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n      this.managedBuffers[buffer.id] = buffer;\n      buffer.disposeRunner.add(this);\n      return buffer._glBuffers[CONTEXT_UID];\n    }\n  }]);\n  return BufferSystem;\n}();\nBufferSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"buffer\"\n};\nextensions.add(BufferSystem);\nexport { BufferSystem };","map":{"version":3,"sources":["../../src/geometry/BufferSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { GLBuffer } from './GLBuffer';\n\nimport type { Renderer } from '../Renderer';\nimport type { Buffer } from './Buffer';\nimport type { ISystem } from '../system/ISystem';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport type { BUFFER_TYPE } from '@pixi/constants';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the PIXI.Buffer class.\n * @class\n * @memberof PIXI\n */\nexport class BufferSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'buffer',\n    };\n\n    CONTEXT_UID: number;\n    gl: IRenderingContext;\n\n    /** Cache for all buffers by id, used in case renderer gets destroyed or for profiling */\n    readonly managedBuffers: {[key: number]: Buffer};\n\n    /** Cache keeping track of the base bound buffer bases */\n    readonly boundBufferBases: {[key: number]: Buffer};\n\n    private renderer: Renderer;\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.managedBuffers = {};\n        this.boundBufferBases = {};\n    }\n\n    /**\n     * @ignore\n     */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        this.gl = this.renderer.gl;\n\n        // TODO fill out...\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    bind(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n    }\n\n    unbind(type: BUFFER_TYPE): void\n    {\n        const { gl } = this;\n\n        gl.bindBuffer(type, null);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    bindBufferBase(buffer: Buffer, index: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        if (this.boundBufferBases[index] !== buffer)\n        {\n            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n            this.boundBufferBases[index] = buffer;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     */\n    bindBufferRange(buffer: Buffer, index?: number, offset?: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        offset = offset || 0;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {PIXI.Buffer} buffer - the buffer to update\n     */\n    update(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n\n        if (glBuffer.byteLength >= buffer.data.byteLength)\n        {\n            // offset is always zero for now!\n            gl.bufferSubData(buffer.type, 0, buffer.data);\n        }\n        else\n        {\n            const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n            glBuffer.byteLength = buffer.data.byteLength;\n            gl.bufferData(buffer.type, buffer.data, drawType);\n        }\n    }\n\n    /**\n     * Disposes buffer\n     * @param {PIXI.Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    dispose(buffer: Buffer, contextLost?: boolean): void\n    {\n        if (!this.managedBuffers[buffer.id])\n        {\n            return;\n        }\n\n        delete this.managedBuffers[buffer.id];\n\n        const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n        const gl = this.gl;\n\n        buffer.disposeRunner.remove(this);\n\n        if (!glBuffer)\n        {\n            return;\n        }\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        delete buffer._glBuffers[this.CONTEXT_UID];\n    }\n\n    /**\n     * dispose all WebGL resources of all managed buffers\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedBuffers);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.dispose(this.managedBuffers[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GLBuffer\n    {\n        const { CONTEXT_UID, gl } = this;\n\n        buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n\n        this.managedBuffers[buffer.id] = buffer;\n\n        buffer.disposeRunner.add(this);\n\n        return buffer._glBuffers[CONTEXT_UID];\n    }\n}\n\nextensions.add(BufferSystem);\n"]},"metadata":{},"sourceType":"module"}