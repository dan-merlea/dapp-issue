{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResultsParser = void 0;\nvar transaction_decoder_1 = require(\"@elrondnetwork/transaction-decoder\");\nvar address_1 = require(\"../address\");\nvar errors_1 = require(\"../errors\");\nvar logger_1 = require(\"../logger\");\nvar argSerializer_1 = require(\"./argSerializer\");\nvar returnCode_1 = require(\"./returnCode\");\nvar WellKnownEvents;\n(function (WellKnownEvents) {\n  WellKnownEvents[\"OnTransactionCompleted\"] = \"completedTxEvent\";\n  WellKnownEvents[\"OnSignalError\"] = \"signalError\";\n  WellKnownEvents[\"OnWriteLog\"] = \"writeLog\";\n})(WellKnownEvents || (WellKnownEvents = {}));\nvar WellKnownTopics;\n(function (WellKnownTopics) {\n  WellKnownTopics[\"TooMuchGas\"] = \"@too much gas provided for processing\";\n})(WellKnownTopics || (WellKnownTopics = {}));\n/**\n * Parses contract query responses and smart contract results.\n * The parsing involves some heuristics, in order to handle slight inconsistencies (e.g. some SCRs are present on API, but missing on Gateway).\n */\nvar ResultsParser = /*#__PURE__*/function () {\n  function ResultsParser() {\n    _classCallCheck(this, ResultsParser);\n  }\n  _createClass(ResultsParser, [{\n    key: \"parseQueryResponse\",\n    value: function parseQueryResponse(queryResponse, endpoint) {\n      var parts = queryResponse.getReturnDataParts();\n      var values = new argSerializer_1.ArgSerializer().buffersToValues(parts, endpoint.output);\n      var returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n      return {\n        returnCode: returnCode,\n        returnMessage: queryResponse.returnMessage,\n        values: values,\n        firstValue: values[0],\n        secondValue: values[1],\n        thirdValue: values[2],\n        lastValue: values[values.length - 1]\n      };\n    }\n  }, {\n    key: \"parseUntypedQueryResponse\",\n    value: function parseUntypedQueryResponse(queryResponse) {\n      var returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n      return {\n        returnCode: returnCode,\n        returnMessage: queryResponse.returnMessage,\n        values: queryResponse.getReturnDataParts()\n      };\n    }\n  }, {\n    key: \"parseOutcome\",\n    value: function parseOutcome(transaction, endpoint) {\n      var untypedBundle = this.parseUntypedOutcome(transaction);\n      var values = new argSerializer_1.ArgSerializer().buffersToValues(untypedBundle.values, endpoint.output);\n      return {\n        returnCode: untypedBundle.returnCode,\n        returnMessage: untypedBundle.returnMessage,\n        values: values,\n        firstValue: values[0],\n        secondValue: values[1],\n        thirdValue: values[2],\n        lastValue: values[values.length - 1]\n      };\n    }\n  }, {\n    key: \"parseUntypedOutcome\",\n    value: function parseUntypedOutcome(transaction) {\n      var bundle;\n      var transactionMetadata = this.parseTransactionMetadata(transaction);\n      bundle = this.createBundleOnSimpleMoveBalance(transaction);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on simple move balance\");\n        return bundle;\n      }\n      bundle = this.createBundleOnInvalidTransaction(transaction);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on invalid transaction\");\n        return bundle;\n      }\n      bundle = this.createBundleOnEasilyFoundResultWithReturnData(transaction.contractResults);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on easily found result with return data\");\n        return bundle;\n      }\n      bundle = this.createBundleOnSignalError(transaction.logs);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on signal error\");\n        return bundle;\n      }\n      bundle = this.createBundleOnTooMuchGasWarning(transaction.logs);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on 'too much gas' warning\");\n        return bundle;\n      }\n      bundle = this.createBundleOnWriteLogWhereFirstTopicEqualsAddress(transaction.logs, transaction.sender);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on writelog with topics[0] == tx.sender\");\n        return bundle;\n      }\n      bundle = this.createBundleWithCustomHeuristics(transaction, transactionMetadata);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): with custom heuristics\");\n        return bundle;\n      }\n      bundle = this.createBundleWithFallbackHeuristics(transaction, transactionMetadata);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): with fallback heuristics\");\n        return bundle;\n      }\n      throw new errors_1.ErrCannotParseContractResults(\"transaction \".concat(transaction.hash.toString()));\n    }\n  }, {\n    key: \"parseTransactionMetadata\",\n    value: function parseTransactionMetadata(transaction) {\n      return new transaction_decoder_1.TransactionDecoder().getTransactionMetadata({\n        sender: transaction.sender.bech32(),\n        receiver: transaction.receiver.bech32(),\n        data: transaction.data.toString(\"base64\"),\n        value: transaction.value.toString(),\n        type: transaction.type\n      });\n    }\n  }, {\n    key: \"createBundleOnSimpleMoveBalance\",\n    value: function createBundleOnSimpleMoveBalance(transaction) {\n      var noResults = transaction.contractResults.items.length == 0;\n      var noLogs = transaction.logs.events.length == 0;\n      if (noResults && noLogs) {\n        return {\n          returnCode: returnCode_1.ReturnCode.None,\n          returnMessage: returnCode_1.ReturnCode.None.toString(),\n          values: []\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"createBundleOnInvalidTransaction\",\n    value: function createBundleOnInvalidTransaction(transaction) {\n      if (transaction.status.isInvalid()) {\n        if (transaction.receipt.data) {\n          return {\n            returnCode: returnCode_1.ReturnCode.OutOfFunds,\n            returnMessage: transaction.receipt.data,\n            values: []\n          };\n        }\n        // If there's no receipt message, let other heuristics to handle the outcome (most probably, a log with \"signalError\" is emitted).\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createBundleOnEasilyFoundResultWithReturnData\",\n    value: function createBundleOnEasilyFoundResultWithReturnData(results) {\n      var resultItemWithReturnData = results.items.find(function (item) {\n        return item.nonce.valueOf() != 0 && item.data.startsWith(\"@\");\n      });\n      if (!resultItemWithReturnData) {\n        return null;\n      }\n      var _this$sliceDataFieldI = this.sliceDataFieldInParts(resultItemWithReturnData.data),\n        returnCode = _this$sliceDataFieldI.returnCode,\n        returnDataParts = _this$sliceDataFieldI.returnDataParts;\n      var returnMessage = resultItemWithReturnData.returnMessage || returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n  }, {\n    key: \"createBundleOnSignalError\",\n    value: function createBundleOnSignalError(logs) {\n      var eventSignalError = logs.findSingleOrNoneEvent(WellKnownEvents.OnSignalError);\n      if (!eventSignalError) {\n        return null;\n      }\n      var _this$sliceDataFieldI2 = this.sliceDataFieldInParts(eventSignalError.data),\n        returnCode = _this$sliceDataFieldI2.returnCode,\n        returnDataParts = _this$sliceDataFieldI2.returnDataParts;\n      var lastTopic = eventSignalError.getLastTopic();\n      var returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n  }, {\n    key: \"createBundleOnTooMuchGasWarning\",\n    value: function createBundleOnTooMuchGasWarning(logs) {\n      var eventTooMuchGas = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, function (event) {\n        return event.findFirstOrNoneTopic(function (topic) {\n          return topic.toString().startsWith(WellKnownTopics.TooMuchGas);\n        }) != undefined;\n      });\n      if (!eventTooMuchGas) {\n        return null;\n      }\n      var _this$sliceDataFieldI3 = this.sliceDataFieldInParts(eventTooMuchGas.data),\n        returnCode = _this$sliceDataFieldI3.returnCode,\n        returnDataParts = _this$sliceDataFieldI3.returnDataParts;\n      var lastTopic = eventTooMuchGas.getLastTopic();\n      var returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n  }, {\n    key: \"createBundleOnWriteLogWhereFirstTopicEqualsAddress\",\n    value: function createBundleOnWriteLogWhereFirstTopicEqualsAddress(logs, address) {\n      var hexAddress = new address_1.Address(address.bech32()).hex();\n      var eventWriteLogWhereTopicIsSender = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, function (event) {\n        return event.findFirstOrNoneTopic(function (topic) {\n          return topic.hex() == hexAddress;\n        }) != undefined;\n      });\n      if (!eventWriteLogWhereTopicIsSender) {\n        return null;\n      }\n      var _this$sliceDataFieldI4 = this.sliceDataFieldInParts(eventWriteLogWhereTopicIsSender.data),\n        returnCode = _this$sliceDataFieldI4.returnCode,\n        returnDataParts = _this$sliceDataFieldI4.returnDataParts;\n      var returnMessage = returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n    /**\n     * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.\n     */\n  }, {\n    key: \"createBundleWithCustomHeuristics\",\n    value: function createBundleWithCustomHeuristics(_transaction, _transactionMetadata) {\n      return null;\n    }\n  }, {\n    key: \"createBundleWithFallbackHeuristics\",\n    value: function createBundleWithFallbackHeuristics(transaction, transactionMetadata) {\n      var contractAddress = new address_1.Address(transactionMetadata.receiver);\n      // Search the nested logs for matching events (writeLog):\n      var _iterator = _createForOfIteratorHelper(transaction.contractResults.items),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var resultItem = _step.value;\n          var writeLogWithReturnData = resultItem.logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, function (event) {\n            var _a;\n            var addressIsSender = event.address.bech32() == transaction.sender.bech32();\n            var firstTopicIsContract = ((_a = event.topics[0]) === null || _a === void 0 ? void 0 : _a.hex()) == contractAddress.hex();\n            return addressIsSender && firstTopicIsContract;\n          });\n          if (writeLogWithReturnData) {\n            var _this$sliceDataFieldI5 = this.sliceDataFieldInParts(writeLogWithReturnData.data),\n              returnCode = _this$sliceDataFieldI5.returnCode,\n              returnDataParts = _this$sliceDataFieldI5.returnDataParts;\n            var returnMessage = returnCode.toString();\n            return {\n              returnCode: returnCode,\n              returnMessage: returnMessage,\n              values: returnDataParts\n            };\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return null;\n    }\n  }, {\n    key: \"sliceDataFieldInParts\",\n    value: function sliceDataFieldInParts(data) {\n      // By default, skip the first part, which is usually empty (e.g. \"[empty]@6f6b\")\n      var startingIndex = 1;\n      // Before trying to parse the hex strings, cut the unwanted parts of the data field, in case of token transfers:\n      if (data.startsWith(\"ESDTTransfer\")) {\n        // Skip \"ESDTTransfer\" (1), token identifier (2), amount (3)\n        startingIndex = 3;\n      } else {\n        // TODO: Upon gathering more transaction samples, fix for other kinds of transfers, as well (future PR, as needed).\n      }\n      var parts = new argSerializer_1.ArgSerializer().stringToBuffers(data);\n      var returnCodePart = parts[startingIndex] || Buffer.from([]);\n      var returnDataParts = parts.slice(startingIndex + 1);\n      if (returnCodePart.length == 0) {\n        throw new errors_1.ErrCannotParseContractResults(\"no return code\");\n      }\n      var returnCode = returnCode_1.ReturnCode.fromBuffer(returnCodePart);\n      return {\n        returnCode: returnCode,\n        returnDataParts: returnDataParts\n      };\n    }\n  }]);\n  return ResultsParser;\n}();\nexports.ResultsParser = ResultsParser;","map":null,"metadata":{},"sourceType":"script"}