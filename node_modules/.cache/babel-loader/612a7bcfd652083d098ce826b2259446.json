{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\nvar primitives_1 = require(\"./primitives\");\nvar WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\n * Algorithm for detecting transaction completion.\n * Based on some heuristics (a bit imprecise therefore, at this moment).\n */\nvar TransactionCompletionStrategyOnProxy = /*#__PURE__*/function () {\n  function TransactionCompletionStrategyOnProxy() {\n    _classCallCheck(this, TransactionCompletionStrategyOnProxy);\n  }\n  _createClass(TransactionCompletionStrategyOnProxy, [{\n    key: \"isCompleted\",\n    value: function isCompleted(transaction) {\n      if (transaction.status.isPending()) {\n        // Certainly not completed.\n        return false;\n      }\n      // Handle gateway mechanics:\n      var _iterator = _createForOfIteratorHelper(WellKnownCompletionEvents),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var completionEvent = _step.value;\n          if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n            // Certainly completed.\n            console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (this.isCertainlyMoveBalance(transaction.data)) {\n        return transaction.status.isExecuted();\n      }\n      var hyperblockNonce = transaction.hyperblockNonce;\n      // Imprecise condition, uncertain completion (usually sufficient, though).\n      // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n      if (hyperblockNonce > 0) {\n        console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"isCertainlyMoveBalance\",\n    value: function isCertainlyMoveBalance(transactionData) {\n      var _this = this;\n      var parts = transactionData.toString().split(\"@\");\n      var prefix = parts[0];\n      var otherParts = parts.slice(1);\n      var emptyPrefix = !prefix;\n      var somePartsAreNotValidArguments = !otherParts.every(function (part) {\n        return _this.looksLikeValidArgument(part);\n      });\n      return emptyPrefix || somePartsAreNotValidArguments;\n    }\n  }, {\n    key: \"looksLikeValidArgument\",\n    value: function looksLikeValidArgument(arg) {\n      return primitives_1.isPaddedHex(arg);\n    }\n  }]);\n  return TransactionCompletionStrategyOnProxy;\n}();\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\nvar TransactionCompletionStrategyOnAPI = /*#__PURE__*/function () {\n  function TransactionCompletionStrategyOnAPI() {\n    _classCallCheck(this, TransactionCompletionStrategyOnAPI);\n  }\n  _createClass(TransactionCompletionStrategyOnAPI, [{\n    key: \"isCompleted\",\n    value: function isCompleted(transaction) {\n      return !transaction.status.isPending();\n    }\n  }]);\n  return TransactionCompletionStrategyOnAPI;\n}();\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;","map":{"version":3,"sources":["../src/transactionCompletionStrategy.ts"],"names":[],"mappings":";;;;;;;;;AAEA,IAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AASA,IAAM,yBAAyB,GAAG,CAAC,kBAAkB,EAAE,UAAU,EAAE,aAAa,CAAC;AAEjF;;;AAGG;AAHH,IAIa,oCAAoC;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OAC7C,qBAAY,WAAkC,EAAA;MAC1C,IAAI,WAAW,CAAC,MAAM,CAAC,SAAS,EAAE,EAAE;QAChC;QACA,OAAO,KAAK;MACf;MAED;MAAA,2CAC8B,yBAAyB;QAAA;MAAA;QAAvD,oDAAyD;UAAA,IAA9C,eAAe;UACtB,IAAI,WAAW,CAAC,IAAI,CAAC,oBAAoB,CAAC,eAAe,CAAC,EAAE;YACxD;YACA,OAAO,CAAC,KAAK,CAAC,2DAA2D,EAAE,eAAe,CAAC;YAC3F,OAAO,IAAI;UACd;;MACJ;QAAA;MAAA;QAAA;MAAA;MAED,IAAI,IAAI,CAAC,sBAAsB,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;QAC/C,OAAO,WAAW,CAAC,MAAM,CAAC,UAAU,EAAE;MACzC;MAED,IAAI,eAAe,GAAG,WAAW,CAAC,eAAe;MAEjD;MACA;MACA,IAAI,eAAe,GAAG,CAAC,EAAE;QACrB,OAAO,CAAC,KAAK,CAAC,sEAAsE,EAAE,eAAe,CAAC;QACtG,OAAO,IAAI;MACd;MAED,OAAO,KAAK;IAChB;EAAC;IAAA;IAAA,OAEO,gCAAuB,eAAuB,EAAA;MAAA;MAClD,IAAI,KAAK,GAAG,eAAe,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC;MACjD,IAAI,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC;MACrB,IAAI,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;MAC/B,IAAI,WAAW,GAAG,CAAC,MAAM;MACzB,IAAI,6BAA6B,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,UAAA,IAAI;QAAA,OAAI,KAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC;MAAA,EAAC;MAEhG,OAAO,WAAW,IAAI,6BAA6B;IACvD;EAAC;IAAA;IAAA,OAEO,gCAAuB,GAAW,EAAA;MACtC,OAAO,YAAA,CAAA,WAAW,CAAC,GAAG,CAAC;IAC3B;EAAC;EAAA;AAAA;AA5CL,OAAA,CAAA,oCAAA,GAAA,oCAAA;AA6CC,IAEY,kCAAkC;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OAC3C,qBAAY,WAAkC,EAAA;MAC1C,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,EAAE;IAC1C;EAAC;EAAA;AAAA;AAHL,OAAA,CAAA,kCAAA,GAAA,kCAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\nconst primitives_1 = require(\"./primitives\");\nconst WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\n * Algorithm for detecting transaction completion.\n * Based on some heuristics (a bit imprecise therefore, at this moment).\n */\nclass TransactionCompletionStrategyOnProxy {\n    isCompleted(transaction) {\n        if (transaction.status.isPending()) {\n            // Certainly not completed.\n            return false;\n        }\n        // Handle gateway mechanics:\n        for (const completionEvent of WellKnownCompletionEvents) {\n            if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n                // Certainly completed.\n                console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n                return true;\n            }\n        }\n        if (this.isCertainlyMoveBalance(transaction.data)) {\n            return transaction.status.isExecuted();\n        }\n        let hyperblockNonce = transaction.hyperblockNonce;\n        // Imprecise condition, uncertain completion (usually sufficient, though).\n        // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n        if (hyperblockNonce > 0) {\n            console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n            return true;\n        }\n        return false;\n    }\n    isCertainlyMoveBalance(transactionData) {\n        let parts = transactionData.toString().split(\"@\");\n        let prefix = parts[0];\n        let otherParts = parts.slice(1);\n        let emptyPrefix = !prefix;\n        let somePartsAreNotValidArguments = !otherParts.every(part => this.looksLikeValidArgument(part));\n        return emptyPrefix || somePartsAreNotValidArguments;\n    }\n    looksLikeValidArgument(arg) {\n        return primitives_1.isPaddedHex(arg);\n    }\n}\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\nclass TransactionCompletionStrategyOnAPI {\n    isCompleted(transaction) {\n        return !transaction.status.isPending();\n    }\n}\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;\n//# sourceMappingURL=transactionCompletionStrategy.js.map"]},"metadata":{},"sourceType":"script"}