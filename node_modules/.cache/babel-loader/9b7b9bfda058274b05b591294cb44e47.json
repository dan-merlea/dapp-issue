{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar TEMP_RECT = new core.Rectangle();\nvar BYTES_PER_PIXEL = 4;\nvar _Extract = /*#__PURE__*/function () {\n  function _Extract(renderer) {\n    _classCallCheck(this, _Extract);\n    this.renderer = renderer;\n  }\n  _createClass(_Extract, [{\n    key: \"image\",\n    value: function () {\n      var _image = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(target, format, quality) {\n        var image;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                image = new Image();\n                _context.next = 3;\n                return this.base64(target, format, quality);\n              case 3:\n                image.src = _context.sent;\n                return _context.abrupt(\"return\", image);\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function image(_x, _x2, _x3) {\n        return _image.apply(this, arguments);\n      }\n      return image;\n    }()\n  }, {\n    key: \"base64\",\n    value: function () {\n      var _base = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(target, format, quality) {\n        var canvas, blob;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                canvas = this.canvas(target);\n                if (!(canvas.toDataURL !== void 0)) {\n                  _context2.next = 3;\n                  break;\n                }\n                return _context2.abrupt(\"return\", canvas.toDataURL(format, quality));\n              case 3:\n                if (!(canvas.convertToBlob !== void 0)) {\n                  _context2.next = 10;\n                  break;\n                }\n                _context2.next = 6;\n                return canvas.convertToBlob({\n                  type: format,\n                  quality: quality\n                });\n              case 6:\n                blob = _context2.sent;\n                _context2.next = 9;\n                return new Promise(function (resolve) {\n                  var reader = new FileReader();\n                  reader.onload = function () {\n                    return resolve(reader.result);\n                  };\n                  reader.readAsDataURL(blob);\n                });\n              case 9:\n                return _context2.abrupt(\"return\", _context2.sent);\n              case 10:\n                throw new Error(\"Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented\");\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function base64(_x4, _x5, _x6) {\n        return _base.apply(this, arguments);\n      }\n      return base64;\n    }()\n  }, {\n    key: \"canvas\",\n    value: function canvas(target, frame) {\n      var renderer = this.renderer;\n      var resolution;\n      var flipY = false;\n      var renderTexture;\n      var generated = false;\n      if (target) {\n        if (target instanceof core.RenderTexture) {\n          renderTexture = target;\n        } else {\n          renderTexture = this.renderer.generateTexture(target);\n          generated = true;\n        }\n      }\n      if (renderTexture) {\n        var _frame;\n        resolution = renderTexture.baseTexture.resolution;\n        frame = (_frame = frame) !== null && _frame !== void 0 ? _frame : renderTexture.frame;\n        flipY = false;\n        renderer.renderTexture.bind(renderTexture);\n      } else {\n        resolution = renderer.resolution;\n        if (!frame) {\n          frame = TEMP_RECT;\n          frame.width = renderer.width;\n          frame.height = renderer.height;\n        }\n        flipY = true;\n        renderer.renderTexture.bind(null);\n      }\n      var width = Math.round(frame.width * resolution);\n      var height = Math.round(frame.height * resolution);\n      var canvasBuffer = new core.utils.CanvasRenderTarget(width, height, 1);\n      var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n      var gl = renderer.gl;\n      gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n      var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n      _Extract.arrayPostDivide(webglPixels, canvasData.data);\n      canvasBuffer.context.putImageData(canvasData, 0, 0);\n      if (flipY) {\n        var target2 = new core.utils.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n        target2.context.scale(1, -1);\n        target2.context.drawImage(canvasBuffer.canvas, 0, -height);\n        canvasBuffer.destroy();\n        canvasBuffer = target2;\n      }\n      if (generated) {\n        renderTexture.destroy(true);\n      }\n      return canvasBuffer.canvas;\n    }\n  }, {\n    key: \"pixels\",\n    value: function pixels(target, frame) {\n      var renderer = this.renderer;\n      var resolution;\n      var renderTexture;\n      var generated = false;\n      if (target) {\n        if (target instanceof core.RenderTexture) {\n          renderTexture = target;\n        } else {\n          renderTexture = this.renderer.generateTexture(target);\n          generated = true;\n        }\n      }\n      if (renderTexture) {\n        var _frame2;\n        resolution = renderTexture.baseTexture.resolution;\n        frame = (_frame2 = frame) !== null && _frame2 !== void 0 ? _frame2 : renderTexture.frame;\n        renderer.renderTexture.bind(renderTexture);\n      } else {\n        resolution = renderer.resolution;\n        if (!frame) {\n          frame = TEMP_RECT;\n          frame.width = renderer.width;\n          frame.height = renderer.height;\n        }\n        renderer.renderTexture.bind(null);\n      }\n      var width = Math.round(frame.width * resolution);\n      var height = Math.round(frame.height * resolution);\n      var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n      var gl = renderer.gl;\n      gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n      if (generated) {\n        renderTexture.destroy(true);\n      }\n      _Extract.arrayPostDivide(webglPixels, webglPixels);\n      return webglPixels;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }], [{\n    key: \"arrayPostDivide\",\n    value: function arrayPostDivide(pixels, out) {\n      for (var i = 0; i < pixels.length; i += 4) {\n        var alpha = out[i + 3] = pixels[i + 3];\n        if (alpha !== 0) {\n          out[i] = Math.round(Math.min(pixels[i] * 255 / alpha, 255));\n          out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255 / alpha, 255));\n          out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255 / alpha, 255));\n        } else {\n          out[i] = pixels[i];\n          out[i + 1] = pixels[i + 1];\n          out[i + 2] = pixels[i + 2];\n        }\n      }\n    }\n  }]);\n  return _Extract;\n}();\nvar Extract = _Extract;\nExtract.extension = {\n  name: \"extract\",\n  type: core.ExtensionType.RendererSystem\n};\ncore.extensions.add(Extract);\nexports.Extract = Extract;","map":{"version":3,"sources":["../src/Extract.ts"],"names":["Rectangle","ExtensionType","RenderTexture","utils","extensions"],"mappings":";;;;;;;;;;AAMA,IAAM,SAAA,GAAY,IAAIA,IAAAA,CAAAA,SAAU,EAAA;AAChC,IAAM,eAAkB,GAAA,CAAA;AAyBjB,IAAM,QAAN;EAaH,kBAAY,QACZ,EAAA;IAAA;IACI,IAAA,CAAK,QAAW,GAAA,QAAA;EAAA;EACpB;IAAA;IAAA;MAAA,wEAUA,iBAAmB,MAAuC,EAAA,MAAA,EAAiB,OAC3E;QAAA;QAAA;UAAA;YAAA;cAAA;gBACU,KAAA,GAAQ,IAAI,KAAM,EAAA;gBAAA;gBAAA,OAEN,IAAA,CAAK,MAAO,CAAA,MAAA,EAAQ,MAAA,EAAQ,OAAO,CAAA;cAAA;gBAArD,KAAA,CAAM,GAAA;gBAAA,iCAEC,KAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACX;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,uEAWA,kBAAoB,MAAuC,EAAA,MAAA,EAAiB,OAC5E;QAAA;QAAA;UAAA;YAAA;cAAA;gBACU,MAAA,GAAS,IAAK,CAAA,MAAA,CAAO,MAAM,CAAA;gBAAA,MAE7B,MAAA,CAAO,SAAA,KAAc,KACzB,CAAA;kBAAA;kBAAA;gBAAA;gBAAA,kCACW,MAAA,CAAO,SAAU,CAAA,MAAA,EAAQ,OAAO,CAAA;cAAA;gBAAA,MAEvC,MAAA,CAAO,aAAA,KAAkB,KAC7B,CAAA;kBAAA;kBAAA;gBAAA;gBAAA;gBAAA,OACuB,MAAO,CAAA,aAAA,CAAc;kBAAE,IAAM,EAAA,MAAA;kBAAQ,OAAA,EAAA;gBAAA,CAAS,CAAA;cAAA;gBAA3D,IAAA;gBAAA;gBAAA,OAEO,IAAI,OAAgB,CAAA,UAAC,OAClC,EAAA;kBACU,IAAA,MAAA,GAAS,IAAI,UAAW,EAAA;kBAE9B,MAAA,CAAO,MAAS,GAAA;oBAAA,OAAM,OAAQ,CAAA,MAAA,CAAO,MAAgB,CAAA;kBAAA;kBACrD,MAAA,CAAO,aAAA,CAAc,IAAI,CAAA;gBAAA,CAC5B,CAAA;cAAA;gBAAA;cAAA;gBAAA,MAGC,IAAI,KAAA,CAAM,wFAAwF,CAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC5G;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OASO,gBAAO,MAAA,EAAuC,KACrD,EAAA;MACI,IAAM,QAAA,GAAW,IAAK,CAAA,QAAA;MAClB,IAAA,UAAA;MACJ,IAAI,KAAQ,GAAA,KAAA;MACR,IAAA,aAAA;MACJ,IAAI,SAAY,GAAA,KAAA;MAEhB,IAAI,MACJ,EAAA;QACI,IAAI,MAAA,YAAkBE,IAAAA,CAAAA,aACtB,EAAA;UACoB,aAAA,GAAA,MAAA;QAAA,CAGpB,MAAA;UACoB,aAAA,GAAA,IAAA,CAAK,QAAS,CAAA,eAAA,CAAgB,MAAM,CAAA;UACxC,SAAA,GAAA,IAAA;QAAA;MAChB;MAGJ,IAAI,aACJ,EAAA;QAAA;QACI,UAAA,GAAa,aAAA,CAAc,WAAY,CAAA,UAAA;QACvC,KAAA,aAAQ,KAAA,2CAAS,aAAc,CAAA,KAAA;QACvB,KAAA,GAAA,KAAA;QACC,QAAA,CAAA,aAAA,CAAc,IAAA,CAAK,aAAa,CAAA;MAAA,CAG7C,MAAA;QACI,UAAA,GAAa,QAAS,CAAA,UAAA;QAEtB,IAAI,CAAC,KACL,EAAA;UACY,KAAA,GAAA,SAAA;UACR,KAAA,CAAM,KAAA,GAAQ,QAAS,CAAA,KAAA;UACvB,KAAA,CAAM,MAAA,GAAS,QAAS,CAAA,MAAA;QAAA;QAGpB,KAAA,GAAA,IAAA;QACC,QAAA,CAAA,aAAA,CAAc,IAAA,CAAK,IAAI,CAAA;MAAA;MAGpC,IAAM,KAAQ,GAAA,IAAA,CAAK,KAAM,CAAA,KAAA,CAAM,KAAA,GAAQ,UAAU,CAAA;MACjD,IAAM,MAAS,GAAA,IAAA,CAAK,KAAM,CAAA,KAAA,CAAM,MAAA,GAAS,UAAU,CAAA;MAEnD,IAAI,YAAA,GAAe,IAAIC,IAAAA,CAAAA,KAAAA,CAAM,kBAAmB,CAAA,KAAA,EAAO,MAAA,EAAQ,CAAC,CAAA;MAEhE,IAAM,WAAc,GAAA,IAAI,UAAW,CAAA,eAAA,GAAkB,KAAA,GAAQ,MAAM,CAAA;MAGnE,IAAM,EAAA,GAAK,QAAS,CAAA,EAAA;MAEpB,EAAA,CAAG,UAAA,CACC,IAAK,CAAA,KAAA,CAAM,KAAA,CAAM,CAAI,GAAA,UAAU,CAAA,EAC/B,IAAK,CAAA,KAAA,CAAM,KAAA,CAAM,CAAI,GAAA,UAAU,CAAA,EAC/B,KACA,EAAA,MAAA,EACA,EAAA,CAAG,IACH,EAAA,EAAA,CAAG,aAAA,EACH,WACJ,CAAA;MAGA,IAAM,UAAA,GAAa,YAAa,CAAA,OAAA,CAAQ,YAAA,CAAa,CAAG,EAAA,CAAA,EAAG,KAAA,EAAO,MAAM,CAAA;MAEhE,QAAA,CAAA,eAAA,CAAgB,WAAa,EAAA,UAAA,CAAW,IAAI,CAAA;MAEpD,YAAA,CAAa,OAAQ,CAAA,YAAA,CAAa,UAAY,EAAA,CAAA,EAAG,CAAC,CAAA;MAGlD,IAAI,KACJ,EAAA;QACU,IAAA,OAAA,GAAS,IAAIA,IAAAA,CAAAA,KAAM,CAAA,kBAAA,CAAmB,YAAA,CAAa,KAAO,EAAA,YAAA,CAAa,MAAA,EAAQ,CAAC,CAAA;QAE/E,OAAA,CAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,EAAG,CAAE,CAAA,CAAA;QAG1B,OAAA,CAAO,OAAA,CAAQ,SAAU,CAAA,YAAA,CAAa,MAAQ,EAAA,CAAA,EAAG,CAAC,MAAM,CAAA;QAExD,YAAA,CAAa,OAAQ,EAAA;QACN,YAAA,GAAA,OAAA;MAAA;MAGnB,IAAI,SACJ,EAAA;QACI,aAAA,CAAc,OAAA,CAAQ,IAAI,CAAA;MAAA;MAI9B,OAAO,YAAa,CAAA,MAAA;IAAA;EACxB;IAAA;IAAA,OAUO,gBAAO,MAAA,EAAwC,KACtD,EAAA;MACI,IAAM,QAAA,GAAW,IAAK,CAAA,QAAA;MAClB,IAAA,UAAA;MACA,IAAA,aAAA;MACJ,IAAI,SAAY,GAAA,KAAA;MAEhB,IAAI,MACJ,EAAA;QACI,IAAI,MAAA,YAAkBD,IAAAA,CAAAA,aACtB,EAAA;UACoB,aAAA,GAAA,MAAA;QAAA,CAGpB,MAAA;UACoB,aAAA,GAAA,IAAA,CAAK,QAAS,CAAA,eAAA,CAAgB,MAAM,CAAA;UACxC,SAAA,GAAA,IAAA;QAAA;MAChB;MAGJ,IAAI,aACJ,EAAA;QAAA;QACI,UAAA,GAAa,aAAA,CAAc,WAAY,CAAA,UAAA;QACvC,KAAA,cAAQ,KAAA,6CAAS,aAAc,CAAA,KAAA;QACtB,QAAA,CAAA,aAAA,CAAc,IAAA,CAAK,aAAa,CAAA;MAAA,CAG7C,MAAA;QACI,UAAA,GAAa,QAAS,CAAA,UAAA;QAEtB,IAAI,CAAC,KACL,EAAA;UACY,KAAA,GAAA,SAAA;UACR,KAAA,CAAM,KAAA,GAAQ,QAAS,CAAA,KAAA;UACvB,KAAA,CAAM,MAAA,GAAS,QAAS,CAAA,MAAA;QAAA;QAGnB,QAAA,CAAA,aAAA,CAAc,IAAA,CAAK,IAAI,CAAA;MAAA;MAGpC,IAAM,KAAQ,GAAA,IAAA,CAAK,KAAM,CAAA,KAAA,CAAM,KAAA,GAAQ,UAAU,CAAA;MACjD,IAAM,MAAS,GAAA,IAAA,CAAK,KAAM,CAAA,KAAA,CAAM,MAAA,GAAS,UAAU,CAAA;MAEnD,IAAM,WAAc,GAAA,IAAI,UAAW,CAAA,eAAA,GAAkB,KAAA,GAAQ,MAAM,CAAA;MAGnE,IAAM,EAAA,GAAK,QAAS,CAAA,EAAA;MAEpB,EAAA,CAAG,UAAA,CACC,IAAK,CAAA,KAAA,CAAM,KAAA,CAAM,CAAI,GAAA,UAAU,CAAA,EAC/B,IAAK,CAAA,KAAA,CAAM,KAAA,CAAM,CAAI,GAAA,UAAU,CAAA,EAC/B,KACA,EAAA,MAAA,EACA,EAAA,CAAG,IACH,EAAA,EAAA,CAAG,aAAA,EACH,WACJ,CAAA;MAEA,IAAI,SACJ,EAAA;QACI,aAAA,CAAc,OAAA,CAAQ,IAAI,CAAA;MAAA;MAGtB,QAAA,CAAA,eAAA,CAAgB,WAAA,EAAa,WAAW,CAAA;MAEzC,OAAA,WAAA;IAAA;EACX;IAAA;IAAA,OAGA,mBACA;MACI,IAAA,CAAK,QAAW,GAAA,IAAA;IAAA;EACpB;IAAA;IAAA,OAQA,yBACI,MAAA,EAAmD,GAEvD,EAAA;MACI,KAAA,IAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,MAAO,CAAA,MAAA,EAAQ,CAAA,IAAK,CACxC,EAAA;QACI,IAAM,KAAQ,GAAA,GAAA,CAAI,CAAI,GAAA,CAAA,CAAA,GAAK,MAAA,CAAO,CAAI,GAAA,CAAA,CAAA;QAEtC,IAAI,KAAA,KAAU,CACd,EAAA;UACQ,GAAA,CAAA,CAAA,CAAA,GAAK,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,GAAA,CAAI,MAAA,CAAO,CAAK,CAAA,GAAA,GAAA,GAAQ,KAAO,EAAA,GAAK,CAAC,CAAA;UAC9D,GAAA,CAAI,CAAI,GAAA,CAAA,CAAA,GAAK,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,GAAA,CAAI,MAAO,CAAA,CAAA,GAAI,CAAK,CAAA,GAAA,GAAA,GAAQ,KAAO,EAAA,GAAK,CAAC,CAAA;UACtE,GAAA,CAAI,CAAI,GAAA,CAAA,CAAA,GAAK,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,GAAA,CAAI,MAAO,CAAA,CAAA,GAAI,CAAK,CAAA,GAAA,GAAA,GAAQ,KAAO,EAAA,GAAK,CAAC,CAAA;QAAA,CAG1E,MAAA;UACI,GAAA,CAAI,CAAA,CAAA,GAAK,MAAO,CAAA,CAAA,CAAA;UACZ,GAAA,CAAA,CAAA,GAAI,CAAK,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,CAAA,CAAA;UACpB,GAAA,CAAA,CAAA,GAAI,CAAK,CAAA,GAAA,MAAA,CAAO,CAAI,GAAA,CAAA,CAAA;QAAA;MAC5B;IACJ;EACJ;EAAA;AAAA,GACJ;AAtRO,IAAM,OAAN,GAAA,QAAA;AAAM,OAAA,CAGF,SAA+B,GAAA;EAClC,IAAM,EAAA,SAAA;EACN,IAAA,EAAMD,IAAAA,CAAAA,aAAc,CAAA;AACxB,CAAA;AAkRJG,IAAAA,CAAAA,UAAAA,CAAW,GAAA,CAAI,OAAO,CAAA","sourcesContent":["import { Rectangle, utils, extensions, ExtensionType, RenderTexture } from '@pixi/core';\n\nimport type { ISystem, ExtensionMetadata, Renderer } from '@pixi/core';\nimport type { DisplayObject } from '@pixi/display';\nimport type { ICanvas } from '@pixi/settings';\n\nconst TEMP_RECT = new Rectangle();\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new app (will auto-add extract plugin to renderer)\n * const app = new Application();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .beginFill(0xFF0000)\n *     .drawCircle(0, 0, 50);\n *\n * // Render the graphics as an HTMLImageElement\n * const image = app.renderer.plugins.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof PIXI\n */\n\nexport class Extract implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'extract',\n        type: ExtensionType.RendererSystem,\n    };\n\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - HTML Image of the target\n     */\n    public async image(target: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(target, format, quality);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     *  `Extract.getCanvas` and then running toDataURL on that.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @returns - A base64 encoded string of the texture.\n     */\n    public async base64(target: DisplayObject | RenderTexture, format?: string, quality?: number): Promise<string>\n    {\n        const canvas = this.canvas(target);\n\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(format, quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: format, quality });\n\n            return await new Promise<string>((resolve) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(target: DisplayObject | RenderTexture, frame?: Rectangle): ICanvas\n    {\n        const renderer = this.renderer;\n        let resolution;\n        let flipY = false;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = frame ?? renderTexture.frame;\n            flipY = false;\n            renderer.renderTexture.bind(renderTexture);\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width;\n                frame.height = renderer.height;\n            }\n\n            flipY = true;\n            renderer.renderTexture.bind(null);\n        }\n\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        let canvasBuffer = new utils.CanvasRenderTarget(width, height, 1);\n\n        const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        // read pixels to the array\n        const gl = renderer.gl;\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            webglPixels\n        );\n\n        // add the pixels to the canvas\n        const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n\n        Extract.arrayPostDivide(webglPixels, canvasData.data);\n\n        canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n        // pulling pixels\n        if (flipY)\n        {\n            const target = new utils.CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n\n            target.context.scale(1, -1);\n\n            // we can't render to itself because we should be empty before render.\n            target.context.drawImage(canvasBuffer.canvas, 0, -height);\n\n            canvasBuffer.destroy();\n            canvasBuffer = target;\n        }\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n\n        // send the canvas back..\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param frame - The frame the extraction is restricted to.\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(target?: DisplayObject | RenderTexture, frame?: Rectangle): Uint8Array\n    {\n        const renderer = this.renderer;\n        let resolution;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = frame ?? renderTexture.frame;\n            renderer.renderTexture.bind(renderTexture);\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!frame)\n            {\n                frame = TEMP_RECT;\n                frame.width = renderer.width;\n                frame.height = renderer.height;\n            }\n\n            renderer.renderTexture.bind(null);\n        }\n\n        const width = Math.round(frame.width * resolution);\n        const height = Math.round(frame.height * resolution);\n\n        const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        // read pixels to the array\n        const gl = renderer.gl;\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            webglPixels\n        );\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n\n        Extract.arrayPostDivide(webglPixels, webglPixels);\n\n        return webglPixels;\n    }\n\n    /** Destroys the extract. */\n    public destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    /**\n     * Takes premultiplied pixel data and produces regular pixel data\n     * @private\n     * @param pixels - array of pixel data\n     * @param out - output array\n     */\n    static arrayPostDivide(\n        pixels: number[] | Uint8Array | Uint8ClampedArray, out: number[] | Uint8Array | Uint8ClampedArray\n    ): void\n    {\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            const alpha = out[i + 3] = pixels[i + 3];\n\n            if (alpha !== 0)\n            {\n                out[i] = Math.round(Math.min(pixels[i] * 255.0 / alpha, 255.0));\n                out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255.0 / alpha, 255.0));\n                out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255.0 / alpha, 255.0));\n            }\n            else\n            {\n                out[i] = pixels[i];\n                out[i + 1] = pixels[i + 1];\n                out[i + 2] = pixels[i + 2];\n            }\n        }\n    }\n}\n\nextensions.add(Extract);\n"]},"metadata":{},"sourceType":"script"}