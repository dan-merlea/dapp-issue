{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionHash = exports.Transaction = void 0;\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar address_1 = require(\"./address\");\nvar networkParams_1 = require(\"./networkParams\");\nvar signature_1 = require(\"./signature\");\nvar utils_1 = require(\"./utils\");\nvar transactionPayload_1 = require(\"./transactionPayload\");\nvar errors = __importStar(require(\"./errors\"));\nvar proto_1 = require(\"./proto\");\nvar hash_1 = require(\"./hash\");\nvar constants_1 = require(\"./constants\");\nvar createTransactionHasher = require(\"blake2b\");\nvar TRANSACTION_HASH_LENGTH = 32;\n/**\n * An abstraction for creating, signing and broadcasting Elrond transactions.\n */\nvar Transaction = /*#__PURE__*/function () {\n  /**\n   * Creates a new Transaction object.\n   */\n  function Transaction(_ref) {\n    var nonce = _ref.nonce,\n      value = _ref.value,\n      receiver = _ref.receiver,\n      sender = _ref.sender,\n      gasPrice = _ref.gasPrice,\n      gasLimit = _ref.gasLimit,\n      data = _ref.data,\n      chainID = _ref.chainID,\n      version = _ref.version,\n      options = _ref.options;\n    _classCallCheck(this, Transaction);\n    this.nonce = nonce || 0;\n    this.value = value || 0;\n    this.sender = sender || address_1.Address.Zero();\n    this.receiver = receiver;\n    this.gasPrice = gasPrice || constants_1.TRANSACTION_MIN_GAS_PRICE;\n    this.gasLimit = gasLimit;\n    this.data = data || new transactionPayload_1.TransactionPayload();\n    this.chainID = chainID;\n    this.version = version || networkParams_1.TransactionVersion.withDefaultVersion();\n    this.options = options || networkParams_1.TransactionOptions.withDefaultOptions();\n    this.signature = signature_1.Signature.empty();\n    this.hash = TransactionHash.empty();\n  }\n  _createClass(Transaction, [{\n    key: \"getNonce\",\n    value: function getNonce() {\n      return this.nonce;\n    }\n    /**\n     * Sets the account sequence number of the sender. Must be done prior signing.\n     */\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(nonce) {\n      this.nonce = nonce;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.value = value;\n    }\n  }, {\n    key: \"getSender\",\n    value: function getSender() {\n      return this.sender;\n    }\n  }, {\n    key: \"getReceiver\",\n    value: function getReceiver() {\n      return this.receiver;\n    }\n  }, {\n    key: \"getGasPrice\",\n    value: function getGasPrice() {\n      return this.gasPrice;\n    }\n  }, {\n    key: \"setGasPrice\",\n    value: function setGasPrice(gasPrice) {\n      this.gasPrice = gasPrice;\n    }\n  }, {\n    key: \"getGasLimit\",\n    value: function getGasLimit() {\n      return this.gasLimit;\n    }\n  }, {\n    key: \"setGasLimit\",\n    value: function setGasLimit(gasLimit) {\n      this.gasLimit = gasLimit;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n  }, {\n    key: \"getChainID\",\n    value: function getChainID() {\n      return this.chainID;\n    }\n  }, {\n    key: \"setChainID\",\n    value: function setChainID(chainID) {\n      this.chainID = chainID;\n    }\n  }, {\n    key: \"getVersion\",\n    value: function getVersion() {\n      return this.version;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this.options;\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return this.signature;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      utils_1.guardNotEmpty(this.hash, \"hash\");\n      return this.hash;\n    }\n    /**\n     * Serializes a transaction to a sequence of bytes, ready to be signed.\n     * This function is called internally by signers.\n     *\n     * @param signedBy The address of the future signer\n     */\n  }, {\n    key: \"serializeForSigning\",\n    value: function serializeForSigning(signedBy) {\n      // TODO: for appropriate tx.version, interpret tx.options accordingly and sign using the content / data hash\n      var plain = this.toPlainObject(signedBy);\n      // Make sure we never sign the transaction with another signature set up (useful when using the same method for verification)\n      if (plain.signature) {\n        delete plain.signature;\n      }\n      var serialized = JSON.stringify(plain);\n      return Buffer.from(serialized);\n    }\n    /**\n     * Converts the transaction object into a ready-to-serialize, plain JavaScript object.\n     * This function is called internally within the signing procedure.\n     *\n     * @param sender The address of the sender (will be provided when called within the signing procedure)\n     */\n  }, {\n    key: \"toPlainObject\",\n    value: function toPlainObject(sender) {\n      return {\n        nonce: this.nonce.valueOf(),\n        value: this.value.toString(),\n        receiver: this.receiver.bech32(),\n        sender: sender ? sender.bech32() : this.sender.bech32(),\n        gasPrice: this.gasPrice.valueOf(),\n        gasLimit: this.gasLimit.valueOf(),\n        data: this.data.length() == 0 ? undefined : this.data.encoded(),\n        chainID: this.chainID.valueOf(),\n        version: this.version.valueOf(),\n        options: this.options.valueOf() == 0 ? undefined : this.options.valueOf(),\n        signature: this.signature.hex() ? this.signature.hex() : undefined\n      };\n    }\n    /**\n     * Converts a plain object transaction into a Transaction Object.\n     *\n     * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()\n     */\n  }, {\n    key: \"applySignature\",\n    value:\n    /**\n     * Applies the signature on the transaction.\n     *\n     * @param signature The signature, as computed by a signer.\n     * @param signedBy The address of the signer.\n     */\n    function applySignature(signature, signedBy) {\n      this.signature = signature;\n      this.sender = signedBy;\n      this.hash = TransactionHash.compute(this);\n    }\n    /**\n     * Converts a transaction to a ready-to-broadcast object.\n     * Called internally by the network provider.\n     */\n  }, {\n    key: \"toSendable\",\n    value: function toSendable() {\n      return this.toPlainObject();\n    }\n    /**\n     * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties\n     * @param networkConfig {@link NetworkConfig}\n     */\n  }, {\n    key: \"computeFee\",\n    value: function computeFee(networkConfig) {\n      var moveBalanceGas = networkConfig.MinGasLimit.valueOf() + this.data.length() * networkConfig.GasPerDataByte.valueOf();\n      if (moveBalanceGas > this.gasLimit.valueOf()) {\n        throw new errors.ErrNotEnoughGas(this.gasLimit.valueOf());\n      }\n      var gasPrice = new bignumber_js_1.BigNumber(this.gasPrice.valueOf());\n      var feeForMove = new bignumber_js_1.BigNumber(moveBalanceGas).multipliedBy(gasPrice);\n      if (moveBalanceGas === this.gasLimit.valueOf()) {\n        return feeForMove;\n      }\n      var diff = new bignumber_js_1.BigNumber(this.gasLimit.valueOf() - moveBalanceGas);\n      var modifiedGasPrice = gasPrice.multipliedBy(new bignumber_js_1.BigNumber(networkConfig.GasPriceModifier.valueOf()));\n      var processingFee = diff.multipliedBy(modifiedGasPrice);\n      return feeForMove.plus(processingFee);\n    }\n  }], [{\n    key: \"fromPlainObject\",\n    value: function fromPlainObject(plainObjectTransaction) {\n      var tx = new Transaction({\n        nonce: Number(plainObjectTransaction.nonce),\n        value: new bignumber_js_1.BigNumber(plainObjectTransaction.value),\n        receiver: address_1.Address.fromString(plainObjectTransaction.receiver),\n        gasPrice: Number(plainObjectTransaction.gasPrice),\n        gasLimit: Number(plainObjectTransaction.gasLimit),\n        data: new transactionPayload_1.TransactionPayload(atob(plainObjectTransaction.data || \"\")),\n        chainID: String(plainObjectTransaction.chainID),\n        version: new networkParams_1.TransactionVersion(plainObjectTransaction.version)\n      });\n      if (plainObjectTransaction.signature) {\n        tx.applySignature(new signature_1.Signature(plainObjectTransaction.signature), address_1.Address.fromString(plainObjectTransaction.sender));\n      }\n      return tx;\n    }\n  }]);\n  return Transaction;\n}();\nexports.Transaction = Transaction;\n/**\n * An abstraction for handling and computing transaction hashes.\n */\nvar TransactionHash = /*#__PURE__*/function (_hash_1$Hash) {\n  _inherits(TransactionHash, _hash_1$Hash);\n  var _super = _createSuper(TransactionHash);\n  function TransactionHash(hash) {\n    _classCallCheck(this, TransactionHash);\n    return _super.call(this, hash);\n  }\n  /**\n   * Computes the hash of a transaction.\n   */\n  _createClass(TransactionHash, null, [{\n    key: \"compute\",\n    value: function compute(transaction) {\n      var serializer = new proto_1.ProtoSerializer();\n      var buffer = serializer.serializeTransaction(transaction);\n      var hash = createTransactionHasher(TRANSACTION_HASH_LENGTH).update(buffer).digest(\"hex\");\n      return new TransactionHash(hash);\n    }\n  }]);\n  return TransactionHash;\n}(hash_1.Hash);\nexports.TransactionHash = TransactionHash;","map":null,"metadata":{},"sourceType":"script"}