{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { RenderTexture } from './RenderTexture.mjs';\nimport { BaseRenderTexture } from './BaseRenderTexture.mjs';\nimport { nextPow2 } from '@pixi/utils';\nimport { MSAA_QUALITY } from '@pixi/constants';\nvar RenderTexturePool = /*#__PURE__*/function () {\n  function RenderTexturePool(textureOptions) {\n    _classCallCheck(this, RenderTexturePool);\n    this.texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n    this._pixelsWidth = 0;\n    this._pixelsHeight = 0;\n  }\n  _createClass(RenderTexturePool, [{\n    key: \"createTexture\",\n    value: function createTexture(realWidth, realHeight) {\n      var multisample = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MSAA_QUALITY.NONE;\n      var baseRenderTexture = new BaseRenderTexture(Object.assign({\n        width: realWidth,\n        height: realHeight,\n        resolution: 1,\n        multisample: multisample\n      }, this.textureOptions));\n      return new RenderTexture(baseRenderTexture);\n    }\n  }, {\n    key: \"getOptimalTexture\",\n    value: function getOptimalTexture(minWidth, minHeight) {\n      var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var multisample = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MSAA_QUALITY.NONE;\n      var key;\n      minWidth = Math.ceil(minWidth * resolution - 1e-6);\n      minHeight = Math.ceil(minHeight * resolution - 1e-6);\n      if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n        key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0;\n        if (multisample > 1) {\n          key += multisample * 4294967296;\n        }\n      } else {\n        key = multisample > 1 ? -multisample : -1;\n      }\n      if (!this.texturePool[key]) {\n        this.texturePool[key] = [];\n      }\n      var renderTexture = this.texturePool[key].pop();\n      if (!renderTexture) {\n        renderTexture = this.createTexture(minWidth, minHeight, multisample);\n      }\n      renderTexture.filterPoolKey = key;\n      renderTexture.setResolution(resolution);\n      return renderTexture;\n    }\n  }, {\n    key: \"getFilterTexture\",\n    value: function getFilterTexture(input, resolution, multisample) {\n      var filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);\n      filterTexture.filterFrame = input.filterFrame;\n      return filterTexture;\n    }\n  }, {\n    key: \"returnTexture\",\n    value: function returnTexture(renderTexture) {\n      var key = renderTexture.filterPoolKey;\n      renderTexture.filterFrame = null;\n      this.texturePool[key].push(renderTexture);\n    }\n  }, {\n    key: \"returnFilterTexture\",\n    value: function returnFilterTexture(renderTexture) {\n      this.returnTexture(renderTexture);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(destroyTextures) {\n      destroyTextures = destroyTextures !== false;\n      if (destroyTextures) {\n        for (var i in this.texturePool) {\n          var textures = this.texturePool[i];\n          if (textures) {\n            for (var j = 0; j < textures.length; j++) {\n              textures[j].destroy(true);\n            }\n          }\n        }\n      }\n      this.texturePool = {};\n    }\n  }, {\n    key: \"setScreenSize\",\n    value: function setScreenSize(size) {\n      if (size.width === this._pixelsWidth && size.height === this._pixelsHeight) {\n        return;\n      }\n      this.enableFullScreen = size.width > 0 && size.height > 0;\n      for (var i in this.texturePool) {\n        if (!(Number(i) < 0)) {\n          continue;\n        }\n        var textures = this.texturePool[i];\n        if (textures) {\n          for (var j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n        this.texturePool[i] = [];\n      }\n      this._pixelsWidth = size.width;\n      this._pixelsHeight = size.height;\n    }\n  }]);\n  return RenderTexturePool;\n}();\nRenderTexturePool.SCREEN_KEY = -1;\nexport { RenderTexturePool };","map":{"version":3,"sources":["../../src/renderTexture/RenderTexturePool.ts"],"names":[],"mappings":";;;;;;IAiBa,iBACb;EAkBI,2BAAY,cACZ,EAAA;IAAA;IACI,IAAA,CAAK,WAAA,GAAc,CAAA,CAAC;IACf,IAAA,CAAA,cAAA,GAAiB,cAAA,IAAkB,CAAA,CAAC;IACzC,IAAA,CAAK,gBAAmB,GAAA,KAAA;IAExB,IAAA,CAAK,YAAe,GAAA,CAAA;IACpB,IAAA,CAAK,aAAgB,GAAA,CAAA;EAAA;EACzB;IAAA;IAAA,OAQA,uBAAc,SAAA,EAAmB,UAAoB,EACrD;MAAA,IADqD,WAAA,uEAAc,YAAA,CAAa,IAChF;MACI,IAAM,iBAAoB,GAAA,IAAI,iBAAkB,CAAA,MAAA,CAAO,MAAO,CAAA;QAC1D,KAAO,EAAA,SAAA;QACP,MAAQ,EAAA,UAAA;QACR,UAAY,EAAA,CAAA;QACZ,WAAA,EAAA;MAAA,CACJ,EAAG,IAAK,CAAA,cAAc,CAAC,CAAA;MAEhB,OAAA,IAAI,aAAA,CAAc,iBAAiB,CAAA;IAAA;EAC9C;IAAA;IAAA,OAUA,2BAAkB,QAAkB,EAAA,SAAA,EACpC;MAAA,IADuD,UAAA,uEAAa,CAAG;MAAA,IAAA,WAAA,uEAAc,YAAA,CAAa,IAClG;MACQ,IAAA,GAAA;MAEJ,QAAA,GAAW,IAAK,CAAA,IAAA,CAAM,QAAW,GAAA,UAAA,GAAc,IAAI,CAAA;MACnD,SAAA,GAAY,IAAK,CAAA,IAAA,CAAM,SAAY,GAAA,UAAA,GAAc,IAAI,CAAA;MAEjD,IAAA,CAAC,IAAA,CAAK,gBAAoB,IAAA,QAAA,KAAa,IAAA,CAAK,YAAgB,IAAA,SAAA,KAAc,IAAA,CAAK,aACnF,EAAA;QACI,QAAA,GAAW,QAAA,CAAS,QAAQ,CAAA;QAC5B,SAAA,GAAY,QAAA,CAAS,SAAS,CAAA;QAC9B,GAAA,GAAS,CAAW,CAAA,QAAA,GAAA,KAAA,KAAW,EAAO,GAAA,SAAA,GAAY,KAAa,MAAA,CAAA;QAE/D,IAAI,WAAA,GAAc,CAClB,EAAA;UACI,GAAA,IAAO,WAAc,GAAA,UAAA;QAAA;MACzB,CAGJ,MAAA;QACU,GAAA,GAAA,WAAA,GAAc,CAAI,GAAA,CAAC,WAAc,GAAA,CAAA,CAAA;MAAA;MAGvC,IAAA,CAAC,IAAK,CAAA,WAAA,CAAY,GACtB,CAAA,EAAA;QACS,IAAA,CAAA,WAAA,CAAY,GAAA,CAAA,GAAO,EAAC;MAAA;MAG7B,IAAI,aAAgB,GAAA,IAAA,CAAK,WAAY,CAAA,GAAA,CAAA,CAAK,GAAI,EAAA;MAE9C,IAAI,CAAC,aACL,EAAA;QACI,aAAA,GAAgB,IAAK,CAAA,aAAA,CAAc,QAAU,EAAA,SAAA,EAAW,WAAW,CAAA;MAAA;MAGvE,aAAA,CAAc,aAAgB,GAAA,GAAA;MAC9B,aAAA,CAAc,aAAA,CAAc,UAAU,CAAA;MAE/B,OAAA,aAAA;IAAA;EACX;IAAA;IAAA,OAWA,0BAAiB,KAAsB,EAAA,UAAA,EAAqB,WAC5D,EAAA;MACI,IAAM,aAAgB,GAAA,IAAA,CAAK,iBAAkB,CAAA,KAAA,CAAM,KAAO,EAAA,KAAA,CAAM,MAAQ,EAAA,UAAA,IAAc,KAAM,CAAA,UAAA,EACxF,WAAe,IAAA,YAAA,CAAa,IAAI,CAAA;MAEpC,aAAA,CAAc,WAAA,GAAc,KAAM,CAAA,WAAA;MAE3B,OAAA,aAAA;IAAA;EACX;IAAA;IAAA,OAMA,uBAAc,aACd,EAAA;MACI,IAAM,GAAA,GAAM,aAAc,CAAA,aAAA;MAE1B,aAAA,CAAc,WAAc,GAAA,IAAA;MACvB,IAAA,CAAA,WAAA,CAAY,GAAK,CAAA,CAAA,IAAA,CAAK,aAAa,CAAA;IAAA;EAC5C;IAAA;IAAA,OAMA,6BAAoB,aACpB,EAAA;MACI,IAAA,CAAK,aAAA,CAAc,aAAa,CAAA;IAAA;EACpC;IAAA;IAAA,OAMA,eAAM,eACN,EAAA;MACI,eAAA,GAAkB,eAAoB,KAAA,KAAA;MACtC,IAAI,eACJ,EAAA;QACe,KAAA,IAAA,CAAA,IAAK,IAAA,CAAK,WACrB,EAAA;UACU,IAAA,QAAA,GAAW,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;UAElC,IAAI,QACJ,EAAA;YACI,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,QAAA,CAAS,MAAA,EAAQ,CACrC,EAAA,EAAA;cACa,QAAA,CAAA,CAAA,CAAA,CAAG,OAAA,CAAQ,IAAI,CAAA;YAAA;UAC5B;QACJ;MACJ;MAGJ,IAAA,CAAK,WAAA,GAAc,CAAA,CAAC;IAAA;EACxB;IAAA;IAAA,OASA,uBAAc,IACd,EAAA;MACI,IAAI,IAAA,CAAK,KAAU,KAAA,IAAA,CAAK,YAAA,IACjB,IAAK,CAAA,MAAA,KAAW,IAAA,CAAK,aAC5B,EAAA;QACI;MAAA;MAGJ,IAAA,CAAK,gBAAmB,GAAA,IAAA,CAAK,KAAQ,GAAA,CAAA,IAAK,IAAA,CAAK,MAAS,GAAA,CAAA;MAE7C,KAAA,IAAA,CAAA,IAAK,IAAA,CAAK,WACrB,EAAA;QACI,IAAI,EAAE,MAAA,CAAO,CAAC,CAAA,GAAI,CAClB,CAAA,EAAA;UACI;QAAA;QAGE,IAAA,QAAA,GAAW,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;QAElC,IAAI,QACJ,EAAA;UACI,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,QAAA,CAAS,MAAA,EAAQ,CACrC,EAAA,EAAA;YACa,QAAA,CAAA,CAAA,CAAA,CAAG,OAAA,CAAQ,IAAI,CAAA;UAAA;QAC5B;QAGC,IAAA,CAAA,WAAA,CAAY,CAAA,CAAA,GAAK,EAAC;MAAA;MAG3B,IAAA,CAAK,YAAA,GAAe,IAAK,CAAA,KAAA;MACzB,IAAA,CAAK,aAAA,GAAgB,IAAK,CAAA,MAAA;IAAA;EAC9B;EAAA;AAAA;AAzMS,iBAAA,CA+MF,UAAa,GAAA,CAAA,CAAA","sourcesContent":["import { RenderTexture } from './RenderTexture';\nimport { BaseRenderTexture } from './BaseRenderTexture';\nimport { nextPow2 } from '@pixi/utils';\nimport { MSAA_QUALITY } from '@pixi/constants';\n\nimport type { IBaseTextureOptions } from '../textures/BaseTexture';\nimport type { ISize } from '@pixi/math';\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @memberof PIXI\n */\nexport class RenderTexturePool\n{\n    public textureOptions: IBaseTextureOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    texturePool: {[x in string | number]: RenderTexture[]};\n    private _pixelsWidth: number;\n    private _pixelsHeight: number;\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {PIXI.SCALE_MODES} [textureOptions.scaleMode] - See {@link PIXI.SCALE_MODES} for possible values.\n     */\n    constructor(textureOptions?: IBaseTextureOptions)\n    {\n        this.texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n\n        this._pixelsWidth = 0;\n        this._pixelsHeight = 0;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param realWidth - Width of texture in pixels.\n     * @param realHeight - Height of texture in pixels.\n     * @param multisample - Number of samples of the framebuffer.\n     */\n    createTexture(realWidth: number, realHeight: number, multisample = MSAA_QUALITY.NONE): RenderTexture\n    {\n        const baseRenderTexture = new BaseRenderTexture(Object.assign({\n            width: realWidth,\n            height: realHeight,\n            resolution: 1,\n            multisample,\n        }, this.textureOptions));\n\n        return new RenderTexture(baseRenderTexture);\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param multisample - Number of samples of the render texture.\n     * @returns The new render texture.\n     */\n    getOptimalTexture(minWidth: number, minHeight: number, resolution = 1, multisample = MSAA_QUALITY.NONE): RenderTexture\n    {\n        let key;\n\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n\n        if (!this.enableFullScreen || minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight)\n        {\n            minWidth = nextPow2(minWidth);\n            minHeight = nextPow2(minHeight);\n            key = (((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF)) >>> 0;\n\n            if (multisample > 1)\n            {\n                key += multisample * 0x100000000;\n            }\n        }\n        else\n        {\n            key = multisample > 1 ? -multisample : -1;\n        }\n\n        if (!this.texturePool[key])\n        {\n            this.texturePool[key] = [];\n        }\n\n        let renderTexture = this.texturePool[key].pop();\n\n        if (!renderTexture)\n        {\n            renderTexture = this.createTexture(minWidth, minHeight, multisample);\n        }\n\n        renderTexture.filterPoolKey = key;\n        renderTexture.setResolution(resolution);\n\n        return renderTexture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     *\n     * `getFilterTexture(input, 0.5)` or `getFilterTexture(0.5, input)`\n     * @param input - renderTexture from which size and resolution will be copied\n     * @param resolution - override resolution of the renderTexture\n     *  It overrides, it does not multiply\n     * @param multisample - number of samples of the renderTexture\n     */\n    getFilterTexture(input: RenderTexture, resolution?: number, multisample?: MSAA_QUALITY): RenderTexture\n    {\n        const filterTexture = this.getOptimalTexture(input.width, input.height, resolution || input.resolution,\n            multisample || MSAA_QUALITY.NONE);\n\n        filterTexture.filterFrame = input.filterFrame;\n\n        return filterTexture;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    returnTexture(renderTexture: RenderTexture): void\n    {\n        const key = renderTexture.filterPoolKey;\n\n        renderTexture.filterFrame = null;\n        this.texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Alias for returnTexture, to be compliant with FilterSystem interface.\n     * @param renderTexture - The renderTexture to free\n     */\n    returnFilterTexture(renderTexture: RenderTexture): void\n    {\n        this.returnTexture(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this.texturePool)\n            {\n                const textures = this.texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this.texturePool = {};\n    }\n\n    /**\n     * If screen size was changed, drops all screen-sized textures,\n     * sets new screen size, sets `enableFullScreen` to true\n     *\n     * Size is measured in pixels, `renderer.view` can be passed here, not `renderer.screen`\n     * @param size - Initial size of screen.\n     */\n    setScreenSize(size: ISize): void\n    {\n        if (size.width === this._pixelsWidth\n            && size.height === this._pixelsHeight)\n        {\n            return;\n        }\n\n        this.enableFullScreen = size.width > 0 && size.height > 0;\n\n        for (const i in this.texturePool)\n        {\n            if (!(Number(i) < 0))\n            {\n                continue;\n            }\n\n            const textures = this.texturePool[i];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n\n            this.texturePool[i] = [];\n        }\n\n        this._pixelsWidth = size.width;\n        this._pixelsHeight = size.height;\n    }\n\n    /**\n     * Key that is used to store fullscreen renderTextures in a pool\n     * @constant\n     */\n    static SCREEN_KEY = -1;\n}\n"]},"metadata":{},"sourceType":"module"}