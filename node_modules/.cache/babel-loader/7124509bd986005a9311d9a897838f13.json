{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Shader, Matrix, Program, TextureMatrix, utils } from '@pixi/core';\nimport fragment from './shader/mesh.mjs';\nimport vertex from './shader/mesh2.mjs';\nvar MeshMaterial = /*#__PURE__*/function (_Shader) {\n  _inherits(MeshMaterial, _Shader);\n  var _super = _createSuper(MeshMaterial);\n  function MeshMaterial(uSampler, options) {\n    var _this;\n    _classCallCheck(this, MeshMaterial);\n    var uniforms = {\n      uSampler: uSampler,\n      alpha: 1,\n      uTextureMatrix: Matrix.IDENTITY,\n      uColor: new Float32Array([1, 1, 1, 1])\n    };\n    options = Object.assign({\n      tint: 16777215,\n      alpha: 1,\n      pluginName: \"batch\"\n    }, options);\n    if (options.uniforms) {\n      Object.assign(uniforms, options.uniforms);\n    }\n    _this = _super.call(this, options.program || Program.from(vertex, fragment), uniforms);\n    _this._colorDirty = false;\n    _this.uvMatrix = new TextureMatrix(uSampler);\n    _this.batchable = options.program === void 0;\n    _this.pluginName = options.pluginName;\n    _this.tint = options.tint;\n    _this.alpha = options.alpha;\n    return _this;\n  }\n  _createClass(MeshMaterial, [{\n    key: \"texture\",\n    get: function get() {\n      return this.uniforms.uSampler;\n    },\n    set: function set(value) {\n      if (this.uniforms.uSampler !== value) {\n        if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode) {\n          this._colorDirty = true;\n        }\n        this.uniforms.uSampler = value;\n        this.uvMatrix.texture = value;\n      }\n    }\n  }, {\n    key: \"alpha\",\n    get: function get() {\n      return this._alpha;\n    },\n    set: function set(value) {\n      if (value === this._alpha) return;\n      this._alpha = value;\n      this._colorDirty = true;\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      if (value === this._tint) return;\n      this._tint = value;\n      this._tintRGB = (value >> 16) + (value & 65280) + ((value & 255) << 16);\n      this._colorDirty = true;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this._colorDirty) {\n        this._colorDirty = false;\n        var baseTexture = this.texture.baseTexture;\n        utils.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.alphaMode);\n      }\n      if (this.uvMatrix.update()) {\n        this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n      }\n    }\n  }]);\n  return MeshMaterial;\n}(Shader);\nexport { MeshMaterial };","map":{"version":3,"sources":["../src/MeshMaterial.ts"],"names":[],"mappings":"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","sourcesContent":["import { Matrix, utils, Program, Shader, TextureMatrix } from '@pixi/core';\nimport fragment from './shader/mesh.frag';\nimport vertex from './shader/mesh.vert';\n\nimport type { Texture } from '@pixi/core';\n\nexport interface IMeshMaterialOptions\n{\n    alpha?: number;\n    tint?: number;\n    pluginName?: string;\n    program?: Program;\n    uniforms?: utils.Dict<unknown>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MeshMaterial extends GlobalMixins.MeshMaterial {}\n\n/**\n * Slightly opinionated default shader for PixiJS 2D objects.\n * @memberof PIXI\n */\nexport class MeshMaterial extends Shader\n{\n    /**\n     * TextureMatrix instance for this Mesh, used to track Texture changes.\n     * @readonly\n     */\n    public readonly uvMatrix: TextureMatrix;\n\n    /**\n     * `true` if shader can be batch with the renderer's batch system.\n     * @default true\n     */\n    public batchable: boolean;\n\n    /**\n     * Renderer plugin for batching.\n     * @default 'batch'\n     */\n    public pluginName: string;\n\n    // Internal-only properties\n    _tintRGB: number;\n\n    /**\n     * Only do update if tint or alpha changes.\n     * @private\n     * @default false\n     */\n    private _colorDirty: boolean;\n    private _alpha: number;\n    private _tint: number;\n\n    /**\n     * @param uSampler - Texture that material uses to render.\n     * @param options - Additional options\n     * @param {number} [options.alpha=1] - Default alpha.\n     * @param {number} [options.tint=0xFFFFFF] - Default tint.\n     * @param {string} [options.pluginName='batch'] - Renderer plugin for batching.\n     * @param {PIXI.Program} [options.program=0xFFFFFF] - Custom program.\n     * @param {object} [options.uniforms] - Custom uniforms.\n     */\n    constructor(uSampler: Texture, options?: IMeshMaterialOptions)\n    {\n        const uniforms = {\n            uSampler,\n            alpha: 1,\n            uTextureMatrix: Matrix.IDENTITY,\n            uColor: new Float32Array([1, 1, 1, 1]),\n        };\n\n        // Set defaults\n        options = Object.assign({\n            tint: 0xFFFFFF,\n            alpha: 1,\n            pluginName: 'batch',\n        }, options);\n\n        if (options.uniforms)\n        {\n            Object.assign(uniforms, options.uniforms);\n        }\n\n        super(options.program || Program.from(vertex, fragment), uniforms);\n\n        this._colorDirty = false;\n\n        this.uvMatrix = new TextureMatrix(uSampler);\n        this.batchable = options.program === undefined;\n        this.pluginName = options.pluginName;\n\n        this.tint = options.tint;\n        this.alpha = options.alpha;\n    }\n\n    /** Reference to the texture being rendered. */\n    get texture(): Texture\n    {\n        return this.uniforms.uSampler;\n    }\n    set texture(value: Texture)\n    {\n        if (this.uniforms.uSampler !== value)\n        {\n            if (!this.uniforms.uSampler.baseTexture.alphaMode !== !value.baseTexture.alphaMode)\n            {\n                this._colorDirty = true;\n            }\n\n            this.uniforms.uSampler = value;\n            this.uvMatrix.texture = value;\n        }\n    }\n\n    /**\n     * This gets automatically set by the object using this.\n     * @default 1\n     */\n    set alpha(value: number)\n    {\n        if (value === this._alpha) return;\n\n        this._alpha = value;\n        this._colorDirty = true;\n    }\n    get alpha(): number\n    {\n        return this._alpha;\n    }\n\n    /**\n     * Multiply tint for the material.\n     * @default 0xFFFFFF\n     */\n    set tint(value: number)\n    {\n        if (value === this._tint) return;\n\n        this._tint = value;\n        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n        this._colorDirty = true;\n    }\n    get tint(): number\n    {\n        return this._tint;\n    }\n\n    /** Gets called automatically by the Mesh. Intended to be overridden for custom {@link MeshMaterial} objects. */\n    public update(): void\n    {\n        if (this._colorDirty)\n        {\n            this._colorDirty = false;\n            const baseTexture = this.texture.baseTexture;\n\n            utils.premultiplyTintToRgba(\n                this._tint, this._alpha, this.uniforms.uColor, (baseTexture.alphaMode as unknown as boolean)\n            );\n        }\n        if (this.uvMatrix.update())\n        {\n            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}