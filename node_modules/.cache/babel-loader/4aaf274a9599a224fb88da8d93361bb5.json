{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiRegistry = void 0;\nvar errors = __importStar(require(\"../../errors\"));\nvar utils_1 = require(\"../../utils\");\nvar struct_1 = require(\"./struct\");\nvar contractInterface_1 = require(\"./contractInterface\");\nvar enum_1 = require(\"./enum\");\nvar typeMapper_1 = require(\"./typeMapper\");\nvar endpoint_1 = require(\"./endpoint\");\nvar AbiRegistry = /*#__PURE__*/function () {\n  function AbiRegistry() {\n    _classCallCheck(this, AbiRegistry);\n    this.interfaces = [];\n    this.customTypes = [];\n  }\n  _createClass(AbiRegistry, [{\n    key: \"extend\",\n    value: function extend(json) {\n      json.types = json.types || {};\n      // The \"endpoints\" collection is interpreted by \"ContractInterface\".\n      var iface = contractInterface_1.ContractInterface.fromJSON(json);\n      this.interfaces.push(iface);\n      for (var customTypeName in json.types) {\n        var itemJson = json.types[customTypeName];\n        var typeDiscriminant = itemJson.type;\n        // Workaround: set the \"name\" field, as required by \"fromJSON()\" below.\n        itemJson.name = customTypeName;\n        var customType = this.createCustomType(typeDiscriminant, itemJson);\n        this.customTypes.push(customType);\n      }\n      this.sortCustomTypesByDependencies();\n      return this;\n    }\n  }, {\n    key: \"createCustomType\",\n    value: function createCustomType(typeDiscriminant, json) {\n      if (typeDiscriminant == \"struct\") {\n        return struct_1.StructType.fromJSON(json);\n      }\n      if (typeDiscriminant == \"enum\") {\n        return enum_1.EnumType.fromJSON(json);\n      }\n      throw new errors.ErrTypingSystem(\"Unknown type discriminant: \".concat(typeDiscriminant));\n    }\n  }, {\n    key: \"sortCustomTypesByDependencies\",\n    value: function sortCustomTypesByDependencies() {\n      // TODO: Improve consistency of the sorting function (and make sure the sorting is stable): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n      this.customTypes.sort(function (a, b) {\n        var bDependsOnA = b.getNamesOfDependencies().indexOf(a.getName()) > -1;\n        if (bDependsOnA) {\n          // Sort \"a\" before \"b\".\n          return -1;\n        }\n        // Sort \"b\" before \"a\".\n        return 1;\n      });\n    }\n  }, {\n    key: \"getInterface\",\n    value: function getInterface(name) {\n      var result = this.interfaces.find(function (e) {\n        return e.name == name;\n      });\n      utils_1.guardValueIsSetWithMessage(\"interface [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getInterfaces\",\n    value: function getInterfaces(names) {\n      var _this = this;\n      return names.map(function (name) {\n        return _this.getInterface(name);\n      });\n    }\n  }, {\n    key: \"getStruct\",\n    value: function getStruct(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(struct_1.StructType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"struct [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getStructs\",\n    value: function getStructs(names) {\n      var _this2 = this;\n      return names.map(function (name) {\n        return _this2.getStruct(name);\n      });\n    }\n  }, {\n    key: \"getEnum\",\n    value: function getEnum(name) {\n      var result = this.customTypes.find(function (e) {\n        return e.getName() == name && e.hasExactClass(enum_1.EnumType.ClassName);\n      });\n      utils_1.guardValueIsSetWithMessage(\"enum [\".concat(name, \"] not found\"), result);\n      return result;\n    }\n  }, {\n    key: \"getEnums\",\n    value: function getEnums(names) {\n      var _this3 = this;\n      return names.map(function (name) {\n        return _this3.getEnum(name);\n      });\n    }\n    /**\n     * Right after loading ABI definitions into a registry, the endpoints and the custom types (structs, enums)\n     * use raw types for their I/O parameters (in the case of endpoints), or for their fields (in the case of structs).\n     *\n     * A raw type is merely an instance of {@link Type}, with a given name and type parameters (if it's a generic type).\n     *\n     * Though, for most (development) purposes, we'd like to operate using known, specific types (e.g. {@link List}, {@link U8Type} etc.).\n     * This function increases the specificity of the types used by parameter / field definitions within a registry (on best-efforts basis).\n     * The result is an equivalent, more explicit ABI registry.\n     */\n  }, {\n    key: \"remapToKnownTypes\",\n    value: function remapToKnownTypes() {\n      var _newRegistry$customTy, _newRegistry$interfac;\n      var mapper = new typeMapper_1.TypeMapper([]);\n      var newCustomTypes = [];\n      var newInterfaces = [];\n      // First, remap custom types (actually, under the hood, this will remap types of struct fields)\n      var _iterator = _createForOfIteratorHelper(this.customTypes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          var mappedTyped = mapper.mapType(type);\n          newCustomTypes.push(mappedTyped);\n        }\n        // Then, remap types of all endpoint parameters.\n        // But we'll use an enhanced mapper, that takes into account the results from the previous step.\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      mapper = new typeMapper_1.TypeMapper(newCustomTypes);\n      var _iterator2 = _createForOfIteratorHelper(this.interfaces),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var iface = _step2.value;\n          var newEndpoints = [];\n          var _iterator3 = _createForOfIteratorHelper(iface.endpoints),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var endpoint = _step3.value;\n              newEndpoints.push(mapEndpoint(endpoint, mapper));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          var newConstructor = iface.constructorDefinition ? mapEndpoint(iface.constructorDefinition, mapper) : null;\n          newInterfaces.push(new contractInterface_1.ContractInterface(iface.name, newConstructor, newEndpoints));\n        }\n        // Now return the new registry, with all types remapped to known types\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var newRegistry = new AbiRegistry();\n      (_newRegistry$customTy = newRegistry.customTypes).push.apply(_newRegistry$customTy, newCustomTypes);\n      (_newRegistry$interfac = newRegistry.interfaces).push.apply(_newRegistry$interfac, newInterfaces);\n      return newRegistry;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(json) {\n      var registry = new AbiRegistry().extend(json);\n      var remappedRegistry = registry.remapToKnownTypes();\n      return remappedRegistry;\n    }\n  }]);\n  return AbiRegistry;\n}();\nexports.AbiRegistry = AbiRegistry;\nfunction mapEndpoint(endpoint, mapper) {\n  var newInput = endpoint.input.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  var newOutput = endpoint.output.map(function (e) {\n    return new endpoint_1.EndpointParameterDefinition(e.name, e.description, mapper.mapType(e.type));\n  });\n  return new endpoint_1.EndpointDefinition(endpoint.name, newInput, newOutput, endpoint.modifiers);\n}","map":null,"metadata":{},"sourceType":"script"}