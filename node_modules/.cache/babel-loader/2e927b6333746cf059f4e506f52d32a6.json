{"ast":null,"code":"'use strict';\n\nmodule.exports = API;\nvar chromeApi = require('./google-u2f-api');\n\n// Feature detection (yes really)\nvar isBrowser = typeof navigator !== 'undefined' && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match(/Safari\\//) && !navigator.userAgent.match(/Chrome\\//);\nvar isEDGE = isBrowser && navigator.userAgent.match(/Edge\\/1[2345]/);\nvar _backend = null;\nfunction getBackend(Promise) {\n  if (!_backend) _backend = new Promise(function (resolve, reject) {\n    function notSupported() {\n      // Note; {native: true} means *not* using Google's hack\n      resolve({\n        u2f: null,\n        native: true\n      });\n    }\n    if (!isBrowser) return notSupported();\n    if (isSafari)\n      // Safari doesn't support U2F, and the Safari-FIDO-U2F\n      // extension lacks full support (Multi-facet apps), so we\n      // block it until proper support.\n      return notSupported();\n    var hasNativeSupport = typeof window.u2f !== 'undefined' && typeof window.u2f.sign === 'function';\n    if (hasNativeSupport) resolve({\n      u2f: window.u2f,\n      native: true\n    });\n    if (isEDGE)\n      // We don't want to check for Google's extension hack on EDGE\n      // as it'll cause trouble (popups, etc)\n      return notSupported();\n    if (location.protocol === 'http:')\n      // U2F isn't supported over http, only https\n      return notSupported();\n    if (typeof MessageChannel === 'undefined')\n      // Unsupported browser, the chrome hack would throw\n      return notSupported();\n\n    // Test for google extension support\n    chromeApi.isSupported(function (ok) {\n      if (ok) resolve({\n        u2f: chromeApi,\n        native: false\n      });else notSupported();\n    });\n  });\n  return _backend;\n}\nfunction API(Promise) {\n  return {\n    isSupported: isSupported.bind(Promise),\n    ensureSupport: ensureSupport.bind(Promise),\n    register: register.bind(Promise),\n    sign: sign.bind(Promise),\n    ErrorCodes: API.ErrorCodes,\n    ErrorNames: API.ErrorNames\n  };\n}\nAPI.ErrorCodes = {\n  CANCELLED: -1,\n  OK: 0,\n  OTHER_ERROR: 1,\n  BAD_REQUEST: 2,\n  CONFIGURATION_UNSUPPORTED: 3,\n  DEVICE_INELIGIBLE: 4,\n  TIMEOUT: 5\n};\nAPI.ErrorNames = {\n  \"-1\": \"CANCELLED\",\n  \"0\": \"OK\",\n  \"1\": \"OTHER_ERROR\",\n  \"2\": \"BAD_REQUEST\",\n  \"3\": \"CONFIGURATION_UNSUPPORTED\",\n  \"4\": \"DEVICE_INELIGIBLE\",\n  \"5\": \"TIMEOUT\"\n};\nfunction makeError(msg, err) {\n  var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n  var type = API.ErrorNames['' + code];\n  var error = new Error(msg);\n  error.metaData = {\n    type: type,\n    code: code\n  };\n  return error;\n}\nfunction deferPromise(Promise, promise) {\n  var ret = {};\n  ret.promise = new Promise(function (resolve, reject) {\n    ret.resolve = resolve;\n    ret.reject = reject;\n    promise.then(resolve, reject);\n  });\n  /**\n   * Reject request promise and disconnect port if 'disconnect' flag is true\n   * @param {string} msg\n   * @param {boolean} disconnect\n   */\n  ret.promise.cancel = function (msg, disconnect) {\n    getBackend(Promise).then(function (backend) {\n      if (disconnect && !backend.native) backend.u2f.disconnect();\n      ret.reject(makeError(msg, {\n        errorCode: -1\n      }));\n    });\n  };\n  return ret;\n}\nfunction defer(Promise, fun) {\n  return deferPromise(Promise, new Promise(function (resolve, reject) {\n    try {\n      fun && fun(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }));\n}\nfunction isSupported() {\n  var Promise = this;\n  return getBackend(Promise).then(function (backend) {\n    return !!backend.u2f;\n  });\n}\nfunction _ensureSupport(backend) {\n  if (!backend.u2f) {\n    if (location.protocol === 'http:') throw new Error(\"U2F isn't supported over http, only https\");\n    throw new Error(\"U2F not supported\");\n  }\n}\nfunction ensureSupport() {\n  var Promise = this;\n  return getBackend(Promise).then(_ensureSupport);\n}\nfunction register(registerRequests, signRequests /* = null */, timeout) {\n  var Promise = this;\n  if (!Array.isArray(registerRequests)) registerRequests = [registerRequests];\n  if (typeof signRequests === 'number' && typeof timeout === 'undefined') {\n    timeout = signRequests;\n    signRequests = null;\n  }\n  if (!signRequests) signRequests = [];\n  return deferPromise(Promise, getBackend(Promise).then(function (backend) {\n    _ensureSupport(backend);\n    var native = backend.native;\n    var u2f = backend.u2f;\n    return new Promise(function (resolve, reject) {\n      function cbNative(response) {\n        if (response.errorCode) reject(makeError(\"Registration failed\", response));else {\n          delete response.errorCode;\n          resolve(response);\n        }\n      }\n      function cbChrome(err, response) {\n        if (err) reject(err);else if (response.errorCode) reject(makeError(\"Registration failed\", response));else resolve(response);\n      }\n      if (native) {\n        var appId = registerRequests[0].appId;\n        u2f.register(appId, registerRequests, signRequests, cbNative, timeout);\n      } else {\n        u2f.register(registerRequests, signRequests, cbChrome, timeout);\n      }\n    });\n  })).promise;\n}\nfunction sign(signRequests, timeout) {\n  var Promise = this;\n  if (!Array.isArray(signRequests)) signRequests = [signRequests];\n  return deferPromise(Promise, getBackend(Promise).then(function (backend) {\n    _ensureSupport(backend);\n    var native = backend.native;\n    var u2f = backend.u2f;\n    return new Promise(function (resolve, reject) {\n      function cbNative(response) {\n        if (response.errorCode) reject(makeError(\"Sign failed\", response));else {\n          delete response.errorCode;\n          resolve(response);\n        }\n      }\n      function cbChrome(err, response) {\n        if (err) reject(err);else if (response.errorCode) reject(makeError(\"Sign failed\", response));else resolve(response);\n      }\n      if (native) {\n        var appId = signRequests[0].appId;\n        var challenge = signRequests[0].challenge;\n        u2f.sign(appId, challenge, signRequests, cbNative, timeout);\n      } else {\n        u2f.sign(signRequests, cbChrome, timeout);\n      }\n    });\n  })).promise;\n}\nfunction makeDefault(func) {\n  API[func] = function () {\n    if (!global.Promise)\n      // This is very unlikely to ever happen, since browsers\n      // supporting U2F will most likely support Promises.\n      throw new Error(\"The platform doesn't natively support promises\");\n    var args = [].slice.call(arguments);\n    return API(global.Promise)[func].apply(null, args);\n  };\n}\n\n// Provide default functions using the built-in Promise if available.\nmakeDefault('isSupported');\nmakeDefault('ensureSupport');\nmakeDefault('register');\nmakeDefault('sign');","map":null,"metadata":{},"sourceType":"script"}