{"ast":null,"code":"/*!\n * @pixi/utils - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar settings = require('@pixi/settings');\nvar eventemitter3 = require('eventemitter3');\nvar earcut = require('earcut');\nvar url$1 = require('url');\nvar constants = require('@pixi/constants');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar eventemitter3__default = /*#__PURE__*/_interopDefaultLegacy(eventemitter3);\nvar earcut__default = /*#__PURE__*/_interopDefaultLegacy(earcut);\n\n/**\n * This file contains redeclared types for Node `url` and `querystring` modules. These modules\n * don't provide their own typings but instead are a part of the full Node typings. The purpose of\n * this file is to redeclare the required types to avoid having the whole Node types as a\n * dependency.\n */\nvar url = {\n  parse: url$1.parse,\n  format: url$1.format,\n  resolve: url$1.resolve\n};\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(path));\n  }\n}\nfunction removeUrlParams(url) {\n  var re = url.split('?')[0];\n  return re.split('#')[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) ;else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += '/..';\n          } else {\n            res = '..';\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += \"/\" + path.slice(lastSlash + 1, i);\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nvar path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix: function toPosix(path) {\n    return replaceAll(path, '\\\\', '/');\n  },\n  /**\n   * Checks if the path is a URL\n   * @param path - The path to check\n   */\n  isUrl: function isUrl(path) {\n    return /^https?:/.test(this.toPosix(path));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl: function isDataUrl(path) {\n    // eslint-disable-next-line max-len\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path);\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol: function hasProtocol(path) {\n    return /^[^/:]+:\\//.test(this.toPosix(path));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, C:/, file:///\n   * @param path - The path to get the protocol from\n   */\n  getProtocol: function getProtocol(path) {\n    assertPath(path);\n    path = this.toPosix(path);\n    var protocol = '';\n    var isFile = /^file:\\/\\/\\//.exec(path);\n    var isHttp = /^[^/:]+:\\/\\//.exec(path);\n    var isWindows = /^[^/:]+:\\//.exec(path);\n    if (isFile || isHttp || isWindows) {\n      var arr = (isFile === null || isFile === void 0 ? void 0 : isFile[0]) || (isHttp === null || isHttp === void 0 ? void 0 : isHttp[0]) || (isWindows === null || isWindows === void 0 ? void 0 : isWindows[0]);\n      protocol = arr;\n      path = path.slice(arr.length);\n    }\n    return protocol;\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute: function toAbsolute(url, customBaseUrl, customRootUrl) {\n    if (this.isDataUrl(url)) {\n      return url;\n    }\n    var baseUrl = removeUrlParams(this.toPosix(customBaseUrl !== null && customBaseUrl !== void 0 ? customBaseUrl : settings.settings.ADAPTER.getBaseUrl()));\n    var rootUrl = removeUrlParams(this.toPosix(customRootUrl !== null && customRootUrl !== void 0 ? customRootUrl : this.rootname(baseUrl)));\n    assertPath(url);\n    url = this.toPosix(url);\n    // root relative url\n    if (url.startsWith('/')) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    var absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize: function normalize(path) {\n    path = this.toPosix(path);\n    assertPath(path);\n    if (path.length === 0) {\n      return '.';\n    }\n    var protocol = '';\n    var isAbsolute = path.startsWith('/');\n    if (this.hasProtocol(path)) {\n      protocol = this.rootname(path);\n      path = path.slice(protocol.length);\n    }\n    var trailingSeparator = path.endsWith('/');\n    // Normalize the path\n    path = normalizeStringPosix(path, false);\n    if (path.length > 0 && trailingSeparator) {\n      path += '/';\n    }\n    if (isAbsolute) {\n      return \"/\" + path;\n    }\n    return protocol + path;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    path = this.toPosix(path);\n    if (this.hasProtocol(path)) {\n      return true;\n    }\n    return path.startsWith('/');\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join: function join() {\n    var arguments$1 = arguments;\n    var _a;\n    var segments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      segments[_i] = arguments$1[_i];\n    }\n    if (segments.length === 0) {\n      return '.';\n    }\n    var joined;\n    for (var i = 0; i < segments.length; ++i) {\n      var arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          var prevArg = (_a = segments[i - 1]) !== null && _a !== void 0 ? _a : '';\n          if (this.extname(prevArg)) {\n            joined += \"/../\" + arg;\n          } else {\n            joined += \"/\" + arg;\n          }\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) {\n      return '.';\n    }\n    path = this.toPosix(path);\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47;\n    var end = -1;\n    var matchedSlash = true;\n    var proto = this.getProtocol(path);\n    var origpath = path;\n    path = path.slice(proto.length);\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n    // if end is -1 and its a url then we need to add the path back\n    // eslint-disable-next-line no-nested-ternary\n    if (end === -1) {\n      return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return proto + path.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname: function rootname(path) {\n    assertPath(path);\n    path = this.toPosix(path);\n    var root = '';\n    if (path.startsWith('/')) {\n      root = '/';\n    } else {\n      root = this.getProtocol(path);\n    }\n    if (this.isUrl(path)) {\n      // need to find the first path separator\n      var index = path.indexOf('/', root.length);\n      if (index !== -1) {\n        root = path.slice(0, index);\n      } else {\n        root = path;\n      }\n      if (!root.endsWith('/')) {\n        root += '/';\n      }\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename: function basename(path, ext) {\n    assertPath(path);\n    if (ext) {\n      assertPath(ext);\n    }\n    path = this.toPosix(path);\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) {\n        return '';\n      }\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === 47) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname: function extname(path) {\n    assertPath(path);\n    path = this.toPosix(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1\n    // We saw a non-dot character immediately before the dot\n    || preDotState === 0\n    // The (right-most) trimmed path component is exactly '..'\n    // eslint-disable-next-line no-mixed-operators\n    || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse: function parse(path) {\n    assertPath(path);\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    path = this.toPosix(path);\n    var code = path.charCodeAt(0);\n    var isAbsolute = this.isAbsolute(path);\n    var start;\n    ret.root = this.rootname(path);\n    if (isAbsolute || this.hasProtocol(path)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1\n    // We saw a non-dot character immediately before the dot\n    || preDotState === 0\n    // The (right-most) trimmed path component is exactly '..'\n    // eslint-disable-next-line no-mixed-operators\n    || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) {\n          ret.base = ret.name = path.slice(1, end);\n        } else {\n          ret.base = ret.name = path.slice(startPart, end);\n        }\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path);\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':'\n};\n\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @memberof PIXI.settings\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nsettings.settings.RETINA_PREFIX = /@([0-9\\.]+)x/;\n/**\n * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported` function.\n * If set to true, a WebGL renderer can fail to be created if the browser thinks there could be performance issues when\n * using WebGL.\n *\n * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many scenarios as possible.\n * However, some users may have a poor experience, for example, if a user has a gpu or driver version blacklisted by the\n * browser.\n *\n * If your application requires high performance rendering, you may wish to set this to false.\n * We recommend one of two options if you decide to set this flag to false:\n *\n * 1: Use the `pixi.js-legacy` package, which includes a Canvas renderer as a fallback in case high performance WebGL is\n *    not supported.\n *\n * 2: Call `isWebGLSupported` (which if found in the PIXI.utils package) in your code before attempting to create a PixiJS\n *    renderer, and show an error message to the user if the function returns false, explaining that their device & browser\n *    combination does not support high performance WebGL.\n *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n * @static\n * @name FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */\nsettings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\nvar saidHello = false;\nvar VERSION = '6.5.8';\n/**\n * Skips the hello message of renderers that are created after this is run.\n * @function skipHello\n * @memberof PIXI.utils\n */\nfunction skipHello() {\n  saidHello = true;\n}\n/**\n * Logs out the version and renderer information for this running instance of PIXI.\n * If you don't want to see this message you can run `PIXI.utils.skipHello()` before\n * creating your renderer. Keep in mind that doing that will forever make you a jerk face.\n * @static\n * @function sayHello\n * @memberof PIXI.utils\n * @param {string} type - The string renderer type to log.\n */\nfunction sayHello(type) {\n  var _a;\n  if (saidHello) {\n    return;\n  }\n  if (settings.settings.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1) {\n    var args = [\"\\n %c %c %c PixiJS \" + VERSION + \" - \\u2730 \" + type + \" \\u2730  %c  %c  http://www.pixijs.com/  %c %c \\u2665%c\\u2665%c\\u2665 \\n\\n\", 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];\n    (_a = globalThis.console).log.apply(_a, args);\n  } else if (globalThis.console) {\n    globalThis.console.log(\"PixiJS \" + VERSION + \" - \" + type + \" - http://www.pixijs.com/\");\n  }\n  saidHello = true;\n}\nvar supported;\n/**\n * Helper for checking for WebGL support.\n * @memberof PIXI.utils\n * @function isWebGLSupported\n * @returns {boolean} Is WebGL supported.\n */\nfunction isWebGLSupported() {\n  if (typeof supported === 'undefined') {\n    supported = function supported() {\n      var contextOptions = {\n        stencil: true,\n        failIfMajorPerformanceCaveat: settings.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n      };\n      try {\n        if (!settings.settings.ADAPTER.getWebGLRenderingContext()) {\n          return false;\n        }\n        var canvas = settings.settings.ADAPTER.createCanvas();\n        var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);\n        var success = !!(gl && gl.getContextAttributes().stencil);\n        if (gl) {\n          var loseContext = gl.getExtension('WEBGL_lose_context');\n          if (loseContext) {\n            loseContext.loseContext();\n          }\n        }\n        gl = null;\n        return success;\n      } catch (e) {\n        return false;\n      }\n    }();\n  }\n  return supported;\n}\nvar aliceblue = \"#f0f8ff\";\nvar antiquewhite = \"#faebd7\";\nvar aqua = \"#00ffff\";\nvar aquamarine = \"#7fffd4\";\nvar azure = \"#f0ffff\";\nvar beige = \"#f5f5dc\";\nvar bisque = \"#ffe4c4\";\nvar black = \"#000000\";\nvar blanchedalmond = \"#ffebcd\";\nvar blue = \"#0000ff\";\nvar blueviolet = \"#8a2be2\";\nvar brown = \"#a52a2a\";\nvar burlywood = \"#deb887\";\nvar cadetblue = \"#5f9ea0\";\nvar chartreuse = \"#7fff00\";\nvar chocolate = \"#d2691e\";\nvar coral = \"#ff7f50\";\nvar cornflowerblue = \"#6495ed\";\nvar cornsilk = \"#fff8dc\";\nvar crimson = \"#dc143c\";\nvar cyan = \"#00ffff\";\nvar darkblue = \"#00008b\";\nvar darkcyan = \"#008b8b\";\nvar darkgoldenrod = \"#b8860b\";\nvar darkgray = \"#a9a9a9\";\nvar darkgreen = \"#006400\";\nvar darkgrey = \"#a9a9a9\";\nvar darkkhaki = \"#bdb76b\";\nvar darkmagenta = \"#8b008b\";\nvar darkolivegreen = \"#556b2f\";\nvar darkorange = \"#ff8c00\";\nvar darkorchid = \"#9932cc\";\nvar darkred = \"#8b0000\";\nvar darksalmon = \"#e9967a\";\nvar darkseagreen = \"#8fbc8f\";\nvar darkslateblue = \"#483d8b\";\nvar darkslategray = \"#2f4f4f\";\nvar darkslategrey = \"#2f4f4f\";\nvar darkturquoise = \"#00ced1\";\nvar darkviolet = \"#9400d3\";\nvar deeppink = \"#ff1493\";\nvar deepskyblue = \"#00bfff\";\nvar dimgray = \"#696969\";\nvar dimgrey = \"#696969\";\nvar dodgerblue = \"#1e90ff\";\nvar firebrick = \"#b22222\";\nvar floralwhite = \"#fffaf0\";\nvar forestgreen = \"#228b22\";\nvar fuchsia = \"#ff00ff\";\nvar gainsboro = \"#dcdcdc\";\nvar ghostwhite = \"#f8f8ff\";\nvar goldenrod = \"#daa520\";\nvar gold = \"#ffd700\";\nvar gray = \"#808080\";\nvar green = \"#008000\";\nvar greenyellow = \"#adff2f\";\nvar grey = \"#808080\";\nvar honeydew = \"#f0fff0\";\nvar hotpink = \"#ff69b4\";\nvar indianred = \"#cd5c5c\";\nvar indigo = \"#4b0082\";\nvar ivory = \"#fffff0\";\nvar khaki = \"#f0e68c\";\nvar lavenderblush = \"#fff0f5\";\nvar lavender = \"#e6e6fa\";\nvar lawngreen = \"#7cfc00\";\nvar lemonchiffon = \"#fffacd\";\nvar lightblue = \"#add8e6\";\nvar lightcoral = \"#f08080\";\nvar lightcyan = \"#e0ffff\";\nvar lightgoldenrodyellow = \"#fafad2\";\nvar lightgray = \"#d3d3d3\";\nvar lightgreen = \"#90ee90\";\nvar lightgrey = \"#d3d3d3\";\nvar lightpink = \"#ffb6c1\";\nvar lightsalmon = \"#ffa07a\";\nvar lightseagreen = \"#20b2aa\";\nvar lightskyblue = \"#87cefa\";\nvar lightslategray = \"#778899\";\nvar lightslategrey = \"#778899\";\nvar lightsteelblue = \"#b0c4de\";\nvar lightyellow = \"#ffffe0\";\nvar lime = \"#00ff00\";\nvar limegreen = \"#32cd32\";\nvar linen = \"#faf0e6\";\nvar magenta = \"#ff00ff\";\nvar maroon = \"#800000\";\nvar mediumaquamarine = \"#66cdaa\";\nvar mediumblue = \"#0000cd\";\nvar mediumorchid = \"#ba55d3\";\nvar mediumpurple = \"#9370db\";\nvar mediumseagreen = \"#3cb371\";\nvar mediumslateblue = \"#7b68ee\";\nvar mediumspringgreen = \"#00fa9a\";\nvar mediumturquoise = \"#48d1cc\";\nvar mediumvioletred = \"#c71585\";\nvar midnightblue = \"#191970\";\nvar mintcream = \"#f5fffa\";\nvar mistyrose = \"#ffe4e1\";\nvar moccasin = \"#ffe4b5\";\nvar navajowhite = \"#ffdead\";\nvar navy = \"#000080\";\nvar oldlace = \"#fdf5e6\";\nvar olive = \"#808000\";\nvar olivedrab = \"#6b8e23\";\nvar orange = \"#ffa500\";\nvar orangered = \"#ff4500\";\nvar orchid = \"#da70d6\";\nvar palegoldenrod = \"#eee8aa\";\nvar palegreen = \"#98fb98\";\nvar paleturquoise = \"#afeeee\";\nvar palevioletred = \"#db7093\";\nvar papayawhip = \"#ffefd5\";\nvar peachpuff = \"#ffdab9\";\nvar peru = \"#cd853f\";\nvar pink = \"#ffc0cb\";\nvar plum = \"#dda0dd\";\nvar powderblue = \"#b0e0e6\";\nvar purple = \"#800080\";\nvar rebeccapurple = \"#663399\";\nvar red = \"#ff0000\";\nvar rosybrown = \"#bc8f8f\";\nvar royalblue = \"#4169e1\";\nvar saddlebrown = \"#8b4513\";\nvar salmon = \"#fa8072\";\nvar sandybrown = \"#f4a460\";\nvar seagreen = \"#2e8b57\";\nvar seashell = \"#fff5ee\";\nvar sienna = \"#a0522d\";\nvar silver = \"#c0c0c0\";\nvar skyblue = \"#87ceeb\";\nvar slateblue = \"#6a5acd\";\nvar slategray = \"#708090\";\nvar slategrey = \"#708090\";\nvar snow = \"#fffafa\";\nvar springgreen = \"#00ff7f\";\nvar steelblue = \"#4682b4\";\nvar tan = \"#d2b48c\";\nvar teal = \"#008080\";\nvar thistle = \"#d8bfd8\";\nvar tomato = \"#ff6347\";\nvar turquoise = \"#40e0d0\";\nvar violet = \"#ee82ee\";\nvar wheat = \"#f5deb3\";\nvar white = \"#ffffff\";\nvar whitesmoke = \"#f5f5f5\";\nvar yellow = \"#ffff00\";\nvar yellowgreen = \"#9acd32\";\nvar cssColorNames = {\n  aliceblue: aliceblue,\n  antiquewhite: antiquewhite,\n  aqua: aqua,\n  aquamarine: aquamarine,\n  azure: azure,\n  beige: beige,\n  bisque: bisque,\n  black: black,\n  blanchedalmond: blanchedalmond,\n  blue: blue,\n  blueviolet: blueviolet,\n  brown: brown,\n  burlywood: burlywood,\n  cadetblue: cadetblue,\n  chartreuse: chartreuse,\n  chocolate: chocolate,\n  coral: coral,\n  cornflowerblue: cornflowerblue,\n  cornsilk: cornsilk,\n  crimson: crimson,\n  cyan: cyan,\n  darkblue: darkblue,\n  darkcyan: darkcyan,\n  darkgoldenrod: darkgoldenrod,\n  darkgray: darkgray,\n  darkgreen: darkgreen,\n  darkgrey: darkgrey,\n  darkkhaki: darkkhaki,\n  darkmagenta: darkmagenta,\n  darkolivegreen: darkolivegreen,\n  darkorange: darkorange,\n  darkorchid: darkorchid,\n  darkred: darkred,\n  darksalmon: darksalmon,\n  darkseagreen: darkseagreen,\n  darkslateblue: darkslateblue,\n  darkslategray: darkslategray,\n  darkslategrey: darkslategrey,\n  darkturquoise: darkturquoise,\n  darkviolet: darkviolet,\n  deeppink: deeppink,\n  deepskyblue: deepskyblue,\n  dimgray: dimgray,\n  dimgrey: dimgrey,\n  dodgerblue: dodgerblue,\n  firebrick: firebrick,\n  floralwhite: floralwhite,\n  forestgreen: forestgreen,\n  fuchsia: fuchsia,\n  gainsboro: gainsboro,\n  ghostwhite: ghostwhite,\n  goldenrod: goldenrod,\n  gold: gold,\n  gray: gray,\n  green: green,\n  greenyellow: greenyellow,\n  grey: grey,\n  honeydew: honeydew,\n  hotpink: hotpink,\n  indianred: indianred,\n  indigo: indigo,\n  ivory: ivory,\n  khaki: khaki,\n  lavenderblush: lavenderblush,\n  lavender: lavender,\n  lawngreen: lawngreen,\n  lemonchiffon: lemonchiffon,\n  lightblue: lightblue,\n  lightcoral: lightcoral,\n  lightcyan: lightcyan,\n  lightgoldenrodyellow: lightgoldenrodyellow,\n  lightgray: lightgray,\n  lightgreen: lightgreen,\n  lightgrey: lightgrey,\n  lightpink: lightpink,\n  lightsalmon: lightsalmon,\n  lightseagreen: lightseagreen,\n  lightskyblue: lightskyblue,\n  lightslategray: lightslategray,\n  lightslategrey: lightslategrey,\n  lightsteelblue: lightsteelblue,\n  lightyellow: lightyellow,\n  lime: lime,\n  limegreen: limegreen,\n  linen: linen,\n  magenta: magenta,\n  maroon: maroon,\n  mediumaquamarine: mediumaquamarine,\n  mediumblue: mediumblue,\n  mediumorchid: mediumorchid,\n  mediumpurple: mediumpurple,\n  mediumseagreen: mediumseagreen,\n  mediumslateblue: mediumslateblue,\n  mediumspringgreen: mediumspringgreen,\n  mediumturquoise: mediumturquoise,\n  mediumvioletred: mediumvioletred,\n  midnightblue: midnightblue,\n  mintcream: mintcream,\n  mistyrose: mistyrose,\n  moccasin: moccasin,\n  navajowhite: navajowhite,\n  navy: navy,\n  oldlace: oldlace,\n  olive: olive,\n  olivedrab: olivedrab,\n  orange: orange,\n  orangered: orangered,\n  orchid: orchid,\n  palegoldenrod: palegoldenrod,\n  palegreen: palegreen,\n  paleturquoise: paleturquoise,\n  palevioletred: palevioletred,\n  papayawhip: papayawhip,\n  peachpuff: peachpuff,\n  peru: peru,\n  pink: pink,\n  plum: plum,\n  powderblue: powderblue,\n  purple: purple,\n  rebeccapurple: rebeccapurple,\n  red: red,\n  rosybrown: rosybrown,\n  royalblue: royalblue,\n  saddlebrown: saddlebrown,\n  salmon: salmon,\n  sandybrown: sandybrown,\n  seagreen: seagreen,\n  seashell: seashell,\n  sienna: sienna,\n  silver: silver,\n  skyblue: skyblue,\n  slateblue: slateblue,\n  slategray: slategray,\n  slategrey: slategrey,\n  snow: snow,\n  springgreen: springgreen,\n  steelblue: steelblue,\n  tan: tan,\n  teal: teal,\n  thistle: thistle,\n  tomato: tomato,\n  turquoise: turquoise,\n  violet: violet,\n  wheat: wheat,\n  white: white,\n  whitesmoke: whitesmoke,\n  yellow: yellow,\n  yellowgreen: yellowgreen\n};\n\n/**\n * Converts a hexadecimal color number to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n * @example\n * PIXI.utils.hex2rgb(0xffffff); // returns [1, 1, 1]\n * @memberof PIXI.utils\n * @function hex2rgb\n * @param {number} hex - The hexadecimal number to convert\n * @param  {number[]} [out=[]] - If supplied, this array will be used rather than returning a new one\n * @returns {number[]} An array representing the [R, G, B] of the color where all values are floats.\n */\nfunction hex2rgb(hex, out) {\n  if (out === void 0) {\n    out = [];\n  }\n  out[0] = (hex >> 16 & 0xFF) / 255;\n  out[1] = (hex >> 8 & 0xFF) / 255;\n  out[2] = (hex & 0xFF) / 255;\n  return out;\n}\n/**\n * Converts a hexadecimal color number to a string.\n * @example\n * PIXI.utils.hex2string(0xffffff); // returns \"#ffffff\"\n * @memberof PIXI.utils\n * @function hex2string\n * @param {number} hex - Number in hex (e.g., `0xffffff`)\n * @returns {string} The string color (e.g., `\"#ffffff\"`).\n */\nfunction hex2string(hex) {\n  var hexString = hex.toString(16);\n  hexString = '000000'.substring(0, 6 - hexString.length) + hexString;\n  return \"#\" + hexString;\n}\n/**\n * Converts a string to a hexadecimal color number.\n * It can handle:\n *  hex strings starting with #: \"#ffffff\"\n *  hex strings starting with 0x: \"0xffffff\"\n *  hex strings without prefix: \"ffffff\"\n *  css colors: \"black\"\n * @example\n * PIXI.utils.string2hex(\"#ffffff\"); // returns 0xffffff, which is 16777215 as an integer\n * @memberof PIXI.utils\n * @function string2hex\n * @param {string} string - The string color (e.g., `\"#ffffff\"`)\n * @returns {number} Number in hexadecimal.\n */\nfunction string2hex(string) {\n  if (typeof string === 'string') {\n    string = cssColorNames[string.toLowerCase()] || string;\n    if (string[0] === '#') {\n      string = string.slice(1);\n    }\n  }\n  return parseInt(string, 16);\n}\n/**\n * Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.\n * @example\n * PIXI.utils.rgb2hex([1, 1, 1]); // returns 0xffffff, which is 16777215 as an integer\n * @memberof PIXI.utils\n * @function rgb2hex\n * @param {number[]} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.\n * @returns {number} Number in hexadecimal.\n */\nfunction rgb2hex(rgb) {\n  return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0);\n}\n\n/**\n * Corrects PixiJS blend, takes premultiplied alpha into account\n * @memberof PIXI.utils\n * @function mapPremultipliedBlendModes\n * @private\n * @returns {Array<number[]>} Mapped modes.\n */\nfunction mapPremultipliedBlendModes() {\n  var pm = [];\n  var npm = [];\n  for (var i = 0; i < 32; i++) {\n    pm[i] = i;\n    npm[i] = i;\n  }\n  pm[constants.BLEND_MODES.NORMAL_NPM] = constants.BLEND_MODES.NORMAL;\n  pm[constants.BLEND_MODES.ADD_NPM] = constants.BLEND_MODES.ADD;\n  pm[constants.BLEND_MODES.SCREEN_NPM] = constants.BLEND_MODES.SCREEN;\n  npm[constants.BLEND_MODES.NORMAL] = constants.BLEND_MODES.NORMAL_NPM;\n  npm[constants.BLEND_MODES.ADD] = constants.BLEND_MODES.ADD_NPM;\n  npm[constants.BLEND_MODES.SCREEN] = constants.BLEND_MODES.SCREEN_NPM;\n  var array = [];\n  array.push(npm);\n  array.push(pm);\n  return array;\n}\n/**\n * maps premultiply flag and blendMode to adjusted blendMode\n * @memberof PIXI.utils\n * @constant premultiplyBlendMode\n * @type {Array<number[]>}\n */\nvar premultiplyBlendMode = mapPremultipliedBlendModes();\n/**\n * changes blendMode according to texture format\n * @memberof PIXI.utils\n * @function correctBlendMode\n * @param {number} blendMode - supposed blend mode\n * @param {boolean} premultiplied - whether source is premultiplied\n * @returns {number} true blend mode for this texture\n */\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\n/**\n * combines rgb and alpha to out array\n * @memberof PIXI.utils\n * @function premultiplyRgba\n * @param {Float32Array|number[]} rgb - input rgb\n * @param {number} alpha - alpha param\n * @param {Float32Array} [out] - output\n * @param {boolean} [premultiply=true] - do premultiply it\n * @returns {Float32Array} vec4 rgba\n */\nfunction premultiplyRgba(rgb, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  if (premultiply || premultiply === undefined) {\n    out[0] = rgb[0] * alpha;\n    out[1] = rgb[1] * alpha;\n    out[2] = rgb[2] * alpha;\n  } else {\n    out[0] = rgb[0];\n    out[1] = rgb[1];\n    out[2] = rgb[2];\n  }\n  out[3] = alpha;\n  return out;\n}\n/**\n * premultiplies tint\n * @memberof PIXI.utils\n * @function premultiplyTint\n * @param {number} tint - integer RGB\n * @param {number} alpha - floating point alpha (0.0-1.0)\n * @returns {number} tint multiplied by alpha\n */\nfunction premultiplyTint(tint, alpha) {\n  if (alpha === 1.0) {\n    return (alpha * 255 << 24) + tint;\n  }\n  if (alpha === 0.0) {\n    return 0;\n  }\n  var R = tint >> 16 & 0xFF;\n  var G = tint >> 8 & 0xFF;\n  var B = tint & 0xFF;\n  R = R * alpha + 0.5 | 0;\n  G = G * alpha + 0.5 | 0;\n  B = B * alpha + 0.5 | 0;\n  return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;\n}\n/**\n * converts integer tint and float alpha to vec4 form, premultiplies by default\n * @memberof PIXI.utils\n * @function premultiplyTintToRgba\n * @param {number} tint - input tint\n * @param {number} alpha - alpha param\n * @param {Float32Array} [out] - output\n * @param {boolean} [premultiply=true] - do premultiply it\n * @returns {Float32Array} vec4 rgba\n */\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  out[0] = (tint >> 16 & 0xFF) / 255.0;\n  out[1] = (tint >> 8 & 0xFF) / 255.0;\n  out[2] = (tint & 0xFF) / 255.0;\n  if (premultiply || premultiply === undefined) {\n    out[0] *= alpha;\n    out[1] *= alpha;\n    out[2] *= alpha;\n  }\n  out[3] = alpha;\n  return out;\n}\n\n/**\n * Generic Mask Stack data structure\n * @memberof PIXI.utils\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nfunction createIndicesForQuads(size, outBuffer) {\n  if (outBuffer === void 0) {\n    outBuffer = null;\n  }\n  // the total number of indices in our array, there are 6 points per quad.\n  var totalIndices = size * 6;\n  outBuffer = outBuffer || new Uint16Array(totalIndices);\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(\"Out buffer length is incorrect, got \" + outBuffer.length + \" and expected \" + totalIndices);\n  }\n  // fill the indices with the quads to draw\n  for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\nfunction getBufferType(array) {\n  if (array.BYTES_PER_ELEMENT === 4) {\n    if (array instanceof Float32Array) {\n      return 'Float32Array';\n    } else if (array instanceof Uint32Array) {\n      return 'Uint32Array';\n    }\n    return 'Int32Array';\n  } else if (array.BYTES_PER_ELEMENT === 2) {\n    if (array instanceof Uint16Array) {\n      return 'Uint16Array';\n    }\n  } else if (array.BYTES_PER_ELEMENT === 1) {\n    if (array instanceof Uint8Array) {\n      return 'Uint8Array';\n    }\n  }\n  // TODO map out the rest of the array elements!\n  return null;\n}\n\n/* eslint-disable object-shorthand */\nvar map = {\n  Float32Array: Float32Array,\n  Uint32Array: Uint32Array,\n  Int32Array: Int32Array,\n  Uint8Array: Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  var outSize = 0;\n  var stride = 0;\n  var views = {};\n  for (var i = 0; i < arrays.length; i++) {\n    stride += sizes[i];\n    outSize += arrays[i].length;\n  }\n  var buffer = new ArrayBuffer(outSize * 4);\n  var out = null;\n  var littleOffset = 0;\n  for (var i = 0; i < arrays.length; i++) {\n    var size = sizes[i];\n    var array = arrays[i];\n    /*\n    @todo This is unsafe casting but consistent with how the code worked previously. Should it stay this way\n          or should and `getBufferTypeUnsafe` function be exposed that throws an Error if unsupported type is passed?\n     */\n    var type = getBufferType(array);\n    if (!views[type]) {\n      views[type] = new map[type](buffer);\n    }\n    out = views[type];\n    for (var j = 0; j < array.length; j++) {\n      var indexStart = (j / size | 0) * stride + littleOffset;\n      var index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\n\n// Taken from the bit-twiddle package\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @memberof PIXI.utils\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n */\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @memberof PIXI.utils\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n */\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\n/**\n * Computes ceil of log base 2\n * @function log2\n * @memberof PIXI.utils\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n */\nfunction log2(v) {\n  var r = (v > 0xFFFF ? 1 : 0) << 4;\n  v >>>= r;\n  var shift = (v > 0xFF ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 0xF ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 0x3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\n/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @memberof PIXI.utils\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nfunction removeItems(arr, startIdx, removeCount) {\n  var length = arr.length;\n  var i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  var len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\n/**\n * Returns sign of number\n * @memberof PIXI.utils\n * @function sign\n * @param {number} n - the number to check the sign of\n * @returns {number} 0 if `n` is 0, -1 if `n` is negative, 1 if `n` is positive\n */\nfunction sign(n) {\n  if (n === 0) {\n    return 0;\n  }\n  return n < 0 ? -1 : 1;\n}\nvar nextUid = 0;\n/**\n * Gets the next unique identifier\n * @memberof PIXI.utils\n * @function uid\n * @returns {number} The next unique identifier to use.\n */\nfunction uid() {\n  return ++nextUid;\n}\n\n// A map of warning messages already fired\nvar warnings = {};\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n * @memberof PIXI.utils\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nfunction deprecation(version, message, ignoreDepth) {\n  if (ignoreDepth === void 0) {\n    ignoreDepth = 3;\n  }\n  // Ignore duplicat\n  if (warnings[message]) {\n    return;\n  }\n  /* eslint-disable no-console */\n  var stack = new Error().stack;\n  // Handle IE < 10 and Safari < 6\n  if (typeof stack === 'undefined') {\n    console.warn('PixiJS Deprecation Warning: ', message + \"\\nDeprecated since v\" + version);\n  } else {\n    // chop off the stack trace which includes PixiJS internal calls\n    stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n    if (console.groupCollapsed) {\n      console.groupCollapsed('%cPixiJS Deprecation Warning: %c%s', 'color:#614108;background:#fffbe6', 'font-weight:normal;color:#614108;background:#fffbe6', message + \"\\nDeprecated since v\" + version);\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn('PixiJS Deprecation Warning: ', message + \"\\nDeprecated since v\" + version);\n      console.warn(stack);\n    }\n  }\n  /* eslint-enable no-console */\n  warnings[message] = true;\n}\n\n/**\n * @todo Describe property usage\n * @static\n * @name ProgramCache\n * @memberof PIXI.utils\n * @type {object}\n */\nvar ProgramCache = {};\n/**\n * @todo Describe property usage\n * @static\n * @name TextureCache\n * @memberof PIXI.utils\n * @type {object}\n */\nvar TextureCache = Object.create(null);\n/**\n * @todo Describe property usage\n * @static\n * @name BaseTextureCache\n * @memberof PIXI.utils\n * @type {object}\n */\nvar BaseTextureCache = Object.create(null);\n/**\n * Destroys all texture in the cache\n * @memberof PIXI.utils\n * @function destroyTextureCache\n */\nfunction destroyTextureCache() {\n  var key;\n  for (key in TextureCache) {\n    TextureCache[key].destroy();\n  }\n  for (key in BaseTextureCache) {\n    BaseTextureCache[key].destroy();\n  }\n}\n/**\n * Removes all textures from cache, but does not destroy them\n * @memberof PIXI.utils\n * @function clearTextureCache\n */\nfunction clearTextureCache() {\n  var key;\n  for (key in TextureCache) {\n    delete TextureCache[key];\n  }\n  for (key in BaseTextureCache) {\n    delete BaseTextureCache[key];\n  }\n}\n\n/**\n * Creates a Canvas element of the given size to be used as a target for rendering to.\n * @class\n * @memberof PIXI.utils\n */\nvar CanvasRenderTarget = /** @class */function () {\n  /**\n   * @param width - the width for the newly created canvas\n   * @param height - the height for the newly created canvas\n   * @param {number} [resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the canvas\n   */\n  function CanvasRenderTarget(width, height, resolution) {\n    this.canvas = settings.settings.ADAPTER.createCanvas();\n    this.context = this.canvas.getContext('2d');\n    this.resolution = resolution || settings.settings.RESOLUTION;\n    this.resize(width, height);\n  }\n  /**\n   * Clears the canvas that was created by the CanvasRenderTarget class.\n   * @private\n   */\n  CanvasRenderTarget.prototype.clear = function () {\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  };\n  /**\n   * Resizes the canvas to the specified width and height.\n   * @param desiredWidth - the desired width of the canvas\n   * @param desiredHeight - the desired height of the canvas\n   */\n  CanvasRenderTarget.prototype.resize = function (desiredWidth, desiredHeight) {\n    this.canvas.width = Math.round(desiredWidth * this.resolution);\n    this.canvas.height = Math.round(desiredHeight * this.resolution);\n  };\n  /** Destroys this canvas. */\n  CanvasRenderTarget.prototype.destroy = function () {\n    this.context = null;\n    this.canvas = null;\n  };\n  Object.defineProperty(CanvasRenderTarget.prototype, \"width\", {\n    /**\n     * The width of the canvas buffer in pixels.\n     * @member {number}\n     */\n    get: function get() {\n      return this.canvas.width;\n    },\n    set: function set(val) {\n      this.canvas.width = Math.round(val);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CanvasRenderTarget.prototype, \"height\", {\n    /**\n     * The height of the canvas buffer in pixels.\n     * @member {number}\n     */\n    get: function get() {\n      return this.canvas.height;\n    },\n    set: function set(val) {\n      this.canvas.height = Math.round(val);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return CanvasRenderTarget;\n}();\n\n/**\n * Trim transparent borders from a canvas\n * @memberof PIXI.utils\n * @function trimCanvas\n * @param {HTMLCanvasElement} canvas - the canvas to trim\n * @returns {object} Trim data\n */\nfunction trimCanvas(canvas) {\n  // https://gist.github.com/remy/784508\n  var width = canvas.width;\n  var height = canvas.height;\n  var context = canvas.getContext('2d', {\n    willReadFrequently: true\n  });\n  var imageData = context.getImageData(0, 0, width, height);\n  var pixels = imageData.data;\n  var len = pixels.length;\n  var bound = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  };\n  var data = null;\n  var i;\n  var x;\n  var y;\n  for (i = 0; i < len; i += 4) {\n    if (pixels[i + 3] !== 0) {\n      x = i / 4 % width;\n      y = ~~(i / 4 / width);\n      if (bound.top === null) {\n        bound.top = y;\n      }\n      if (bound.left === null) {\n        bound.left = x;\n      } else if (x < bound.left) {\n        bound.left = x;\n      }\n      if (bound.right === null) {\n        bound.right = x + 1;\n      } else if (bound.right < x) {\n        bound.right = x + 1;\n      }\n      if (bound.bottom === null) {\n        bound.bottom = y;\n      } else if (bound.bottom < y) {\n        bound.bottom = y;\n      }\n    }\n  }\n  if (bound.top !== null) {\n    width = bound.right - bound.left;\n    height = bound.bottom - bound.top + 1;\n    data = context.getImageData(bound.left, bound.top, width, height);\n  }\n  return {\n    height: height,\n    width: width,\n    data: data\n  };\n}\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @static\n * @constant {RegExp|string} DATA_URI\n * @memberof PIXI\n * @example data:image/png;base64\n */\nvar DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n/**\n * @memberof PIXI.utils\n * @interface DecomposedDataUri\n */\n/**\n * type, eg. `image`\n * @memberof PIXI.utils.DecomposedDataUri#\n * @member {string} mediaType\n */\n/**\n * Sub type, eg. `png`\n * @memberof PIXI.utils.DecomposedDataUri#\n * @member {string} subType\n */\n/**\n * @memberof PIXI.utils.DecomposedDataUri#\n * @member {string} charset\n */\n/**\n * Data encoding, eg. `base64`\n * @memberof PIXI.utils.DecomposedDataUri#\n * @member {string} encoding\n */\n/**\n * The actual data\n * @memberof PIXI.utils.DecomposedDataUri#\n * @member {string} data\n */\n/**\n * Split a data URI into components. Returns undefined if\n * parameter `dataUri` is not a valid data URI.\n * @memberof PIXI.utils\n * @function decomposeDataUri\n * @param {string} dataUri - the data URI to check\n * @returns {PIXI.utils.DecomposedDataUri|undefined} The decomposed data uri or undefined\n */\nfunction decomposeDataUri(dataUri) {\n  var dataUriMatch = DATA_URI.exec(dataUri);\n  if (dataUriMatch) {\n    return {\n      mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,\n      subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,\n      charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,\n      encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,\n      data: dataUriMatch[5]\n    };\n  }\n  return undefined;\n}\nvar tempAnchor;\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param {string} url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns {string} The crossOrigin value to use (or empty string for none).\n */\nfunction determineCrossOrigin(url$1, loc) {\n  if (loc === void 0) {\n    loc = globalThis.location;\n  }\n  // data: and javascript: urls are considered same-origin\n  if (url$1.indexOf('data:') === 0) {\n    return '';\n  }\n  // default is window.location\n  loc = loc || globalThis.location;\n  if (!tempAnchor) {\n    tempAnchor = document.createElement('a');\n  }\n  // let the browser determine the full href for the url of this resource and then\n  // parse with the node url lib, we can't use the properties of the anchor element\n  // because they don't work in IE9 :(\n  tempAnchor.href = url$1;\n  var parsedUrl = url.parse(tempAnchor.href);\n  var samePort = !parsedUrl.port && loc.port === '' || parsedUrl.port === loc.port;\n  // if cross origin\n  if (parsedUrl.hostname !== loc.hostname || !samePort || parsedUrl.protocol !== loc.protocol) {\n    return 'anonymous';\n  }\n  return '';\n}\n\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @memberof PIXI.utils\n * @function getResolutionOfUrl\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nfunction getResolutionOfUrl(url, defaultValue) {\n  var resolution = settings.settings.RETINA_PREFIX.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue !== undefined ? defaultValue : 1;\n}\nObject.defineProperty(exports, 'isMobile', {\n  enumerable: true,\n  get: function get() {\n    return settings.isMobile;\n  }\n});\nObject.defineProperty(exports, 'EventEmitter', {\n  enumerable: true,\n  get: function get() {\n    return eventemitter3__default[\"default\"];\n  }\n});\nObject.defineProperty(exports, 'earcut', {\n  enumerable: true,\n  get: function get() {\n    return earcut__default[\"default\"];\n  }\n});\nexports.BaseTextureCache = BaseTextureCache;\nexports.CanvasRenderTarget = CanvasRenderTarget;\nexports.DATA_URI = DATA_URI;\nexports.ProgramCache = ProgramCache;\nexports.TextureCache = TextureCache;\nexports.clearTextureCache = clearTextureCache;\nexports.correctBlendMode = correctBlendMode;\nexports.createIndicesForQuads = createIndicesForQuads;\nexports.decomposeDataUri = decomposeDataUri;\nexports.deprecation = deprecation;\nexports.destroyTextureCache = destroyTextureCache;\nexports.determineCrossOrigin = determineCrossOrigin;\nexports.getBufferType = getBufferType;\nexports.getResolutionOfUrl = getResolutionOfUrl;\nexports.hex2rgb = hex2rgb;\nexports.hex2string = hex2string;\nexports.interleaveTypedArrays = interleaveTypedArrays;\nexports.isPow2 = isPow2;\nexports.isWebGLSupported = isWebGLSupported;\nexports.log2 = log2;\nexports.nextPow2 = nextPow2;\nexports.path = path;\nexports.premultiplyBlendMode = premultiplyBlendMode;\nexports.premultiplyRgba = premultiplyRgba;\nexports.premultiplyTint = premultiplyTint;\nexports.premultiplyTintToRgba = premultiplyTintToRgba;\nexports.removeItems = removeItems;\nexports.rgb2hex = rgb2hex;\nexports.sayHello = sayHello;\nexports.sign = sign;\nexports.skipHello = skipHello;\nexports.string2hex = string2hex;\nexports.trimCanvas = trimCanvas;\nexports.uid = uid;\nexports.url = url;","map":null,"metadata":{},"sourceType":"script"}