{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResultsParser = void 0;\nvar transaction_decoder_1 = require(\"@elrondnetwork/transaction-decoder\");\nvar address_1 = require(\"../address\");\nvar errors_1 = require(\"../errors\");\nvar logger_1 = require(\"../logger\");\nvar argSerializer_1 = require(\"./argSerializer\");\nvar returnCode_1 = require(\"./returnCode\");\nvar WellKnownEvents;\n(function (WellKnownEvents) {\n  WellKnownEvents[\"OnTransactionCompleted\"] = \"completedTxEvent\";\n  WellKnownEvents[\"OnSignalError\"] = \"signalError\";\n  WellKnownEvents[\"OnWriteLog\"] = \"writeLog\";\n})(WellKnownEvents || (WellKnownEvents = {}));\nvar WellKnownTopics;\n(function (WellKnownTopics) {\n  WellKnownTopics[\"TooMuchGas\"] = \"@too much gas provided for processing\";\n})(WellKnownTopics || (WellKnownTopics = {}));\n/**\n * Parses contract query responses and smart contract results.\n * The parsing involves some heuristics, in order to handle slight inconsistencies (e.g. some SCRs are present on API, but missing on Gateway).\n */\nvar ResultsParser = /*#__PURE__*/function () {\n  function ResultsParser() {\n    _classCallCheck(this, ResultsParser);\n  }\n  _createClass(ResultsParser, [{\n    key: \"parseQueryResponse\",\n    value: function parseQueryResponse(queryResponse, endpoint) {\n      var parts = queryResponse.getReturnDataParts();\n      var values = new argSerializer_1.ArgSerializer().buffersToValues(parts, endpoint.output);\n      var returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n      return {\n        returnCode: returnCode,\n        returnMessage: queryResponse.returnMessage,\n        values: values,\n        firstValue: values[0],\n        secondValue: values[1],\n        thirdValue: values[2],\n        lastValue: values[values.length - 1]\n      };\n    }\n  }, {\n    key: \"parseUntypedQueryResponse\",\n    value: function parseUntypedQueryResponse(queryResponse) {\n      var returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n      return {\n        returnCode: returnCode,\n        returnMessage: queryResponse.returnMessage,\n        values: queryResponse.getReturnDataParts()\n      };\n    }\n  }, {\n    key: \"parseOutcome\",\n    value: function parseOutcome(transaction, endpoint) {\n      var untypedBundle = this.parseUntypedOutcome(transaction);\n      var values = new argSerializer_1.ArgSerializer().buffersToValues(untypedBundle.values, endpoint.output);\n      return {\n        returnCode: untypedBundle.returnCode,\n        returnMessage: untypedBundle.returnMessage,\n        values: values,\n        firstValue: values[0],\n        secondValue: values[1],\n        thirdValue: values[2],\n        lastValue: values[values.length - 1]\n      };\n    }\n  }, {\n    key: \"parseUntypedOutcome\",\n    value: function parseUntypedOutcome(transaction) {\n      var bundle;\n      var transactionMetadata = this.parseTransactionMetadata(transaction);\n      bundle = this.createBundleOnSimpleMoveBalance(transaction);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on simple move balance\");\n        return bundle;\n      }\n      bundle = this.createBundleOnInvalidTransaction(transaction);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on invalid transaction\");\n        return bundle;\n      }\n      bundle = this.createBundleOnEasilyFoundResultWithReturnData(transaction.contractResults);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on easily found result with return data\");\n        return bundle;\n      }\n      bundle = this.createBundleOnSignalError(transaction.logs);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on signal error\");\n        return bundle;\n      }\n      bundle = this.createBundleOnTooMuchGasWarning(transaction.logs);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on 'too much gas' warning\");\n        return bundle;\n      }\n      bundle = this.createBundleOnWriteLogWhereFirstTopicEqualsAddress(transaction.logs, transaction.sender);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): on writelog with topics[0] == tx.sender\");\n        return bundle;\n      }\n      bundle = this.createBundleWithCustomHeuristics(transaction, transactionMetadata);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): with custom heuristics\");\n        return bundle;\n      }\n      bundle = this.createBundleWithFallbackHeuristics(transaction, transactionMetadata);\n      if (bundle) {\n        logger_1.Logger.trace(\"parseUntypedOutcome(): with fallback heuristics\");\n        return bundle;\n      }\n      throw new errors_1.ErrCannotParseContractResults(\"transaction \".concat(transaction.hash.toString()));\n    }\n  }, {\n    key: \"parseTransactionMetadata\",\n    value: function parseTransactionMetadata(transaction) {\n      return new transaction_decoder_1.TransactionDecoder().getTransactionMetadata({\n        sender: transaction.sender.bech32(),\n        receiver: transaction.receiver.bech32(),\n        data: transaction.data.toString(\"base64\"),\n        value: transaction.value.toString(),\n        type: transaction.type\n      });\n    }\n  }, {\n    key: \"createBundleOnSimpleMoveBalance\",\n    value: function createBundleOnSimpleMoveBalance(transaction) {\n      var noResults = transaction.contractResults.items.length == 0;\n      var noLogs = transaction.logs.events.length == 0;\n      if (noResults && noLogs) {\n        return {\n          returnCode: returnCode_1.ReturnCode.None,\n          returnMessage: returnCode_1.ReturnCode.None.toString(),\n          values: []\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"createBundleOnInvalidTransaction\",\n    value: function createBundleOnInvalidTransaction(transaction) {\n      if (transaction.status.isInvalid()) {\n        if (transaction.receipt.data) {\n          return {\n            returnCode: returnCode_1.ReturnCode.OutOfFunds,\n            returnMessage: transaction.receipt.data,\n            values: []\n          };\n        }\n        // If there's no receipt message, let other heuristics to handle the outcome (most probably, a log with \"signalError\" is emitted).\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createBundleOnEasilyFoundResultWithReturnData\",\n    value: function createBundleOnEasilyFoundResultWithReturnData(results) {\n      var resultItemWithReturnData = results.items.find(function (item) {\n        return item.nonce.valueOf() != 0 && item.data.startsWith(\"@\");\n      });\n      if (!resultItemWithReturnData) {\n        return null;\n      }\n      var _this$sliceDataFieldI = this.sliceDataFieldInParts(resultItemWithReturnData.data),\n        returnCode = _this$sliceDataFieldI.returnCode,\n        returnDataParts = _this$sliceDataFieldI.returnDataParts;\n      var returnMessage = resultItemWithReturnData.returnMessage || returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n  }, {\n    key: \"createBundleOnSignalError\",\n    value: function createBundleOnSignalError(logs) {\n      var eventSignalError = logs.findSingleOrNoneEvent(WellKnownEvents.OnSignalError);\n      if (!eventSignalError) {\n        return null;\n      }\n      var _this$sliceDataFieldI2 = this.sliceDataFieldInParts(eventSignalError.data),\n        returnCode = _this$sliceDataFieldI2.returnCode,\n        returnDataParts = _this$sliceDataFieldI2.returnDataParts;\n      var lastTopic = eventSignalError.getLastTopic();\n      var returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n  }, {\n    key: \"createBundleOnTooMuchGasWarning\",\n    value: function createBundleOnTooMuchGasWarning(logs) {\n      var eventTooMuchGas = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, function (event) {\n        return event.findFirstOrNoneTopic(function (topic) {\n          return topic.toString().startsWith(WellKnownTopics.TooMuchGas);\n        }) != undefined;\n      });\n      if (!eventTooMuchGas) {\n        return null;\n      }\n      var _this$sliceDataFieldI3 = this.sliceDataFieldInParts(eventTooMuchGas.data),\n        returnCode = _this$sliceDataFieldI3.returnCode,\n        returnDataParts = _this$sliceDataFieldI3.returnDataParts;\n      var lastTopic = eventTooMuchGas.getLastTopic();\n      var returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n  }, {\n    key: \"createBundleOnWriteLogWhereFirstTopicEqualsAddress\",\n    value: function createBundleOnWriteLogWhereFirstTopicEqualsAddress(logs, address) {\n      var hexAddress = new address_1.Address(address.bech32()).hex();\n      var eventWriteLogWhereTopicIsSender = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, function (event) {\n        return event.findFirstOrNoneTopic(function (topic) {\n          return topic.hex() == hexAddress;\n        }) != undefined;\n      });\n      if (!eventWriteLogWhereTopicIsSender) {\n        return null;\n      }\n      var _this$sliceDataFieldI4 = this.sliceDataFieldInParts(eventWriteLogWhereTopicIsSender.data),\n        returnCode = _this$sliceDataFieldI4.returnCode,\n        returnDataParts = _this$sliceDataFieldI4.returnDataParts;\n      var returnMessage = returnCode.toString();\n      return {\n        returnCode: returnCode,\n        returnMessage: returnMessage,\n        values: returnDataParts\n      };\n    }\n    /**\n     * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.\n     */\n  }, {\n    key: \"createBundleWithCustomHeuristics\",\n    value: function createBundleWithCustomHeuristics(_transaction, _transactionMetadata) {\n      return null;\n    }\n  }, {\n    key: \"createBundleWithFallbackHeuristics\",\n    value: function createBundleWithFallbackHeuristics(transaction, transactionMetadata) {\n      var contractAddress = new address_1.Address(transactionMetadata.receiver);\n      // Search the nested logs for matching events (writeLog):\n      var _iterator = _createForOfIteratorHelper(transaction.contractResults.items),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var resultItem = _step.value;\n          var writeLogWithReturnData = resultItem.logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, function (event) {\n            var _a;\n            var addressIsSender = event.address.bech32() == transaction.sender.bech32();\n            var firstTopicIsContract = ((_a = event.topics[0]) === null || _a === void 0 ? void 0 : _a.hex()) == contractAddress.hex();\n            return addressIsSender && firstTopicIsContract;\n          });\n          if (writeLogWithReturnData) {\n            var _this$sliceDataFieldI5 = this.sliceDataFieldInParts(writeLogWithReturnData.data),\n              returnCode = _this$sliceDataFieldI5.returnCode,\n              returnDataParts = _this$sliceDataFieldI5.returnDataParts;\n            var returnMessage = returnCode.toString();\n            return {\n              returnCode: returnCode,\n              returnMessage: returnMessage,\n              values: returnDataParts\n            };\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return null;\n    }\n  }, {\n    key: \"sliceDataFieldInParts\",\n    value: function sliceDataFieldInParts(data) {\n      // By default, skip the first part, which is usually empty (e.g. \"[empty]@6f6b\")\n      var startingIndex = 1;\n      // Before trying to parse the hex strings, cut the unwanted parts of the data field, in case of token transfers:\n      if (data.startsWith(\"ESDTTransfer\")) {\n        // Skip \"ESDTTransfer\" (1), token identifier (2), amount (3)\n        startingIndex = 3;\n      } else {\n        // TODO: Upon gathering more transaction samples, fix for other kinds of transfers, as well (future PR, as needed).\n      }\n      var parts = new argSerializer_1.ArgSerializer().stringToBuffers(data);\n      var returnCodePart = parts[startingIndex] || Buffer.from([]);\n      var returnDataParts = parts.slice(startingIndex + 1);\n      if (returnCodePart.length == 0) {\n        throw new errors_1.ErrCannotParseContractResults(\"no return code\");\n      }\n      var returnCode = returnCode_1.ReturnCode.fromBuffer(returnCodePart);\n      return {\n        returnCode: returnCode,\n        returnDataParts: returnDataParts\n      };\n    }\n  }]);\n  return ResultsParser;\n}();\nexports.ResultsParser = ResultsParser;","map":{"version":3,"sources":["../../src/smartcontracts/resultsParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResultsParser = void 0;\nconst transaction_decoder_1 = require(\"@elrondnetwork/transaction-decoder\");\nconst address_1 = require(\"../address\");\nconst errors_1 = require(\"../errors\");\nconst logger_1 = require(\"../logger\");\nconst argSerializer_1 = require(\"./argSerializer\");\nconst returnCode_1 = require(\"./returnCode\");\nvar WellKnownEvents;\n(function (WellKnownEvents) {\n    WellKnownEvents[\"OnTransactionCompleted\"] = \"completedTxEvent\";\n    WellKnownEvents[\"OnSignalError\"] = \"signalError\";\n    WellKnownEvents[\"OnWriteLog\"] = \"writeLog\";\n})(WellKnownEvents || (WellKnownEvents = {}));\nvar WellKnownTopics;\n(function (WellKnownTopics) {\n    WellKnownTopics[\"TooMuchGas\"] = \"@too much gas provided for processing\";\n})(WellKnownTopics || (WellKnownTopics = {}));\n/**\n * Parses contract query responses and smart contract results.\n * The parsing involves some heuristics, in order to handle slight inconsistencies (e.g. some SCRs are present on API, but missing on Gateway).\n */\nclass ResultsParser {\n    parseQueryResponse(queryResponse, endpoint) {\n        let parts = queryResponse.getReturnDataParts();\n        let values = new argSerializer_1.ArgSerializer().buffersToValues(parts, endpoint.output);\n        let returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n        return {\n            returnCode: returnCode,\n            returnMessage: queryResponse.returnMessage,\n            values: values,\n            firstValue: values[0],\n            secondValue: values[1],\n            thirdValue: values[2],\n            lastValue: values[values.length - 1]\n        };\n    }\n    parseUntypedQueryResponse(queryResponse) {\n        let returnCode = new returnCode_1.ReturnCode(queryResponse.returnCode.toString());\n        return {\n            returnCode: returnCode,\n            returnMessage: queryResponse.returnMessage,\n            values: queryResponse.getReturnDataParts()\n        };\n    }\n    parseOutcome(transaction, endpoint) {\n        let untypedBundle = this.parseUntypedOutcome(transaction);\n        let values = new argSerializer_1.ArgSerializer().buffersToValues(untypedBundle.values, endpoint.output);\n        return {\n            returnCode: untypedBundle.returnCode,\n            returnMessage: untypedBundle.returnMessage,\n            values: values,\n            firstValue: values[0],\n            secondValue: values[1],\n            thirdValue: values[2],\n            lastValue: values[values.length - 1]\n        };\n    }\n    parseUntypedOutcome(transaction) {\n        let bundle;\n        let transactionMetadata = this.parseTransactionMetadata(transaction);\n        bundle = this.createBundleOnSimpleMoveBalance(transaction);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): on simple move balance\");\n            return bundle;\n        }\n        bundle = this.createBundleOnInvalidTransaction(transaction);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): on invalid transaction\");\n            return bundle;\n        }\n        bundle = this.createBundleOnEasilyFoundResultWithReturnData(transaction.contractResults);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): on easily found result with return data\");\n            return bundle;\n        }\n        bundle = this.createBundleOnSignalError(transaction.logs);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): on signal error\");\n            return bundle;\n        }\n        bundle = this.createBundleOnTooMuchGasWarning(transaction.logs);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): on 'too much gas' warning\");\n            return bundle;\n        }\n        bundle = this.createBundleOnWriteLogWhereFirstTopicEqualsAddress(transaction.logs, transaction.sender);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): on writelog with topics[0] == tx.sender\");\n            return bundle;\n        }\n        bundle = this.createBundleWithCustomHeuristics(transaction, transactionMetadata);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): with custom heuristics\");\n            return bundle;\n        }\n        bundle = this.createBundleWithFallbackHeuristics(transaction, transactionMetadata);\n        if (bundle) {\n            logger_1.Logger.trace(\"parseUntypedOutcome(): with fallback heuristics\");\n            return bundle;\n        }\n        throw new errors_1.ErrCannotParseContractResults(`transaction ${transaction.hash.toString()}`);\n    }\n    parseTransactionMetadata(transaction) {\n        return new transaction_decoder_1.TransactionDecoder().getTransactionMetadata({\n            sender: transaction.sender.bech32(),\n            receiver: transaction.receiver.bech32(),\n            data: transaction.data.toString(\"base64\"),\n            value: transaction.value.toString(),\n            type: transaction.type\n        });\n    }\n    createBundleOnSimpleMoveBalance(transaction) {\n        let noResults = transaction.contractResults.items.length == 0;\n        let noLogs = transaction.logs.events.length == 0;\n        if (noResults && noLogs) {\n            return {\n                returnCode: returnCode_1.ReturnCode.None,\n                returnMessage: returnCode_1.ReturnCode.None.toString(),\n                values: []\n            };\n        }\n        return null;\n    }\n    createBundleOnInvalidTransaction(transaction) {\n        if (transaction.status.isInvalid()) {\n            if (transaction.receipt.data) {\n                return {\n                    returnCode: returnCode_1.ReturnCode.OutOfFunds,\n                    returnMessage: transaction.receipt.data,\n                    values: []\n                };\n            }\n            // If there's no receipt message, let other heuristics to handle the outcome (most probably, a log with \"signalError\" is emitted).\n        }\n        return null;\n    }\n    createBundleOnEasilyFoundResultWithReturnData(results) {\n        let resultItemWithReturnData = results.items.find(item => item.nonce.valueOf() != 0 && item.data.startsWith(\"@\"));\n        if (!resultItemWithReturnData) {\n            return null;\n        }\n        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(resultItemWithReturnData.data);\n        let returnMessage = resultItemWithReturnData.returnMessage || returnCode.toString();\n        return {\n            returnCode: returnCode,\n            returnMessage: returnMessage,\n            values: returnDataParts\n        };\n    }\n    createBundleOnSignalError(logs) {\n        let eventSignalError = logs.findSingleOrNoneEvent(WellKnownEvents.OnSignalError);\n        if (!eventSignalError) {\n            return null;\n        }\n        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(eventSignalError.data);\n        let lastTopic = eventSignalError.getLastTopic();\n        let returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n        return {\n            returnCode: returnCode,\n            returnMessage: returnMessage,\n            values: returnDataParts\n        };\n    }\n    createBundleOnTooMuchGasWarning(logs) {\n        let eventTooMuchGas = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, event => event.findFirstOrNoneTopic(topic => topic.toString().startsWith(WellKnownTopics.TooMuchGas)) != undefined);\n        if (!eventTooMuchGas) {\n            return null;\n        }\n        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(eventTooMuchGas.data);\n        let lastTopic = eventTooMuchGas.getLastTopic();\n        let returnMessage = (lastTopic === null || lastTopic === void 0 ? void 0 : lastTopic.toString()) || returnCode.toString();\n        return {\n            returnCode: returnCode,\n            returnMessage: returnMessage,\n            values: returnDataParts\n        };\n    }\n    createBundleOnWriteLogWhereFirstTopicEqualsAddress(logs, address) {\n        let hexAddress = new address_1.Address(address.bech32()).hex();\n        let eventWriteLogWhereTopicIsSender = logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, event => event.findFirstOrNoneTopic(topic => topic.hex() == hexAddress) != undefined);\n        if (!eventWriteLogWhereTopicIsSender) {\n            return null;\n        }\n        let { returnCode, returnDataParts } = this.sliceDataFieldInParts(eventWriteLogWhereTopicIsSender.data);\n        let returnMessage = returnCode.toString();\n        return {\n            returnCode: returnCode,\n            returnMessage: returnMessage,\n            values: returnDataParts\n        };\n    }\n    /**\n     * Override this method (in a subclass of {@link ResultsParser}) if the basic heuristics of the parser are not sufficient.\n     */\n    createBundleWithCustomHeuristics(_transaction, _transactionMetadata) {\n        return null;\n    }\n    createBundleWithFallbackHeuristics(transaction, transactionMetadata) {\n        let contractAddress = new address_1.Address(transactionMetadata.receiver);\n        // Search the nested logs for matching events (writeLog):\n        for (const resultItem of transaction.contractResults.items) {\n            let writeLogWithReturnData = resultItem.logs.findSingleOrNoneEvent(WellKnownEvents.OnWriteLog, event => {\n                var _a;\n                let addressIsSender = event.address.bech32() == transaction.sender.bech32();\n                let firstTopicIsContract = ((_a = event.topics[0]) === null || _a === void 0 ? void 0 : _a.hex()) == contractAddress.hex();\n                return addressIsSender && firstTopicIsContract;\n            });\n            if (writeLogWithReturnData) {\n                let { returnCode, returnDataParts } = this.sliceDataFieldInParts(writeLogWithReturnData.data);\n                let returnMessage = returnCode.toString();\n                return {\n                    returnCode: returnCode,\n                    returnMessage: returnMessage,\n                    values: returnDataParts\n                };\n            }\n        }\n        return null;\n    }\n    sliceDataFieldInParts(data) {\n        // By default, skip the first part, which is usually empty (e.g. \"[empty]@6f6b\")\n        let startingIndex = 1;\n        // Before trying to parse the hex strings, cut the unwanted parts of the data field, in case of token transfers:\n        if (data.startsWith(\"ESDTTransfer\")) {\n            // Skip \"ESDTTransfer\" (1), token identifier (2), amount (3)\n            startingIndex = 3;\n        }\n        else {\n            // TODO: Upon gathering more transaction samples, fix for other kinds of transfers, as well (future PR, as needed).\n        }\n        let parts = new argSerializer_1.ArgSerializer().stringToBuffers(data);\n        let returnCodePart = parts[startingIndex] || Buffer.from([]);\n        let returnDataParts = parts.slice(startingIndex + 1);\n        if (returnCodePart.length == 0) {\n            throw new errors_1.ErrCannotParseContractResults(\"no return code\");\n        }\n        let returnCode = returnCode_1.ReturnCode.fromBuffer(returnCodePart);\n        return { returnCode, returnDataParts };\n    }\n}\nexports.ResultsParser = ResultsParser;\n//# sourceMappingURL=resultsParser.js.map"]},"metadata":{},"sourceType":"script"}