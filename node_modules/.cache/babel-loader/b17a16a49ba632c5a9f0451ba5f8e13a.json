{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource.mjs';\nvar ArrayResource = /*#__PURE__*/function (_AbstractMultiResourc) {\n  _inherits(ArrayResource, _AbstractMultiResourc);\n  var _super = _createSuper(ArrayResource);\n  function ArrayResource(source, options) {\n    var _this;\n    _classCallCheck(this, ArrayResource);\n    var _ref = options || {},\n      width = _ref.width,\n      height = _ref.height;\n    var urls;\n    var length;\n    if (Array.isArray(source)) {\n      urls = source;\n      length = source.length;\n    } else {\n      length = source;\n    }\n    _this = _super.call(this, length, {\n      width: width,\n      height: height\n    });\n    if (urls) {\n      _this.initFromArray(urls, options);\n    }\n    return _this;\n  }\n  _createClass(ArrayResource, [{\n    key: \"addBaseTextureAt\",\n    value: function addBaseTextureAt(baseTexture, index) {\n      if (baseTexture.resource) {\n        this.addResourceAt(baseTexture.resource, index);\n      } else {\n        throw new Error(\"ArrayResource does not support RenderTexture\");\n      }\n      return this;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(baseTexture) {\n      _get(_getPrototypeOf(ArrayResource.prototype), \"bind\", this).call(this, baseTexture);\n      baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(renderer, texture, glTexture) {\n      var length = this.length,\n        itemDirtyIds = this.itemDirtyIds,\n        items = this.items;\n      var gl = renderer.gl;\n      if (glTexture.dirtyId < 0) {\n        gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);\n      }\n      for (var i = 0; i < length; i++) {\n        var item = items[i];\n        if (itemDirtyIds[i] < item.dirtyId) {\n          itemDirtyIds[i] = item.dirtyId;\n          if (item.valid) {\n            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source);\n          }\n        }\n      }\n      return true;\n    }\n  }]);\n  return ArrayResource;\n}(AbstractMultiResource);\nexport { ArrayResource };","map":{"version":3,"sources":["../../../src/textures/resources/ArrayResource.ts"],"names":[],"mappings":";;;;;;;;IAaa,aAAA;EAAA;EAAA;EAST,uBAAY,MAAA,EAA6B,OACzC,EAAA;IAAA;IAAA;IACI,WAA0B,OAAA,IAAW,CAAA,CAAC;MAA9B,KAAA,QAAA,KAAA;MAAO,MAAW,QAAX,MAAW;IAEtB,IAAA,IAAA;IACA,IAAA,MAAA;IAEA,IAAA,KAAA,CAAM,OAAQ,CAAA,MAAM,CACxB,EAAA;MACW,IAAA,GAAA,MAAA;MACP,MAAA,GAAS,MAAO,CAAA,MAAA;IAAA,CAGpB,MAAA;MACa,MAAA,GAAA,MAAA;IAAA;IAGb,0BAAM,MAAQ,EAAA;MAAE,KAAO,EAAP,KAAO;MAAA,MAAA,EAAA;IAAA,CAAQ;IAE/B,IAAI,IACJ,EAAA;MACS,MAAA,aAAA,CAAc,IAAA,EAAM,OAAO,CAAA;IAAA;IACpC;EAAA;EACJ;IAAA;IAAA,OASA,0BAAiB,WAAA,EAA0B,KAC3C,EAAA;MACI,IAAI,WAAA,CAAY,QAChB,EAAA;QACS,IAAA,CAAA,aAAA,CAAc,WAAY,CAAA,QAAA,EAAU,KAAK,CAAA;MAAA,CAGlD,MAAA;QACU,MAAA,IAAI,KAAA,CAAM,8CAA8C,CAAA;MAAA;MAG3D,OAAA,IAAA;IAAA;EACX;IAAA;IAAA,OAMA,cAAK,WACL,EAAA;MACI,wEAAW,WAAW;MAEtB,WAAA,CAAY,MAAA,GAAS,OAAQ,CAAA,gBAAA;IAAA;EACjC;IAAA;IAAA,OASA,gBAAO,QAAoB,EAAA,OAAA,EAAsB,SACjD,EAAA;MACU,IAAE,MAAQ,GAAwB,IAAA,CAAhC,MAAQ;QAAA,YAAA,GAAwB,IAAA,CAAxB,YAAA;QAAc,KAAU,GAAA,IAAA,CAAV,KAAU;MACxC,IAAQ,EAAO,GAAA,QAAA,CAAP,EAAO;MAEX,IAAA,SAAA,CAAU,OAAA,GAAU,CACxB,EAAA;QACI,EAAA,CAAG,UAAA,CACC,EAAG,CAAA,gBAAA,EACH,CACA,EAAA,SAAA,CAAU,cAAA,EACV,IAAK,CAAA,MAAA,EACL,IAAK,CAAA,OAAA,EACL,MAAA,EACA,CACA,EAAA,OAAA,CAAQ,MACR,EAAA,SAAA,CAAU,IAAA,EACV,IACJ,CAAA;MAAA;MAGJ,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,EAAQ,CAC5B,EAAA,EAAA;QACI,IAAM,IAAA,GAAO,KAAM,CAAA,CAAA,CAAA;QAEf,IAAA,YAAA,CAAa,CAAK,CAAA,GAAA,IAAA,CAAK,OAC3B,EAAA;UACI,YAAA,CAAa,CAAA,CAAA,GAAK,IAAK,CAAA,OAAA;UACvB,IAAI,IAAA,CAAK,KACT,EAAA;YACO,EAAA,CAAA,aAAA,CACC,EAAA,CAAG,gBACH,EAAA,CAAA,EACA,CAAA,EACA,CACA,EAAA,CAAA,EACA,IAAA,CAAK,QAAS,CAAA,KAAA,EACd,IAAA,CAAK,QAAS,CAAA,MAAA,EACd,CAAA,EACA,OAAQ,CAAA,MAAA,EACR,SAAA,CAAU,IACT,EAAA,IAAA,CAAK,QAAA,CAA+B,MACzC,CAAA;UAAA;QACJ;MACJ;MAGG,OAAA,IAAA;IAAA;EACX;EAAA;AAAA,EAzH+B,qBACnC","sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { BaseImageResource } from './BaseImageResource';\n\n/**\n * A resource that contains a number of sources.\n * @memberof PIXI\n */\nexport class ArrayResource extends AbstractMultiResource\n{\n    /**\n     * @param source - Number of items in array or the collection\n     *        of image URLs to use. Can also be resources, image elements, canvas, etc.\n     * @param options - Options to apply to {@link PIXI.autoDetectResource}\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(source: number | Array<any>, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        let urls;\n        let length: number;\n\n        if (Array.isArray(source))\n        {\n            urls = source;\n            length = source.length;\n        }\n        else\n        {\n            length = source;\n        }\n\n        super(length, { width, height });\n\n        if (urls)\n        {\n            this.initFromArray(urls, options);\n        }\n    }\n\n    /**\n     * Set a baseTexture by ID,\n     * ArrayResource just takes resource from it, nothing more\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addBaseTextureAt(baseTexture: BaseTexture, index: number): this\n    {\n        if (baseTexture.resource)\n        {\n            this.addResourceAt(baseTexture.resource, index);\n        }\n        else\n        {\n            throw new Error('ArrayResource does not support RenderTexture');\n        }\n\n        return this;\n    }\n\n    /**\n     * Add binding\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_2D_ARRAY;\n    }\n\n    /**\n     * Upload the resources to the GPU.\n     * @param renderer\n     * @param texture\n     * @param glTexture\n     * @returns - whether texture was uploaded\n     */\n    upload(renderer: Renderer, texture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const { length, itemDirtyIds, items } = this;\n        const { gl } = renderer;\n\n        if (glTexture.dirtyId < 0)\n        {\n            gl.texImage3D(\n                gl.TEXTURE_2D_ARRAY,\n                0,\n                glTexture.internalFormat,\n                this._width,\n                this._height,\n                length,\n                0,\n                texture.format,\n                glTexture.type,\n                null\n            );\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            const item = items[i];\n\n            if (itemDirtyIds[i] < item.dirtyId)\n            {\n                itemDirtyIds[i] = item.dirtyId;\n                if (item.valid)\n                {\n                    gl.texSubImage3D(\n                        gl.TEXTURE_2D_ARRAY,\n                        0,\n                        0, // xoffset\n                        0, // yoffset\n                        i, // zoffset\n                        item.resource.width,\n                        item.resource.height,\n                        1,\n                        texture.format,\n                        glTexture.type,\n                        (item.resource as BaseImageResource).source\n                    );\n                }\n            }\n        }\n\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}