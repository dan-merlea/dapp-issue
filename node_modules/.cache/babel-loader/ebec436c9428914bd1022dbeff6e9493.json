{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar spriteTilingSimple = require('./sprite-tiling-simple.js');\nvar spriteTilingFallback = require('./sprite-tiling-fallback.js');\nvar spriteTilingFallback$1 = require('./sprite-tiling-fallback2.js');\nvar spriteTiling = require('./sprite-tiling.js');\nvar spriteTiling$1 = require('./sprite-tiling2.js');\nvar tempMat = new core.Matrix();\nvar TilingSpriteRenderer = /*#__PURE__*/function (_core$ObjectRenderer) {\n  _inherits(TilingSpriteRenderer, _core$ObjectRenderer);\n  var _super = _createSuper(TilingSpriteRenderer);\n  function TilingSpriteRenderer(renderer) {\n    var _this;\n    _classCallCheck(this, TilingSpriteRenderer);\n    _this = _super.call(this, renderer);\n    renderer.runners.contextChange.add(_assertThisInitialized(_this));\n    _this.quad = new core.QuadUv();\n    _this.state = core.State.for2d();\n    return _this;\n  }\n  _createClass(TilingSpriteRenderer, [{\n    key: \"contextChange\",\n    value: function contextChange() {\n      var renderer = this.renderer;\n      var uniforms = {\n        globals: renderer.globalUniforms\n      };\n      this.simpleShader = core.Shader.from(spriteTilingFallback[\"default\"], spriteTilingSimple[\"default\"], uniforms);\n      this.shader = renderer.context.webGLVersion > 1 ? core.Shader.from(spriteTiling[\"default\"], spriteTiling$1[\"default\"], uniforms) : core.Shader.from(spriteTilingFallback[\"default\"], spriteTilingFallback$1[\"default\"], uniforms);\n    }\n  }, {\n    key: \"render\",\n    value: function render(ts) {\n      var renderer = this.renderer;\n      var quad = this.quad;\n      var vertices = quad.vertices;\n      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);\n      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);\n      var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n      var anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n      vertices = quad.uvs;\n      vertices[0] = vertices[6] = -anchorX;\n      vertices[1] = vertices[3] = -anchorY;\n      vertices[2] = vertices[4] = 1 - anchorX;\n      vertices[5] = vertices[7] = 1 - anchorY;\n      quad.invalidate();\n      var tex = ts._texture;\n      var baseTex = tex.baseTexture;\n      var premultiplied = baseTex.alphaMode > 0;\n      var lt = ts.tileTransform.localTransform;\n      var uv = ts.uvMatrix;\n      var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n      if (isSimple) {\n        if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n          if (baseTex.wrapMode === core.WRAP_MODES.CLAMP) {\n            baseTex.wrapMode = core.WRAP_MODES.REPEAT;\n          }\n        } else {\n          isSimple = baseTex.wrapMode !== core.WRAP_MODES.CLAMP;\n        }\n      }\n      var shader = isSimple ? this.simpleShader : this.shader;\n      var w = tex.width;\n      var h = tex.height;\n      var W = ts._width;\n      var H = ts._height;\n      tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n      tempMat.invert();\n      if (isSimple) {\n        tempMat.prepend(uv.mapCoord);\n      } else {\n        shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n        shader.uniforms.uClampFrame = uv.uClampFrame;\n        shader.uniforms.uClampOffset = uv.uClampOffset;\n      }\n      shader.uniforms.uTransform = tempMat.toArray(true);\n      shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, premultiplied);\n      shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n      shader.uniforms.uSampler = tex;\n      renderer.shader.bind(shader);\n      renderer.geometry.bind(quad);\n      this.state.blendMode = core.utils.correctBlendMode(ts.blendMode, premultiplied);\n      renderer.state.set(this.state);\n      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n  }]);\n  return TilingSpriteRenderer;\n}(core.ObjectRenderer);\nTilingSpriteRenderer.extension = {\n  name: \"tilingSprite\",\n  type: core.ExtensionType.RendererPlugin\n};\ncore.extensions.add(TilingSpriteRenderer);\nexports.TilingSpriteRenderer = TilingSpriteRenderer;","map":{"version":3,"sources":["../src/TilingSpriteRenderer.ts"],"names":["Matrix","ObjectRenderer","ExtensionType","QuadUv","State","fragmentSimpleSrc","Shader","gl2VertexSrc","gl1FragmentSrc","WRAP_MODES","extensions"],"mappings":"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","sourcesContent":["import { ObjectRenderer, Shader, State, QuadUv, ExtensionType, WRAP_MODES, Matrix, utils, extensions } from '@pixi/core';\n\nimport fragmentSimpleSrc from './sprite-tiling-simple.frag';\nimport gl1VertexSrc from './sprite-tiling-fallback.vert';\nimport gl1FragmentSrc from './sprite-tiling-fallback.frag';\nimport gl2VertexSrc from './sprite-tiling.vert';\nimport gl2FragmentSrc from './sprite-tiling.frag';\n\nimport type { Renderer, ExtensionMetadata } from '@pixi/core';\nimport type { TilingSprite } from './TilingSprite';\n\nconst tempMat = new Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport class TilingSpriteRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'tilingSprite',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    public shader: Shader;\n    public simpleShader: Shader;\n    public quad: QuadUv;\n    public readonly state: State;\n\n    /**\n     * constructor for renderer\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // WebGL version is not available during initialization!\n        renderer.runners.contextChange.add(this);\n\n        this.quad = new QuadUv();\n\n        /**\n         * The WebGL state in which this renderer will work.\n         * @member {PIXI.State}\n         * @readonly\n         */\n        this.state = State.for2d();\n    }\n\n    /** Creates shaders when context is initialized. */\n    contextChange(): void\n    {\n        const renderer = this.renderer;\n        const uniforms = { globals: renderer.globalUniforms };\n\n        this.simpleShader = Shader.from(gl1VertexSrc, fragmentSimpleSrc, uniforms);\n        this.shader = renderer.context.webGLVersion > 1\n            ? Shader.from(gl2VertexSrc, gl2FragmentSrc, uniforms)\n            : Shader.from(gl1VertexSrc, gl1FragmentSrc, uniforms);\n    }\n\n    /**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    public render(ts: TilingSprite): void\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        const anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0;\n        const anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;\n\n        vertices = quad.uvs;\n\n        vertices[0] = vertices[6] = -anchorX;\n        vertices[1] = vertices[3] = -anchorY;\n\n        vertices[2] = vertices[4] = 1.0 - anchorX;\n        vertices[5] = vertices[7] = 1.0 - anchorY;\n\n        quad.invalidate();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const premultiplied = baseTex.alphaMode > 0;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvMatrix;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, premultiplied);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n\n        this.state.blendMode = utils.correctBlendMode(ts.blendMode, premultiplied);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\nextensions.add(TilingSpriteRenderer);\n"]},"metadata":{},"sourceType":"script"}