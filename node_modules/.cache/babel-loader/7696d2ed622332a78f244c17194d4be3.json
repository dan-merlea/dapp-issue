{"ast":null,"code":"import _objectSpread from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"region\"];\nimport { Transform, Matrix } from '@pixi/math';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { RenderTexture } from './RenderTexture.mjs';\nvar tempTransform = new Transform();\nvar GenerateTextureSystem = /*#__PURE__*/function () {\n  function GenerateTextureSystem(renderer) {\n    _classCallCheck(this, GenerateTextureSystem);\n    this.renderer = renderer;\n    this._tempMatrix = new Matrix();\n  }\n  _createClass(GenerateTextureSystem, [{\n    key: \"generateTexture\",\n    value: function generateTexture(displayObject, options) {\n      var _ref = options || {},\n        manualRegion = _ref.region,\n        textureOptions = _objectWithoutProperties(_ref, _excluded);\n      var region = manualRegion || displayObject.getLocalBounds(null, true);\n      if (region.width === 0) region.width = 1;\n      if (region.height === 0) region.height = 1;\n      var renderTexture = RenderTexture.create(_objectSpread({\n        width: region.width,\n        height: region.height\n      }, textureOptions));\n      this._tempMatrix.tx = -region.x;\n      this._tempMatrix.ty = -region.y;\n      var transform = displayObject.transform;\n      displayObject.transform = tempTransform;\n      this.renderer.render(displayObject, {\n        renderTexture: renderTexture,\n        transform: this._tempMatrix,\n        skipUpdateTransform: !!displayObject.parent,\n        blit: true\n      });\n      displayObject.transform = transform;\n      return renderTexture;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {}\n  }]);\n  return GenerateTextureSystem;\n}();\nGenerateTextureSystem.extension = {\n  type: [ExtensionType.RendererSystem, ExtensionType.CanvasRendererSystem],\n  name: \"textureGenerator\"\n};\nextensions.add(GenerateTextureSystem);\nexport { GenerateTextureSystem };","map":{"version":3,"sources":["../../src/renderTexture/GenerateTextureSystem.ts"],"names":[],"mappings":";;;;;;;;AASA,IAAM,aAAA,GAAgB,IAAI,SAAU,EAAA;AAAA,IAsBvB,qBACb;EAcI,+BAAY,QACZ,EAAA;IAAA;IACI,IAAA,CAAK,QAAW,GAAA,QAAA;IAEX,IAAA,CAAA,WAAA,GAAc,IAAI,MAAO,EAAA;EAAA;EAClC;IAAA;IAAA,OASA,yBAAgB,aAAA,EAAkC,OAClD,EAAA;MACI,WAAoD,OAAA,IAAW,CAAA,CAAC;QAAhD,YAAiB,QAAzB,MAAA;QAAyB,cAAA;MAEjC,IAAM,MAAS,GAAA,YAAA,IAAiB,aAAuC,CAAA,cAAA,CAAe,IAAA,EAAM,IAAI,CAAA;MAGhG,IAAI,MAAA,CAAO,KAAU,KAAA,CAAA,EAAG,MAAA,CAAO,KAAQ,GAAA,CAAA;MACvC,IAAI,MAAA,CAAO,MAAW,KAAA,CAAA,EAAG,MAAA,CAAO,MAAS,GAAA,CAAA;MAEnC,IAAA,aAAA,GAAgB,aAAA,CAAc,MAChC;QACI,KAAA,EAAO,MAAO,CAAA,KAAA;QACd,MAAA,EAAQ,MAAO,CAAA;MAAA,GACZ,cAAA,EACN;MAEA,IAAA,CAAA,WAAA,CAAY,EAAK,GAAA,CAAC,MAAO,CAAA,CAAA;MACzB,IAAA,CAAA,WAAA,CAAY,EAAK,GAAA,CAAC,MAAO,CAAA,CAAA;MAE9B,IAAM,SAAA,GAAY,aAAc,CAAA,SAAA;MAEhC,aAAA,CAAc,SAAY,GAAA,aAAA;MAErB,IAAA,CAAA,QAAA,CAAS,MAAA,CAAO,aAAe,EAAA;QAChC,aAAA,EAAA,aAAA;QACA,SAAA,EAAW,IAAK,CAAA,WAAA;QAChB,mBAAA,EAAqB,CAAC,CAAC,aAAc,CAAA,MAAA;QACrC,IAAM,EAAA;MAAA,CACT,CAAA;MAED,aAAA,CAAc,SAAY,GAAA,SAAA;MAEnB,OAAA,aAAA;IAAA;EACX;IAAA;IAAA,OAEA,mBACA,CAAA;EAEA;EAAA;AAAA;AApES,qBAAA,CAGF,SAA+B,GAAA;EAClC,IAAM,EAAA,CACF,aAAc,CAAA,cAAA,EACd,aAAc,CAAA,oBAAA,CAClB;EACA,IAAM,EAAA;AACV,CAAA;AA8DJ,UAAA,CAAW,GAAA,CAAI,qBAAqB,CAAA","sourcesContent":["import type { MSAA_QUALITY, SCALE_MODES } from '@pixi/constants';\nimport type { Rectangle } from '@pixi/math';\nimport { Matrix, Transform } from '@pixi/math';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport type { IRenderer, IRenderableContainer, IRenderableObject } from '../IRenderer';\nimport type { ISystem } from '../system/ISystem';\nimport { RenderTexture } from './RenderTexture';\n\nconst tempTransform = new Transform();\n\n// TODO could this just be part of extract?\nexport interface IGenerateTextureOptions\n{\n    /** The scale mode of the texture. Optional, defaults to `PIXI.settings.SCALE_MODE`. */\n    scaleMode?: SCALE_MODES;\n    /** The resolution / device pixel ratio of the texture being generated. Optional defaults to Renderer resolution. */\n    resolution?: number;\n    /**\n     * The region of the displayObject, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the displayObject.\n     */\n    region?: Rectangle;\n    /** The number of samples of the frame buffer. */\n    multisample?: MSAA_QUALITY;\n}\n\n/**\n * System that manages the generation of textures from the renderer.\n * @memberof PIXI\n */\nexport class GenerateTextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: [\n            ExtensionType.RendererSystem,\n            ExtensionType.CanvasRendererSystem\n        ],\n        name: 'textureGenerator',\n    };\n\n    renderer: IRenderer;\n\n    private readonly _tempMatrix: Matrix;\n\n    constructor(renderer: IRenderer)\n    {\n        this.renderer = renderer;\n\n        this._tempMatrix = new Matrix();\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.\n     * @param displayObject - The displayObject the object will be generated from.\n     * @param {IGenerateTextureOptions} options - Generate texture options.\n     * @returns a shiny new texture of the display object passed in\n     */\n    generateTexture(displayObject: IRenderableObject, options?: IGenerateTextureOptions): RenderTexture\n    {\n        const { region: manualRegion, ...textureOptions } = options || {};\n\n        const region = manualRegion || (displayObject as IRenderableContainer).getLocalBounds(null, true);\n\n        // minimum texture size is 1x1, 0x0 will throw an error\n        if (region.width === 0) region.width = 1;\n        if (region.height === 0) region.height = 1;\n\n        const renderTexture = RenderTexture.create(\n            {\n                width: region.width,\n                height: region.height,\n                ...textureOptions,\n            });\n\n        this._tempMatrix.tx = -region.x;\n        this._tempMatrix.ty = -region.y;\n\n        const transform = displayObject.transform;\n\n        displayObject.transform = tempTransform;\n\n        this.renderer.render(displayObject, {\n            renderTexture,\n            transform: this._tempMatrix,\n            skipUpdateTransform: !!displayObject.parent,\n            blit: true,\n        });\n\n        displayObject.transform = transform;\n\n        return renderTexture;\n    }\n\n    destroy(): void\n    {\n        // ka boom!\n    }\n}\n\nextensions.add(GenerateTextureSystem);\n"]},"metadata":{},"sourceType":"module"}