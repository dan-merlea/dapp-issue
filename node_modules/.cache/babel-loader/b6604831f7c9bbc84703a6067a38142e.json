{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\nvar utils_1 = require(\"../../utils\");\nvar collections_1 = require(\"./collections\");\nvar types_1 = require(\"./types\");\n// TODO: Move to a new file, \"genericOption.ts\"\nvar OptionType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(OptionType, _types_1$Type);\n  var _super = _createSuper(OptionType);\n  function OptionType(typeParameter) {\n    _classCallCheck(this, OptionType);\n    return _super.call(this, \"Option\", [typeParameter]);\n  }\n  _createClass(OptionType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionType.ClassName;\n    }\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      if (!type.hasExactClass(OptionType.ClassName)) {\n        return false;\n      }\n      var invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n      var fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n      return invariantTypeParameters || fakeCovarianceToNull;\n    }\n  }]);\n  return OptionType;\n}(types_1.Type);\nexports.OptionType = OptionType;\nOptionType.ClassName = \"OptionType\";\n// TODO: Move to a new file, \"genericList.ts\"\nvar ListType = /*#__PURE__*/function (_types_1$Type2) {\n  _inherits(ListType, _types_1$Type2);\n  var _super2 = _createSuper(ListType);\n  function ListType(typeParameter) {\n    _classCallCheck(this, ListType);\n    return _super2.call(this, \"List\", [typeParameter]);\n  }\n  _createClass(ListType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return ListType.ClassName;\n    }\n  }]);\n  return ListType;\n}(types_1.Type);\nexports.ListType = ListType;\nListType.ClassName = \"ListType\";\n// TODO: Move to a new file, \"genericOption.ts\"\nvar OptionValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(OptionValue, _types_1$TypedValue);\n  var _super3 = _createSuper(OptionValue);\n  function OptionValue(type) {\n    var _this;\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, OptionValue);\n    _this = _super3.call(this, type);\n    // TODO: assert value is of type type.getFirstTypeParameter()\n    _this.value = value;\n    return _this;\n  }\n  _createClass(OptionValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionValue.ClassName;\n    }\n    /**\n     * Creates an OptionValue, as a missing option argument.\n     */\n  }, {\n    key: \"isSet\",\n    value: function isSet() {\n      return this.value ? true : false;\n    }\n  }, {\n    key: \"getTypedValue\",\n    value: function getTypedValue() {\n      utils_1.guardValueIsSet(\"value\", this.value);\n      return this.value;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value ? this.value.valueOf() : null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var _a;\n      return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n  }], [{\n    key: \"newMissing\",\n    value: function newMissing() {\n      var type = new OptionType(new types_1.NullType());\n      return new OptionValue(type);\n    }\n  }, {\n    key: \"newMissingTyped\",\n    value: function newMissingTyped(type) {\n      return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n  }, {\n    key: \"newProvided\",\n    value: function newProvided(typedValue) {\n      var type = new OptionType(typedValue.getType());\n      return new OptionValue(type, typedValue);\n    }\n  }]);\n  return OptionValue;\n}(types_1.TypedValue);\nexports.OptionValue = OptionValue;\nOptionValue.ClassName = \"OptionValue\";\n// TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\nvar List = /*#__PURE__*/function (_types_1$TypedValue2) {\n  _inherits(List, _types_1$TypedValue2);\n  var _super4 = _createSuper(List);\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  function List(type, items) {\n    var _this2;\n    _classCallCheck(this, List);\n    _this2 = _super4.call(this, type);\n    // TODO: assert items are of type type.getFirstTypeParameter()\n    _this2.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    return _this2;\n  }\n  _createClass(List, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return List.ClassName;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this.backingCollection.getLength();\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.backingCollection.getItems();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.backingCollection.valueOf();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.backingCollection.equals(other.backingCollection);\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems(items) {\n      if (items.length == 0) {\n        return new List(new types_1.TypePlaceholder(), []);\n      }\n      var typeParameter = items[0].getType();\n      var listType = new ListType(typeParameter);\n      return new List(listType, items);\n    }\n  }]);\n  return List;\n}(types_1.TypedValue);\nexports.List = List;\nList.ClassName = \"List\";","map":null,"metadata":{},"sourceType":"script"}