{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { RenderTexturePool } from '../renderTexture/RenderTexturePool.mjs';\nimport { Quad } from '../utils/Quad.mjs';\nimport { QuadUv } from '../utils/QuadUv.mjs';\nimport { Point, Matrix, Rectangle } from '@pixi/math';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\nimport { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { FilterState } from './FilterState.mjs';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nvar tempPoints = [new Point(), new Point(), new Point(), new Point()];\nvar tempMatrix = new Matrix();\nvar FilterSystem = /*#__PURE__*/function () {\n  function FilterSystem(renderer) {\n    _classCallCheck(this, FilterSystem);\n    this.renderer = renderer;\n    this.defaultFilterStack = [{}];\n    this.texturePool = new RenderTexturePool();\n    this.statePool = [];\n    this.quad = new Quad();\n    this.quadUv = new QuadUv();\n    this.tempRect = new Rectangle();\n    this.activeState = {};\n    this.globalUniforms = new UniformGroup({\n      outputFrame: new Rectangle(),\n      inputSize: new Float32Array(4),\n      inputPixel: new Float32Array(4),\n      inputClamp: new Float32Array(4),\n      resolution: 1,\n      filterArea: new Float32Array(4),\n      filterClamp: new Float32Array(4)\n    }, true);\n    this.forceClear = false;\n    this.useMaxPadding = false;\n  }\n  _createClass(FilterSystem, [{\n    key: \"init\",\n    value: function init() {\n      this.texturePool.setScreenSize(this.renderer.view);\n    }\n  }, {\n    key: \"push\",\n    value: function push(target, filters) {\n      var _filters$0$legacy;\n      var renderer = this.renderer;\n      var filterStack = this.defaultFilterStack;\n      var state = this.statePool.pop() || new FilterState();\n      var renderTextureSystem = this.renderer.renderTexture;\n      var resolution = filters[0].resolution;\n      var multisample = filters[0].multisample;\n      var padding = filters[0].padding;\n      var autoFit = filters[0].autoFit;\n      var legacy = (_filters$0$legacy = filters[0].legacy) !== null && _filters$0$legacy !== void 0 ? _filters$0$legacy : true;\n      for (var i = 1; i < filters.length; i++) {\n        var _filter$legacy;\n        var filter = filters[i];\n        resolution = Math.min(resolution, filter.resolution);\n        multisample = Math.min(multisample, filter.multisample);\n        padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;\n        autoFit = autoFit && filter.autoFit;\n        legacy = legacy || ((_filter$legacy = filter.legacy) !== null && _filter$legacy !== void 0 ? _filter$legacy : true);\n      }\n      if (filterStack.length === 1) {\n        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n      }\n      filterStack.push(state);\n      state.resolution = resolution;\n      state.multisample = multisample;\n      state.legacy = legacy;\n      state.target = target;\n      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n      state.sourceFrame.pad(padding);\n      var sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n      if (renderer.projection.transform) {\n        this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), sourceFrameProjected);\n      }\n      if (autoFit) {\n        state.sourceFrame.fit(sourceFrameProjected);\n        if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0) {\n          state.sourceFrame.width = 0;\n          state.sourceFrame.height = 0;\n        }\n      } else if (!state.sourceFrame.intersects(sourceFrameProjected)) {\n        state.sourceFrame.width = 0;\n        state.sourceFrame.height = 0;\n      }\n      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution, multisample);\n      state.filters = filters;\n      state.destinationFrame.width = state.renderTexture.width;\n      state.destinationFrame.height = state.renderTexture.height;\n      var destinationFrame = this.tempRect;\n      destinationFrame.x = 0;\n      destinationFrame.y = 0;\n      destinationFrame.width = state.sourceFrame.width;\n      destinationFrame.height = state.sourceFrame.height;\n      state.renderTexture.filterFrame = state.sourceFrame;\n      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n      state.transform = renderer.projection.transform;\n      renderer.projection.transform = null;\n      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n      renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      var filterStack = this.defaultFilterStack;\n      var state = filterStack.pop();\n      var filters = state.filters;\n      this.activeState = state;\n      var globalUniforms = this.globalUniforms.uniforms;\n      globalUniforms.outputFrame = state.sourceFrame;\n      globalUniforms.resolution = state.resolution;\n      var inputSize = globalUniforms.inputSize;\n      var inputPixel = globalUniforms.inputPixel;\n      var inputClamp = globalUniforms.inputClamp;\n      inputSize[0] = state.destinationFrame.width;\n      inputSize[1] = state.destinationFrame.height;\n      inputSize[2] = 1 / inputSize[0];\n      inputSize[3] = 1 / inputSize[1];\n      inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n      inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n      inputPixel[2] = 1 / inputPixel[0];\n      inputPixel[3] = 1 / inputPixel[1];\n      inputClamp[0] = 0.5 * inputPixel[2];\n      inputClamp[1] = 0.5 * inputPixel[3];\n      inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2];\n      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3];\n      if (state.legacy) {\n        var filterArea = globalUniforms.filterArea;\n        filterArea[0] = state.destinationFrame.width;\n        filterArea[1] = state.destinationFrame.height;\n        filterArea[2] = state.sourceFrame.x;\n        filterArea[3] = state.sourceFrame.y;\n        globalUniforms.filterClamp = globalUniforms.inputClamp;\n      }\n      this.globalUniforms.update();\n      var lastState = filterStack[filterStack.length - 1];\n      this.renderer.framebuffer.blit();\n      if (filters.length === 1) {\n        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n        this.returnFilterTexture(state.renderTexture);\n      } else {\n        var flip = state.renderTexture;\n        var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n        flop.filterFrame = flip.filterFrame;\n        var i = 0;\n        for (i = 0; i < filters.length - 1; ++i) {\n          if (i === 1 && state.multisample > 1) {\n            flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);\n            flop.filterFrame = flip.filterFrame;\n          }\n          filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n          var t = flip;\n          flip = flop;\n          flop = t;\n        }\n        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n        if (i > 1 && state.multisample > 1) {\n          this.returnFilterTexture(state.renderTexture);\n        }\n        this.returnFilterTexture(flip);\n        this.returnFilterTexture(flop);\n      }\n      state.clear();\n      this.statePool.push(state);\n    }\n  }, {\n    key: \"bindAndClear\",\n    value: function bindAndClear(filterTexture) {\n      var clearMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CLEAR_MODES.CLEAR;\n      var _this$renderer = this.renderer,\n        renderTextureSystem = _this$renderer.renderTexture,\n        stateSystem = _this$renderer.state;\n      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n        this.renderer.projection.transform = this.activeState.transform;\n      } else {\n        this.renderer.projection.transform = null;\n      }\n      if (filterTexture !== null && filterTexture !== void 0 && filterTexture.filterFrame) {\n        var destinationFrame = this.tempRect;\n        destinationFrame.x = 0;\n        destinationFrame.y = 0;\n        destinationFrame.width = filterTexture.filterFrame.width;\n        destinationFrame.height = filterTexture.filterFrame.height;\n        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n      } else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture) {\n        renderTextureSystem.bind(filterTexture);\n      } else {\n        this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n      }\n      var autoClear = stateSystem.stateId & 1 || this.forceClear;\n      if (clearMode === CLEAR_MODES.CLEAR || clearMode === CLEAR_MODES.BLIT && autoClear) {\n        this.renderer.framebuffer.clear(0, 0, 0, 0);\n      }\n    }\n  }, {\n    key: \"applyFilter\",\n    value: function applyFilter(filter, input, output, clearMode) {\n      var renderer = this.renderer;\n      renderer.state.set(filter.state);\n      this.bindAndClear(output, clearMode);\n      filter.uniforms.uSampler = input;\n      filter.uniforms.filterGlobals = this.globalUniforms;\n      renderer.shader.bind(filter);\n      filter.legacy = !!filter.program.attributeData.aTextureCoord;\n      if (filter.legacy) {\n        this.quadUv.map(input._frame, input.filterFrame);\n        renderer.geometry.bind(this.quadUv);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n      } else {\n        renderer.geometry.bind(this.quad);\n        renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n      }\n    }\n  }, {\n    key: \"calculateSpriteMatrix\",\n    value: function calculateSpriteMatrix(outputMatrix, sprite) {\n      var _this$activeState = this.activeState,\n        sourceFrame = _this$activeState.sourceFrame,\n        destinationFrame = _this$activeState.destinationFrame;\n      var orig = sprite._texture.orig;\n      var mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);\n      var worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n      worldTransform.invert();\n      mappedMatrix.prepend(worldTransform);\n      mappedMatrix.scale(1 / orig.width, 1 / orig.height);\n      mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n      return mappedMatrix;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n      this.texturePool.clear(false);\n    }\n  }, {\n    key: \"getOptimalFilterTexture\",\n    value: function getOptimalFilterTexture(minWidth, minHeight) {\n      var resolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var multisample = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MSAA_QUALITY.NONE;\n      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n    }\n  }, {\n    key: \"getFilterTexture\",\n    value: function getFilterTexture(input, resolution, multisample) {\n      if (typeof input === \"number\") {\n        var swap = input;\n        input = resolution;\n        resolution = swap;\n      }\n      input = input || this.activeState.renderTexture;\n      var filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || MSAA_QUALITY.NONE);\n      filterTexture.filterFrame = input.filterFrame;\n      return filterTexture;\n    }\n  }, {\n    key: \"returnFilterTexture\",\n    value: function returnFilterTexture(renderTexture) {\n      this.texturePool.returnTexture(renderTexture);\n    }\n  }, {\n    key: \"emptyPool\",\n    value: function emptyPool() {\n      this.texturePool.clear(true);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      this.texturePool.setScreenSize(this.renderer.view);\n    }\n  }, {\n    key: \"transformAABB\",\n    value: function transformAABB(matrix, rect) {\n      var lt = tempPoints[0];\n      var lb = tempPoints[1];\n      var rt = tempPoints[2];\n      var rb = tempPoints[3];\n      lt.set(rect.left, rect.top);\n      lb.set(rect.left, rect.bottom);\n      rt.set(rect.right, rect.top);\n      rb.set(rect.right, rect.bottom);\n      matrix.apply(lt, lt);\n      matrix.apply(lb, lb);\n      matrix.apply(rt, rt);\n      matrix.apply(rb, rb);\n      var x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n      var y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n      var x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n      var y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n      rect.x = x0;\n      rect.y = y0;\n      rect.width = x1 - x0;\n      rect.height = y1 - y0;\n    }\n  }, {\n    key: \"roundFrame\",\n    value: function roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n      if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0) {\n        return;\n      }\n      if (transform) {\n        var _transform = transform,\n          a = _transform.a,\n          b = _transform.b,\n          c = _transform.c,\n          d = _transform.d;\n        if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4)) {\n          return;\n        }\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n      this.transformAABB(transform, frame);\n      frame.ceil(resolution);\n      this.transformAABB(transform.invert(), frame);\n    }\n  }]);\n  return FilterSystem;\n}();\nFilterSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"filter\"\n};\nextensions.add(FilterSystem);\nexport { FilterSystem };","map":{"version":3,"sources":["../../src/filters/FilterSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { RenderTexturePool } from '../renderTexture/RenderTexturePool';\nimport { Quad } from '../utils/Quad';\nimport { QuadUv } from '../utils/QuadUv';\nimport { Rectangle, Matrix, Point } from '@pixi/math';\nimport { UniformGroup } from '../shader/UniformGroup';\nimport { DRAW_MODES, CLEAR_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { FilterState } from './FilterState';\n\nimport type { ISystem } from '../system/ISystem';\nimport type { Filter } from './Filter';\nimport type { IFilterTarget } from './IFilterTarget';\nimport type { ISpriteMaskTarget } from './spriteMask/SpriteMaskFilter';\nimport type { RenderTexture } from '../renderTexture/RenderTexture';\nimport type { Renderer } from '../Renderer';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\n\n/**\n * System plugin to the renderer to manage filters.\n *\n * ## Pipeline\n *\n * The FilterSystem executes the filtering pipeline by rendering the display-object into a texture, applying its\n * [filters]{@link PIXI.Filter} in series, and the last filter outputs into the final render-target.\n *\n * The filter-frame is the rectangle in world space being filtered, and those contents are mapped into\n * `(0, 0, filterFrame.width, filterFrame.height)` into the filter render-texture. The filter-frame is also called\n * the source-frame, as it is used to bind the filter render-textures. The last filter outputs to the `filterFrame`\n * in the final render-target.\n *\n * ## Usage\n *\n * {@link PIXI.Container#renderAdvanced} is an example of how to use the filter system. It is a 3 step process:\n *\n * **push**: Use {@link PIXI.FilterSystem#push} to push the set of filters to be applied on a filter-target.\n * **render**: Render the contents to be filtered using the renderer. The filter-system will only capture the contents\n *      inside the bounds of the filter-target. NOTE: Using {@link PIXI.Renderer#render} is\n *      illegal during an existing render cycle, and it may reset the filter system.\n * **pop**: Use {@link PIXI.FilterSystem#pop} to pop & execute the filters you initially pushed. It will apply them\n *      serially and output to the bounds of the filter-target.\n * @memberof PIXI\n */\nexport class FilterSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'filter',\n    };\n\n    /**\n     * List of filters for the FilterSystem\n     * @member {object[]}\n     */\n    public readonly defaultFilterStack: Array<FilterState>;\n\n    /** A pool for storing filter states, save us creating new ones each tick. */\n    public statePool: Array<FilterState>;\n\n    /** Stores a bunch of POT textures used for filtering. */\n    public texturePool: RenderTexturePool;\n\n    /** Whether to clear output renderTexture in AUTO/BLIT mode. See {@link PIXI.CLEAR_MODES}. */\n    public forceClear: boolean;\n\n    /**\n     * Old padding behavior is to use the max amount instead of sum padding.\n     * Use this flag if you need the old behavior.\n     * @default false\n     */\n    public useMaxPadding: boolean;\n\n    /** A very simple geometry used when drawing a filter effect to the screen. */\n    protected quad: Quad;\n\n    /** Quad UVs */\n    protected quadUv: QuadUv;\n\n    /**\n     * Active state\n     * @member {object}\n     */\n    protected activeState: FilterState;\n\n    /**\n     * This uniform group is attached to filter uniforms when used.\n     * @property {PIXI.Rectangle} outputFrame -\n     * @property {Float32Array} inputSize -\n     * @property {Float32Array} inputPixel -\n     * @property {Float32Array} inputClamp -\n     * @property {number} resolution -\n     * @property {Float32Array} filterArea -\n     * @property {Float32Array} filterClamp -\n     */\n    protected globalUniforms: UniformGroup;\n\n    /** Temporary rect for math. */\n    private tempRect: Rectangle;\n    public renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultFilterStack = [{}] as any;\n\n        this.texturePool = new RenderTexturePool();\n\n        this.statePool = [];\n\n        this.quad = new Quad();\n        this.quadUv = new QuadUv();\n        this.tempRect = new Rectangle();\n        this.activeState = {} as any;\n\n        this.globalUniforms = new UniformGroup({\n            outputFrame: new Rectangle(),\n            inputSize: new Float32Array(4),\n            inputPixel: new Float32Array(4),\n            inputClamp: new Float32Array(4),\n            resolution: 1,\n\n            // legacy variables\n            filterArea: new Float32Array(4),\n            filterClamp: new Float32Array(4),\n        }, true);\n\n        this.forceClear = false;\n        this.useMaxPadding = false;\n    }\n\n    init(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n     * input render-texture for the rest of the filtering pipeline.\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param filters - The filters to apply.\n     */\n    push(target: IFilterTarget, filters: Array<Filter>): void\n    {\n        const renderer = this.renderer;\n        const filterStack = this.defaultFilterStack;\n        const state = this.statePool.pop() || new FilterState();\n        const renderTextureSystem = this.renderer.renderTexture;\n\n        let resolution = filters[0].resolution;\n        let multisample = filters[0].multisample;\n        let padding = filters[0].padding;\n        let autoFit = filters[0].autoFit;\n        // We don't know whether it's a legacy filter until it was bound for the first time,\n        // therefore we have to assume that it is if legacy is undefined.\n        let legacy = filters[0].legacy ?? true;\n\n        for (let i = 1; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // let's use the lowest resolution\n            resolution = Math.min(resolution, filter.resolution);\n            // let's use the lowest number of samples\n            multisample = Math.min(multisample, filter.multisample);\n            // figure out the padding required for filters\n            padding = this.useMaxPadding\n                // old behavior: use largest amount of padding!\n                ? Math.max(padding, filter.padding)\n                // new behavior: sum the padding\n                : padding + filter.padding;\n            // only auto fit if all filters are autofit\n            autoFit = autoFit && filter.autoFit;\n\n            legacy = legacy || (filter.legacy ?? true);\n        }\n\n        if (filterStack.length === 1)\n        {\n            this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n        }\n\n        filterStack.push(state);\n\n        state.resolution = resolution;\n        state.multisample = multisample;\n\n        state.legacy = legacy;\n\n        state.target = target;\n        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n\n        state.sourceFrame.pad(padding);\n\n        const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n\n        // Project source frame into world space (if projection is applied)\n        if (renderer.projection.transform)\n        {\n            this.transformAABB(\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\n                sourceFrameProjected\n            );\n        }\n\n        if (autoFit)\n        {\n            state.sourceFrame.fit(sourceFrameProjected);\n\n            if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0)\n            {\n                state.sourceFrame.width = 0;\n                state.sourceFrame.height = 0;\n            }\n        }\n        else if (!state.sourceFrame.intersects(sourceFrameProjected))\n        {\n            state.sourceFrame.width = 0;\n            state.sourceFrame.height = 0;\n        }\n\n        // Round sourceFrame in screen space based on render-texture.\n        this.roundFrame(\n            state.sourceFrame,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform,\n        );\n\n        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height,\n            resolution, multisample);\n        state.filters = filters;\n\n        state.destinationFrame.width = state.renderTexture.width;\n        state.destinationFrame.height = state.renderTexture.height;\n\n        const destinationFrame = this.tempRect;\n\n        destinationFrame.x = 0;\n        destinationFrame.y = 0;\n        destinationFrame.width = state.sourceFrame.width;\n        destinationFrame.height = state.sourceFrame.height;\n\n        state.renderTexture.filterFrame = state.sourceFrame;\n        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n\n        state.transform = renderer.projection.transform;\n        renderer.projection.transform = null;\n        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n        renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n\n    /** Pops off the filter and applies it. */\n    pop(): void\n    {\n        const filterStack = this.defaultFilterStack;\n        const state = filterStack.pop();\n        const filters = state.filters;\n\n        this.activeState = state;\n\n        const globalUniforms = this.globalUniforms.uniforms;\n\n        globalUniforms.outputFrame = state.sourceFrame;\n        globalUniforms.resolution = state.resolution;\n\n        const inputSize = globalUniforms.inputSize;\n        const inputPixel = globalUniforms.inputPixel;\n        const inputClamp = globalUniforms.inputClamp;\n\n        inputSize[0] = state.destinationFrame.width;\n        inputSize[1] = state.destinationFrame.height;\n        inputSize[2] = 1.0 / inputSize[0];\n        inputSize[3] = 1.0 / inputSize[1];\n\n        inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n        inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        // only update the rect if its legacy..\n        if (state.legacy)\n        {\n            const filterArea = globalUniforms.filterArea;\n\n            filterArea[0] = state.destinationFrame.width;\n            filterArea[1] = state.destinationFrame.height;\n            filterArea[2] = state.sourceFrame.x;\n            filterArea[3] = state.sourceFrame.y;\n\n            globalUniforms.filterClamp = globalUniforms.inputClamp;\n        }\n\n        this.globalUniforms.update();\n\n        const lastState = filterStack[filterStack.length - 1];\n\n        this.renderer.framebuffer.blit();\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            this.returnFilterTexture(state.renderTexture);\n        }\n        else\n        {\n            let flip = state.renderTexture;\n            let flop = this.getOptimalFilterTexture(\n                flip.width,\n                flip.height,\n                state.resolution\n            );\n\n            flop.filterFrame = flip.filterFrame;\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                if (i === 1 && state.multisample > 1)\n                {\n                    flop = this.getOptimalFilterTexture(\n                        flip.width,\n                        flip.height,\n                        state.resolution\n                    );\n\n                    flop.filterFrame = flip.filterFrame;\n                }\n\n                filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            if (i > 1 && state.multisample > 1)\n            {\n                this.returnFilterTexture(state.renderTexture);\n            }\n\n            this.returnFilterTexture(flip);\n            this.returnFilterTexture(flop);\n        }\n\n        // lastState.renderTexture is blitted when lastState is popped\n\n        state.clear();\n        this.statePool.push(state);\n    }\n\n    /**\n     * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n     * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n     * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n     */\n    bindAndClear(filterTexture: RenderTexture, clearMode: CLEAR_MODES = CLEAR_MODES.CLEAR): void\n    {\n        const {\n            renderTexture: renderTextureSystem,\n            state: stateSystem,\n        } = this.renderer;\n\n        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            // Restore projection transform if rendering into the output render-target.\n            this.renderer.projection.transform = this.activeState.transform;\n        }\n        else\n        {\n            // Prevent projection within filtering pipeline.\n            this.renderer.projection.transform = null;\n        }\n\n        if (filterTexture?.filterFrame)\n        {\n            const destinationFrame = this.tempRect;\n\n            destinationFrame.x = 0;\n            destinationFrame.y = 0;\n            destinationFrame.width = filterTexture.filterFrame.width;\n            destinationFrame.height = filterTexture.filterFrame.height;\n\n            renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n        }\n        else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            renderTextureSystem.bind(filterTexture);\n        }\n        else\n        {\n            // Restore binding for output render-target.\n            this.renderer.renderTexture.bind(\n                filterTexture,\n                this.activeState.bindingSourceFrame,\n                this.activeState.bindingDestinationFrame\n            );\n        }\n\n        // Clear the texture in BLIT mode if blending is disabled or the forceClear flag is set. The blending\n        // is stored in the 0th bit of the state.\n        const autoClear = (stateSystem.stateId & 1) || this.forceClear;\n\n        if (clearMode === CLEAR_MODES.CLEAR\n            || (clearMode === CLEAR_MODES.BLIT && autoClear))\n        {\n            // Use framebuffer.clear because we want to clear the whole filter texture, not just the filtering\n            // area over which the shaders are run. This is because filters may sampling outside of it (e.g. blur)\n            // instead of clamping their arithmetic.\n            this.renderer.framebuffer.clear(0, 0, 0, 0);\n        }\n    }\n\n    /**\n     * Draws a filter using the default rendering process.\n     *\n     * This should be called only by {@link Filter#apply}.\n     * @param filter - The filter to draw.\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter: Filter, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES): void\n    {\n        const renderer = this.renderer;\n\n        // Set state before binding, so bindAndClear gets the blend mode.\n        renderer.state.set(filter.state);\n        this.bindAndClear(output, clearMode);\n\n        // set the uniforms..\n        filter.uniforms.uSampler = input;\n        filter.uniforms.filterGlobals = this.globalUniforms;\n\n        // TODO make it so that the order of this does not matter..\n        // because it does at the moment cos of global uniforms.\n        // they need to get resynced\n        renderer.shader.bind(filter);\n\n        // check to see if the filter is a legacy one..\n        filter.legacy = !!filter.program.attributeData.aTextureCoord;\n\n        if (filter.legacy)\n        {\n            this.quadUv.map(input._frame, input.filterFrame);\n\n            renderer.geometry.bind(this.quadUv);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n        }\n        else\n        {\n            renderer.geometry.bind(this.quad);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n        }\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix: Matrix, sprite: ISpriteMaskTarget): Matrix\n    {\n        const { sourceFrame, destinationFrame } = this.activeState;\n        const { orig } = sprite._texture;\n        const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0,\n            destinationFrame.height, sourceFrame.x, sourceFrame.y);\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    /** Destroys this Filter System. */\n    destroy(): void\n    {\n        this.renderer = null;\n\n        // Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem\n        this.texturePool.clear(false);\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture in real pixels.\n     * @param minHeight - The minimum height of the render texture in real pixels.\n     * @param resolution - The resolution of the render texture.\n     * @param multisample - Number of samples of the render texture.\n     * @returns - The new render texture.\n     */\n    protected getOptimalFilterTexture(minWidth: number, minHeight: number, resolution = 1,\n        multisample: MSAA_QUALITY = MSAA_QUALITY.NONE): RenderTexture\n    {\n        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n    }\n\n    /**\n     * Gets extra render texture to use inside current filter\n     * To be compliant with older filters, you can use params in any order\n     * @param input - renderTexture from which size and resolution will be copied\n     * @param resolution - override resolution of the renderTexture\n     * @param multisample - number of samples of the renderTexture\n     */\n    getFilterTexture(input?: RenderTexture, resolution?: number, multisample?: MSAA_QUALITY): RenderTexture\n    {\n        if (typeof input === 'number')\n        {\n            const swap = input;\n\n            input = resolution as any;\n            resolution = swap;\n        }\n\n        input = input || this.activeState.renderTexture;\n\n        const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution,\n            multisample || MSAA_QUALITY.NONE);\n\n        filterTexture.filterFrame = input.filterFrame;\n\n        return filterTexture;\n    }\n\n    /**\n     * Frees a render texture back into the pool.\n     * @param renderTexture - The renderTarget to free\n     */\n    returnFilterTexture(renderTexture: RenderTexture): void\n    {\n        this.texturePool.returnTexture(renderTexture);\n    }\n\n    /** Empties the texture pool. */\n    emptyPool(): void\n    {\n        this.texturePool.clear(true);\n    }\n\n    /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n    resize(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * @param matrix - first param\n     * @param rect - second param\n     */\n    private transformAABB(matrix: Matrix, rect: Rectangle): void\n    {\n        const lt = tempPoints[0];\n        const lb = tempPoints[1];\n        const rt = tempPoints[2];\n        const rb = tempPoints[3];\n\n        lt.set(rect.left, rect.top);\n        lb.set(rect.left, rect.bottom);\n        rt.set(rect.right, rect.top);\n        rb.set(rect.right, rect.bottom);\n\n        matrix.apply(lt, lt);\n        matrix.apply(lb, lb);\n        matrix.apply(rt, rt);\n        matrix.apply(rb, rb);\n\n        const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n        const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n        const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n        const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n\n        rect.x = x0;\n        rect.y = y0;\n        rect.width = x1 - x0;\n        rect.height = y1 - y0;\n    }\n\n    private roundFrame(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix\n    )\n    {\n        if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)\n        {\n            return;\n        }\n\n        if (transform)\n        {\n            const { a, b, c, d } = transform;\n\n            // Skip if skew/rotation present in matrix, except for multiple of 90 rotation. If rotation\n            // is a multiple of 90, then either pair of (b,c) or (a,d) will be (0,0).\n            if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n                && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n            {\n                return;\n            }\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        this.transformAABB(transform, frame);\n\n        // Round frame in screen space\n        frame.ceil(resolution);\n\n        // Project back into world space.\n        this.transformAABB(transform.invert(), frame);\n    }\n}\n\nextensions.add(FilterSystem);\n"]},"metadata":{},"sourceType":"module"}