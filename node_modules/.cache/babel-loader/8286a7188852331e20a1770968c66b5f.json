{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Texture, BaseTexture } from '@pixi/core';\nimport '../utils/index.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nvar CacheClass = /*#__PURE__*/function () {\n  function CacheClass() {\n    _classCallCheck(this, CacheClass);\n    this._parsers = [];\n    this._cache = /* @__PURE__ */new Map();\n    this._cacheMap = /* @__PURE__ */new Map();\n  }\n  _createClass(CacheClass, [{\n    key: \"reset\",\n    value: function reset() {\n      this._cacheMap.clear();\n      this._cache.clear();\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this._cache.has(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var result = this._cache.get(key);\n      if (!result) {}\n      return result;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var _this = this;\n      var keys = convertToList(key);\n      var cacheableAssets;\n      for (var i = 0; i < this.parsers.length; i++) {\n        var parser = this.parsers[i];\n        if (parser.test(value)) {\n          cacheableAssets = parser.getCacheableAssets(keys, value);\n          break;\n        }\n      }\n      if (!cacheableAssets) {\n        cacheableAssets = {};\n        keys.forEach(function (key2) {\n          cacheableAssets[key2] = value;\n        });\n      }\n      var cacheKeys = Object.keys(cacheableAssets);\n      var cachedAssets = {\n        cacheKeys: cacheKeys,\n        keys: keys\n      };\n      keys.forEach(function (key2) {\n        _this._cacheMap.set(key2, cachedAssets);\n      });\n      cacheKeys.forEach(function (key2) {\n        if (_this._cache.has(key2) && _this._cache.get(key2) !== value) {}\n        _this._cache.set(key2, cacheableAssets[key2]);\n      });\n      if (value instanceof Texture) {\n        var texture = value;\n        keys.forEach(function (key2) {\n          if (texture.baseTexture !== Texture.EMPTY.baseTexture) {\n            BaseTexture.addToCache(texture.baseTexture, key2);\n          }\n          Texture.addToCache(texture, key2);\n        });\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var _this2 = this;\n      this._cacheMap.get(key);\n      if (!this._cacheMap.has(key)) {\n        return;\n      }\n      var cacheMap = this._cacheMap.get(key);\n      var cacheKeys = cacheMap.cacheKeys;\n      cacheKeys.forEach(function (key2) {\n        _this2._cache.delete(key2);\n      });\n      cacheMap.keys.forEach(function (key2) {\n        _this2._cacheMap.delete(key2);\n      });\n    }\n  }, {\n    key: \"parsers\",\n    get: function get() {\n      return this._parsers;\n    }\n  }]);\n  return CacheClass;\n}();\nvar Cache = new CacheClass();\nexport { Cache };","map":{"version":3,"sources":["../../src/cache/Cache.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseTexture, Texture } from '@pixi/core';\nimport { convertToList } from '../utils';\nimport type { CacheParser } from './CacheParser';\n\n/**\n * A single Cache for all assets.\n *\n * When assets are added to the cache via set they normally are added to the cache as key-value pairs.\n *\n * With this cache, you can add parsers that will take the object and convert it to a list of assets that can be cached.\n * for example a cacheSprite Sheet parser will add all of the textures found within its sprite sheet directly to the cache.\n *\n * This gives devs the flexibility to cache any type of object however we want.\n *\n * It is not intended that this class is created by developers - it is part of the Asset package.\n * This is the first major system of PixiJS' main Assets class.\n * @memberof PIXI\n * @class Cache\n */\nclass CacheClass\n{\n    private _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<string, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: string): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: string): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set(key: string | string[], value: unknown): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        if (!cacheableAssets)\n        {\n            cacheableAssets = {};\n\n            keys.forEach((key) =>\n            {\n                cacheableAssets[key] = value;\n            });\n        }\n\n        const cacheKeys = Object.keys(cacheableAssets);\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            if (this._cache.has(key) && this._cache.get(key) !== value)\n            {\n                // #if _DEBUG\n                console.warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableAssets[key]);\n        });\n\n        // temporary to keep compatible with existing texture caching.. until we remove them!\n        if (value instanceof Texture)\n        {\n            const texture: Texture = value;\n\n            keys.forEach((key) =>\n            {\n                if (texture.baseTexture !== Texture.EMPTY.baseTexture)\n                {\n                    BaseTexture.addToCache(texture.baseTexture, key);\n                }\n\n                Texture.addToCache(texture, key);\n            });\n        }\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: string): void\n    {\n        this._cacheMap.get(key);\n\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            console.warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\nexport const Cache = new CacheClass();\n"]},"metadata":{},"sourceType":"module"}