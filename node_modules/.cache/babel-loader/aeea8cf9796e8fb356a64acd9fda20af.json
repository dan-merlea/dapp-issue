{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT } from \"./utils\";\nexport function generateKeyPair() {\n  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : randomBytes(KEY_PAIR_SEED_LENGTH);\n  return ed25519.generateKeyPairFromSeed(seed);\n}\nexport function signJWT(_x, _x2, _x3, _x4) {\n  return _signJWT.apply(this, arguments);\n}\nfunction _signJWT() {\n  _signJWT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sub, aud, ttl, keyPair) {\n    var iat,\n      header,\n      iss,\n      exp,\n      payload,\n      data,\n      signature,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            iat = _args.length > 4 && _args[4] !== undefined ? _args[4] : fromMiliseconds(Date.now());\n            header = {\n              alg: JWT_IRIDIUM_ALG,\n              typ: JWT_IRIDIUM_TYP\n            };\n            iss = encodeIss(keyPair.publicKey);\n            exp = iat + ttl;\n            payload = {\n              iss: iss,\n              sub: sub,\n              aud: aud,\n              iat: iat,\n              exp: exp\n            };\n            data = encodeData({\n              header: header,\n              payload: payload\n            });\n            signature = ed25519.sign(keyPair.secretKey, data);\n            return _context.abrupt(\"return\", encodeJWT({\n              header: header,\n              payload: payload,\n              signature: signature\n            }));\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _signJWT.apply(this, arguments);\n}\nexport function verifyJWT(_x5) {\n  return _verifyJWT.apply(this, arguments);\n}\nfunction _verifyJWT() {\n  _verifyJWT = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(jwt) {\n    var _decodeJWT, header, payload, signature, publicKey, data;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _decodeJWT = decodeJWT(jwt), header = _decodeJWT.header, payload = _decodeJWT.payload, signature = _decodeJWT.signature;\n            if (!(header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP)) {\n              _context2.next = 3;\n              break;\n            }\n            throw new Error(\"JWT must use EdDSA algorithm\");\n          case 3:\n            publicKey = decodeIss(payload.iss);\n            data = encodeData({\n              header: header,\n              payload: payload\n            });\n            return _context2.abrupt(\"return\", ed25519.verify(publicKey, data, signature));\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _verifyJWT.apply(this, arguments);\n}","map":{"version":3,"sources":["../../src/api.ts"],"names":[],"mappings":";;AAAA,OAAO,KAAK,OAAO,MAAM,oBAAoB;AAC7C,SAAS,WAAW,QAAQ,mBAAmB;AAC/C,SAAS,eAAe,QAAQ,qBAAqB;AACrD,SACE,eAAe,EACf,eAAe,EACf,oBAAoB,QACf,aAAa;AAEpB,SACE,SAAS,EACT,SAAS,EACT,UAAU,EACV,SAAS,EACT,SAAS,QACJ,SAAS;AAEhB,OAAM,SAAU,eAAe,GACuB;EAAA,IAApD,IAAA,uEAAmB,WAAW,CAAC,oBAAoB,CAAC;EAEpD,OAAO,OAAO,CAAC,uBAAuB,CAAC,IAAI,CAAC;AAC9C;AAEA,gBAAsB,OAAO;EAAA;AAAA;AAc5B;EAAA,sEAdM,iBACL,GAAW,EACX,GAAW,EACX,GAAW,EACX,OAAwB;IAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;IAAA;MAAA;QAAA;UAAA;YACxB,GAAA,2DAAc,eAAe,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YAEnC,MAAM,GAAG;cAAE,GAAG,EAAE,eAAe;cAAE,GAAG,EAAE;YAAe,CAAE;YACvD,GAAG,GAAG,SAAS,CAAC,OAAO,CAAC,SAAS,CAAC;YAClC,GAAG,GAAG,GAAG,GAAG,GAAG;YACf,OAAO,GAAG;cAAE,GAAG,EAAH,GAAG;cAAE,GAAG,EAAH,GAAG;cAAE,GAAG,EAAH,GAAG;cAAE,GAAG,EAAH,GAAG;cAAE,GAAG,EAAH;YAAG,CAAE;YACrC,IAAI,GAAG,UAAU,CAAC;cAAE,MAAM,EAAN,MAAM;cAAE,OAAO,EAAP;YAAO,CAAE,CAAC;YACtC,SAAS,GAAG,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC;YAAA,iCAChD,SAAS,CAAC;cAAE,MAAM,EAAN,MAAM;cAAE,OAAO,EAAP,OAAO;cAAE,SAAS,EAAT;YAAS,CAAE,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACjD;EAAA;AAAA;AAED,gBAAsB,SAAS;EAAA;AAAA;AAQ9B;EAAA,wEARM,kBAAyB,GAAW;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,aACF,SAAS,CAAC,GAAG,CAAC,EAA7C,MAAM,cAAN,MAAM,EAAE,OAAO,cAAP,OAAO,EAAE,SAAS,cAAT,SAAS;YAAA,MAC9B,MAAM,CAAC,GAAG,KAAK,eAAe,IAAI,MAAM,CAAC,GAAG,KAAK,eAAe;cAAA;cAAA;YAAA;YAAA,MAC5D,IAAI,KAAK,CAAC,8BAA8B,CAAC;UAAA;YAE3C,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC;YAClC,IAAI,GAAG,UAAU,CAAC;cAAE,MAAM,EAAN,MAAM;cAAE,OAAO,EAAP;YAAO,CAAE,CAAC;YAAA,kCACrC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAClD;EAAA;AAAA","sourceRoot":"","sourcesContent":["import * as ed25519 from \"@stablelib/ed25519\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { fromMiliseconds } from \"@walletconnect/time\";\nimport { JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, KEY_PAIR_SEED_LENGTH, } from \"./constants\";\nimport { decodeIss, decodeJWT, encodeData, encodeIss, encodeJWT, } from \"./utils\";\nexport function generateKeyPair(seed = randomBytes(KEY_PAIR_SEED_LENGTH)) {\n    return ed25519.generateKeyPairFromSeed(seed);\n}\nexport async function signJWT(sub, aud, ttl, keyPair, iat = fromMiliseconds(Date.now())) {\n    const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };\n    const iss = encodeIss(keyPair.publicKey);\n    const exp = iat + ttl;\n    const payload = { iss, sub, aud, iat, exp };\n    const data = encodeData({ header, payload });\n    const signature = ed25519.sign(keyPair.secretKey, data);\n    return encodeJWT({ header, payload, signature });\n}\nexport async function verifyJWT(jwt) {\n    const { header, payload, signature } = decodeJWT(jwt);\n    if (header.alg !== JWT_IRIDIUM_ALG || header.typ !== JWT_IRIDIUM_TYP) {\n        throw new Error(\"JWT must use EdDSA algorithm\");\n    }\n    const publicKey = decodeIss(payload.iss);\n    const data = encodeData({ header, payload });\n    return ed25519.verify(publicKey, data, signature);\n}\n//# sourceMappingURL=api.js.map"]},"metadata":{},"sourceType":"module"}