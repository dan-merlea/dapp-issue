{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar Shader = require('../shader/Shader.js');\nvar Program = require('../shader/Program.js');\nvar UniformGroup = require('../shader/UniformGroup.js');\nvar math = require('@pixi/math');\nvar BatchShaderGenerator = /*#__PURE__*/function () {\n  function BatchShaderGenerator(vertexSrc, fragTemplate) {\n    _classCallCheck(this, BatchShaderGenerator);\n    this.vertexSrc = vertexSrc;\n    this.fragTemplate = fragTemplate;\n    this.programCache = {};\n    this.defaultGroupCache = {};\n    if (!fragTemplate.includes(\"%count%\")) {\n      throw new Error('Fragment template must contain \"%count%\".');\n    }\n    if (!fragTemplate.includes(\"%forloop%\")) {\n      throw new Error('Fragment template must contain \"%forloop%\".');\n    }\n  }\n  _createClass(BatchShaderGenerator, [{\n    key: \"generateShader\",\n    value: function generateShader(maxTextures) {\n      if (!this.programCache[maxTextures]) {\n        var sampleValues = new Int32Array(maxTextures);\n        for (var i = 0; i < maxTextures; i++) {\n          sampleValues[i] = i;\n        }\n        this.defaultGroupCache[maxTextures] = UniformGroup.UniformGroup.from({\n          uSamplers: sampleValues\n        }, true);\n        var fragmentSrc = this.fragTemplate;\n        fragmentSrc = fragmentSrc.replace(/%count%/gi, \"\".concat(maxTextures));\n        fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n        this.programCache[maxTextures] = new Program.Program(this.vertexSrc, fragmentSrc);\n      }\n      var uniforms = {\n        tint: new Float32Array([1, 1, 1, 1]),\n        translationMatrix: new math.Matrix(),\n        default: this.defaultGroupCache[maxTextures]\n      };\n      return new Shader.Shader(this.programCache[maxTextures], uniforms);\n    }\n  }, {\n    key: \"generateSampleSrc\",\n    value: function generateSampleSrc(maxTextures) {\n      var src = \"\";\n      src += \"\\n\";\n      src += \"\\n\";\n      for (var i = 0; i < maxTextures; i++) {\n        if (i > 0) {\n          src += \"\\nelse \";\n        }\n        if (i < maxTextures - 1) {\n          src += \"if(vTextureId < \".concat(i, \".5)\");\n        }\n        src += \"\\n{\";\n        src += \"\\n\\tcolor = texture2D(uSamplers[\".concat(i, \"], vTextureCoord);\");\n        src += \"\\n}\";\n      }\n      src += \"\\n\";\n      src += \"\\n\";\n      return src;\n    }\n  }]);\n  return BatchShaderGenerator;\n}();\nexports.BatchShaderGenerator = BatchShaderGenerator;","map":{"version":3,"sources":["../../src/batch/BatchShaderGenerator.ts"],"names":["UniformGroup","Program","Matrix","Shader"],"mappings":";;;;;;;;;;;IASa,oBACb;EAcI,8BAAY,SAAA,EAAmB,YAC/B,EAAA;IAAA;IACI,IAAA,CAAK,SAAY,GAAA,SAAA;IACjB,IAAA,CAAK,YAAe,GAAA,YAAA;IAEpB,IAAA,CAAK,YAAA,GAAe,CAAA,CAAC;IACrB,IAAA,CAAK,iBAAA,GAAoB,CAAA,CAAC;IAE1B,IAAI,CAAC,YAAA,CAAa,QAAS,CAAA,SAAS,CACpC,EAAA;MACU,MAAA,IAAI,KAAA,CAAM,2CAA2C,CAAA;IAAA;IAG/D,IAAI,CAAC,YAAA,CAAa,QAAS,CAAA,WAAW,CACtC,EAAA;MACU,MAAA,IAAI,KAAA,CAAM,6CAA6C,CAAA;IAAA;EACjE;EACJ;IAAA;IAAA,OAEA,wBAAe,WACf,EAAA;MACQ,IAAA,CAAC,IAAK,CAAA,YAAA,CAAa,WACvB,CAAA,EAAA;QACU,IAAA,YAAA,GAAe,IAAI,UAAA,CAAW,WAAW,CAAA;QAE/C,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CACjC,EAAA,EAAA;UACI,YAAA,CAAa,CAAK,CAAA,GAAA,CAAA;QAAA;QAGjB,IAAA,CAAA,iBAAA,CAAkB,WAAA,CAAA,GAAeA,YAAAA,CAAAA,YAAa,CAAA,IAAA,CAAK;UAAE,SAAW,EAAA;QAAA,CAAA,EAAgB,IAAI,CAAA;QAEzF,IAAI,WAAA,GAAc,IAAK,CAAA,YAAA;QAEvB,WAAA,GAAc,WAAY,CAAA,OAAA,CAAQ,WAAa,YAAG,WAAa,EAAA;QAC/D,WAAA,GAAc,WAAA,CAAY,OAAQ,CAAA,aAAA,EAAe,IAAK,CAAA,iBAAA,CAAkB,WAAW,CAAC,CAAA;QAEpF,IAAA,CAAK,YAAA,CAAa,WAAe,CAAA,GAAA,IAAIC,OAAAA,CAAAA,OAAQ,CAAA,IAAA,CAAK,SAAA,EAAW,WAAW,CAAA;MAAA;MAG5E,IAAM,QAAW,GAAA;QACb,IAAA,EAAM,IAAI,YAAa,CAAA,CAAC,CAAA,EAAG,CAAG,EAAA,CAAA,EAAG,CAAC,CAAC,CAAA;QACnC,iBAAA,EAAmB,IAAIC,IAAAA,CAAAA,MAAO,EAAA;QAC9B,OAAA,EAAS,IAAA,CAAK,iBAAkB,CAAA,WAAA;MAAA,CACpC;MAEA,OAAO,IAAIC,MAAAA,CAAAA,MAAAA,CAAO,IAAK,CAAA,YAAA,CAAa,WAAA,CAAA,EAAc,QAAQ,CAAA;IAAA;EAC9D;IAAA;IAAA,OAEA,2BAAkB,WAClB,EAAA;MACI,IAAI,GAAM,GAAA,EAAA;MAEH,GAAA,IAAA,IAAA;MACA,GAAA,IAAA,IAAA;MAEP,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CACjC,EAAA,EAAA;QACI,IAAI,CAAA,GAAI,CACR,EAAA;UACW,GAAA,IAAA,SAAA;QAAA;QAGP,IAAA,CAAA,GAAI,WAAA,GAAc,CACtB,EAAA;UACI,GAAA,8BAA0B,CAAA,QAAA;QAAA;QAGvB,GAAA,IAAA,KAAA;QACA,GAAA,8CAAmC,CAAA,uBAAA;QACnC,GAAA,IAAA,KAAA;MAAA;MAGJ,GAAA,IAAA,IAAA;MACA,GAAA,IAAA,IAAA;MAEA,OAAA,GAAA;IAAA;EACX;EAAA;AAAA","sourcesContent":["import { Shader } from '../shader/Shader';\nimport { Program } from '../shader/Program';\nimport { UniformGroup } from '../shader/UniformGroup';\nimport { Matrix } from '@pixi/math';\n\n/**\n * Helper that generates batching multi-texture shader. Use it with your new BatchRenderer\n * @memberof PIXI\n */\nexport class BatchShaderGenerator\n{\n    /** Reference to the vertex shader source. */\n    public vertexSrc: string;\n\n    /** Reference to the fragment shader template. Must contain \"%count%\" and \"%forloop%\". */\n    public fragTemplate: string;\n\n    programCache: {[key: number]: Program};\n    defaultGroupCache: {[key: number]: UniformGroup};\n\n    /**\n     * @param vertexSrc - Vertex shader\n     * @param fragTemplate - Fragment shader template\n     */\n    constructor(vertexSrc: string, fragTemplate: string)\n    {\n        this.vertexSrc = vertexSrc;\n        this.fragTemplate = fragTemplate;\n\n        this.programCache = {};\n        this.defaultGroupCache = {};\n\n        if (!fragTemplate.includes('%count%'))\n        {\n            throw new Error('Fragment template must contain \"%count%\".');\n        }\n\n        if (!fragTemplate.includes('%forloop%'))\n        {\n            throw new Error('Fragment template must contain \"%forloop%\".');\n        }\n    }\n\n    generateShader(maxTextures: number): Shader\n    {\n        if (!this.programCache[maxTextures])\n        {\n            const sampleValues = new Int32Array(maxTextures);\n\n            for (let i = 0; i < maxTextures; i++)\n            {\n                sampleValues[i] = i;\n            }\n\n            this.defaultGroupCache[maxTextures] = UniformGroup.from({ uSamplers: sampleValues }, true);\n\n            let fragmentSrc = this.fragTemplate;\n\n            fragmentSrc = fragmentSrc.replace(/%count%/gi, `${maxTextures}`);\n            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n\n            this.programCache[maxTextures] = new Program(this.vertexSrc, fragmentSrc);\n        }\n\n        const uniforms = {\n            tint: new Float32Array([1, 1, 1, 1]),\n            translationMatrix: new Matrix(),\n            default: this.defaultGroupCache[maxTextures],\n        };\n\n        return new Shader(this.programCache[maxTextures], uniforms);\n    }\n\n    generateSampleSrc(maxTextures: number): string\n    {\n        let src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i > 0)\n            {\n                src += '\\nelse ';\n            }\n\n            if (i < maxTextures - 1)\n            {\n                src += `if(vTextureId < ${i}.5)`;\n            }\n\n            src += '\\n{';\n            src += `\\n\\tcolor = texture2D(uSamplers[${i}], vTextureCoord);`;\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}