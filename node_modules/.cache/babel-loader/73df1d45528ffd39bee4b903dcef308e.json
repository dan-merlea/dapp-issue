{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BaseImageResource } from './BaseImageResource.mjs';\nimport { Ticker } from '@pixi/ticker';\nvar _VideoResource = /*#__PURE__*/function (_BaseImageResource) {\n  _inherits(_VideoResource, _BaseImageResource);\n  var _super = _createSuper(_VideoResource);\n  function _VideoResource(source, options) {\n    var _this;\n    _classCallCheck(this, _VideoResource);\n    options = options || {};\n    if (!(source instanceof HTMLVideoElement)) {\n      var videoElement = document.createElement(\"video\");\n      videoElement.setAttribute(\"preload\", \"auto\");\n      videoElement.setAttribute(\"webkit-playsinline\", \"\");\n      videoElement.setAttribute(\"playsinline\", \"\");\n      if (typeof source === \"string\") {\n        source = [source];\n      }\n      var firstSrc = source[0].src || source[0];\n      BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n      for (var i = 0; i < source.length; ++i) {\n        var sourceElement = document.createElement(\"source\");\n        var _source$i = source[i],\n          src = _source$i.src,\n          mime = _source$i.mime;\n        src = src || source[i];\n        var baseSrc = src.split(\"?\").shift().toLowerCase();\n        var ext = baseSrc.slice(baseSrc.lastIndexOf(\".\") + 1);\n        mime = mime || _VideoResource.MIME_TYPES[ext] || \"video/\".concat(ext);\n        sourceElement.src = src;\n        sourceElement.type = mime;\n        videoElement.appendChild(sourceElement);\n      }\n      source = videoElement;\n    }\n    _this = _super.call(this, source);\n    _this.noSubImage = true;\n    _this._autoUpdate = true;\n    _this._isConnectedToTicker = false;\n    _this._updateFPS = options.updateFPS || 0;\n    _this._msToNextUpdate = 0;\n    _this.autoPlay = options.autoPlay !== false;\n    _this._load = null;\n    _this._resolve = null;\n    _this._onCanPlay = _this._onCanPlay.bind(_assertThisInitialized(_this));\n    _this._onError = _this._onError.bind(_assertThisInitialized(_this));\n    if (options.autoLoad !== false) {\n      _this.load();\n    }\n    return _this;\n  }\n  _createClass(_VideoResource, [{\n    key: \"update\",\n    value: function update() {\n      var _deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (!this.destroyed) {\n        var elapsedMS = Ticker.shared.elapsedMS * this.source.playbackRate;\n        this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        if (!this._updateFPS || this._msToNextUpdate <= 0) {\n          _get(_getPrototypeOf(_VideoResource.prototype), \"update\", this).call(this);\n          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n        }\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this2 = this;\n      if (this._load) {\n        return this._load;\n      }\n      var source = this.source;\n      if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n        source.complete = true;\n      }\n      source.addEventListener(\"play\", this._onPlayStart.bind(this));\n      source.addEventListener(\"pause\", this._onPlayStop.bind(this));\n      if (!this._isSourceReady()) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n        source.addEventListener(\"canplaythrough\", this._onCanPlay);\n        source.addEventListener(\"error\", this._onError, true);\n      } else {\n        this._onCanPlay();\n      }\n      this._load = new Promise(function (resolve) {\n        if (_this2.valid) {\n          resolve(_this2);\n        } else {\n          _this2._resolve = resolve;\n          source.load();\n        }\n      });\n      return this._load;\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(event) {\n      this.source.removeEventListener(\"error\", this._onError, true);\n      this.onError.emit(event);\n    }\n  }, {\n    key: \"_isSourcePlaying\",\n    value: function _isSourcePlaying() {\n      var source = this.source;\n      return !source.paused && !source.ended && this._isSourceReady();\n    }\n  }, {\n    key: \"_isSourceReady\",\n    value: function _isSourceReady() {\n      var source = this.source;\n      return source.readyState > 2;\n    }\n  }, {\n    key: \"_onPlayStart\",\n    value: function _onPlayStart() {\n      if (!this.valid) {\n        this._onCanPlay();\n      }\n      if (this.autoUpdate && !this._isConnectedToTicker) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }, {\n    key: \"_onPlayStop\",\n    value: function _onPlayStop() {\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      }\n    }\n  }, {\n    key: \"_onCanPlay\",\n    value: function _onCanPlay() {\n      var source = this.source;\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n      var valid = this.valid;\n      this.resize(source.videoWidth, source.videoHeight);\n      if (!valid && this._resolve) {\n        this._resolve(this);\n        this._resolve = null;\n      }\n      if (this._isSourcePlaying()) {\n        this._onPlayStart();\n      } else if (this.autoPlay) {\n        source.play();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      }\n      var source = this.source;\n      if (source) {\n        source.removeEventListener(\"error\", this._onError, true);\n        source.pause();\n        source.src = \"\";\n        source.load();\n      }\n      _get(_getPrototypeOf(_VideoResource.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"autoUpdate\",\n    get: function get() {\n      return this._autoUpdate;\n    },\n    set: function set(value) {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n        if (!this._autoUpdate && this._isConnectedToTicker) {\n          Ticker.shared.remove(this.update, this);\n          this._isConnectedToTicker = false;\n        } else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying()) {\n          Ticker.shared.add(this.update, this);\n          this._isConnectedToTicker = true;\n        }\n      }\n    }\n  }, {\n    key: \"updateFPS\",\n    get: function get() {\n      return this._updateFPS;\n    },\n    set: function set(value) {\n      if (value !== this._updateFPS) {\n        this._updateFPS = value;\n      }\n    }\n  }], [{\n    key: \"test\",\n    value: function test(source, extension) {\n      return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || _VideoResource.TYPES.includes(extension);\n    }\n  }]);\n  return _VideoResource;\n}(BaseImageResource);\nvar VideoResource = _VideoResource;\nVideoResource.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"];\nVideoResource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nexport { VideoResource };","map":{"version":3,"sources":["../../../src/textures/resources/VideoResource.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseImageResource } from './BaseImageResource';\nimport { Ticker } from '@pixi/ticker';\n\nimport type { Dict } from '@pixi/utils';\n\nexport interface IVideoResourceOptions\n{\n    autoLoad?: boolean;\n    autoPlay?: boolean;\n    updateFPS?: number;\n    crossorigin?: boolean | string;\n}\n\nexport interface IVideoResourceOptionsElement\n{\n    src: string;\n    mime: string;\n}\n\n/**\n * Resource type for {@code HTMLVideoElement}.\n * @memberof PIXI\n */\nexport class VideoResource extends BaseImageResource\n{\n    /** Override the source to be the video element. */\n    public source: HTMLVideoElement;\n\n    /**\n     * `true` to use PIXI.Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    protected _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    protected _isConnectedToTicker: boolean;\n    protected _updateFPS: number;\n    protected _msToNextUpdate: number;\n\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<VideoResource>;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: VideoResource | PromiseLike<VideoResource>) => void;\n\n    /**\n     * @param {HTMLVideoElement|object|string|Array<string|object>} source - Video element to use.\n     * @param {object} [options] - Options to use\n     * @param {boolean} [options.autoLoad=true] - Start loading the video immediately\n     * @param {boolean} [options.autoPlay=true] - Start playing video immediately\n     * @param {number} [options.updateFPS=0] - How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * @param {boolean} [options.crossorigin=true] - Load image using cross origin\n     */\n    constructor(\n        source?: HTMLVideoElement | Array<string | IVideoResourceOptionsElement> | string, options?: IVideoResourceOptions\n    )\n    {\n        options = options || {};\n\n        if (!(source instanceof HTMLVideoElement))\n        {\n            const videoElement = document.createElement('video');\n\n            // workaround for https://github.com/pixijs/pixi.js/issues/5996\n            videoElement.setAttribute('preload', 'auto');\n            videoElement.setAttribute('webkit-playsinline', '');\n            videoElement.setAttribute('playsinline', '');\n\n            if (typeof source === 'string')\n            {\n                source = [source];\n            }\n\n            const firstSrc = (source[0] as IVideoResourceOptionsElement).src || source[0] as string;\n\n            BaseImageResource.crossOrigin(videoElement, firstSrc, options.crossorigin);\n\n            // array of objects or strings\n            for (let i = 0; i < source.length; ++i)\n            {\n                const sourceElement = document.createElement('source');\n\n                let { src, mime } = source[i] as IVideoResourceOptionsElement;\n\n                src = src || source[i] as string;\n\n                const baseSrc = src.split('?').shift().toLowerCase();\n                const ext = baseSrc.slice(baseSrc.lastIndexOf('.') + 1);\n\n                mime = mime || VideoResource.MIME_TYPES[ext] || `video/${ext}`;\n\n                sourceElement.src = src;\n                sourceElement.type = mime;\n\n                videoElement.appendChild(sourceElement);\n            }\n\n            // Override the source\n            source = videoElement;\n        }\n\n        super(source);\n\n        this.noSubImage = true;\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n\n        this._load = null;\n        this._resolve = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onError = this._onError.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Trigger updating of the texture.\n     * @param _deltaTime - time delta since last tick\n     */\n    update(_deltaTime = 0): void\n    {\n        if (!this.destroyed)\n        {\n            // account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * (this.source as HTMLVideoElement).playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n            if (!this._updateFPS || this._msToNextUpdate <= 0)\n            {\n                super.update(/* deltaTime*/);\n                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n            }\n        }\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<void>} Handle the validate event\n     */\n    load(): Promise<VideoResource>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.source as HTMLVideoElement;\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n\n        this._load = new Promise((resolve): void =>\n        {\n            if (this.valid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        (this.source as HTMLVideoElement).removeEventListener('error', this._onError, true);\n        this.onError.emit(event);\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     * @returns - True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.source as HTMLVideoElement;\n\n        return (!source.paused && !source.ended && this._isSourceReady());\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     * @returns - True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.source as HTMLVideoElement;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.valid)\n        {\n            this._onCanPlay();\n        }\n\n        if (this.autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /** Fired when a pause event is triggered, stops the update loop. */\n    private _onPlayStop(): void\n    {\n        if (this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _onCanPlay(): void\n    {\n        const source = this.source as HTMLVideoElement;\n\n        source.removeEventListener('canplay', this._onCanPlay);\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        const valid = this.valid;\n\n        this.resize(source.videoWidth, source.videoHeight);\n\n        // prevent multiple loaded dispatches..\n        if (!valid && this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n        }\n\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            source.play();\n        }\n    }\n\n    /** Destroys this texture. */\n    dispose(): void\n    {\n        if (this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n\n        const source = this.source as HTMLVideoElement;\n\n        if (source)\n        {\n            source.removeEventListener('error', this._onError, true);\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n        super.dispose();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying())\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video. Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n        }\n    }\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @param {string} extension - The extension of source, if set\n     * @returns {boolean} `true` if video source\n     */\n    static test(source: unknown, extension?: string): source is HTMLVideoElement\n    {\n        return (globalThis.HTMLVideoElement && source instanceof HTMLVideoElement)\n            || VideoResource.TYPES.includes(extension);\n    }\n\n    /**\n     * List of common video file extensions supported by VideoResource.\n     * @readonly\n     */\n    static TYPES: Array<string> = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    static MIME_TYPES: Dict<string> = {\n        ogv: 'video/ogg',\n        mov: 'video/quicktime',\n        m4v: 'video/mp4',\n    };\n}\n"]},"metadata":{},"sourceType":"module"}