{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Container, MIPMAP_MODES, Point, Sprite, Texture } from 'pixi.js';\nimport PathSprite from './PathSprite';\nimport { TextLabel } from '..';\nimport { Constants, Maths } from '@krogan/common';\nimport { TargetTexture } from 'images/textures';\nimport timeLeftToShortString from 'utils/time';\nimport SpaceshipIcon from './SpaceshipIcon';\nvar PathDirection;\n(function (PathDirection) {\n  PathDirection[PathDirection[\"X\"] = 0] = \"X\";\n  PathDirection[PathDirection[\"Y\"] = 1] = \"Y\";\n  PathDirection[PathDirection[\"Z\"] = 2] = \"Z\";\n})(PathDirection || (PathDirection = {}));\nvar MapPathContainer = /*#__PURE__*/function (_Container) {\n  _inherits(MapPathContainer, _Container);\n  var _super = _createSuper(MapPathContainer);\n  function MapPathContainer(tiles, travel) {\n    var _this;\n    _classCallCheck(this, MapPathContainer);\n    _this = _super.call(this);\n    _this._segments = [];\n    _this._spaceship = void 0;\n    _this._time = void 0;\n    _this.timer = void 0;\n    var pathLength = tiles.length;\n    _this.drawNextSegment(tiles);\n    var destination = tiles.first();\n    var texture = Texture.from(TargetTexture);\n    texture.baseTexture.mipmap = MIPMAP_MODES.POW2;\n    var target = new Sprite(texture);\n    target.anchor.x = 0.5;\n    target.anchor.y = 0.5;\n    target.width = 20;\n    target.height = 18;\n    target.x = destination.x;\n    target.y = destination.y;\n    _this.addChild(target);\n    _this._time = new TextLabel('Warp', 8);\n    _this._time.x = destination.x + 9;\n    _this._time.y = destination.y - 18;\n    _this.addChild(_this._time);\n    var spaceship = new SpaceshipIcon(-100, -100);\n    _this.addChild(spaceship);\n    _this._spaceship = spaceship;\n    if (travel) {\n      var progress = Maths.getTimeProgress(travel.start, travel.end);\n      spaceship.alignOnPath(_this.getPathPosition(progress));\n      _this.timer = setInterval(function () {\n        _this.updateSpaceshipPosition(travel);\n      }, 1000);\n    } else {\n      spaceship.alignOnPath(_this.getPathPosition(0));\n      var timeLeft = Constants.PATH_TIME(pathLength);\n      var timeLeftText = timeLeftToShortString(timeLeft / 1000);\n      _this._time.setText(timeLeftText);\n    }\n    _this.zIndex = 100; // 0-99 it's the tile \n    // TODO: change this to enum of layers\n    return _this;\n  }\n  _createClass(MapPathContainer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.timer) clearInterval(this.timer);\n      _get(_getPrototypeOf(MapPathContainer.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"updateSpaceshipPosition\",\n    value: function updateSpaceshipPosition(travel) {\n      var progress = Maths.getTimeProgress(travel.start, travel.end);\n      if (progress == 1) this.destroy();\n      this._spaceship.alignOnPath(this.getPathPosition(progress));\n      var timeLeft = (travel.end - Date.now()) / 1000;\n      console.log(\"[Travel][Update] Time left: \".concat(timeLeft));\n      var timeLeftText = timeLeftToShortString(timeLeft);\n      this._time.setText(timeLeftText);\n    }\n  }, {\n    key: \"drawNextSegment\",\n    value: function drawNextSegment(tiles) {\n      if (tiles.length < 2) return;\n      var start = tiles.pop();\n      var prev = start;\n      var next = tiles.pop();\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var direction = this.getPathDirection(prev, next);\n      var newDirection = direction;\n      do {\n        prev = next;\n        next = tiles.pop();\n        if (!next) break;\n        newDirection = this.getPathDirection(prev, next);\n      } while (direction == newDirection);\n      if (start && prev) {\n        this.drawPath(start, prev);\n        if (next) tiles.push(next);\n        tiles.push(prev);\n      }\n      this.drawNextSegment(tiles);\n    }\n  }, {\n    key: \"getPathDirection\",\n    value: function getPathDirection(prev, next) {\n      if (prev.coordinate.x == next.coordinate.x) {\n        return PathDirection.X;\n      } else if (prev.coordinate.y == next.coordinate.y) {\n        return PathDirection.Y;\n      } else {\n        return PathDirection.Z;\n      }\n    }\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(start, end) {\n      var path = new PathSprite(start.position.x, start.position.y, end.position.x, end.position.y);\n      this.addChild(path);\n      this._segments.push(path);\n    }\n\n    /**\n     * @param {number} progress A number from 0 to 1 to represent the progress.\n     */\n  }, {\n    key: \"getPathPosition\",\n    value: function getPathPosition(progress) {\n      var totalDistance = this._segments.reduce(function (partialSum, seg) {\n        return partialSum + seg.distance;\n      }, 0);\n      var distanceReached = 0;\n      for (var i = 0; i < this._segments.length; i++) {\n        var segment = this._segments[i];\n        if (distanceReached + segment.distance > totalDistance * progress) {\n          // partial segment\n          var segmentProgress = totalDistance * progress - distanceReached;\n          var segmentPercentage = segmentProgress / segment.distance;\n          return {\n            position: segment.pointAt(segmentPercentage),\n            angle: segment.angle\n          };\n        }\n        // completed segment\n        distanceReached += segment.distance;\n      }\n      return {\n        position: new Point(0, 0),\n        angle: 0\n      };\n    }\n  }]);\n  return MapPathContainer;\n}(Container);\nexport { MapPathContainer as default };","map":{"version":3,"names":["Container","MIPMAP_MODES","Point","Sprite","Texture","PathSprite","TextLabel","Constants","Maths","TargetTexture","timeLeftToShortString","SpaceshipIcon","PathDirection","MapPathContainer","tiles","travel","_segments","_spaceship","_time","timer","pathLength","length","drawNextSegment","destination","first","texture","from","baseTexture","mipmap","POW2","target","anchor","x","y","width","height","addChild","spaceship","progress","getTimeProgress","start","end","alignOnPath","getPathPosition","setInterval","updateSpaceshipPosition","timeLeft","PATH_TIME","timeLeftText","setText","zIndex","clearInterval","destroy","Date","now","console","log","pop","prev","next","direction","getPathDirection","newDirection","drawPath","push","coordinate","X","Y","Z","path","position","totalDistance","reduce","partialSum","seg","distance","distanceReached","i","segment","segmentProgress","segmentPercentage","pointAt","angle"],"sources":["/Users/merlea/Development/Crypto/Krogan/kroganverse-com/packages/client/src/sprites/map/MapPathContainer.ts"],"sourcesContent":["import { Container, MIPMAP_MODES, Point, Sprite, Texture } from 'pixi.js';\nimport PathSprite from './PathSprite';\nimport { TextLabel, TileContainer } from '..';\nimport { Travel } from 'state/Travel';\nimport { Constants, Maths } from '@krogan/common';\nimport { TargetTexture } from 'images/textures';\nimport timeLeftToShortString from 'utils/time';\nimport SpaceshipIcon from './SpaceshipIcon';\n\nenum PathDirection {\n\tX,\n\tY,\n\tZ\n}\n\nexport interface PathPosition {\n\tposition: Point,\n\tangle: number\n}\n\nexport default class MapPathContainer extends Container {\n\n\tprivate _segments: PathSprite[] = []\n\tprivate _spaceship: SpaceshipIcon\n\tprivate _time: TextLabel\n\n\tprivate timer?: NodeJS.Timer\n\n    constructor(tiles: TileContainer[], travel?: Travel) {\n        super();\n\t\tconst pathLength = tiles.length\n\t\tthis.drawNextSegment(tiles)\n\t\t\n\t\tconst destination = tiles.first()\n\n\t\tconst texture = Texture.from(TargetTexture)\n\t\ttexture.baseTexture.mipmap = MIPMAP_MODES.POW2;\n\n        const target = new Sprite(texture)\n\t\ttarget.anchor.x = 0.5\n\t\ttarget.anchor.y = 0.5\n\t\ttarget.width = 20\n\t\ttarget.height = 18\n\t\ttarget.x = destination.x\n\t\ttarget.y = destination.y\n\t\tthis.addChild(target)\n\t\t\n\t\tthis._time = new TextLabel('Warp', 8)\n\t\tthis._time.x = destination.x + 9\n\t\tthis._time.y = destination.y - 18\n\t\tthis.addChild(this._time)\n\n\t\tconst spaceship = new SpaceshipIcon(-100, -100)\n\t\tthis.addChild(spaceship)\n\t\tthis._spaceship = spaceship\n\n\t\tif (travel) {\n\t\t\tconst progress = Maths.getTimeProgress(travel.start, travel.end)\n\t\t\tspaceship.alignOnPath(this.getPathPosition(progress))\n\n\t\t\tthis.timer = setInterval(() => {\n                this.updateSpaceshipPosition(travel)\n            }, 1000)\n\t\t} else {\n\t\t\tspaceship.alignOnPath(this.getPathPosition(0))\n\t\t\tconst timeLeft = Constants.PATH_TIME(pathLength)\n\t\t\tconst timeLeftText = timeLeftToShortString(timeLeft/1000)\n\t\t\tthis._time.setText(timeLeftText)\n\t\t}\n\n\t\tthis.zIndex = 100 // 0-99 it's the tile \n\t\t// TODO: change this to enum of layers\n    }\n\n\tdestroy() {\n\t\tif (this.timer) clearInterval(this.timer)\n\t\tsuper.destroy()\n\t}\n\n\tupdateSpaceshipPosition(travel: Travel) {\n\t\tconst progress = Maths.getTimeProgress(travel.start, travel.end)\n\t\tif (progress == 1) this.destroy()\n\n\t\tthis._spaceship.alignOnPath(this.getPathPosition(progress))\n\n\t\tconst timeLeft = (travel.end - Date.now())/1000\n\t\tconsole.log(`[Travel][Update] Time left: ${timeLeft}`)\n\t\tconst timeLeftText = timeLeftToShortString(timeLeft)\n\t\tthis._time.setText(timeLeftText)\n\t}\n\n\tdrawNextSegment(tiles: TileContainer[]) {\n\t\tif (tiles.length < 2) return\n\n\t\tconst start = tiles.pop()\n\t\tlet prev = start\n\t\tlet next = tiles.pop()\n\t\t\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tconst direction = this.getPathDirection(prev!, next!)\n\t\tlet newDirection = direction\n\t\t\n\t\tdo {\n\t\t\tprev = next\n\t\t\tnext = tiles.pop()\n\t\t\tif (!next) break\n\t\t\tnewDirection = this.getPathDirection(prev!, next)\n\t\t} while(direction == newDirection)\n\n\t\tif (start && prev) {\n\t\t\tthis.drawPath(start, prev)\n\t\t\tif (next) tiles.push(next)\n\t\t\ttiles.push(prev)\n\t\t}\n\n\t\tthis.drawNextSegment(tiles)\n\t}\n\n\tgetPathDirection(prev: TileContainer, next: TileContainer): PathDirection {\n\t\tif (prev.coordinate.x == next.coordinate.x) {\n\t\t\treturn PathDirection.X\n\t\t} else if (prev.coordinate.y == next.coordinate.y) {\n\t\t\treturn PathDirection.Y\n\t\t} else {\n\t\t\treturn PathDirection.Z\n\t\t}\n\t}\n\n\tdrawPath(start: TileContainer, end: TileContainer) {\n\t\tconst path = new PathSprite(\n\t\t\tstart.position.x, start.position.y, \n\t\t\tend.position.x, end.position.y\n\t\t)\n\t\tthis.addChild(path)\n\t\tthis._segments.push(path)\n\t}\n\n\t/**\n\t * @param {number} progress A number from 0 to 1 to represent the progress.\n\t */\n\tgetPathPosition(progress: number): PathPosition {\n\t\tconst totalDistance =  this._segments.reduce((partialSum, seg) => partialSum + seg.distance, 0)\n\t\t\n\t\tlet distanceReached = 0\n\t\tfor (let i = 0; i < this._segments.length; i++) {\n\t\t\tconst segment = this._segments[i];\n\t\t\t\n\t\t\tif (distanceReached + segment.distance > totalDistance * progress) {\n\t\t\t\t// partial segment\n\t\t\t\tconst segmentProgress = totalDistance * progress - distanceReached\n\t\t\t\tconst segmentPercentage = segmentProgress / segment.distance\n\t\t\t\treturn {\n\t\t\t\t\tposition: segment.pointAt(segmentPercentage),\n\t\t\t\t\tangle: segment.angle\n\t\t\t\t}\n\t\t\t}\n\t\t\t// completed segment\n\t\t\tdistanceReached += segment.distance\n\t\t}\n\n\t\treturn {\n\t\t\tposition: new Point(0, 0),\n\t\t\tangle: 0\n\t\t}\n\t}\n\n}\n"],"mappings":";;;;;;AAAA,SAASA,SAAS,EAAEC,YAAY,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,QAAQ,SAAS;AACzE,OAAOC,UAAU,MAAM,cAAc;AACrC,SAASC,SAAS,QAAuB,IAAI;AAE7C,SAASC,SAAS,EAAEC,KAAK,QAAQ,gBAAgB;AACjD,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,OAAOC,qBAAqB,MAAM,YAAY;AAC9C,OAAOC,aAAa,MAAM,iBAAiB;AAAC,IAEvCC,aAAa;AAAA,WAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;AAAA,GAAbA,aAAa,KAAbA,aAAa;AAAA,IAWGC,gBAAgB;EAAA;EAAA;EAQjC,0BAAYC,KAAsB,EAAEC,MAAe,EAAE;IAAA;IAAA;IACjD;IAAQ,MAPPC,SAAS,GAAiB,EAAE;IAAA,MAC5BC,UAAU;IAAA,MACVC,KAAK;IAAA,MAELC,KAAK;IAIZ,IAAMC,UAAU,GAAGN,KAAK,CAACO,MAAM;IAC/B,MAAKC,eAAe,CAACR,KAAK,CAAC;IAE3B,IAAMS,WAAW,GAAGT,KAAK,CAACU,KAAK,EAAE;IAEjC,IAAMC,OAAO,GAAGrB,OAAO,CAACsB,IAAI,CAACjB,aAAa,CAAC;IAC3CgB,OAAO,CAACE,WAAW,CAACC,MAAM,GAAG3B,YAAY,CAAC4B,IAAI;IAExC,IAAMC,MAAM,GAAG,IAAI3B,MAAM,CAACsB,OAAO,CAAC;IACxCK,MAAM,CAACC,MAAM,CAACC,CAAC,GAAG,GAAG;IACrBF,MAAM,CAACC,MAAM,CAACE,CAAC,GAAG,GAAG;IACrBH,MAAM,CAACI,KAAK,GAAG,EAAE;IACjBJ,MAAM,CAACK,MAAM,GAAG,EAAE;IAClBL,MAAM,CAACE,CAAC,GAAGT,WAAW,CAACS,CAAC;IACxBF,MAAM,CAACG,CAAC,GAAGV,WAAW,CAACU,CAAC;IACxB,MAAKG,QAAQ,CAACN,MAAM,CAAC;IAErB,MAAKZ,KAAK,GAAG,IAAIZ,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;IACrC,MAAKY,KAAK,CAACc,CAAC,GAAGT,WAAW,CAACS,CAAC,GAAG,CAAC;IAChC,MAAKd,KAAK,CAACe,CAAC,GAAGV,WAAW,CAACU,CAAC,GAAG,EAAE;IACjC,MAAKG,QAAQ,CAAC,MAAKlB,KAAK,CAAC;IAEzB,IAAMmB,SAAS,GAAG,IAAI1B,aAAa,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;IAC/C,MAAKyB,QAAQ,CAACC,SAAS,CAAC;IACxB,MAAKpB,UAAU,GAAGoB,SAAS;IAE3B,IAAItB,MAAM,EAAE;MACX,IAAMuB,QAAQ,GAAG9B,KAAK,CAAC+B,eAAe,CAACxB,MAAM,CAACyB,KAAK,EAAEzB,MAAM,CAAC0B,GAAG,CAAC;MAChEJ,SAAS,CAACK,WAAW,CAAC,MAAKC,eAAe,CAACL,QAAQ,CAAC,CAAC;MAErD,MAAKnB,KAAK,GAAGyB,WAAW,CAAC,YAAM;QAClB,MAAKC,uBAAuB,CAAC9B,MAAM,CAAC;MACxC,CAAC,EAAE,IAAI,CAAC;IAClB,CAAC,MAAM;MACNsB,SAAS,CAACK,WAAW,CAAC,MAAKC,eAAe,CAAC,CAAC,CAAC,CAAC;MAC9C,IAAMG,QAAQ,GAAGvC,SAAS,CAACwC,SAAS,CAAC3B,UAAU,CAAC;MAChD,IAAM4B,YAAY,GAAGtC,qBAAqB,CAACoC,QAAQ,GAAC,IAAI,CAAC;MACzD,MAAK5B,KAAK,CAAC+B,OAAO,CAACD,YAAY,CAAC;IACjC;IAEA,MAAKE,MAAM,GAAG,GAAG,EAAC;IAClB;IAAA;EACE;EAAC;IAAA;IAAA,OAEJ,mBAAU;MACT,IAAI,IAAI,CAAC/B,KAAK,EAAEgC,aAAa,CAAC,IAAI,CAAChC,KAAK,CAAC;MACzC;IACD;EAAC;IAAA;IAAA,OAED,iCAAwBJ,MAAc,EAAE;MACvC,IAAMuB,QAAQ,GAAG9B,KAAK,CAAC+B,eAAe,CAACxB,MAAM,CAACyB,KAAK,EAAEzB,MAAM,CAAC0B,GAAG,CAAC;MAChE,IAAIH,QAAQ,IAAI,CAAC,EAAE,IAAI,CAACc,OAAO,EAAE;MAEjC,IAAI,CAACnC,UAAU,CAACyB,WAAW,CAAC,IAAI,CAACC,eAAe,CAACL,QAAQ,CAAC,CAAC;MAE3D,IAAMQ,QAAQ,GAAG,CAAC/B,MAAM,CAAC0B,GAAG,GAAGY,IAAI,CAACC,GAAG,EAAE,IAAE,IAAI;MAC/CC,OAAO,CAACC,GAAG,uCAAgCV,QAAQ,EAAG;MACtD,IAAME,YAAY,GAAGtC,qBAAqB,CAACoC,QAAQ,CAAC;MACpD,IAAI,CAAC5B,KAAK,CAAC+B,OAAO,CAACD,YAAY,CAAC;IACjC;EAAC;IAAA;IAAA,OAED,yBAAgBlC,KAAsB,EAAE;MACvC,IAAIA,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE;MAEtB,IAAMmB,KAAK,GAAG1B,KAAK,CAAC2C,GAAG,EAAE;MACzB,IAAIC,IAAI,GAAGlB,KAAK;MAChB,IAAImB,IAAI,GAAG7C,KAAK,CAAC2C,GAAG,EAAE;;MAEtB;MACA,IAAMG,SAAS,GAAG,IAAI,CAACC,gBAAgB,CAACH,IAAI,EAAGC,IAAI,CAAE;MACrD,IAAIG,YAAY,GAAGF,SAAS;MAE5B,GAAG;QACFF,IAAI,GAAGC,IAAI;QACXA,IAAI,GAAG7C,KAAK,CAAC2C,GAAG,EAAE;QAClB,IAAI,CAACE,IAAI,EAAE;QACXG,YAAY,GAAG,IAAI,CAACD,gBAAgB,CAACH,IAAI,EAAGC,IAAI,CAAC;MAClD,CAAC,QAAOC,SAAS,IAAIE,YAAY;MAEjC,IAAItB,KAAK,IAAIkB,IAAI,EAAE;QAClB,IAAI,CAACK,QAAQ,CAACvB,KAAK,EAAEkB,IAAI,CAAC;QAC1B,IAAIC,IAAI,EAAE7C,KAAK,CAACkD,IAAI,CAACL,IAAI,CAAC;QAC1B7C,KAAK,CAACkD,IAAI,CAACN,IAAI,CAAC;MACjB;MAEA,IAAI,CAACpC,eAAe,CAACR,KAAK,CAAC;IAC5B;EAAC;IAAA;IAAA,OAED,0BAAiB4C,IAAmB,EAAEC,IAAmB,EAAiB;MACzE,IAAID,IAAI,CAACO,UAAU,CAACjC,CAAC,IAAI2B,IAAI,CAACM,UAAU,CAACjC,CAAC,EAAE;QAC3C,OAAOpB,aAAa,CAACsD,CAAC;MACvB,CAAC,MAAM,IAAIR,IAAI,CAACO,UAAU,CAAChC,CAAC,IAAI0B,IAAI,CAACM,UAAU,CAAChC,CAAC,EAAE;QAClD,OAAOrB,aAAa,CAACuD,CAAC;MACvB,CAAC,MAAM;QACN,OAAOvD,aAAa,CAACwD,CAAC;MACvB;IACD;EAAC;IAAA;IAAA,OAED,kBAAS5B,KAAoB,EAAEC,GAAkB,EAAE;MAClD,IAAM4B,IAAI,GAAG,IAAIhE,UAAU,CAC1BmC,KAAK,CAAC8B,QAAQ,CAACtC,CAAC,EAAEQ,KAAK,CAAC8B,QAAQ,CAACrC,CAAC,EAClCQ,GAAG,CAAC6B,QAAQ,CAACtC,CAAC,EAAES,GAAG,CAAC6B,QAAQ,CAACrC,CAAC,CAC9B;MACD,IAAI,CAACG,QAAQ,CAACiC,IAAI,CAAC;MACnB,IAAI,CAACrD,SAAS,CAACgD,IAAI,CAACK,IAAI,CAAC;IAC1B;;IAEA;AACD;AACA;EAFC;IAAA;IAAA,OAGA,yBAAgB/B,QAAgB,EAAgB;MAC/C,IAAMiC,aAAa,GAAI,IAAI,CAACvD,SAAS,CAACwD,MAAM,CAAC,UAACC,UAAU,EAAEC,GAAG;QAAA,OAAKD,UAAU,GAAGC,GAAG,CAACC,QAAQ;MAAA,GAAE,CAAC,CAAC;MAE/F,IAAIC,eAAe,GAAG,CAAC;MACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC7D,SAAS,CAACK,MAAM,EAAEwD,CAAC,EAAE,EAAE;QAC/C,IAAMC,OAAO,GAAG,IAAI,CAAC9D,SAAS,CAAC6D,CAAC,CAAC;QAEjC,IAAID,eAAe,GAAGE,OAAO,CAACH,QAAQ,GAAGJ,aAAa,GAAGjC,QAAQ,EAAE;UAClE;UACA,IAAMyC,eAAe,GAAGR,aAAa,GAAGjC,QAAQ,GAAGsC,eAAe;UAClE,IAAMI,iBAAiB,GAAGD,eAAe,GAAGD,OAAO,CAACH,QAAQ;UAC5D,OAAO;YACNL,QAAQ,EAAEQ,OAAO,CAACG,OAAO,CAACD,iBAAiB,CAAC;YAC5CE,KAAK,EAAEJ,OAAO,CAACI;UAChB,CAAC;QACF;QACA;QACAN,eAAe,IAAIE,OAAO,CAACH,QAAQ;MACpC;MAEA,OAAO;QACNL,QAAQ,EAAE,IAAIpE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;QACzBgF,KAAK,EAAE;MACR,CAAC;IACF;EAAC;EAAA;AAAA,EAhJ4ClF,SAAS;AAAA,SAAlCa,gBAAgB"},"metadata":{},"sourceType":"module"}