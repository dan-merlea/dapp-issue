{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BLEND_MODES } from '@pixi/constants';\nvar BLEND = 0;\nvar OFFSET = 1;\nvar CULLING = 2;\nvar DEPTH_TEST = 3;\nvar WINDING = 4;\nvar DEPTH_MASK = 5;\nvar State = /*#__PURE__*/function () {\n  function State() {\n    _classCallCheck(this, State);\n    this.data = 0;\n    this.blendMode = BLEND_MODES.NORMAL;\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  _createClass(State, [{\n    key: \"blend\",\n    get: function get() {\n      return !!(this.data & 1 << BLEND);\n    },\n    set: function set(value) {\n      if (!!(this.data & 1 << BLEND) !== value) {\n        this.data ^= 1 << BLEND;\n      }\n    }\n  }, {\n    key: \"offsets\",\n    get: function get() {\n      return !!(this.data & 1 << OFFSET);\n    },\n    set: function set(value) {\n      if (!!(this.data & 1 << OFFSET) !== value) {\n        this.data ^= 1 << OFFSET;\n      }\n    }\n  }, {\n    key: \"culling\",\n    get: function get() {\n      return !!(this.data & 1 << CULLING);\n    },\n    set: function set(value) {\n      if (!!(this.data & 1 << CULLING) !== value) {\n        this.data ^= 1 << CULLING;\n      }\n    }\n  }, {\n    key: \"depthTest\",\n    get: function get() {\n      return !!(this.data & 1 << DEPTH_TEST);\n    },\n    set: function set(value) {\n      if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n        this.data ^= 1 << DEPTH_TEST;\n      }\n    }\n  }, {\n    key: \"depthMask\",\n    get: function get() {\n      return !!(this.data & 1 << DEPTH_MASK);\n    },\n    set: function set(value) {\n      if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n        this.data ^= 1 << DEPTH_MASK;\n      }\n    }\n  }, {\n    key: \"clockwiseFrontFace\",\n    get: function get() {\n      return !!(this.data & 1 << WINDING);\n    },\n    set: function set(value) {\n      if (!!(this.data & 1 << WINDING) !== value) {\n        this.data ^= 1 << WINDING;\n      }\n    }\n  }, {\n    key: \"blendMode\",\n    get: function get() {\n      return this._blendMode;\n    },\n    set: function set(value) {\n      this.blend = value !== BLEND_MODES.NONE;\n      this._blendMode = value;\n    }\n  }, {\n    key: \"polygonOffset\",\n    get: function get() {\n      return this._polygonOffset;\n    },\n    set: function set(value) {\n      this.offsets = !!value;\n      this._polygonOffset = value;\n    }\n  }], [{\n    key: \"for2d\",\n    value: function for2d() {\n      var state = new State();\n      state.depthTest = false;\n      state.blend = true;\n      return state;\n    }\n  }]);\n  return State;\n}();\nexport { State };","map":{"version":3,"sources":["../../src/state/State.ts"],"names":[],"mappings":"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","sourcesContent":["import { BLEND_MODES } from '@pixi/constants';\n\n/* eslint-disable max-len */\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link PIXI.StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof PIXI\n */\nexport class State\n{\n    data: number;\n    _blendMode: BLEND_MODES;\n    _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = BLEND_MODES.NORMAL;\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n        //  this.depthTest = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== BLEND_MODES.NONE);\n        this._blendMode = value;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    toString(): string\n    {\n        return `[@pixi/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}