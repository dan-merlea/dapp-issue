{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BaseRenderTexture } from './BaseRenderTexture.mjs';\nimport { Texture } from '../textures/Texture.mjs';\nvar RenderTexture = /*#__PURE__*/function (_Texture) {\n  _inherits(RenderTexture, _Texture);\n  var _super = _createSuper(RenderTexture);\n  function RenderTexture(baseRenderTexture, frame) {\n    var _this;\n    _classCallCheck(this, RenderTexture);\n    _this = _super.call(this, baseRenderTexture, frame);\n    _this.valid = true;\n    _this.filterFrame = null;\n    _this.filterPoolKey = null;\n    _this.updateUvs();\n    return _this;\n  }\n  _createClass(RenderTexture, [{\n    key: \"framebuffer\",\n    get: function get() {\n      return this.baseTexture.framebuffer;\n    }\n  }, {\n    key: \"multisample\",\n    get: function get() {\n      return this.framebuffer.multisample;\n    },\n    set: function set(value) {\n      this.framebuffer.multisample = value;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(desiredWidth, desiredHeight) {\n      var resizeBaseTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var resolution = this.baseTexture.resolution;\n      var width = Math.round(desiredWidth * resolution) / resolution;\n      var height = Math.round(desiredHeight * resolution) / resolution;\n      this.valid = width > 0 && height > 0;\n      this._frame.width = this.orig.width = width;\n      this._frame.height = this.orig.height = height;\n      if (resizeBaseTexture) {\n        this.baseTexture.resize(width, height);\n      }\n      this.updateUvs();\n    }\n  }, {\n    key: \"setResolution\",\n    value: function setResolution(resolution) {\n      var baseTexture = this.baseTexture;\n      if (baseTexture.resolution === resolution) {\n        return;\n      }\n      baseTexture.setResolution(resolution);\n      this.resize(baseTexture.width, baseTexture.height, false);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(options) {\n      return new RenderTexture(new BaseRenderTexture(options));\n    }\n  }]);\n  return RenderTexture;\n}(Texture);\nexport { RenderTexture };","map":{"version":3,"sources":["../../src/renderTexture/RenderTexture.ts"],"names":[],"mappings":";;;;;;IA2Ca,aAAA;EAAA;EAAA;EAsBT,uBAAY,iBAAA,EAAsC,KAClD,EAAA;IAAA;IAAA;IACI,0BAAM,iBAAA,EAAmB,KAAK;IAE9B,MAAK,KAAQ,GAAA,IAAA;IAEb,MAAK,WAAc,GAAA,IAAA;IACnB,MAAK,aAAgB,GAAA,IAAA;IAErB,MAAK,SAAU,EAAA;IAAA;EAAA;EACnB;IAAA;IAAA,KAMA,eACA;MACI,OAAO,IAAA,CAAK,WAAY,CAAA,WAAA;IAAA;EAC5B;IAAA;IAAA,KAMA,eACA;MACI,OAAO,IAAA,CAAK,WAAY,CAAA,WAAA;IAAA,CAC5B;IAAA,KAEA,aAAgB,KAChB,EAAA;MACI,IAAA,CAAK,WAAA,CAAY,WAAc,GAAA,KAAA;IAAA;EACnC;IAAA;IAAA,OAQA,gBAAO,YAAA,EAAsB,aAAuB,EACpD;MAAA,IADoD,iBAAA,uEAAoB,IACxE;MACU,IAAA,UAAA,GAAa,IAAA,CAAK,WAAY,CAAA,UAAA;MACpC,IAAM,KAAQ,GAAA,IAAA,CAAK,KAAM,CAAA,YAAA,GAAe,UAAU,CAAI,GAAA,UAAA;MACtD,IAAM,MAAS,GAAA,IAAA,CAAK,KAAM,CAAA,aAAA,GAAgB,UAAU,CAAI,GAAA,UAAA;MAGnD,IAAA,CAAA,KAAA,GAAS,KAAQ,GAAA,CAAA,IAAK,MAAS,GAAA,CAAA;MAEpC,IAAA,CAAK,MAAO,CAAA,KAAA,GAAQ,IAAK,CAAA,IAAA,CAAK,KAAQ,GAAA,KAAA;MACtC,IAAA,CAAK,MAAO,CAAA,MAAA,GAAS,IAAK,CAAA,IAAA,CAAK,MAAS,GAAA,MAAA;MAExC,IAAI,iBACJ,EAAA;QACS,IAAA,CAAA,WAAA,CAAY,MAAO,CAAA,KAAA,EAAO,MAAM,CAAA;MAAA;MAGzC,IAAA,CAAK,SAAU,EAAA;IAAA;EACnB;IAAA;IAAA,OAMA,uBAAc,UACd,EAAA;MACI,IAAQ,WAAgB,GAAA,IAAA,CAAhB,WAAgB;MAEpB,IAAA,WAAA,CAAY,UAAA,KAAe,UAC/B,EAAA;QACI;MAAA;MAGJ,WAAA,CAAY,aAAA,CAAc,UAAU,CAAA;MACpC,IAAA,CAAK,MAAO,CAAA,WAAA,CAAY,KAAO,EAAA,WAAA,CAAY,MAAA,EAAQ,KAAK,CAAA;IAAA;EAC5D;IAAA;IAAA,OAcA,gBAAc,OACd,EAAA;MACI,OAAO,IAAI,aAAA,CAAc,IAAI,iBAAA,CAAkB,OAAO,CAAC,CAAA;IAAA;EAC3D;EAAA;AAAA,EAnH+B,OACnC","sourcesContent":["import { BaseRenderTexture } from './BaseRenderTexture';\nimport { Texture } from '../textures/Texture';\n\nimport type { Rectangle } from '@pixi/math';\nimport type { Framebuffer } from '../framebuffer/Framebuffer';\nimport type { IBaseTextureOptions } from '../textures/BaseTexture';\nimport type { MSAA_QUALITY } from '@pixi/constants';\n\n/**\n * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * __Hint-2__: The actual memory allocation will happen on first render.\n * You shouldn't create renderTextures each frame just to delete them after, try to reuse them.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:\n * @example\n * import { autoDetectRenderer, RenderTexture, Sprite } from 'pixi.js';\n *\n * const renderer = autoDetectRenderer();\n * const renderTexture = RenderTexture.create({ width: 800, height: 600 });\n * const sprite = Sprite.from('spinObj_01.png');\n *\n * sprite.position.x = 800 / 2;\n * sprite.position.y = 600 / 2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, { renderTexture });\n *\n * // Note that you should not create a new renderer, but reuse the same one as the rest of the application.\n * // The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * // you can clear the transform\n *\n * sprite.setTransform();\n *\n * const renderTexture = new RenderTexture.create({ width: 100, height: 100 });\n *\n * renderer.render(sprite, { renderTexture });  // Renders to center of RenderTexture\n * @memberof PIXI\n */\nexport class RenderTexture extends Texture\n{\n    public baseTexture: BaseRenderTexture;\n\n    /**\n     * Stores `sourceFrame` when this texture is inside current filter stack.\n     *\n     * You can read it inside filters.\n     * @readonly\n     */\n    public filterFrame: Rectangle | null;\n\n    /**\n     * The key for pooled texture of FilterSystem.\n     * @see PIXI.RenderTexturePool\n     */\n    public filterPoolKey: string | number | null;\n\n    /**\n     * @param baseRenderTexture - The base texture object that this texture uses.\n     * @param frame - The rectangle frame of the texture to show.\n     */\n    constructor(baseRenderTexture: BaseRenderTexture, frame?: Rectangle)\n    {\n        super(baseRenderTexture, frame);\n\n        this.valid = true;\n\n        this.filterFrame = null;\n        this.filterPoolKey = null;\n\n        this.updateUvs();\n    }\n\n    /**\n     * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.\n     * @readonly\n     */\n    get framebuffer(): Framebuffer\n    {\n        return this.baseTexture.framebuffer;\n    }\n\n    /**\n     * Shortcut to `this.framebuffer.multisample`.\n     * @default PIXI.MSAA_QUALITY.NONE\n     */\n    get multisample(): MSAA_QUALITY\n    {\n        return this.framebuffer.multisample;\n    }\n\n    set multisample(value: MSAA_QUALITY)\n    {\n        this.framebuffer.multisample = value;\n    }\n\n    /**\n     * Resizes the RenderTexture.\n     * @param desiredWidth - The desired width to resize to.\n     * @param desiredHeight - The desired height to resize to.\n     * @param resizeBaseTexture - Should the baseTexture.width and height values be resized as well?\n     */\n    resize(desiredWidth: number, desiredHeight: number, resizeBaseTexture = true): void\n    {\n        const resolution = this.baseTexture.resolution;\n        const width = Math.round(desiredWidth * resolution) / resolution;\n        const height = Math.round(desiredHeight * resolution) / resolution;\n\n        // TODO - could be not required..\n        this.valid = (width > 0 && height > 0);\n\n        this._frame.width = this.orig.width = width;\n        this._frame.height = this.orig.height = height;\n\n        if (resizeBaseTexture)\n        {\n            this.baseTexture.resize(width, height);\n        }\n\n        this.updateUvs();\n    }\n\n    /**\n     * Changes the resolution of baseTexture, but does not change framebuffer size.\n     * @param resolution - The new resolution to apply to RenderTexture\n     */\n    setResolution(resolution: number): void\n    {\n        const { baseTexture } = this;\n\n        if (baseTexture.resolution === resolution)\n        {\n            return;\n        }\n\n        baseTexture.setResolution(resolution);\n        this.resize(baseTexture.width, baseTexture.height, false);\n    }\n\n    /**\n     * A short hand way of creating a render texture.\n     * @param options - Options\n     * @param {number} [options.width=100] - The width of the render texture\n     * @param {number} [options.height=100] - The height of the render texture\n     * @param {PIXI.SCALE_MODES} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES}\n     *    for possible values\n     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the texture\n     *    being generated\n     * @param {PIXI.MSAA_QUALITY} [options.multisample=PIXI.MSAA_QUALITY.NONE] - The number of samples of the frame buffer\n     * @returns The new render texture\n     */\n    static create(options?: IBaseTextureOptions): RenderTexture\n    {\n        return new RenderTexture(new BaseRenderTexture(options));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}