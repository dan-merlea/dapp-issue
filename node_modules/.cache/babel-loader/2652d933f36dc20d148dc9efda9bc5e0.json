{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\nvar primitives_1 = require(\"./primitives\");\nvar WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\n * Algorithm for detecting transaction completion.\n * Based on some heuristics (a bit imprecise therefore, at this moment).\n */\nvar TransactionCompletionStrategyOnProxy = /*#__PURE__*/function () {\n  function TransactionCompletionStrategyOnProxy() {\n    _classCallCheck(this, TransactionCompletionStrategyOnProxy);\n  }\n  _createClass(TransactionCompletionStrategyOnProxy, [{\n    key: \"isCompleted\",\n    value: function isCompleted(transaction) {\n      if (transaction.status.isPending()) {\n        // Certainly not completed.\n        return false;\n      }\n      // Handle gateway mechanics:\n      var _iterator = _createForOfIteratorHelper(WellKnownCompletionEvents),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var completionEvent = _step.value;\n          if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n            // Certainly completed.\n            console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (this.isCertainlyMoveBalance(transaction.data)) {\n        return transaction.status.isExecuted();\n      }\n      var hyperblockNonce = transaction.hyperblockNonce;\n      // Imprecise condition, uncertain completion (usually sufficient, though).\n      // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n      if (hyperblockNonce > 0) {\n        console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"isCertainlyMoveBalance\",\n    value: function isCertainlyMoveBalance(transactionData) {\n      var _this = this;\n      var parts = transactionData.toString().split(\"@\");\n      var prefix = parts[0];\n      var otherParts = parts.slice(1);\n      var emptyPrefix = !prefix;\n      var somePartsAreNotValidArguments = !otherParts.every(function (part) {\n        return _this.looksLikeValidArgument(part);\n      });\n      return emptyPrefix || somePartsAreNotValidArguments;\n    }\n  }, {\n    key: \"looksLikeValidArgument\",\n    value: function looksLikeValidArgument(arg) {\n      return primitives_1.isPaddedHex(arg);\n    }\n  }]);\n  return TransactionCompletionStrategyOnProxy;\n}();\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\nvar TransactionCompletionStrategyOnAPI = /*#__PURE__*/function () {\n  function TransactionCompletionStrategyOnAPI() {\n    _classCallCheck(this, TransactionCompletionStrategyOnAPI);\n  }\n  _createClass(TransactionCompletionStrategyOnAPI, [{\n    key: \"isCompleted\",\n    value: function isCompleted(transaction) {\n      return !transaction.status.isPending();\n    }\n  }]);\n  return TransactionCompletionStrategyOnAPI;\n}();\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;","map":{"version":3,"mappings":";;;;;;;;;AAEA;AASA,IAAMA,yBAAyB,GAAG,CAAC,kBAAkB,EAAE,UAAU,EAAE,aAAa,CAAC;AAEjF;;;;AAAA,IAIaC,oCAAoC;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OAC7C,qBAAYC,WAAkC;MAC1C,IAAIA,WAAW,CAACC,MAAM,CAACC,SAAS,EAAE,EAAE;QAChC;QACA,OAAO,KAAK;;MAGhB;MAAA,2CAC8BJ,yBAAyB;QAAA;MAAA;QAAvD,oDAAyD;UAAA,IAA9CK,eAAe;UACtB,IAAIH,WAAW,CAACI,IAAI,CAACC,oBAAoB,CAACF,eAAe,CAAC,EAAE;YACxD;YACAG,OAAO,CAACC,KAAK,CAAC,2DAA2D,EAAEJ,eAAe,CAAC;YAC3F,OAAO,IAAI;;;MAElB;QAAA;MAAA;QAAA;MAAA;MAED,IAAI,IAAI,CAACK,sBAAsB,CAACR,WAAW,CAACS,IAAI,CAAC,EAAE;QAC/C,OAAOT,WAAW,CAACC,MAAM,CAACS,UAAU,EAAE;;MAG1C,IAAIC,eAAe,GAAGX,WAAW,CAACW,eAAe;MAEjD;MACA;MACA,IAAIA,eAAe,GAAG,CAAC,EAAE;QACrBL,OAAO,CAACC,KAAK,CAAC,sEAAsE,EAAEI,eAAe,CAAC;QACtG,OAAO,IAAI;;MAGf,OAAO,KAAK;IAChB;EAAC;IAAA;IAAA,OAEO,gCAAuBC,eAAuB;MAAA;MAClD,IAAIC,KAAK,GAAGD,eAAe,CAACE,QAAQ,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;MACjD,IAAIC,MAAM,GAAGH,KAAK,CAAC,CAAC,CAAC;MACrB,IAAII,UAAU,GAAGJ,KAAK,CAACK,KAAK,CAAC,CAAC,CAAC;MAC/B,IAAIC,WAAW,GAAG,CAACH,MAAM;MACzB,IAAII,6BAA6B,GAAG,CAACH,UAAU,CAACI,KAAK,CAAC,cAAI;QAAA,OAAI,KAAI,CAACC,sBAAsB,CAACC,IAAI,CAAC;MAAA,EAAC;MAEhG,OAAOJ,WAAW,IAAIC,6BAA6B;IACvD;EAAC;IAAA;IAAA,OAEO,gCAAuBI,GAAW;MACtC,OAAOC,wBAAW,CAACD,GAAG,CAAC;IAC3B;EAAC;EAAA;AAAA;AA5CLE;AA6CC,IAEYC,kCAAkC;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA,OAC3C,qBAAY3B,WAAkC;MAC1C,OAAO,CAACA,WAAW,CAACC,MAAM,CAACC,SAAS,EAAE;IAC1C;EAAC;EAAA;AAAA;AAHLwB","names":["WellKnownCompletionEvents","TransactionCompletionStrategyOnProxy","transaction","status","isPending","completionEvent","logs","findFirstOrNoneEvent","console","debug","isCertainlyMoveBalance","data","isExecuted","hyperblockNonce","transactionData","parts","toString","split","prefix","otherParts","slice","emptyPrefix","somePartsAreNotValidArguments","every","looksLikeValidArgument","part","arg","primitives_1","exports","TransactionCompletionStrategyOnAPI"],"sourceRoot":"","sources":["../src/transactionCompletionStrategy.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}