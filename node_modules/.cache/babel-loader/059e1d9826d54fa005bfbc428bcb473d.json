{"ast":null,"code":"import { BLEND_MODES } from '@pixi/constants';\nfunction mapPremultipliedBlendModes() {\n  var pm = [];\n  var npm = [];\n  for (var i = 0; i < 32; i++) {\n    pm[i] = i;\n    npm[i] = i;\n  }\n  pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;\n  pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;\n  pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;\n  npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;\n  npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;\n  npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n  var array = [];\n  array.push(npm);\n  array.push(pm);\n  return array;\n}\nvar premultiplyBlendMode = mapPremultipliedBlendModes();\nfunction correctBlendMode(blendMode, premultiplied) {\n  return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\nfunction premultiplyRgba(rgb, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  if (premultiply || premultiply === void 0) {\n    out[0] = rgb[0] * alpha;\n    out[1] = rgb[1] * alpha;\n    out[2] = rgb[2] * alpha;\n  } else {\n    out[0] = rgb[0];\n    out[1] = rgb[1];\n    out[2] = rgb[2];\n  }\n  out[3] = alpha;\n  return out;\n}\nfunction premultiplyTint(tint, alpha) {\n  if (alpha === 1) {\n    return (alpha * 255 << 24) + tint;\n  }\n  if (alpha === 0) {\n    return 0;\n  }\n  var R = tint >> 16 & 255;\n  var G = tint >> 8 & 255;\n  var B = tint & 255;\n  R = R * alpha + 0.5 | 0;\n  G = G * alpha + 0.5 | 0;\n  B = B * alpha + 0.5 | 0;\n  return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;\n}\nfunction premultiplyTintToRgba(tint, alpha, out, premultiply) {\n  out = out || new Float32Array(4);\n  out[0] = (tint >> 16 & 255) / 255;\n  out[1] = (tint >> 8 & 255) / 255;\n  out[2] = (tint & 255) / 255;\n  if (premultiply || premultiply === void 0) {\n    out[0] *= alpha;\n    out[1] *= alpha;\n    out[2] *= alpha;\n  }\n  out[3] = alpha;\n  return out;\n}\nexport { correctBlendMode, premultiplyBlendMode, premultiplyRgba, premultiplyTint, premultiplyTintToRgba };","map":{"version":3,"sources":["../../src/color/premultiply.ts"],"names":[],"mappings":"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","sourcesContent":["import { BLEND_MODES } from '@pixi/constants';\n\n/**\n * Corrects PixiJS blend, takes premultiplied alpha into account\n * @memberof PIXI.utils\n * @function mapPremultipliedBlendModes\n * @private\n * @returns {Array<number[]>} Mapped modes.\n */\nfunction mapPremultipliedBlendModes(): number[][]\n{\n    const pm = [];\n    const npm = [];\n\n    for (let i = 0; i < 32; i++)\n    {\n        pm[i] = i;\n        npm[i] = i;\n    }\n\n    pm[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL;\n    pm[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD;\n    pm[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN;\n\n    npm[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM;\n    npm[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM;\n    npm[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;\n\n    const array: number[][] = [];\n\n    array.push(npm);\n    array.push(pm);\n\n    return array;\n}\n\n/**\n * maps premultiply flag and blendMode to adjusted blendMode\n * @memberof PIXI.utils\n * @constant premultiplyBlendMode\n * @type {Array<number[]>}\n */\nexport const premultiplyBlendMode = mapPremultipliedBlendModes();\n\n/**\n * changes blendMode according to texture format\n * @memberof PIXI.utils\n * @function correctBlendMode\n * @param {number} blendMode - supposed blend mode\n * @param {boolean} premultiplied - whether source is premultiplied\n * @returns {number} true blend mode for this texture\n */\nexport function correctBlendMode(blendMode: number, premultiplied: boolean): number\n{\n    return premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];\n}\n\n/**\n * combines rgb and alpha to out array\n * @memberof PIXI.utils\n * @function premultiplyRgba\n * @param {Float32Array|number[]} rgb - input rgb\n * @param {number} alpha - alpha param\n * @param {Float32Array} [out] - output\n * @param {boolean} [premultiply=true] - do premultiply it\n * @returns {Float32Array} vec4 rgba\n */\nexport function premultiplyRgba(\n    rgb: Float32Array | number[],\n    alpha: number,\n    out?: Float32Array,\n    premultiply?: boolean\n): Float32Array\n{\n    out = out || new Float32Array(4);\n    if (premultiply || premultiply === undefined)\n    {\n        out[0] = rgb[0] * alpha;\n        out[1] = rgb[1] * alpha;\n        out[2] = rgb[2] * alpha;\n    }\n    else\n    {\n        out[0] = rgb[0];\n        out[1] = rgb[1];\n        out[2] = rgb[2];\n    }\n    out[3] = alpha;\n\n    return out;\n}\n\n/**\n * premultiplies tint\n * @memberof PIXI.utils\n * @function premultiplyTint\n * @param {number} tint - integer RGB\n * @param {number} alpha - floating point alpha (0.0-1.0)\n * @returns {number} tint multiplied by alpha\n */\nexport function premultiplyTint(tint: number, alpha: number): number\n{\n    if (alpha === 1.0)\n    {\n        return (alpha * 255 << 24) + tint;\n    }\n    if (alpha === 0.0)\n    {\n        return 0;\n    }\n    let R = ((tint >> 16) & 0xFF);\n    let G = ((tint >> 8) & 0xFF);\n    let B = (tint & 0xFF);\n\n    R = ((R * alpha) + 0.5) | 0;\n    G = ((G * alpha) + 0.5) | 0;\n    B = ((B * alpha) + 0.5) | 0;\n\n    return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;\n}\n\n/**\n * converts integer tint and float alpha to vec4 form, premultiplies by default\n * @memberof PIXI.utils\n * @function premultiplyTintToRgba\n * @param {number} tint - input tint\n * @param {number} alpha - alpha param\n * @param {Float32Array} [out] - output\n * @param {boolean} [premultiply=true] - do premultiply it\n * @returns {Float32Array} vec4 rgba\n */\nexport function premultiplyTintToRgba(tint: number, alpha: number, out: Float32Array, premultiply?: boolean): Float32Array\n{\n    out = out || new Float32Array(4);\n    out[0] = ((tint >> 16) & 0xFF) / 255.0;\n    out[1] = ((tint >> 8) & 0xFF) / 255.0;\n    out[2] = (tint & 0xFF) / 255.0;\n    if (premultiply || premultiply === undefined)\n    {\n        out[0] *= alpha;\n        out[1] *= alpha;\n        out[2] *= alpha;\n    }\n    out[3] = alpha;\n\n    return out;\n}\n"]},"metadata":{},"sourceType":"module"}