{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SmartContract = void 0;\nvar address_1 = require(\"../address\");\nvar transaction_1 = require(\"../transaction\");\nvar transactionPayload_1 = require(\"../transactionPayload\");\nvar codeMetadata_1 = require(\"./codeMetadata\");\nvar transactionPayloadBuilders_1 = require(\"./transactionPayloadBuilders\");\nvar function_1 = require(\"./function\");\nvar query_1 = require(\"./query\");\nvar utils_1 = require(\"../utils\");\nvar utils_2 = require(\"./codec/utils\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar interaction_1 = require(\"./interaction\");\nvar nativeSerializer_1 = require(\"./nativeSerializer\");\nvar errors_1 = require(\"../errors\");\nvar createKeccakHash = require(\"keccak\");\n/**\n * An abstraction for deploying and interacting with Smart Contracts.\n */\nvar SmartContract = /*#__PURE__*/function () {\n  /**\n   * Create a SmartContract object by providing its address on the Network.\n   */\n  function SmartContract(_ref) {\n    var address = _ref.address,\n      abi = _ref.abi;\n    _classCallCheck(this, SmartContract);\n    this.address = new address_1.Address();\n    /**\n     * This object contains a function for each endpoint defined by the contract.\n     * (a bit similar to web3js's \"contract.methods\").\n     */\n    this.methodsExplicit = {};\n    /**\n     * This object contains a function for each endpoint defined by the contract.\n     * (a bit similar to web3js's \"contract.methods\").\n     *\n     * This is an alternative to {@link methodsExplicit}.\n     * Unlike {@link methodsExplicit}, automatic type inference (wrt. ABI) is applied when using {@link methods}.\n     */\n    this.methods = {};\n    this.address = address || new address_1.Address();\n    this.abi = abi;\n    if (abi) {\n      this.setupMethods();\n    }\n  }\n  _createClass(SmartContract, [{\n    key: \"setupMethods\",\n    value: function setupMethods() {\n      var _this = this;\n      var contract = this;\n      var abi = this.getAbi();\n      var _iterator = _createForOfIteratorHelper(abi.getAllEndpoints()),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var definition = _step.value;\n          var functionName = definition.name;\n          // For each endpoint defined by the ABI, we attach a function to the \"methods\" and \"methodsAuto\" objects,\n          // a function that receives typed values as arguments\n          // and returns a prepared contract interaction.\n          _this.methodsExplicit[functionName] = function (args) {\n            var func = new function_1.ContractFunction(functionName);\n            var interaction = new interaction_1.Interaction(contract, func, args || []);\n            return interaction;\n          };\n          _this.methods[functionName] = function (args) {\n            var func = new function_1.ContractFunction(functionName);\n            // Perform automatic type inference, wrt. the endpoint definition:\n            var typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args || [], definition);\n            var interaction = new interaction_1.Interaction(contract, func, typedArgs || []);\n            return interaction;\n          };\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Sets the address, as on Network.\n     */\n  }, {\n    key: \"setAddress\",\n    value: function setAddress(address) {\n      this.address = address;\n    }\n    /**\n     * Gets the address, as on Network.\n     */\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return this.address;\n    }\n  }, {\n    key: \"setAbi\",\n    value: function setAbi(abi) {\n      this.abi = abi;\n    }\n  }, {\n    key: \"getAbi\",\n    value: function getAbi() {\n      utils_1.guardValueIsSet(\"abi\", this.abi);\n      return this.abi;\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint(name) {\n      return this.getAbi().getEndpoint(name);\n    }\n    /**\n     * Creates a {@link Transaction} for deploying the Smart Contract to the Network.\n     */\n  }, {\n    key: \"deploy\",\n    value: function deploy(_ref2) {\n      var code = _ref2.code,\n        codeMetadata = _ref2.codeMetadata,\n        initArguments = _ref2.initArguments,\n        value = _ref2.value,\n        gasLimit = _ref2.gasLimit,\n        gasPrice = _ref2.gasPrice,\n        chainID = _ref2.chainID;\n      codeMetadata = codeMetadata || new codeMetadata_1.CodeMetadata();\n      initArguments = initArguments || [];\n      value = value || 0;\n      var payload = transactionPayload_1.TransactionPayload.contractDeploy().setCode(code).setCodeMetadata(codeMetadata).setInitArgs(initArguments).build();\n      var transaction = new transaction_1.Transaction({\n        receiver: address_1.Address.Zero(),\n        value: value,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice,\n        data: payload,\n        chainID: chainID\n      });\n      return transaction;\n    }\n    /**\n     * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.\n     */\n  }, {\n    key: \"upgrade\",\n    value: function upgrade(_ref3) {\n      var code = _ref3.code,\n        codeMetadata = _ref3.codeMetadata,\n        initArguments = _ref3.initArguments,\n        value = _ref3.value,\n        gasLimit = _ref3.gasLimit,\n        gasPrice = _ref3.gasPrice,\n        chainID = _ref3.chainID;\n      this.ensureHasAddress();\n      codeMetadata = codeMetadata || new codeMetadata_1.CodeMetadata();\n      initArguments = initArguments || [];\n      value = value || 0;\n      var payload = transactionPayload_1.TransactionPayload.contractUpgrade().setCode(code).setCodeMetadata(codeMetadata).setInitArgs(initArguments).build();\n      var transaction = new transaction_1.Transaction({\n        receiver: this.getAddress(),\n        value: value,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice,\n        data: payload,\n        chainID: chainID\n      });\n      return transaction;\n    }\n    /**\n     * Creates a {@link Transaction} for calling (a function of) the Smart Contract.\n     */\n  }, {\n    key: \"call\",\n    value: function call(_ref4) {\n      var func = _ref4.func,\n        args = _ref4.args,\n        value = _ref4.value,\n        gasLimit = _ref4.gasLimit,\n        receiver = _ref4.receiver,\n        gasPrice = _ref4.gasPrice,\n        chainID = _ref4.chainID;\n      this.ensureHasAddress();\n      args = args || [];\n      value = value || 0;\n      var payload = transactionPayload_1.TransactionPayload.contractCall().setFunction(func).setArgs(args).build();\n      var transaction = new transaction_1.Transaction({\n        receiver: receiver ? receiver : this.getAddress(),\n        value: value,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice,\n        data: payload,\n        chainID: chainID\n      });\n      return transaction;\n    }\n  }, {\n    key: \"createQuery\",\n    value: function createQuery(_ref5) {\n      var func = _ref5.func,\n        args = _ref5.args,\n        value = _ref5.value,\n        caller = _ref5.caller;\n      this.ensureHasAddress();\n      return new query_1.Query({\n        address: this.getAddress(),\n        func: func,\n        args: args,\n        value: value,\n        caller: caller\n      });\n    }\n  }, {\n    key: \"ensureHasAddress\",\n    value: function ensureHasAddress() {\n      if (!this.getAddress().bech32()) {\n        throw new errors_1.ErrContractHasNoAddress();\n      }\n    }\n    /**\n     * Computes the address of a Smart Contract.\n     * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.\n     *\n     * @param owner The owner of the Smart Contract\n     * @param nonce The owner nonce used for the deployment transaction\n     */\n  }], [{\n    key: \"computeAddress\",\n    value: function computeAddress(owner, nonce) {\n      var initialPadding = Buffer.alloc(8, 0);\n      var ownerPubkey = new address_1.Address(owner.bech32()).pubkey();\n      var shardSelector = ownerPubkey.slice(30);\n      var ownerNonceBytes = Buffer.alloc(8);\n      var bigNonce = new bignumber_js_1.default(nonce.valueOf().toString(10));\n      var bigNonceBuffer = utils_2.bigIntToBuffer(bigNonce);\n      ownerNonceBytes.write(bigNonceBuffer.reverse().toString('hex'), 'hex');\n      var bytesToHash = Buffer.concat([ownerPubkey, ownerNonceBytes]);\n      var hash = createKeccakHash(\"keccak256\").update(bytesToHash).digest();\n      var vmTypeBytes = Buffer.from(transactionPayloadBuilders_1.ArwenVirtualMachine, \"hex\");\n      var addressBytes = Buffer.concat([initialPadding, vmTypeBytes, hash.slice(10, 30), shardSelector]);\n      var address = new address_1.Address(addressBytes);\n      return address;\n    }\n  }]);\n  return SmartContract;\n}();\nexports.SmartContract = SmartContract;","map":{"version":3,"sources":["../../src/smartcontracts/smartContract.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SmartContract = void 0;\nconst address_1 = require(\"../address\");\nconst transaction_1 = require(\"../transaction\");\nconst transactionPayload_1 = require(\"../transactionPayload\");\nconst codeMetadata_1 = require(\"./codeMetadata\");\nconst transactionPayloadBuilders_1 = require(\"./transactionPayloadBuilders\");\nconst function_1 = require(\"./function\");\nconst query_1 = require(\"./query\");\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"./codec/utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst interaction_1 = require(\"./interaction\");\nconst nativeSerializer_1 = require(\"./nativeSerializer\");\nconst errors_1 = require(\"../errors\");\nconst createKeccakHash = require(\"keccak\");\n/**\n * An abstraction for deploying and interacting with Smart Contracts.\n */\nclass SmartContract {\n    /**\n     * Create a SmartContract object by providing its address on the Network.\n     */\n    constructor({ address, abi }) {\n        this.address = new address_1.Address();\n        /**\n         * This object contains a function for each endpoint defined by the contract.\n         * (a bit similar to web3js's \"contract.methods\").\n         */\n        this.methodsExplicit = {};\n        /**\n         * This object contains a function for each endpoint defined by the contract.\n         * (a bit similar to web3js's \"contract.methods\").\n         *\n         * This is an alternative to {@link methodsExplicit}.\n         * Unlike {@link methodsExplicit}, automatic type inference (wrt. ABI) is applied when using {@link methods}.\n         */\n        this.methods = {};\n        this.address = address || new address_1.Address();\n        this.abi = abi;\n        if (abi) {\n            this.setupMethods();\n        }\n    }\n    setupMethods() {\n        let contract = this;\n        let abi = this.getAbi();\n        for (const definition of abi.getAllEndpoints()) {\n            let functionName = definition.name;\n            // For each endpoint defined by the ABI, we attach a function to the \"methods\" and \"methodsAuto\" objects,\n            // a function that receives typed values as arguments\n            // and returns a prepared contract interaction.\n            this.methodsExplicit[functionName] = function (args) {\n                let func = new function_1.ContractFunction(functionName);\n                let interaction = new interaction_1.Interaction(contract, func, args || []);\n                return interaction;\n            };\n            this.methods[functionName] = function (args) {\n                let func = new function_1.ContractFunction(functionName);\n                // Perform automatic type inference, wrt. the endpoint definition:\n                let typedArgs = nativeSerializer_1.NativeSerializer.nativeToTypedValues(args || [], definition);\n                let interaction = new interaction_1.Interaction(contract, func, typedArgs || []);\n                return interaction;\n            };\n        }\n    }\n    /**\n     * Sets the address, as on Network.\n     */\n    setAddress(address) {\n        this.address = address;\n    }\n    /**\n     * Gets the address, as on Network.\n     */\n    getAddress() {\n        return this.address;\n    }\n    setAbi(abi) {\n        this.abi = abi;\n    }\n    getAbi() {\n        utils_1.guardValueIsSet(\"abi\", this.abi);\n        return this.abi;\n    }\n    getEndpoint(name) {\n        return this.getAbi().getEndpoint(name);\n    }\n    /**\n     * Creates a {@link Transaction} for deploying the Smart Contract to the Network.\n     */\n    deploy({ code, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID }) {\n        codeMetadata = codeMetadata || new codeMetadata_1.CodeMetadata();\n        initArguments = initArguments || [];\n        value = value || 0;\n        let payload = transactionPayload_1.TransactionPayload.contractDeploy()\n            .setCode(code)\n            .setCodeMetadata(codeMetadata)\n            .setInitArgs(initArguments)\n            .build();\n        let transaction = new transaction_1.Transaction({\n            receiver: address_1.Address.Zero(),\n            value: value,\n            gasLimit: gasLimit,\n            gasPrice: gasPrice,\n            data: payload,\n            chainID: chainID\n        });\n        return transaction;\n    }\n    /**\n     * Creates a {@link Transaction} for upgrading the Smart Contract on the Network.\n     */\n    upgrade({ code, codeMetadata, initArguments, value, gasLimit, gasPrice, chainID }) {\n        this.ensureHasAddress();\n        codeMetadata = codeMetadata || new codeMetadata_1.CodeMetadata();\n        initArguments = initArguments || [];\n        value = value || 0;\n        let payload = transactionPayload_1.TransactionPayload.contractUpgrade()\n            .setCode(code)\n            .setCodeMetadata(codeMetadata)\n            .setInitArgs(initArguments)\n            .build();\n        let transaction = new transaction_1.Transaction({\n            receiver: this.getAddress(),\n            value: value,\n            gasLimit: gasLimit,\n            gasPrice: gasPrice,\n            data: payload,\n            chainID: chainID\n        });\n        return transaction;\n    }\n    /**\n     * Creates a {@link Transaction} for calling (a function of) the Smart Contract.\n     */\n    call({ func, args, value, gasLimit, receiver, gasPrice, chainID }) {\n        this.ensureHasAddress();\n        args = args || [];\n        value = value || 0;\n        let payload = transactionPayload_1.TransactionPayload.contractCall()\n            .setFunction(func)\n            .setArgs(args)\n            .build();\n        let transaction = new transaction_1.Transaction({\n            receiver: receiver ? receiver : this.getAddress(),\n            value: value,\n            gasLimit: gasLimit,\n            gasPrice: gasPrice,\n            data: payload,\n            chainID: chainID\n        });\n        return transaction;\n    }\n    createQuery({ func, args, value, caller }) {\n        this.ensureHasAddress();\n        return new query_1.Query({\n            address: this.getAddress(),\n            func: func,\n            args: args,\n            value: value,\n            caller: caller\n        });\n    }\n    ensureHasAddress() {\n        if (!this.getAddress().bech32()) {\n            throw new errors_1.ErrContractHasNoAddress();\n        }\n    }\n    /**\n     * Computes the address of a Smart Contract.\n     * The address is computed deterministically, from the address of the owner and the nonce of the deployment transaction.\n     *\n     * @param owner The owner of the Smart Contract\n     * @param nonce The owner nonce used for the deployment transaction\n     */\n    static computeAddress(owner, nonce) {\n        let initialPadding = Buffer.alloc(8, 0);\n        let ownerPubkey = new address_1.Address(owner.bech32()).pubkey();\n        let shardSelector = ownerPubkey.slice(30);\n        let ownerNonceBytes = Buffer.alloc(8);\n        const bigNonce = new bignumber_js_1.default(nonce.valueOf().toString(10));\n        const bigNonceBuffer = utils_2.bigIntToBuffer(bigNonce);\n        ownerNonceBytes.write(bigNonceBuffer.reverse().toString('hex'), 'hex');\n        let bytesToHash = Buffer.concat([ownerPubkey, ownerNonceBytes]);\n        let hash = createKeccakHash(\"keccak256\").update(bytesToHash).digest();\n        let vmTypeBytes = Buffer.from(transactionPayloadBuilders_1.ArwenVirtualMachine, \"hex\");\n        let addressBytes = Buffer.concat([\n            initialPadding,\n            vmTypeBytes,\n            hash.slice(10, 30),\n            shardSelector\n        ]);\n        let address = new address_1.Address(addressBytes);\n        return address;\n    }\n}\nexports.SmartContract = SmartContract;\n//# sourceMappingURL=smartContract.js.map"]},"metadata":{},"sourceType":"script"}