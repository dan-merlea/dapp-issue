{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar _Spritesheet = /*#__PURE__*/function () {\n  function _Spritesheet(texture, data) {\n    var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, _Spritesheet);\n    this.linkedSheets = [];\n    this._texture = texture instanceof core.Texture ? texture : null;\n    this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    var resource = this.baseTexture.resource;\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  _createClass(_Spritesheet, [{\n    key: \"_updateResolution\",\n    value: function _updateResolution() {\n      var resolutionFilename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var scale = this.data.meta.scale;\n      var resolution = core.utils.getResolutionOfUrl(resolutionFilename, null);\n      if (resolution === null) {\n        resolution = parseFloat(scale !== null && scale !== void 0 ? scale : \"1\");\n      }\n      if (resolution !== 1) {\n        this.baseTexture.setResolution(resolution);\n      }\n      return resolution;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var _this = this;\n      return new Promise(function (resolve) {\n        _this._callback = resolve;\n        _this._batchIndex = 0;\n        if (_this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n          _this._processFrames(0);\n          _this._processAnimations();\n          _this._parseComplete();\n        } else {\n          _this._nextBatch();\n        }\n      });\n    }\n  }, {\n    key: \"_processFrames\",\n    value: function _processFrames(initialFrameIndex) {\n      var frameIndex = initialFrameIndex;\n      var maxFrames = _Spritesheet.BATCH_SIZE;\n      while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n        var i = this._frameKeys[frameIndex];\n        var data = this._frames[i];\n        var rect = data.frame;\n        if (rect) {\n          var frame = null;\n          var trim = null;\n          var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n          var orig = new core.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n          if (data.rotated) {\n            frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n          } else {\n            frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n          }\n          if (data.trimmed !== false && data.spriteSourceSize) {\n            trim = new core.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n          }\n          this.textures[i] = new core.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n          core.Texture.addToCache(this.textures[i], i);\n        }\n        frameIndex++;\n      }\n    }\n  }, {\n    key: \"_processAnimations\",\n    value: function _processAnimations() {\n      var animations = this.data.animations || {};\n      for (var animName in animations) {\n        this.animations[animName] = [];\n        for (var i = 0; i < animations[animName].length; i++) {\n          var frameName = animations[animName][i];\n          this.animations[animName].push(this.textures[frameName]);\n        }\n      }\n    }\n  }, {\n    key: \"_parseComplete\",\n    value: function _parseComplete() {\n      var callback = this._callback;\n      this._callback = null;\n      this._batchIndex = 0;\n      callback.call(this, this.textures);\n    }\n  }, {\n    key: \"_nextBatch\",\n    value: function _nextBatch() {\n      var _this2 = this;\n      this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n      this._batchIndex++;\n      setTimeout(function () {\n        if (_this2._batchIndex * _Spritesheet.BATCH_SIZE < _this2._frameKeys.length) {\n          _this2._nextBatch();\n        } else {\n          _this2._processAnimations();\n          _this2._parseComplete();\n        }\n      }, 0);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      for (var i in this.textures) {\n        this.textures[i].destroy();\n      }\n      this._frames = null;\n      this._frameKeys = null;\n      this.data = null;\n      this.textures = null;\n      if (destroyBase) {\n        var _this$_texture;\n        (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.destroy();\n        this.baseTexture.destroy();\n      }\n      this._texture = null;\n      this.baseTexture = null;\n      this.linkedSheets = [];\n    }\n  }]);\n  return _Spritesheet;\n}();\nvar Spritesheet = _Spritesheet;\nSpritesheet.BATCH_SIZE = 1e3;\nexports.Spritesheet = Spritesheet;","map":{"version":3,"sources":["../src/Spritesheet.ts"],"names":["BaseTexture","Rectangle","Texture"],"mappings":"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","sourcesContent":["import { Texture, BaseTexture, utils, Rectangle } from '@pixi/core';\nimport type { ImageResource, IPointData } from '@pixi/core';\n\n/** Represents the JSON data for a spritesheet atlas. */\nexport interface ISpritesheetFrameData\n{\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    trimmed?: boolean;\n    rotated?: boolean;\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    spriteSourceSize?: {\n        x: number;\n        y: number;\n    };\n    anchor?: IPointData;\n}\n\n/** Atlas format. */\nexport interface ISpritesheetData\n{\n    frames: utils.Dict<ISpritesheetFrameData>;\n    animations?: utils.Dict<string[]>;\n    meta: {\n        scale: string;\n        // eslint-disable-next-line camelcase\n        related_multi_packs?: string[];\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /** The maximum number of Textures to build per process. */\n    static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet[] = [];\n\n    /** Reference to ths source texture. */\n    public baseTexture: BaseTexture;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: utils.Dict<Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: utils.Dict<Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: ISpritesheetData;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: utils.Dict<ISpritesheetFrameData>;\n\n    /** Collection of frame names. */\n    private _frameKeys: string[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: utils.Dict<Texture>) => void;\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     * @param resolutionFilename - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(texture: BaseTexture | Texture, data: ISpritesheetData, resolutionFilename: string = null)\n    {\n        this._texture = texture instanceof Texture ? texture : null;\n        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n        this.textures = {};\n        this.animations = {};\n        this.data = data;\n\n        const resource = this.baseTexture.resource as ImageResource;\n\n        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     * @param resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @returns Resolution to use for spritesheet.\n     */\n    private _updateResolution(resolutionFilename: string = null): number\n    {\n        const { scale } = this.data.meta;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = utils.getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = parseFloat(scale ?? '1');\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     * @method PIXI.Spritesheet#parse\n     */\n    public parse(): Promise<utils.Dict<Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.baseTexture.destroy();\n        }\n        this._texture = null;\n        this.baseTexture = null;\n        this.linkedSheets = [];\n    }\n}\n"]},"metadata":{},"sourceType":"script"}