{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionalValue = exports.OptionalType = void 0;\nvar utils_1 = require(\"../../utils\");\nvar types_1 = require(\"./types\");\n/**\n * An optional is an algebraic type. It holds zero or one values.\n */\nvar OptionalType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(OptionalType, _types_1$Type);\n  var _super = _createSuper(OptionalType);\n  function OptionalType(typeParameter) {\n    _classCallCheck(this, OptionalType);\n    return _super.call(this, \"Optional\", [typeParameter], types_1.TypeCardinality.variable(1));\n  }\n  _createClass(OptionalType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionalType.ClassName;\n    }\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      if (!type.hasExactClass(OptionalType.ClassName)) {\n        return false;\n      }\n      var invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n      var fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n      return invariantTypeParameters || fakeCovarianceToNull;\n    }\n  }]);\n  return OptionalType;\n}(types_1.Type);\nexports.OptionalType = OptionalType;\nOptionalType.ClassName = \"OptionalType\";\nvar OptionalValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(OptionalValue, _types_1$TypedValue);\n  var _super2 = _createSuper(OptionalValue);\n  function OptionalValue(type) {\n    var _this;\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    _classCallCheck(this, OptionalValue);\n    _this = _super2.call(this, type);\n    // TODO: assert value is of type type.getFirstTypeParameter()\n    _this.value = value;\n    return _this;\n  }\n  _createClass(OptionalValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return OptionalValue.ClassName;\n    }\n    /**\n     * Creates an OptionalValue, as not provided (missing).\n     */\n  }, {\n    key: \"isSet\",\n    value: function isSet() {\n      return this.value ? true : false;\n    }\n  }, {\n    key: \"getTypedValue\",\n    value: function getTypedValue() {\n      utils_1.guardValueIsSet(\"value\", this.value);\n      return this.value;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value ? this.value.valueOf() : null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var _a;\n      return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n  }], [{\n    key: \"newMissing\",\n    value: function newMissing() {\n      var type = new OptionalType(new types_1.NullType());\n      return new OptionalValue(type);\n    }\n  }]);\n  return OptionalValue;\n}(types_1.TypedValue);\nexports.OptionalValue = OptionalValue;\nOptionalValue.ClassName = \"OptionalValue\";","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/algebraic.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;AAEG;AAFH,IAGa,YAAa;EAAA;EAAA;EAGtB,sBAAY,aAAmB,EAAA;IAAA;IAAA,yBACrB,UAAU,EAAE,CAAC,aAAa,CAAC,EAAE,OAAA,CAAA,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;EAClE;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,YAAY,CAAC,SAAS;IACjC;EAAC;IAAA;IAAA,OAED,0BAAiB,IAAU,EAAA;MACvB,IAAI,CAAE,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,SAAS,CAAE,EAAE;QAC/C,OAAO,KAAK;MACf;MAED,IAAI,uBAAuB,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,qBAAqB,EAAE,CAAC;MAC/F,IAAI,oBAAoB,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC,aAAa,CAAC,OAAA,CAAA,QAAQ,CAAC,SAAS,CAAC;MACzF,OAAO,uBAAuB,IAAI,oBAAoB;IAC1D;EAAC;EAAA;AAAA,EAnB6B,OAAA,CAAA,IAAI;AAAtC,OAAA,CAAA,YAAA,GAAA,YAAA;AACW,YAAA,CAAA,SAAS,GAAG,cAAc;AAAC,IAqBzB,aAAc;EAAA;EAAA;EAIvB,uBAAY,IAAkB,EAAiC;IAAA;IAAA,IAA/B,KAAA,uEAA2B,IAAI;IAAA;IAC3D,2BAAM,IAAI;IAEV;IAEA,MAAK,KAAK,GAAG,KAAK;IAAC;EACvB;EAAC;IAAA;IAAA,OAED,wBAAY;MACR,OAAO,aAAa,CAAC,SAAS;IAClC;IAEA;;AAEG;EAFH;IAAA;IAAA,OAQA,iBAAK;MACD,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,GAAG,KAAK;IACpC;EAAC;IAAA;IAAA,OAED,yBAAa;MACT,OAAA,CAAA,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC;MACpC,OAAO,IAAI,CAAC,KAAM;IACtB;EAAC;IAAA;IAAA,OAED,mBAAO;MACH,OAAO,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,IAAI;IACnD;EAAC;IAAA;IAAA,OAED,gBAAO,KAAoB,EAAA;;MACvB,OAAO,CAAA,CAAA,EAAA,GAAA,IAAI,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,MAAM,CAAC,KAAK,CAAC,KAAK,CAAA,KAAK,KAAK;IACnD;EAAC;IAAA;IAAA,OApBD,sBAAiB;MACb,IAAI,IAAI,GAAG,IAAI,YAAY,CAAC,IAAI,OAAA,CAAA,QAAQ,EAAE,CAAC;MAC3C,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC;IAClC;EAAC;EAAA;AAAA,EAtB8B,OAAA,CAAA,UAAU;AAA7C,OAAA,CAAA,aAAA,GAAA,aAAA;AACW,aAAA,CAAA,SAAS,GAAG,eAAe","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OptionalValue = exports.OptionalType = void 0;\nconst utils_1 = require(\"../../utils\");\nconst types_1 = require(\"./types\");\n/**\n * An optional is an algebraic type. It holds zero or one values.\n */\nclass OptionalType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"Optional\", [typeParameter], types_1.TypeCardinality.variable(1));\n    }\n    getClassName() {\n        return OptionalType.ClassName;\n    }\n    isAssignableFrom(type) {\n        if (!(type.hasExactClass(OptionalType.ClassName))) {\n            return false;\n        }\n        let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n        let fakeCovarianceToNull = type.getFirstTypeParameter().hasExactClass(types_1.NullType.ClassName);\n        return invariantTypeParameters || fakeCovarianceToNull;\n    }\n}\nexports.OptionalType = OptionalType;\nOptionalType.ClassName = \"OptionalType\";\nclass OptionalValue extends types_1.TypedValue {\n    constructor(type, value = null) {\n        super(type);\n        // TODO: assert value is of type type.getFirstTypeParameter()\n        this.value = value;\n    }\n    getClassName() {\n        return OptionalValue.ClassName;\n    }\n    /**\n     * Creates an OptionalValue, as not provided (missing).\n     */\n    static newMissing() {\n        let type = new OptionalType(new types_1.NullType());\n        return new OptionalValue(type);\n    }\n    isSet() {\n        return this.value ? true : false;\n    }\n    getTypedValue() {\n        utils_1.guardValueIsSet(\"value\", this.value);\n        return this.value;\n    }\n    valueOf() {\n        return this.value ? this.value.valueOf() : null;\n    }\n    equals(other) {\n        var _a;\n        return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n}\nexports.OptionalValue = OptionalValue;\nOptionalValue.ClassName = \"OptionalValue\";\n//# sourceMappingURL=algebraic.js.map"]},"metadata":{},"sourceType":"script"}