{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar sprite = require('@pixi/sprite');\nvar core = require('@pixi/core');\nvar AnimatedSprite = /*#__PURE__*/function (_sprite$Sprite) {\n  _inherits(AnimatedSprite, _sprite$Sprite);\n  var _super = _createSuper(AnimatedSprite);\n  function AnimatedSprite(textures) {\n    var _this;\n    var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, AnimatedSprite);\n    _this = _super.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);\n    _this._textures = null;\n    _this._durations = null;\n    _this._autoUpdate = autoUpdate;\n    _this._isConnectedToTicker = false;\n    _this.animationSpeed = 1;\n    _this.loop = true;\n    _this.updateAnchor = false;\n    _this.onComplete = null;\n    _this.onFrameChange = null;\n    _this.onLoop = null;\n    _this._currentTime = 0;\n    _this._playing = false;\n    _this._previousFrame = null;\n    _this.textures = textures;\n    return _this;\n  }\n  _createClass(AnimatedSprite, [{\n    key: \"stop\",\n    value: function stop() {\n      if (!this._playing) {\n        return;\n      }\n      this._playing = false;\n      if (this._autoUpdate && this._isConnectedToTicker) {\n        core.Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this._playing) {\n        return;\n      }\n      this._playing = true;\n      if (this._autoUpdate && !this._isConnectedToTicker) {\n        core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }, {\n    key: \"gotoAndStop\",\n    value: function gotoAndStop(frameNumber) {\n      this.stop();\n      this.currentFrame = frameNumber;\n    }\n  }, {\n    key: \"gotoAndPlay\",\n    value: function gotoAndPlay(frameNumber) {\n      this.currentFrame = frameNumber;\n      this.play();\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (!this._playing) {\n        return;\n      }\n      var elapsed = this.animationSpeed * deltaTime;\n      var previousFrame = this.currentFrame;\n      if (this._durations !== null) {\n        var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n        lag += elapsed / 60 * 1e3;\n        while (lag < 0) {\n          this._currentTime--;\n          lag += this._durations[this.currentFrame];\n        }\n        var sign = Math.sign(this.animationSpeed * deltaTime);\n        this._currentTime = Math.floor(this._currentTime);\n        while (lag >= this._durations[this.currentFrame]) {\n          lag -= this._durations[this.currentFrame] * sign;\n          this._currentTime += sign;\n        }\n        this._currentTime += lag / this._durations[this.currentFrame];\n      } else {\n        this._currentTime += elapsed;\n      }\n      if (this._currentTime < 0 && !this.loop) {\n        this.gotoAndStop(0);\n        if (this.onComplete) {\n          this.onComplete();\n        }\n      } else if (this._currentTime >= this._textures.length && !this.loop) {\n        this.gotoAndStop(this._textures.length - 1);\n        if (this.onComplete) {\n          this.onComplete();\n        }\n      } else if (previousFrame !== this.currentFrame) {\n        if (this.loop && this.onLoop) {\n          if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {\n            this.onLoop();\n          } else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n            this.onLoop();\n          }\n        }\n        this.updateTexture();\n      }\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture() {\n      var currentFrame = this.currentFrame;\n      if (this._previousFrame === currentFrame) {\n        return;\n      }\n      this._previousFrame = currentFrame;\n      this._texture = this._textures[currentFrame];\n      this._textureID = -1;\n      this._textureTrimmedID = -1;\n      this._cachedTint = 16777215;\n      this.uvs = this._texture._uvs.uvsFloat32;\n      if (this.updateAnchor) {\n        this._anchor.copyFrom(this._texture.defaultAnchor);\n      }\n      if (this.onFrameChange) {\n        this.onFrameChange(this.currentFrame);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      this.stop();\n      _get(_getPrototypeOf(AnimatedSprite.prototype), \"destroy\", this).call(this, options);\n      this.onComplete = null;\n      this.onFrameChange = null;\n      this.onLoop = null;\n    }\n  }, {\n    key: \"totalFrames\",\n    get: function get() {\n      return this._textures.length;\n    }\n  }, {\n    key: \"textures\",\n    get: function get() {\n      return this._textures;\n    },\n    set: function set(value) {\n      if (value[0] instanceof core.Texture) {\n        this._textures = value;\n        this._durations = null;\n      } else {\n        this._textures = [];\n        this._durations = [];\n        for (var i = 0; i < value.length; i++) {\n          this._textures.push(value[i].texture);\n          this._durations.push(value[i].time);\n        }\n      }\n      this._previousFrame = null;\n      this.gotoAndStop(0);\n      this.updateTexture();\n    }\n  }, {\n    key: \"currentFrame\",\n    get: function get() {\n      var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n      if (currentFrame < 0) {\n        currentFrame += this._textures.length;\n      }\n      return currentFrame;\n    },\n    set: function set(value) {\n      if (value < 0 || value > this.totalFrames - 1) {\n        throw new Error(\"[AnimatedSprite]: Invalid frame index value \".concat(value, \", expected to be between 0 and totalFrames \").concat(this.totalFrames, \".\"));\n      }\n      var previousFrame = this.currentFrame;\n      this._currentTime = value;\n      if (previousFrame !== this.currentFrame) {\n        this.updateTexture();\n      }\n    }\n  }, {\n    key: \"playing\",\n    get: function get() {\n      return this._playing;\n    }\n  }, {\n    key: \"autoUpdate\",\n    get: function get() {\n      return this._autoUpdate;\n    },\n    set: function set(value) {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n        if (!this._autoUpdate && this._isConnectedToTicker) {\n          core.Ticker.shared.remove(this.update, this);\n          this._isConnectedToTicker = false;\n        } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n          core.Ticker.shared.add(this.update, this);\n          this._isConnectedToTicker = true;\n        }\n      }\n    }\n  }], [{\n    key: \"fromFrames\",\n    value: function fromFrames(frames) {\n      var textures = [];\n      for (var i = 0; i < frames.length; ++i) {\n        textures.push(core.Texture.from(frames[i]));\n      }\n      return new AnimatedSprite(textures);\n    }\n  }, {\n    key: \"fromImages\",\n    value: function fromImages(images) {\n      var textures = [];\n      for (var i = 0; i < images.length; ++i) {\n        textures.push(core.Texture.from(images[i]));\n      }\n      return new AnimatedSprite(textures);\n    }\n  }]);\n  return AnimatedSprite;\n}(sprite.Sprite);\nexports.AnimatedSprite = AnimatedSprite;","map":{"version":3,"sources":["../src/AnimatedSprite.ts"],"names":["Sprite","UPDATE_PRIORITY","Texture"],"mappings":"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","sourcesContent":["import { Sprite } from '@pixi/sprite';\nimport { Texture, Ticker, UPDATE_PRIORITY } from '@pixi/core';\nimport type { IDestroyOptions } from '@pixi/display';\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}\n * containing the animation definitions:\n * @example\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * @memberof PIXI\n */\nexport class AnimatedSprite extends Sprite\n{\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed: number;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop: boolean;\n\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     * @default false\n     */\n    public updateAnchor: boolean;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite finishes playing.\n     * @example\n     * animation.onComplete = () => {\n     *     // Finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *     // Updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n     * loops around to start again.\n     * @example\n     * animation.onLoop = () => {\n     *     // Looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    private _playing: boolean;\n    private _textures: Texture[];\n    private _durations: number[];\n\n    /**\n     * `true` uses PIXI.Ticker.shared to auto update animation time.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /** Elapsed time since animation has been started, used internally to display current texture. */\n    private _currentTime: number;\n\n    /** The texture index that was displayed last time. */\n    private _previousFrame: number;\n\n    /**\n     * @param textures - An array of {@link PIXI.Texture} or frame\n     *  objects that make up the animation.\n     * @param {boolean} [autoUpdate=true] - Whether to use PIXI.Ticker.shared to auto update animation time.\n     */\n    constructor(textures: Texture[] | FrameObject[], autoUpdate = true)\n    {\n        super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n\n        this._textures = null;\n        this._durations = null;\n        this._autoUpdate = autoUpdate;\n        this._isConnectedToTicker = false;\n\n        this.animationSpeed = 1;\n        this.loop = true;\n        this.updateAnchor = false;\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n\n        this._currentTime = 0;\n\n        this._playing = false;\n        this._previousFrame = null;\n\n        this.textures = textures;\n    }\n\n    /** Stops the AnimatedSprite. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the AnimatedSprite. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     * @param frameNumber - Frame index to stop at.\n     */\n    public gotoAndStop(frameNumber: number): void\n    {\n        this.stop();\n        this.currentFrame = frameNumber;\n    }\n\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     * @param frameNumber - Frame index to start at.\n     */\n    public gotoAndPlay(frameNumber: number): void\n    {\n        this.currentFrame = frameNumber;\n        this.play();\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * @param deltaTime - Time since last tick.\n     */\n    update(deltaTime: number): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        const elapsed = this.animationSpeed * deltaTime;\n        const previousFrame = this.currentFrame;\n\n        if (this._durations !== null)\n        {\n            let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n            lag += elapsed / 60 * 1000;\n\n            while (lag < 0)\n            {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n\n            const sign = Math.sign(this.animationSpeed * deltaTime);\n\n            this._currentTime = Math.floor(this._currentTime);\n\n            while (lag >= this._durations[this.currentFrame])\n            {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else\n        {\n            this._currentTime += elapsed;\n        }\n\n        if (this._currentTime < 0 && !this.loop)\n        {\n            this.gotoAndStop(0);\n\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop)\n        {\n            this.gotoAndStop(this._textures.length - 1);\n\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame)\n        {\n            if (this.loop && this.onLoop)\n            {\n                if (this.animationSpeed > 0 && this.currentFrame < previousFrame)\n                {\n                    this.onLoop();\n                }\n                else if (this.animationSpeed < 0 && this.currentFrame > previousFrame)\n                {\n                    this.onLoop();\n                }\n            }\n\n            this.updateTexture();\n        }\n    }\n\n    /** Updates the displayed texture to match the current frame index. */\n    private updateTexture(): void\n    {\n        const currentFrame = this.currentFrame;\n\n        if (this._previousFrame === currentFrame)\n        {\n            return;\n        }\n\n        this._previousFrame = currentFrame;\n\n        this._texture = this._textures[currentFrame];\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n        this._cachedTint = 0xFFFFFF;\n        this.uvs = this._texture._uvs.uvsFloat32;\n\n        if (this.updateAnchor)\n        {\n            this._anchor.copyFrom(this._texture.defaultAnchor);\n        }\n\n        if (this.onFrameChange)\n        {\n            this.onFrameChange(this.currentFrame);\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and destroys it.\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this.stop();\n        super.destroy(options);\n\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @returns - The new animated sprite with the specified frames.\n     */\n    public static fromFrames(frames: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < frames.length; ++i)\n        {\n            textures.push(Texture.from(frames[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @returns The new animate sprite with the specified images as frames.\n     */\n    public static fromImages(images: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < images.length; ++i)\n        {\n            textures.push(Texture.from(images[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     * @readonly\n     * @default 0\n     */\n    get totalFrames(): number\n    {\n        return this._textures.length;\n    }\n\n    /** The array of textures used for this AnimatedSprite. */\n    get textures(): Texture[] | FrameObject[]\n    {\n        return this._textures;\n    }\n\n    set textures(value: Texture[] | FrameObject[])\n    {\n        if (value[0] instanceof Texture)\n        {\n            this._textures = value as Texture[];\n            this._durations = null;\n        }\n        else\n        {\n            this._textures = [];\n            this._durations = [];\n\n            for (let i = 0; i < value.length; i++)\n            {\n                this._textures.push((value[i] as FrameObject).texture);\n                this._durations.push((value[i] as FrameObject).time);\n            }\n        }\n        this._previousFrame = null;\n        this.gotoAndStop(0);\n        this.updateTexture();\n    }\n\n    /** The AnimatedSprites current frame index. */\n    get currentFrame(): number\n    {\n        let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n        if (currentFrame < 0)\n        {\n            currentFrame += this._textures.length;\n        }\n\n        return currentFrame;\n    }\n\n    set currentFrame(value: number)\n    {\n        if (value < 0 || value > this.totalFrames - 1)\n        {\n            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, `\n                + `expected to be between 0 and totalFrames ${this.totalFrames}.`);\n        }\n\n        const previousFrame = this.currentFrame;\n\n        this._currentTime = value;\n\n        if (previousFrame !== this.currentFrame)\n        {\n            this.updateTexture();\n        }\n    }\n\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     * @readonly\n     */\n    get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /** Whether to use PIXI.Ticker.shared to auto update animation time. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n}\n\n/** @memberof PIXI.AnimatedSprite */\nexport interface FrameObject\n{\n    /** The {@link PIXI.Texture} of the frame. */\n    texture: Texture;\n\n    /** The duration of the frame, in milliseconds. */\n    time: number;\n}\n"]},"metadata":{},"sourceType":"script"}