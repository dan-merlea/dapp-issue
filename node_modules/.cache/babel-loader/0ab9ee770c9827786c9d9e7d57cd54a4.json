{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionCompletionStrategyOnAPI = exports.TransactionCompletionStrategyOnProxy = void 0;\nvar primitives_1 = require(\"./primitives\");\nvar WellKnownCompletionEvents = [\"completedTxEvent\", \"SCDeploy\", \"signalError\"];\n/**\n * Algorithm for detecting transaction completion.\n * Based on some heuristics (a bit imprecise therefore, at this moment).\n */\nvar TransactionCompletionStrategyOnProxy = /*#__PURE__*/function () {\n  function TransactionCompletionStrategyOnProxy() {\n    _classCallCheck(this, TransactionCompletionStrategyOnProxy);\n  }\n  _createClass(TransactionCompletionStrategyOnProxy, [{\n    key: \"isCompleted\",\n    value: function isCompleted(transaction) {\n      if (transaction.status.isPending()) {\n        // Certainly not completed.\n        return false;\n      }\n      // Handle gateway mechanics:\n      var _iterator = _createForOfIteratorHelper(WellKnownCompletionEvents),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var completionEvent = _step.value;\n          if (transaction.logs.findFirstOrNoneEvent(completionEvent)) {\n            // Certainly completed.\n            console.debug(\"TransactionCompletionStrategy.isCompleted(), found event:\", completionEvent);\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (this.isCertainlyMoveBalance(transaction.data)) {\n        return transaction.status.isExecuted();\n      }\n      var hyperblockNonce = transaction.hyperblockNonce;\n      // Imprecise condition, uncertain completion (usually sufficient, though).\n      // This is WRONG when (at least): timeOf(block with execution at destination is notarized) < timeOf(the \"completedTxEvent\" occurs).\n      if (hyperblockNonce > 0) {\n        console.debug(\"TransactionCompletionStrategy.isCompleted(), found hyperblock nonce:\", hyperblockNonce);\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"isCertainlyMoveBalance\",\n    value: function isCertainlyMoveBalance(transactionData) {\n      var _this = this;\n      var parts = transactionData.toString().split(\"@\");\n      var prefix = parts[0];\n      var otherParts = parts.slice(1);\n      var emptyPrefix = !prefix;\n      var somePartsAreNotValidArguments = !otherParts.every(function (part) {\n        return _this.looksLikeValidArgument(part);\n      });\n      return emptyPrefix || somePartsAreNotValidArguments;\n    }\n  }, {\n    key: \"looksLikeValidArgument\",\n    value: function looksLikeValidArgument(arg) {\n      return primitives_1.isPaddedHex(arg);\n    }\n  }]);\n  return TransactionCompletionStrategyOnProxy;\n}();\nexports.TransactionCompletionStrategyOnProxy = TransactionCompletionStrategyOnProxy;\nvar TransactionCompletionStrategyOnAPI = /*#__PURE__*/function () {\n  function TransactionCompletionStrategyOnAPI() {\n    _classCallCheck(this, TransactionCompletionStrategyOnAPI);\n  }\n  _createClass(TransactionCompletionStrategyOnAPI, [{\n    key: \"isCompleted\",\n    value: function isCompleted(transaction) {\n      return !transaction.status.isPending();\n    }\n  }]);\n  return TransactionCompletionStrategyOnAPI;\n}();\nexports.TransactionCompletionStrategyOnAPI = TransactionCompletionStrategyOnAPI;","map":null,"metadata":{},"sourceType":"script"}