{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar display = require('@pixi/display');\nvar ParticleContainer = /*#__PURE__*/function (_display$Container) {\n  _inherits(ParticleContainer, _display$Container);\n  var _super = _createSuper(ParticleContainer);\n  function ParticleContainer() {\n    var _this;\n    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1500;\n    var properties = arguments.length > 1 ? arguments[1] : undefined;\n    var batchSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16384;\n    var autoResize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, ParticleContainer);\n    _this = _super.call(this);\n    var maxBatchSize = 16384;\n    if (batchSize > maxBatchSize) {\n      batchSize = maxBatchSize;\n    }\n    _this._properties = [false, true, false, false, false];\n    _this._maxSize = maxSize;\n    _this._batchSize = batchSize;\n    _this._buffers = null;\n    _this._bufferUpdateIDs = [];\n    _this._updateID = 0;\n    _this.interactiveChildren = false;\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n    _this.autoResize = autoResize;\n    _this.roundPixels = true;\n    _this.baseTexture = null;\n    _this.setProperties(properties);\n    _this._tint = 0;\n    _this.tintRgb = new Float32Array(4);\n    _this.tint = 16777215;\n    return _this;\n  }\n  _createClass(ParticleContainer, [{\n    key: \"setProperties\",\n    value: function setProperties(properties) {\n      if (properties) {\n        this._properties[0] = \"vertices\" in properties || \"scale\" in properties ? !!properties.vertices || !!properties.scale : this._properties[0];\n        this._properties[1] = \"position\" in properties ? !!properties.position : this._properties[1];\n        this._properties[2] = \"rotation\" in properties ? !!properties.rotation : this._properties[2];\n        this._properties[3] = \"uvs\" in properties ? !!properties.uvs : this._properties[3];\n        this._properties[4] = \"tint\" in properties || \"alpha\" in properties ? !!properties.tint || !!properties.alpha : this._properties[4];\n      }\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      this.displayObjectUpdateTransform();\n    }\n  }, {\n    key: \"tint\",\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      this._tint = value;\n      core.utils.hex2rgb(value, this.tintRgb);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer) {\n      var _this2 = this;\n      if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n        return;\n      }\n      if (!this.baseTexture) {\n        this.baseTexture = this.children[0]._texture.baseTexture;\n        if (!this.baseTexture.valid) {\n          this.baseTexture.once(\"update\", function () {\n            return _this2.onChildrenChange(0);\n          });\n        }\n      }\n      renderer.batch.setObjectRenderer(renderer.plugins.particle);\n      renderer.plugins.particle.render(this);\n    }\n  }, {\n    key: \"onChildrenChange\",\n    value: function onChildrenChange(smallestChildIndex) {\n      var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n      while (this._bufferUpdateIDs.length < bufferIndex) {\n        this._bufferUpdateIDs.push(0);\n      }\n      this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._buffers) {\n        for (var i = 0; i < this._buffers.length; ++i) {\n          this._buffers[i].destroy();\n        }\n        this._buffers = null;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options) {\n      _get(_getPrototypeOf(ParticleContainer.prototype), \"destroy\", this).call(this, options);\n      this.dispose();\n      this._properties = null;\n      this._buffers = null;\n      this._bufferUpdateIDs = null;\n    }\n  }]);\n  return ParticleContainer;\n}(display.Container);\nexports.ParticleContainer = ParticleContainer;","map":{"version":3,"sources":["../src/ParticleContainer.ts"],"names":["Container","BLEND_MODES","utils"],"mappings":";;;;;;;;;;;;;IA0Ca,iBAAA;EAAA;EAAA;EA+ET,6BACA;IAAA;IAAA,IADY,OAAU,uEAAA,IAAA;IAAA,IAAM,UAAA;IAAA,IAAkC,SAAY,uEAAA,KAAA;IAAA,IAAO,UAAA,uEAAa,KAC9F;IAAA;IACU;IAKN,IAAM,YAAe,GAAA,KAAA;IAErB,IAAI,SAAA,GAAY,YAChB,EAAA;MACgB,SAAA,GAAA,YAAA;IAAA;IAGhB,MAAK,WAAA,GAAc,CAAC,KAAA,EAAO,IAAM,EAAA,KAAA,EAAO,KAAA,EAAO,KAAK,CAAA;IACpD,MAAK,QAAW,GAAA,OAAA;IAChB,MAAK,UAAa,GAAA,SAAA;IAClB,MAAK,QAAW,GAAA,IAAA;IAChB,MAAK,gBAAA,GAAmB,EAAC;IACzB,MAAK,SAAY,GAAA,CAAA;IAEjB,MAAK,mBAAsB,GAAA,KAAA;IAC3B,MAAK,SAAA,GAAYC,IAAAA,CAAAA,WAAY,CAAA,MAAA;IAC7B,MAAK,UAAa,GAAA,UAAA;IAClB,MAAK,WAAc,GAAA,IAAA;IACnB,MAAK,WAAc,GAAA,IAAA;IAEnB,MAAK,aAAA,CAAc,UAAU,CAAA;IAE7B,MAAK,KAAQ,GAAA,CAAA;IACR,MAAA,OAAA,GAAU,IAAI,YAAA,CAAa,CAAC,CAAA;IACjC,MAAK,IAAO,GAAA,QAAA;IAAA;EAAA;EAChB;IAAA;IAAA,OAMO,uBAAc,UACrB,EAAA;MACI,IAAI,UACJ,EAAA;QACI,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA,GAAK,UAAc,IAAA,UAAA,IAAc,OAAA,IAAW,UACvD,GAAA,CAAC,CAAC,UAAA,CAAW,QAAA,IAAY,CAAC,CAAC,UAAW,CAAA,KAAA,GAAQ,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;QAChE,IAAA,CAAA,WAAA,CAAY,CAAA,CAAA,GAAK,UAAc,IAAA,UAAA,GAAa,CAAC,CAAC,UAAA,CAAW,QAAW,GAAA,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;QACrF,IAAA,CAAA,WAAA,CAAY,CAAA,CAAA,GAAK,UAAc,IAAA,UAAA,GAAa,CAAC,CAAC,UAAA,CAAW,QAAW,GAAA,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;QACrF,IAAA,CAAA,WAAA,CAAY,CAAA,CAAA,GAAK,KAAS,IAAA,UAAA,GAAa,CAAC,CAAC,UAAA,CAAW,GAAM,GAAA,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;QAChF,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA,GAAK,MAAU,IAAA,UAAA,IAAc,OAAA,IAAW,UACnD,GAAA,CAAC,CAAC,UAAA,CAAW,IAAA,IAAQ,CAAC,CAAC,UAAW,CAAA,KAAA,GAAQ,IAAA,CAAK,WAAY,CAAA,CAAA,CAAA;MAAA;IACrE;EACJ;IAAA;IAAA,OAEA,2BACA;MAEI,IAAA,CAAK,4BAA6B,EAAA;IAAA;EACtC;IAAA;IAAA,KAQA,eACA;MACI,OAAO,IAAK,CAAA,KAAA;IAAA,CAChB;IAAA,KAEA,aAAS,KACT,EAAA;MACI,IAAA,CAAK,KAAQ,GAAA,KAAA;MACPC,IAAAA,CAAAA,KAAAA,CAAAA,OAAAA,CAAQ,KAAO,EAAA,IAAA,CAAK,OAAO,CAAA;IAAA;EACrC;IAAA;IAAA,OAMO,gBAAO,QACd,EAAA;MAAA;MACI,IAAI,CAAC,IAAA,CAAK,OAAW,IAAA,IAAA,CAAK,UAAc,IAAA,CAAA,IAAK,CAAC,IAAA,CAAK,QAAS,CAAA,MAAA,IAAU,CAAC,IAAA,CAAK,UAC5E,EAAA;QACI;MAAA;MAGA,IAAA,CAAC,IAAA,CAAK,WACV,EAAA;QACI,IAAA,CAAK,WAAc,GAAA,IAAA,CAAK,QAAS,CAAA,CAAA,CAAA,CAAG,QAAS,CAAA,WAAA;QACzC,IAAA,CAAC,IAAK,CAAA,WAAA,CAAY,KACtB,EAAA;UACI,IAAA,CAAK,WAAA,CAAY,IAAK,CAAA,QAAA,EAAU;YAAA,OAAM,MAAK,CAAA,gBAAA,CAAiB,CAAC,CAAC;UAAA,EAAA;QAAA;MAClE;MAGJ,QAAA,CAAS,KAAM,CAAA,iBAAA,CAAkB,QAAS,CAAA,OAAA,CAAQ,QAAQ,CAAA;MACjD,QAAA,CAAA,OAAA,CAAQ,QAAS,CAAA,MAAA,CAAO,IAAI,CAAA;IAAA;EACzC;IAAA;IAAA,OAMU,0BAAiB,kBAC3B,EAAA;MACI,IAAM,WAAc,GAAA,IAAA,CAAK,KAAM,CAAA,kBAAA,GAAqB,IAAA,CAAK,UAAU,CAAA;MAE5D,OAAA,IAAA,CAAK,gBAAiB,CAAA,MAAA,GAAS,WACtC,EAAA;QACS,IAAA,CAAA,gBAAA,CAAiB,IAAA,CAAK,CAAC,CAAA;MAAA;MAE3B,IAAA,CAAA,gBAAA,CAAiB,WAAe,CAAA,GAAA,EAAE,IAAK,CAAA,SAAA;IAAA;EAChD;IAAA;IAAA,OAEA,mBACA;MACI,IAAI,IAAA,CAAK,QACT,EAAA;QACI,KAAA,IAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,IAAA,CAAK,QAAS,CAAA,MAAA,EAAQ,EAAE,CAC5C,EAAA;UACS,IAAA,CAAA,QAAA,CAAS,CAAA,CAAA,CAAG,OAAQ,EAAA;QAAA;QAG7B,IAAA,CAAK,QAAW,GAAA,IAAA;MAAA;IACpB;EACJ;IAAA;IAAA,OAaO,iBAAQ,OACf,EAAA;MACI,+EAAc,OAAO;MAErB,IAAA,CAAK,OAAQ,EAAA;MAEb,IAAA,CAAK,WAAc,GAAA,IAAA;MACnB,IAAA,CAAK,QAAW,GAAA,IAAA;MAChB,IAAA,CAAK,gBAAmB,GAAA,IAAA;IAAA;EAC5B;EAAA;AAAA,EAlOmCF,OAAAA,CAAAA,SACvC","sourcesContent":["import { BLEND_MODES, utils } from '@pixi/core';\nimport { Container } from '@pixi/display';\n\nimport type { BaseTexture, Renderer } from '@pixi/core';\nimport type { ParticleBuffer } from './ParticleBuffer';\nimport type { IDestroyOptions } from '@pixi/display';\nimport type { Sprite } from '@pixi/sprite';\n\nexport interface IParticleProperties\n{\n    vertices?: boolean;\n    position?: boolean;\n    rotation?: boolean;\n    uvs?: boolean;\n    tint?: boolean;\n    alpha?: boolean;\n    scale?: boolean;\n}\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles.\n *\n * The tradeoff of the ParticleContainer is that most advanced functionality will not work.\n * ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n *\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use. And here you have a hundred sprites that will be rendered at the speed of light.\n * @example\n * import { ParticleContainer, Sprite } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = Sprite.from('myImage.png');\n *     container.addChild(sprite);\n * }\n * @memberof PIXI\n */\nexport class ParticleContainer extends Container<Sprite>\n{\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n     * to reset the blend mode.\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public blendMode: BLEND_MODES;\n\n    /**\n     * If true, container allocates more batches in case there are more than `maxSize` particles.\n     * @default false\n     */\n    public autoResize: boolean;\n\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * Default to true here as performance is usually the priority for particles.\n     * @default true\n     */\n    public roundPixels: boolean;\n\n    /**\n     * The texture used to render the children.\n     * @readonly\n     */\n    public baseTexture: BaseTexture;\n    public tintRgb: Float32Array;\n\n    /** @private */\n    _maxSize: number;\n\n    /** @private */\n    _buffers: ParticleBuffer[];\n\n    /** @private */\n    _batchSize: number;\n\n    /**\n     * Set properties to be dynamic (true) / static (false).\n     * @private\n     */\n    _properties: boolean[];\n\n    /**\n     * For every batch, stores _updateID corresponding to the last change in that batch.\n     * @private\n     */\n    _bufferUpdateIDs: number[];\n\n    /**\n     * When child inserted, removed or changes position this number goes up.\n     * @private\n     */\n    _updateID: number;\n\n    /**\n     * The tint applied to the container.\n     * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    private _tint: number;\n\n    /**\n     * @param maxSize - The maximum number of particles that can be rendered by the container.\n     *  Affects size of allocated buffers.\n     * @param properties - The properties of children that should be uploaded to the gpu and applied.\n     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n     * @param {boolean} [autoResize=false] - If true, container allocates more batches in case\n     *  there are more than `maxSize` particles.\n     */\n    constructor(maxSize = 1500, properties?: IParticleProperties, batchSize = 16384, autoResize = false)\n    {\n        super();\n\n        // Making sure the batch size is valid\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        const maxBatchSize = 16384;\n\n        if (batchSize > maxBatchSize)\n        {\n            batchSize = maxBatchSize;\n        }\n\n        this._properties = [false, true, false, false, false];\n        this._maxSize = maxSize;\n        this._batchSize = batchSize;\n        this._buffers = null;\n        this._bufferUpdateIDs = [];\n        this._updateID = 0;\n\n        this.interactiveChildren = false;\n        this.blendMode = BLEND_MODES.NORMAL;\n        this.autoResize = autoResize;\n        this.roundPixels = true;\n        this.baseTexture = null;\n\n        this.setProperties(properties);\n\n        this._tint = 0;\n        this.tintRgb = new Float32Array(4);\n        this.tint = 0xFFFFFF;\n    }\n\n    /**\n     * Sets the private properties array to dynamic / static based on the passed properties object\n     * @param properties - The properties to be uploaded\n     */\n    public setProperties(properties: IParticleProperties): void\n    {\n        if (properties)\n        {\n            this._properties[0] = 'vertices' in properties || 'scale' in properties\n                ? !!properties.vertices || !!properties.scale : this._properties[0];\n            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n            this._properties[4] = 'tint' in properties || 'alpha' in properties\n                ? !!properties.tint || !!properties.alpha : this._properties[4];\n        }\n    }\n\n    updateTransform(): void\n    {\n        // TODO don't need to!\n        this.displayObjectUpdateTransform();\n    }\n\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        return this._tint;\n    }\n\n    set tint(value: number)\n    {\n        this._tint = value;\n        utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Renders the container using the WebGL renderer.\n     * @param renderer - The WebGL renderer.\n     */\n    public render(renderer: Renderer): void\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        if (!this.baseTexture)\n        {\n            this.baseTexture = this.children[0]._texture.baseTexture;\n            if (!this.baseTexture.valid)\n            {\n                this.baseTexture.once('update', () => this.onChildrenChange(0));\n            }\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins.particle);\n        renderer.plugins.particle.render(this);\n    }\n\n    /**\n     * Set the flag that static data should be updated to true\n     * @param smallestChildIndex - The smallest child index.\n     */\n    protected onChildrenChange(smallestChildIndex: number): void\n    {\n        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n        while (this._bufferUpdateIDs.length < bufferIndex)\n        {\n            this._bufferUpdateIDs.push(0);\n        }\n        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n\n    public dispose(): void\n    {\n        if (this._buffers)\n        {\n            for (let i = 0; i < this._buffers.length; ++i)\n            {\n                this._buffers[i].destroy();\n            }\n\n            this._buffers = null;\n        }\n    }\n\n    /**\n     * Destroys the container\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        super.destroy(options);\n\n        this.dispose();\n\n        this._properties = null;\n        this._buffers = null;\n        this._bufferUpdateIDs = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}