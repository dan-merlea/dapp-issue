{"ast":null,"code":"// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n\n'use strict';\n\n/** Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.Request;\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.Response;\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\nu2f.RegisterRequest;\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\nu2f.RegisterResponse;\n\n// Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\nu2f.disconnect = function () {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function (callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function () {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function (callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID, {\n    'includeTlsChannelId': true\n  });\n  setTimeout(function () {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function (port) {\n  this.port_ = port;\n};\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function (message) {\n  this.port_.postMessage(message);\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener = function (eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function (message) {\n      // Emulate a minimal MessageEvent object\n      handler({\n        'data': message\n      });\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function (callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n  var hasCalledBack = false;\n  var channel = new MessageChannel();\n  var ready = function ready(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      if (!hasCalledBack) {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n  iframe.addEventListener('load', function () {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n\n  // Give this 200ms to initialize, after that, we treat this method as failed\n  setTimeout(function () {\n    if (!hasCalledBack) {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n};\n\n// High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function (callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function (err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message', /** @type {function(Event)} */u2f.responseHandler_);\n        }\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length) {\n          u2f.waitingForPort_.shift()(err, port);\n        }\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function (message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\nu2f.isSupported = function (callback) {\n  u2f.getPortSingleton_(function (err, port) {\n    callback(!err);\n  });\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function (signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function (err, port) {\n    if (err) return callback(err);\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function (registerRequests, signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function (err, port) {\n    if (err) return callback(err);\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: typeof opt_timeoutSeconds !== 'undefined' ? opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC,\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};","map":{"version":3,"names":["u2f","module","exports","EXTENSION_ID","MessageTypes","ErrorCodes","Request","Response","Error","SignRequest","SignResponse","RegisterRequest","RegisterResponse","disconnect","port_","getMessagePort","callback","chrome","runtime","msg","type","U2F_SIGN_REQUEST","signRequests","sendMessage","lastError","getChromeRuntimePort_","getIframePort_","port","connect","setTimeout","WrappedChromeRuntimePort_","prototype","postMessage","message","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","error","iframeOrigin","iframe","document","createElement","src","setAttribute","body","appendChild","hasCalledBack","channel","MessageChannel","ready","data","port1","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","length","err","responseHandler_","shift","push","response","reqId","cb","isSupported","sign","opt_timeoutSeconds","req","timeoutSeconds","requestId","register","registerRequests","U2F_REGISTER_REQUEST"],"sources":["/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/u2f-api/lib/google-u2f-api.js"],"sourcesContent":["// Copyright 2014 Google Inc. All rights reserved\n//\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file or at\n// https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n\n'use strict';\n\n/** Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * The U2F extension id\n * @type {string}\n * @const\n */\nu2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n  'U2F_REGISTER_REQUEST': 'u2f_register_request',\n  'U2F_SIGN_REQUEST': 'u2f_sign_request',\n  'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n  'U2F_SIGN_RESPONSE': 'u2f_sign_response'\n};\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n  'OK': 0,\n  'OTHER_ERROR': 1,\n  'BAD_REQUEST': 2,\n  'CONFIGURATION_UNSUPPORTED': 3,\n  'DEVICE_INELIGIBLE': 4,\n  'TIMEOUT': 5\n};\n\n/**\n * A message type for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   signRequests: Array.<u2f.SignRequest>,\n *   registerRequests: ?Array.<u2f.RegisterRequest>,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.Request;\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.Response;\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   appId: string\n * }}\n */\nu2f.RegisterRequest;\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   registrationData: string,\n *   clientData: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n// Low level MessagePort API support\n\n/**\n * Call MessagePort disconnect\n */\nu2f.disconnect = function() {\n  if (u2f.port_ && u2f.port_.port_) {\n    u2f.port_.port_.disconnect();\n    u2f.port_ = null;\n  }\n};\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n    {'includeTlsChannelId': true});\n  setTimeout(function() {\n    callback(null, new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n  this.port_ = port;\n};\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n  this.port_.postMessage(message);\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function(message) {\n      // Emulate a minimal MessageEvent object\n      handler({'data': message});\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n\n  var hasCalledBack = false;\n\n  var channel = new MessageChannel();\n  var ready = function(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      if (!hasCalledBack)\n      {\n        hasCalledBack = true;\n        callback(null, channel.port1);\n      }\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n\n  iframe.addEventListener('load', function() {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n\n  // Give this 200ms to initialize, after that, we treat this method as failed\n  setTimeout(function() {\n    if (!hasCalledBack)\n    {\n      hasCalledBack = true;\n      callback(new Error(\"IFrame extension not supported\"));\n    }\n  }, 200);\n};\n\n\n// High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n  if (u2f.port_) {\n    callback(null, u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function(err, port) {\n        if (!err) {\n          u2f.port_ = port;\n          u2f.port_.addEventListener('message',\n            /** @type {function(Event)} */ (u2f.responseHandler_));\n        }\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length)\n          u2f.waitingForPort_.shift()(err, port);\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(null, response['responseData']);\n};\n\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\nu2f.isSupported = function(callback) {\n  u2f.getPortSingleton_(function(err, port) {\n    callback(!err);\n  });\n}\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(signRequests, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {Array.<u2f.RegisterRequest>} registerRequests\n * @param {Array.<u2f.SignRequest>} signRequests\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(registerRequests, signRequests,\n    callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(err, port) {\n    if (err)\n      return callback(err);\n\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA,IAAIA,GAAG,GAAGA,GAAG,IAAI,CAAC,CAAC;AAEnBC,MAAM,CAACC,OAAO,GAAGF,GAAG,CAAC,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACAA,GAAG,CAACG,YAAY,GAAG,kCAAkC;;AAErD;AACA;AACA;AACA;AACA;AACAH,GAAG,CAACI,YAAY,GAAG;EACjB,sBAAsB,EAAE,sBAAsB;EAC9C,kBAAkB,EAAE,kBAAkB;EACtC,uBAAuB,EAAE,uBAAuB;EAChD,mBAAmB,EAAE;AACvB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAJ,GAAG,CAACK,UAAU,GAAG;EACf,IAAI,EAAE,CAAC;EACP,aAAa,EAAE,CAAC;EAChB,aAAa,EAAE,CAAC;EAChB,2BAA2B,EAAE,CAAC;EAC9B,mBAAmB,EAAE,CAAC;EACtB,SAAS,EAAE;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,GAAG,CAACM,OAAO;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,GAAG,CAACO,QAAQ;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAP,GAAG,CAACQ,KAAK;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,GAAG,CAACS,WAAW;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,GAAG,CAACU,YAAY;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAV,GAAG,CAACW,eAAe;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,GAAG,CAACY,gBAAgB;;AAGpB;;AAEA;AACA;AACA;AACAZ,GAAG,CAACa,UAAU,GAAG,YAAW;EAC1B,IAAIb,GAAG,CAACc,KAAK,IAAId,GAAG,CAACc,KAAK,CAACA,KAAK,EAAE;IAChCd,GAAG,CAACc,KAAK,CAACA,KAAK,CAACD,UAAU,EAAE;IAC5Bb,GAAG,CAACc,KA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"},"metadata":{},"sourceType":"script"}