{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar getBufferType = require('./getBufferType.js');\nvar map = {\n  Float32Array: Float32Array,\n  Uint32Array: Uint32Array,\n  Int32Array: Int32Array,\n  Uint8Array: Uint8Array\n};\nfunction interleaveTypedArrays(arrays, sizes) {\n  var outSize = 0;\n  var stride = 0;\n  var views = {};\n  for (var i = 0; i < arrays.length; i++) {\n    stride += sizes[i];\n    outSize += arrays[i].length;\n  }\n  var buffer = new ArrayBuffer(outSize * 4);\n  var out = null;\n  var littleOffset = 0;\n  for (var _i = 0; _i < arrays.length; _i++) {\n    var size = sizes[_i];\n    var array = arrays[_i];\n    var type = getBufferType.getBufferType(array);\n    if (!views[type]) {\n      views[type] = new map[type](buffer);\n    }\n    out = views[type];\n    for (var j = 0; j < array.length; j++) {\n      var indexStart = (j / size | 0) * stride + littleOffset;\n      var index = j % size;\n      out[indexStart + index] = array[j];\n    }\n    littleOffset += size;\n  }\n  return new Float32Array(buffer);\n}\nexports.interleaveTypedArrays = interleaveTypedArrays;","map":{"version":3,"sources":["../../src/data/interleaveTypedArrays.ts"],"names":["getBufferType"],"mappings":";;;;;;AAGA,IAAM,GAAM,GAAA;EAAE,YAA4B,EAA5B,YAA4B;EAAA,WAAA,EAAA,WAAA;EAA0B,UAAA,EAAA,UAAA;EAAwB,UAAuB,EAAvB;AAAuB,CAAA;AAI5G,SAAA,qBAAA,CAA+B,MAAA,EAAuB,KAC7D,EAAA;EACI,IAAI,OAAU,GAAA,CAAA;EACd,IAAI,MAAS,GAAA,CAAA;EACb,IAAM,KAAA,GAAsC,CAAA,CAAC;EAE7C,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,EAAA;IACI,MAAA,IAAU,KAAM,CAAA,CAAA,CAAA;IAChB,OAAA,IAAW,MAAA,CAAO,CAAG,CAAA,CAAA,MAAA;EAAA;EAGzB,IAAM,MAAS,GAAA,IAAI,WAAY,CAAA,OAAA,GAAU,CAAC,CAAA;EAE1C,IAAI,GAAM,GAAA,IAAA;EACV,IAAI,YAAe,GAAA,CAAA;EAEnB,KAAA,IAAS,EAAI,GAAA,CAAA,EAAG,EAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,EACnC,EAAA,EAAA;IACI,IAAM,IAAA,GAAO,KAAM,CAAA,EAAA,CAAA;IACnB,IAAM,KAAA,GAAQ,MAAO,CAAA,EAAA,CAAA;IAMf,IAAA,IAAA,GAAOA,aAAAA,CAAAA,aAAAA,CAAc,KAAK,CAAA;IAE5B,IAAA,CAAC,KAAA,CAAM,IACX,CAAA,EAAA;MACI,KAAA,CAAM,IAAQ,CAAA,GAAA,IAAI,GAAI,CAAA,IAAA,CAAA,CAAM,MAAM,CAAA;IAAA;IAGtC,GAAA,GAAM,KAAM,CAAA,IAAA,CAAA;IAEZ,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,MAAA,EAAQ,CAClC,EAAA,EAAA;MACI,IAAM,UAAe,GAAA,CAAA,CAAA,GAAI,IAAO,GAAA,CAAA,IAAK,MAAU,GAAA,YAAA;MAC/C,IAAM,KAAA,GAAQ,CAAI,GAAA,IAAA;MAEd,GAAA,CAAA,UAAA,GAAa,KAAA,CAAA,GAAS,KAAM,CAAA,CAAA,CAAA;IAAA;IAGpB,YAAA,IAAA,IAAA;EAAA;EAGb,OAAA,IAAI,YAAA,CAAa,MAAM,CAAA;AAClC","sourcesContent":["import { getBufferType } from './getBufferType';\n\n/* eslint-disable object-shorthand */\nconst map = { Float32Array: Float32Array, Uint32Array: Uint32Array, Int32Array: Int32Array, Uint8Array: Uint8Array };\n\ntype PackedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\nexport function interleaveTypedArrays(arrays: PackedArray[], sizes: number[]): Float32Array\n{\n    let outSize = 0;\n    let stride = 0;\n    const views: {[key: string]: PackedArray} = {};\n\n    for (let i = 0; i < arrays.length; i++)\n    {\n        stride += sizes[i];\n        outSize += arrays[i].length;\n    }\n\n    const buffer = new ArrayBuffer(outSize * 4);\n\n    let out = null;\n    let littleOffset = 0;\n\n    for (let i = 0; i < arrays.length; i++)\n    {\n        const size = sizes[i];\n        const array = arrays[i];\n\n        /*\n        @todo This is unsafe casting but consistent with how the code worked previously. Should it stay this way\n              or should and `getBufferTypeUnsafe` function be exposed that throws an Error if unsupported type is passed?\n         */\n        const type = getBufferType(array) as keyof typeof map;\n\n        if (!views[type])\n        {\n            views[type] = new map[type](buffer);\n        }\n\n        out = views[type];\n\n        for (let j = 0; j < array.length; j++)\n        {\n            const indexStart = ((j / size | 0) * stride) + littleOffset;\n            const index = j % size;\n\n            out[indexStart + index] = array[j];\n        }\n\n        littleOffset += size;\n    }\n\n    return new Float32Array(buffer);\n}\n"]},"metadata":{},"sourceType":"script"}