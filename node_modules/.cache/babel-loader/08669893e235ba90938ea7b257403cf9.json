{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { AbstractMaskSystem } from './AbstractMaskSystem.mjs';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { ExtensionType, extensions } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\nvar tempMatrix = new Matrix();\nvar rectPool = [];\nvar _ScissorSystem = /*#__PURE__*/function (_AbstractMaskSystem) {\n  _inherits(_ScissorSystem, _AbstractMaskSystem);\n  var _super = _createSuper(_ScissorSystem);\n  function _ScissorSystem(renderer) {\n    var _this;\n    _classCallCheck(this, _ScissorSystem);\n    _this = _super.call(this, renderer);\n    _this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n    return _this;\n  }\n  _createClass(_ScissorSystem, [{\n    key: \"getStackLength\",\n    value: function getStackLength() {\n      var maskData = this.maskStack[this.maskStack.length - 1];\n      if (maskData) {\n        return maskData._scissorCounter;\n      }\n      return 0;\n    }\n  }, {\n    key: \"calcScissorRect\",\n    value: function calcScissorRect(maskData) {\n      var _rectPool$pop;\n      if (maskData._scissorRectLocal) {\n        return;\n      }\n      var prevData = maskData._scissorRect;\n      var maskObject = maskData.maskObject;\n      var renderer = this.renderer;\n      var renderTextureSystem = renderer.renderTexture;\n      var rect = maskObject.getBounds(true, (_rectPool$pop = rectPool.pop()) !== null && _rectPool$pop !== void 0 ? _rectPool$pop : new Rectangle());\n      this.roundFrameToPixels(rect, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);\n      if (prevData) {\n        rect.fit(prevData);\n      }\n      maskData._scissorRectLocal = rect;\n    }\n  }, {\n    key: \"testScissor\",\n    value: function testScissor(maskData) {\n      var maskObject = maskData.maskObject;\n      if (!maskObject.isFastRect || !maskObject.isFastRect()) {\n        return false;\n      }\n      if (_ScissorSystem.isMatrixRotated(maskObject.worldTransform)) {\n        return false;\n      }\n      if (_ScissorSystem.isMatrixRotated(this.renderer.projection.transform)) {\n        return false;\n      }\n      this.calcScissorRect(maskData);\n      var rect = maskData._scissorRectLocal;\n      return rect.width > 0 && rect.height > 0;\n    }\n  }, {\n    key: \"roundFrameToPixels\",\n    value: function roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {\n      if (_ScissorSystem.isMatrixRotated(transform)) {\n        return;\n      }\n      transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n      transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n      this.renderer.filter.transformAABB(transform, frame);\n      frame.fit(bindingDestinationFrame);\n      frame.x = Math.round(frame.x * resolution);\n      frame.y = Math.round(frame.y * resolution);\n      frame.width = Math.round(frame.width * resolution);\n      frame.height = Math.round(frame.height * resolution);\n    }\n  }, {\n    key: \"push\",\n    value: function push(maskData) {\n      if (!maskData._scissorRectLocal) {\n        this.calcScissorRect(maskData);\n      }\n      var gl = this.renderer.gl;\n      if (!maskData._scissorRect) {\n        gl.enable(gl.SCISSOR_TEST);\n      }\n      maskData._scissorCounter++;\n      maskData._scissorRect = maskData._scissorRectLocal;\n      this._useCurrent();\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(maskData) {\n      var gl = this.renderer.gl;\n      if (maskData) {\n        rectPool.push(maskData._scissorRectLocal);\n      }\n      if (this.getStackLength() > 0) {\n        this._useCurrent();\n      } else {\n        gl.disable(gl.SCISSOR_TEST);\n      }\n    }\n  }, {\n    key: \"_useCurrent\",\n    value: function _useCurrent() {\n      var rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n      var y;\n      if (this.renderer.renderTexture.current) {\n        y = rect.y;\n      } else {\n        y = this.renderer.height - rect.height - rect.y;\n      }\n      this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n    }\n  }], [{\n    key: \"isMatrixRotated\",\n    value: function isMatrixRotated(matrix) {\n      if (!matrix) {\n        return false;\n      }\n      var a = matrix.a,\n        b = matrix.b,\n        c = matrix.c,\n        d = matrix.d;\n      return (Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4);\n    }\n  }]);\n  return _ScissorSystem;\n}(AbstractMaskSystem);\nvar ScissorSystem = _ScissorSystem;\nScissorSystem.extension = {\n  type: ExtensionType.RendererSystem,\n  name: \"scissor\"\n};\nextensions.add(ScissorSystem);\nexport { ScissorSystem };","map":{"version":3,"sources":["../../src/mask/ScissorSystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractMaskSystem } from './AbstractMaskSystem';\n\nimport type { Renderer } from '../Renderer';\nimport type { MaskData } from './MaskData';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\n\nconst tempMatrix = new Matrix();\nconst rectPool: Rectangle[] = [];\n\n/**\n * System plugin to the renderer to manage scissor masking.\n *\n * Scissor masking discards pixels outside of a rectangle called the scissor box. The scissor box is in the framebuffer\n * viewport's space; however, the mask's rectangle is projected from world-space to viewport space automatically\n * by this system.\n * @memberof PIXI\n */\nexport class ScissorSystem extends AbstractMaskSystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'scissor',\n    };\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        this.glConst = settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;\n    }\n\n    getStackLength(): number\n    {\n        const maskData = this.maskStack[this.maskStack.length - 1];\n\n        if (maskData)\n        {\n            return maskData._scissorCounter;\n        }\n\n        return 0;\n    }\n\n    /**\n     * evaluates _boundsTransformed, _scissorRect for MaskData\n     * @param maskData\n     */\n    calcScissorRect(maskData: MaskData): void\n    {\n        if (maskData._scissorRectLocal)\n        {\n            return;\n        }\n\n        const prevData = maskData._scissorRect;\n        const { maskObject } = maskData;\n        const { renderer } = this;\n        const renderTextureSystem = renderer.renderTexture;\n        const rect = maskObject.getBounds(true, rectPool.pop() ?? new Rectangle());\n\n        this.roundFrameToPixels(rect,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform);\n\n        if (prevData)\n        {\n            rect.fit(prevData);\n        }\n        maskData._scissorRectLocal = rect;\n    }\n\n    private static isMatrixRotated(matrix: Matrix)\n    {\n        if (!matrix)\n        {\n            return false;\n        }\n        const { a, b, c, d } = matrix;\n\n        // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n        // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n        return ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n            && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4));\n    }\n\n    /**\n     * Test, whether the object can be scissor mask with current renderer projection.\n     * Calls \"calcScissorRect()\" if its true.\n     * @param maskData - mask data\n     * @returns whether Whether the object can be scissor mask\n     */\n    public testScissor(maskData: MaskData): boolean\n    {\n        const { maskObject } = maskData;\n\n        if (!maskObject.isFastRect || !maskObject.isFastRect())\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(maskObject.worldTransform))\n        {\n            return false;\n        }\n        if (ScissorSystem.isMatrixRotated(this.renderer.projection.transform))\n        {\n            return false;\n        }\n\n        this.calcScissorRect(maskData);\n\n        const rect = maskData._scissorRectLocal;\n\n        return rect.width > 0 && rect.height > 0;\n    }\n\n    private roundFrameToPixels(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix,\n    )\n    {\n        if (ScissorSystem.isMatrixRotated(transform))\n        {\n            return;\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        (this.renderer.filter as any).transformAABB(transform, frame);\n\n        frame.fit(bindingDestinationFrame);\n        frame.x = Math.round(frame.x * resolution);\n        frame.y = Math.round(frame.y * resolution);\n        frame.width = Math.round(frame.width * resolution);\n        frame.height = Math.round(frame.height * resolution);\n    }\n\n    /**\n     * Applies the Mask and adds it to the current stencil stack.\n     * @author alvin\n     * @param maskData - The mask data.\n     */\n    push(maskData: MaskData): void\n    {\n        if (!maskData._scissorRectLocal)\n        {\n            this.calcScissorRect(maskData);\n        }\n\n        const { gl } = this.renderer;\n\n        if (!maskData._scissorRect)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        maskData._scissorCounter++;\n        maskData._scissorRect = maskData._scissorRectLocal;\n        this._useCurrent();\n    }\n\n    /**\n     * This should be called after a mask is popped off the mask stack. It will rebind the scissor box to be latest with the\n     * last mask in the stack.\n     *\n     * This can also be called when you directly modify the scissor box and want to restore PixiJS state.\n     * @param maskData - The mask data.\n     */\n    pop(maskData?: MaskData): void\n    {\n        const { gl } = this.renderer;\n\n        if (maskData)\n        {\n            rectPool.push(maskData._scissorRectLocal);\n        }\n\n        if (this.getStackLength() > 0)\n        {\n            this._useCurrent();\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n    }\n\n    /**\n     * Setup renderer to use the current scissor data.\n     * @private\n     */\n    _useCurrent(): void\n    {\n        const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;\n        let y: number;\n\n        if (this.renderer.renderTexture.current)\n        {\n            y = rect.y;\n        }\n        else\n        {\n            // flipY. In future we'll have it over renderTextures as an option\n            y = this.renderer.height - rect.height - rect.y;\n        }\n\n        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);\n    }\n}\n\nextensions.add(ScissorSystem);\n"]},"metadata":{},"sourceType":"module"}