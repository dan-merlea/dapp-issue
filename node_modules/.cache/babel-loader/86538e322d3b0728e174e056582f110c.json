{"ast":null,"code":"var INSTALLED = [];\nfunction autoDetectResource(source, options) {\n  if (!source) {\n    return null;\n  }\n  var extension = \"\";\n  if (typeof source === \"string\") {\n    var result = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(source);\n    if (result) {\n      extension = result[1].toLowerCase();\n    }\n  }\n  for (var i = INSTALLED.length - 1; i >= 0; --i) {\n    var ResourcePlugin = INSTALLED[i];\n    if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {\n      return new ResourcePlugin(source, options);\n    }\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\nexport { INSTALLED, autoDetectResource };","map":{"version":3,"sources":["../../../src/textures/resources/autoDetectResource.ts"],"names":[],"mappings":"AA0DO,IAAM,SAAA,GAA8C,EAAA;AAgCpD,SAAA,kBAAA,CAAoD,MAAA,EAAiB,OAC5E,EAAA;EACI,IAAI,CAAC,MACL,EAAA;IACW,OAAA,IAAA;EAAA;EAGX,IAAI,SAAY,GAAA,EAAA;EAEZ,IAAA,OAAO,MAAA,KAAW,QACtB,EAAA;IAEU,IAAA,MAAA,GAAU,wBAA0B,CAAA,IAAA,CAAK,MAAM,CAAA;IAErD,IAAI,MACJ,EAAA;MACgB,SAAA,GAAA,MAAA,CAAO,CAAA,CAAA,CAAG,WAAY,EAAA;IAAA;EACtC;EAGJ,KAAA,IAAS,CAAA,GAAI,SAAU,CAAA,MAAA,GAAS,CAAA,EAAG,CAAK,IAAA,CAAA,EAAG,EAAE,CAC7C,EAAA;IACI,IAAM,cAAA,GAAiB,SAAU,CAAA,CAAA,CAAA;IAEjC,IAAI,cAAA,CAAe,IAAQ,IAAA,cAAA,CAAe,IAAK,CAAA,MAAA,EAAQ,SAAS,CAChE,EAAA;MACW,OAAA,IAAI,cAAe,CAAA,MAAA,EAAQ,OAAO,CAAA;IAAA;EAC7C;EAGE,MAAA,IAAI,KAAA,CAAM,kDAAkD,CAAA;AACtE","sourcesContent":["import type { Resource } from './Resource';\n\nimport type { IImageResourceOptions } from './ImageResource';\nimport type { ISize } from '@pixi/math';\nimport type { ICubeResourceOptions } from './CubeResource';\nimport type { ISVGResourceOptions } from './SVGResource';\nimport type { IVideoResourceOptions } from './VideoResource';\n\n/*\n * Allow flexible options for resource plugins\n */\nexport type IResourcePluginOptions = { [key: string]: any };\n\n/*\n * All allowable options for autoDetectResource\n */\nexport type IAutoDetectOptions = ISize\n| ICubeResourceOptions\n| IImageResourceOptions\n| ISVGResourceOptions\n| IVideoResourceOptions\n| IResourcePluginOptions;\n\n/**\n * Shape of supported resource plugins\n * @memberof PIXI\n */\nexport interface IResourcePlugin<R, RO>\n{\n    test(source: unknown, extension: string): boolean;\n    new (source: any, options?: RO): R;\n}\n\n/**\n * Collection of installed resource types, class must extend {@link PIXI.Resource}.\n * @example\n * class CustomResource extends PIXI.Resource {\n *     // MUST have source, options constructor signature\n *     // for auto-detected resources to be created.\n *     constructor(source, options) {\n *         super();\n *     }\n *     upload(renderer, baseTexture, glTexture) {\n *         // Upload with GL\n *         return true;\n *     }\n *     // Used to auto-detect resource\n *     static test(source, extension) {\n *         return extension === 'xyz' || source instanceof SomeClass;\n *     }\n * }\n * // Install the new resource type\n * PIXI.INSTALLED.push(CustomResource);\n * @memberof PIXI\n * @type {Array<PIXI.IResourcePlugin>}\n * @static\n * @readonly\n */\nexport const INSTALLED: Array<IResourcePlugin<any, any>> = [];\n\n/**\n * Create a resource element from a single source element. This\n * auto-detects which type of resource to create. All resources that\n * are auto-detectable must have a static `test` method and a constructor\n * with the arguments `(source, options?)`. Currently, the supported\n * resources for auto-detection include:\n *  - {@link PIXI.ImageResource}\n *  - {@link PIXI.CanvasResource}\n *  - {@link PIXI.VideoResource}\n *  - {@link PIXI.SVGResource}\n *  - {@link PIXI.BufferResource}\n * @static\n * @memberof PIXI\n * @function autoDetectResource\n * @param {string|*} source - Resource source, this can be the URL to the resource,\n *        a typed-array (for BufferResource), HTMLVideoElement, SVG data-uri\n *        or any other resource that can be auto-detected. If not resource is\n *        detected, it's assumed to be an ImageResource.\n * @param {object} [options] - Pass-through options to use for Resource\n * @param {number} [options.width] - Width of BufferResource or SVG rasterization\n * @param {number} [options.height] - Height of BufferResource or SVG rasterization\n * @param {boolean} [options.autoLoad=true] - Image, SVG and Video flag to start loading\n * @param {number} [options.scale=1] - SVG source scale. Overridden by width, height\n * @param {boolean} [options.createBitmap=PIXI.settings.CREATE_IMAGE_BITMAP] - Image option to create Bitmap object\n * @param {boolean} [options.crossorigin=true] - Image and Video option to set crossOrigin\n * @param {boolean} [options.autoPlay=true] - Video option to start playing video immediately\n * @param {number} [options.updateFPS=0] - Video option to update how many times a second the\n *        texture should be updated from the video. Leave at 0 to update at every render\n * @returns {PIXI.Resource} The created resource.\n */\nexport function autoDetectResource<R extends Resource, RO>(source: unknown, options?: RO): R\n{\n    if (!source)\n    {\n        return null;\n    }\n\n    let extension = '';\n\n    if (typeof source === 'string')\n    {\n        // search for file extension: period, 3-4 chars, then ?, # or EOL\n        const result = (/\\.(\\w{3,4})(?:$|\\?|#)/i).exec(source);\n\n        if (result)\n        {\n            extension = result[1].toLowerCase();\n        }\n    }\n\n    for (let i = INSTALLED.length - 1; i >= 0; --i)\n    {\n        const ResourcePlugin = INSTALLED[i] as IResourcePlugin<R, RO>;\n\n        if (ResourcePlugin.test && ResourcePlugin.test(source, extension))\n        {\n            return new ResourcePlugin(source, options);\n        }\n    }\n\n    throw new Error('Unrecognized source type to auto-detect Resource');\n}\n"]},"metadata":{},"sourceType":"module"}