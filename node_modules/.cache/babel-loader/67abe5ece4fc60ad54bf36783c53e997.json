{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { COLLISION_TYPES } from './types';\nimport { RectangleBody } from '../geometry';\nimport { circleToRectangleSide, rectangleToRectangleSide } from '.';\nimport RBush from 'rbush';\n/**\n * A R-Tree implementation handling Rectangle and Circle bodies\n */\nexport var TreeCollider = /*#__PURE__*/function (_RBush) {\n  _inherits(TreeCollider, _RBush);\n  var _super = _createSuper(TreeCollider);\n  function TreeCollider() {\n    _classCallCheck(this, TreeCollider);\n    return _super.apply(this, arguments);\n  }\n  _createClass(TreeCollider, [{\n    key: \"collidesWithRectangle\",\n    value:\n    // Collisions\n    function collidesWithRectangle(body, type) {\n      // If no collision type is specified, we just proceed with default\n      if (!type) {\n        return this.collides({\n          minX: body.left,\n          minY: body.top,\n          maxX: body.right,\n          maxY: body.bottom\n        });\n      }\n      var leaves = this.searchWithRectangle(body);\n      if (!leaves || !leaves.length) {\n        return false;\n      }\n      var _iterator = _createForOfIteratorHelper(leaves),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var wall = _step.value;\n          if (wall.collider === 'full') {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"collidesWithCircle\",\n    value: function collidesWithCircle(body, type) {\n      // If no collision type is specified, we just proceed with default\n      if (!type) {\n        return this.collides({\n          minX: body.left,\n          minY: body.top,\n          maxX: body.right,\n          maxY: body.bottom\n        });\n      }\n      var leaves = this.searchWithCircle(body);\n      if (!leaves || !leaves.length) {\n        return false;\n      }\n      var _iterator2 = _createForOfIteratorHelper(leaves),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var wall = _step2.value;\n          if (wall.collider === 'full') {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return false;\n    }\n    // Searches\n  }, {\n    key: \"searchWithRectangle\",\n    value: function searchWithRectangle(body) {\n      return this.search({\n        minX: body.left,\n        minY: body.top,\n        maxX: body.right,\n        maxY: body.bottom\n      });\n    }\n  }, {\n    key: \"searchWithCircle\",\n    value: function searchWithCircle(body) {\n      return this.search({\n        minX: body.left,\n        minY: body.top,\n        maxX: body.right,\n        maxY: body.bottom\n      });\n    }\n    // Corrects\n  }, {\n    key: \"correctWithRectangle\",\n    value: function correctWithRectangle(body) {\n      var leaves = this.searchWithRectangle(body);\n      if (!leaves || !leaves.length) {\n        return body;\n      }\n      var updatedBody = body.copy();\n      var leafBody = new RectangleBody(0, 0, 0, 0);\n      var _iterator3 = _createForOfIteratorHelper(leaves),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var wall = _step3.value;\n          if (!wall.collider || !COLLISION_TYPES.includes(wall.collider)) {\n            continue;\n          }\n          leafBody.x = wall.minX;\n          leafBody.y = wall.minY;\n          leafBody.width = wall.maxX - wall.minX;\n          leafBody.height = wall.maxY - wall.minY;\n          var side = rectangleToRectangleSide(updatedBody, leafBody);\n          switch (side) {\n            case 'left':\n              updatedBody.right = leafBody.left;\n              break;\n            case 'top':\n              updatedBody.bottom = leafBody.top;\n              break;\n            case 'right':\n              updatedBody.left = leafBody.right;\n              break;\n            case 'bottom':\n              updatedBody.top = leafBody.bottom;\n              break;\n            default:\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return updatedBody;\n    }\n  }, {\n    key: \"correctWithCircle\",\n    value: function correctWithCircle(body) {\n      var leaves = this.searchWithCircle(body);\n      if (!leaves || !leaves.length) {\n        return body;\n      }\n      var updatedBody = body.copy();\n      var leafBody = new RectangleBody(0, 0, 0, 0);\n      var _iterator4 = _createForOfIteratorHelper(leaves),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var wall = _step4.value;\n          if (!wall.collider || !COLLISION_TYPES.includes(wall.collider)) {\n            continue;\n          }\n          leafBody.x = wall.minX;\n          leafBody.y = wall.minY;\n          leafBody.width = wall.maxX - wall.minX;\n          leafBody.height = wall.maxY - wall.minY;\n          var side = circleToRectangleSide(body, leafBody);\n          switch (side) {\n            case 'left':\n              updatedBody.right = leafBody.left;\n              break;\n            case 'top':\n              updatedBody.bottom = leafBody.top;\n              break;\n            case 'right':\n              updatedBody.left = leafBody.right;\n              break;\n            case 'bottom':\n              updatedBody.top = leafBody.bottom;\n              break;\n            default:\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return updatedBody;\n    }\n    // Getters\n  }, {\n    key: \"getAllByType\",\n    value: function getAllByType(type) {\n      var walls = this.all();\n      var filtered = walls.filter(function (wall) {\n        return wall.type === type;\n      });\n      var mapped = filtered.map(function (wall) {\n        return new RectangleBody(wall.minX, wall.minY, wall.maxX, wall.maxY);\n      });\n      return mapped;\n    }\n  }]);\n  return TreeCollider;\n}(RBush);","map":{"version":3,"names":["COLLISION_TYPES","RectangleBody","circleToRectangleSide","rectangleToRectangleSide","RBush","TreeCollider","body","type","collides","minX","left","minY","top","maxX","right","maxY","bottom","leaves","searchWithRectangle","length","wall","collider","searchWithCircle","search","updatedBody","copy","leafBody","includes","x","y","width","height","side","walls","all","filtered","filter","mapped","map"],"sources":["/Users/merlea/Development/Crypto/Krogan/kroganverse-com/packages/common/build/collisions/collisions.js"],"sourcesContent":["import { COLLISION_TYPES } from './types';\nimport { RectangleBody } from '../geometry';\nimport { circleToRectangleSide, rectangleToRectangleSide } from '.';\nimport RBush from 'rbush';\n/**\n * A R-Tree implementation handling Rectangle and Circle bodies\n */\nexport class TreeCollider extends RBush {\n    // Collisions\n    collidesWithRectangle(body, type) {\n        // If no collision type is specified, we just proceed with default\n        if (!type) {\n            return this.collides({\n                minX: body.left,\n                minY: body.top,\n                maxX: body.right,\n                maxY: body.bottom,\n            });\n        }\n        const leaves = this.searchWithRectangle(body);\n        if (!leaves || !leaves.length) {\n            return false;\n        }\n        for (const wall of leaves) {\n            if (wall.collider === 'full') {\n                return true;\n            }\n        }\n        return false;\n    }\n    collidesWithCircle(body, type) {\n        // If no collision type is specified, we just proceed with default\n        if (!type) {\n            return this.collides({\n                minX: body.left,\n                minY: body.top,\n                maxX: body.right,\n                maxY: body.bottom,\n            });\n        }\n        const leaves = this.searchWithCircle(body);\n        if (!leaves || !leaves.length) {\n            return false;\n        }\n        for (const wall of leaves) {\n            if (wall.collider === 'full') {\n                return true;\n            }\n        }\n        return false;\n    }\n    // Searches\n    searchWithRectangle(body) {\n        return this.search({\n            minX: body.left,\n            minY: body.top,\n            maxX: body.right,\n            maxY: body.bottom,\n        });\n    }\n    searchWithCircle(body) {\n        return this.search({\n            minX: body.left,\n            minY: body.top,\n            maxX: body.right,\n            maxY: body.bottom,\n        });\n    }\n    // Corrects\n    correctWithRectangle(body) {\n        const leaves = this.searchWithRectangle(body);\n        if (!leaves || !leaves.length) {\n            return body;\n        }\n        const updatedBody = body.copy();\n        const leafBody = new RectangleBody(0, 0, 0, 0);\n        for (const wall of leaves) {\n            if (!wall.collider || !COLLISION_TYPES.includes(wall.collider)) {\n                continue;\n            }\n            leafBody.x = wall.minX;\n            leafBody.y = wall.minY;\n            leafBody.width = wall.maxX - wall.minX;\n            leafBody.height = wall.maxY - wall.minY;\n            const side = rectangleToRectangleSide(updatedBody, leafBody);\n            switch (side) {\n                case 'left':\n                    updatedBody.right = leafBody.left;\n                    break;\n                case 'top':\n                    updatedBody.bottom = leafBody.top;\n                    break;\n                case 'right':\n                    updatedBody.left = leafBody.right;\n                    break;\n                case 'bottom':\n                    updatedBody.top = leafBody.bottom;\n                    break;\n                default:\n                    break;\n            }\n        }\n        return updatedBody;\n    }\n    correctWithCircle(body) {\n        const leaves = this.searchWithCircle(body);\n        if (!leaves || !leaves.length) {\n            return body;\n        }\n        const updatedBody = body.copy();\n        const leafBody = new RectangleBody(0, 0, 0, 0);\n        for (const wall of leaves) {\n            if (!wall.collider || !COLLISION_TYPES.includes(wall.collider)) {\n                continue;\n            }\n            leafBody.x = wall.minX;\n            leafBody.y = wall.minY;\n            leafBody.width = wall.maxX - wall.minX;\n            leafBody.height = wall.maxY - wall.minY;\n            const side = circleToRectangleSide(body, leafBody);\n            switch (side) {\n                case 'left':\n                    updatedBody.right = leafBody.left;\n                    break;\n                case 'top':\n                    updatedBody.bottom = leafBody.top;\n                    break;\n                case 'right':\n                    updatedBody.left = leafBody.right;\n                    break;\n                case 'bottom':\n                    updatedBody.top = leafBody.bottom;\n                    break;\n                default:\n                    break;\n            }\n        }\n        return updatedBody;\n    }\n    // Getters\n    getAllByType(type) {\n        const walls = this.all();\n        const filtered = walls.filter((wall) => wall.type === type);\n        const mapped = filtered.map((wall) => new RectangleBody(wall.minX, wall.minY, wall.maxX, wall.maxY));\n        return mapped;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}