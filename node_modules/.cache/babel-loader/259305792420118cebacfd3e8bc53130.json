{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nrequire('./utils/index.js');\nvar utils = require('@pixi/utils');\nvar defaultProgram$1 = require('./defaultProgram.js');\nvar defaultProgram = require('./defaultProgram2.js');\nvar settings = require('@pixi/settings');\nvar constants = require('@pixi/constants');\nvar setPrecision = require('./utils/setPrecision.js');\nvar getMaxFragmentPrecision = require('./utils/getMaxFragmentPrecision.js');\nvar UID = 0;\nvar nameCache = {};\nvar Program = /*#__PURE__*/function () {\n  function Program(vertexSrc, fragmentSrc) {\n    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"pixi-shader\";\n    var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, Program);\n    this.extra = {};\n    this.id = UID++;\n    this.vertexSrc = vertexSrc || Program.defaultVertexSrc;\n    this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;\n    this.vertexSrc = this.vertexSrc.trim();\n    this.fragmentSrc = this.fragmentSrc.trim();\n    this.extra = extra;\n    if (this.vertexSrc.substring(0, 8) !== \"#version\") {\n      name = name.replace(/\\s+/g, \"-\");\n      if (nameCache[name]) {\n        nameCache[name]++;\n        name += \"-\".concat(nameCache[name]);\n      } else {\n        nameCache[name] = 1;\n      }\n      this.vertexSrc = \"#define SHADER_NAME \".concat(name, \"\\n\").concat(this.vertexSrc);\n      this.fragmentSrc = \"#define SHADER_NAME \".concat(name, \"\\n\").concat(this.fragmentSrc);\n      this.vertexSrc = setPrecision.setPrecision(this.vertexSrc, settings.settings.PRECISION_VERTEX, constants.PRECISION.HIGH);\n      this.fragmentSrc = setPrecision.setPrecision(this.fragmentSrc, settings.settings.PRECISION_FRAGMENT, getMaxFragmentPrecision.getMaxFragmentPrecision());\n    }\n    this.glPrograms = {};\n    this.syncUniforms = null;\n  }\n  _createClass(Program, null, [{\n    key: \"defaultVertexSrc\",\n    get: function get() {\n      return defaultProgram[\"default\"];\n    }\n  }, {\n    key: \"defaultFragmentSrc\",\n    get: function get() {\n      return defaultProgram$1[\"default\"];\n    }\n  }, {\n    key: \"from\",\n    value: function from(vertexSrc, fragmentSrc, name) {\n      var key = vertexSrc + fragmentSrc;\n      var program = utils.ProgramCache[key];\n      if (!program) {\n        utils.ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);\n      }\n      return program;\n    }\n  }]);\n  return Program;\n}();\nexports.Program = Program;","map":{"version":3,"sources":["../../src/shader/Program.ts"],"names":["setPrecision","settings","PRECISION","getMaxFragmentPrecision","ProgramCache"],"mappings":";;;;;;;;;;;;;;;AAUA,IAAI,GAAM,GAAA,CAAA;AAEV,IAAM,SAAA,GAAuC,CAAA,CAAC;AAAA,IAgCjC,OACb;EA2BI,iBAAY,SAAoB,EAAA,WAAA,EAChC;IAAA,IADsD,IAAA,uEAAO,aAAe;IAAA,IAAA,KAAA,uEAA2B,CAAA,CACvG;IAAA;IATA,IAAA,CAAA,KAAA,GAA2B,CAAA,CAAC;IAUxB,IAAA,CAAK,EAAK,GAAA,GAAA,EAAA;IACL,IAAA,CAAA,SAAA,GAAY,SAAA,IAAa,OAAQ,CAAA,gBAAA;IACjC,IAAA,CAAA,WAAA,GAAc,WAAA,IAAe,OAAQ,CAAA,kBAAA;IAErC,IAAA,CAAA,SAAA,GAAY,IAAK,CAAA,SAAA,CAAU,IAAK,EAAA;IAChC,IAAA,CAAA,WAAA,GAAc,IAAK,CAAA,WAAA,CAAY,IAAK,EAAA;IAEzC,IAAA,CAAK,KAAQ,GAAA,KAAA;IAEb,IAAI,IAAA,CAAK,SAAU,CAAA,SAAA,CAAU,CAAG,EAAA,CAAC,CAAA,KAAM,UACvC,EAAA;MACW,IAAA,GAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,EAAQ,GAAG,CAAA;MAE/B,IAAI,SAAA,CAAU,IACd,CAAA,EAAA;QACc,SAAA,CAAA,IAAA,CAAA,EAAA;QACV,IAAA,eAAY,SAAU,CAAA,IAAA,CAAA,CAAA;MAAA,CAG1B,MAAA;QACI,SAAA,CAAU,IAAQ,CAAA,GAAA,CAAA;MAAA;MAGtB,IAAA,CAAK,SAAA,iCAAmC,IAAA,eAAS,IAAK,CAAA,SAAA,CAAA;MACtD,IAAA,CAAK,WAAA,iCAAqC,IAAA,eAAS,IAAK,CAAA,WAAA,CAAA;MAExD,IAAA,CAAK,SAAA,GAAYA,YAAAA,CAAAA,YAAa,CAAA,IAAA,CAAK,SAAA,EAAWC,QAAAA,CAAAA,QAAS,CAAA,gBAAA,EAAkBC,SAAAA,CAAAA,SAAAA,CAAU,IAAI,CAAA;MACvF,IAAA,CAAK,WAAA,GAAcF,YAAAA,CAAAA,YAAa,CAAA,IAAA,CAAK,WAAA,EAAaC,QAAAA,CAAAA,QAAS,CAAA,kBAAA,EAAoBE,uBAAAA,CAAAA,uBAAAA,EAAyB,CAAA;IAAA;IAK5G,IAAA,CAAK,UAAA,GAAa,CAAA,CAAC;IAEnB,IAAA,CAAK,YAAe,GAAA,IAAA;EAAA;EACxB;IAAA;IAAA,KAMA,eACA;MACW,OAAA,cAAA,CAAA,SAAA,CAAA;IAAA;EACX;IAAA;IAAA,KAMA,eACA;MACW,OAAA,gBAAA,CAAA,SAAA,CAAA;IAAA;EACX;IAAA;IAAA,OAWA,cAAY,SAAoB,EAAA,WAAA,EAAsB,IACtD,EAAA;MACI,IAAM,GAAA,GAAM,SAAY,GAAA,WAAA;MAExB,IAAI,OAAA,GAAUC,KAAAA,CAAAA,YAAa,CAAA,GAAA,CAAA;MAE3B,IAAI,CAAC,OACL,EAAA;QACI,KAAA,CAAA,YAAA,CAAa,GAAA,CAAA,GAAO,OAAU,GAAA,IAAI,OAAQ,CAAA,SAAA,EAAW,WAAA,EAAa,IAAI,CAAA;MAAA;MAGnE,OAAA,OAAA;IAAA;EACX;EAAA;AAAA","sourcesContent":["import { setPrecision,\n    getMaxFragmentPrecision } from './utils';\nimport { ProgramCache } from '@pixi/utils';\nimport defaultFragment from './defaultProgram.frag';\nimport defaultVertex from './defaultProgram.vert';\nimport { settings } from '@pixi/settings';\nimport { PRECISION } from '@pixi/constants';\n\nimport type { GLProgram } from './GLProgram';\n\nlet UID = 0;\n\nconst nameCache: { [key: string]: number } = {};\n\nexport interface IAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface IUniformData\n{\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n    name: string;\n}\n\nexport interface IProgramExtraData\n{\n    transformFeedbackVaryings?: {\n        names: string[],\n        bufferMode: 'separate' | 'interleaved'\n    }\n}\n\n/**\n * Helper class to create a shader program.\n * @memberof PIXI\n */\nexport class Program\n{\n    public id: number;\n\n    /** Source code for the vertex shader. */\n    public vertexSrc: string;\n\n    /** Source code for the fragment shader. */\n    public fragmentSrc: string;\n\n    nameCache: any;\n    glPrograms: { [ key: number ]: GLProgram};\n    syncUniforms: any;\n\n    /** Assigned when a program is first bound to the shader system. */\n    attributeData: { [key: string]: IAttributeData};\n\n    /** Assigned when a program is first bound to the shader system. */\n    uniformData: {[key: string]: IUniformData};\n\n    extra: IProgramExtraData = {};\n\n    /**\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param name - Name for shader\n     * @param extra - Extra data for shader\n     */\n    constructor(vertexSrc?: string, fragmentSrc?: string, name = 'pixi-shader', extra: IProgramExtraData = {})\n    {\n        this.id = UID++;\n        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;\n        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;\n\n        this.vertexSrc = this.vertexSrc.trim();\n        this.fragmentSrc = this.fragmentSrc.trim();\n\n        this.extra = extra;\n\n        if (this.vertexSrc.substring(0, 8) !== '#version')\n        {\n            name = name.replace(/\\s+/g, '-');\n\n            if (nameCache[name])\n            {\n                nameCache[name]++;\n                name += `-${nameCache[name]}`;\n            }\n            else\n            {\n                nameCache[name] = 1;\n            }\n\n            this.vertexSrc = `#define SHADER_NAME ${name}\\n${this.vertexSrc}`;\n            this.fragmentSrc = `#define SHADER_NAME ${name}\\n${this.fragmentSrc}`;\n\n            this.vertexSrc = setPrecision(this.vertexSrc, settings.PRECISION_VERTEX, PRECISION.HIGH);\n            this.fragmentSrc = setPrecision(this.fragmentSrc, settings.PRECISION_FRAGMENT, getMaxFragmentPrecision());\n        }\n\n        // currently this does not extract structs only default types\n        // this is where we store shader references..\n        this.glPrograms = {};\n\n        this.syncUniforms = null;\n    }\n\n    /**\n     * The default vertex shader source.\n     * @constant\n     */\n    static get defaultVertexSrc(): string\n    {\n        return defaultVertex;\n    }\n\n    /**\n     * The default fragment shader source.\n     * @constant\n     */\n    static get defaultFragmentSrc(): string\n    {\n        return defaultFragment;\n    }\n\n    /**\n     * A short hand function to create a program based of a vertex and fragment shader.\n     *\n     * This method will also check to see if there is a cached program.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param name - Name for shader\n     * @returns A shiny new PixiJS shader program!\n     */\n    static from(vertexSrc?: string, fragmentSrc?: string, name?: string): Program\n    {\n        const key = vertexSrc + fragmentSrc;\n\n        let program = ProgramCache[key];\n\n        if (!program)\n        {\n            ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);\n        }\n\n        return program;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}