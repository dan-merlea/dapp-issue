{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar storedGl;\nvar extensions;\nfunction getCompressedTextureExtensions() {\n  extensions = {\n    s3tc: storedGl.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n    s3tc_sRGB: storedGl.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n    etc: storedGl.getExtension(\"WEBGL_compressed_texture_etc\"),\n    etc1: storedGl.getExtension(\"WEBGL_compressed_texture_etc1\"),\n    pvrtc: storedGl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || storedGl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n    atc: storedGl.getExtension(\"WEBGL_compressed_texture_atc\"),\n    astc: storedGl.getExtension(\"WEBGL_compressed_texture_astc\")\n  };\n}\nvar detectCompressedTextures = {\n  extension: {\n    type: core.ExtensionType.DetectionParser,\n    priority: 2\n  },\n  test: function () {\n    var _test = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var canvas, gl;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              canvas = core.settings.ADAPTER.createCanvas();\n              gl = canvas.getContext(\"webgl\");\n              if (gl) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", false);\n            case 4:\n              storedGl = gl;\n              return _context.abrupt(\"return\", true);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    function test() {\n      return _test.apply(this, arguments);\n    }\n    return test;\n  }(),\n  add: function () {\n    var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(formats) {\n      var textureFormats, extensionName, extension;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!extensions) getCompressedTextureExtensions();\n              textureFormats = [];\n              _context2.t0 = _regeneratorRuntime().keys(extensions);\n            case 3:\n              if ((_context2.t1 = _context2.t0()).done) {\n                _context2.next = 11;\n                break;\n              }\n              extensionName = _context2.t1.value;\n              extension = extensions[extensionName];\n              if (extension) {\n                _context2.next = 8;\n                break;\n              }\n              return _context2.abrupt(\"continue\", 3);\n            case 8:\n              textureFormats.push(extensionName);\n              _context2.next = 3;\n              break;\n            case 11:\n              return _context2.abrupt(\"return\", [].concat(textureFormats, _toConsumableArray(formats)));\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    function add(_x) {\n      return _add.apply(this, arguments);\n    }\n    return add;\n  }(),\n  remove: function () {\n    var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(formats) {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!extensions) getCompressedTextureExtensions();\n              return _context3.abrupt(\"return\", formats.filter(function (f) {\n                return !(f in extensions);\n              }));\n            case 2:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    function remove(_x2) {\n      return _remove.apply(this, arguments);\n    }\n    return remove;\n  }()\n};\ncore.extensions.add(detectCompressedTextures);\nexports.detectCompressedTextures = detectCompressedTextures;","map":{"version":3,"sources":["../../src/loaders/detectCompressedTextures.ts"],"names":["ExtensionType","settings","ext"],"mappings":";;;;;;;;;AAKA,IAAI,QAAA;AACJ,IAAI,UAAA;AAEJ,SACA,8BAAA,GAAA;EACiB,UAAA,GAAA;IACT,IAAA,EAAM,QAAS,CAAA,YAAA,CAAa,+BAA+B,CAAA;IAC3D,SAAA,EAAW,QAAS,CAAA,YAAA,CAAa,oCAAoC,CAAA;IACrE,GAAA,EAAK,QAAS,CAAA,YAAA,CAAa,8BAA8B,CAAA;IACzD,IAAA,EAAM,QAAS,CAAA,YAAA,CAAa,+BAA+B,CAAA;IAC3D,KAAA,EAAO,QAAS,CAAA,YAAA,CAAa,gCAAgC,CACtD,IAAA,QAAA,CAAS,YAAA,CAAa,uCAAuC,CAAA;IACpE,GAAA,EAAK,QAAS,CAAA,YAAA,CAAa,8BAA8B,CAAA;IACzD,IAAA,EAAM,QAAS,CAAA,YAAA,CAAa,+BAA+B;EAAA,CAC/D;AACJ;AAEO,IAAM,wBAA2B,GAAA;EACpC,SAAW,EAAA;IACP,IAAA,EAAMA,IAAAA,CAAAA,aAAc,CAAA,eAAA;IACpB,QAAU,EAAA;EAAA,CACd;EACA,IAAA;IAAA,uEAAM;MAAA;MAAA;QAAA;UAAA;YAAA;cAGI,MAAA,GAASC,IAAAA,CAAAA,QAAS,CAAA,OAAA,CAAQ,YAAa,EAAA;cACvC,EAAA,GAAK,MAAO,CAAA,UAAA,CAAW,OAAO,CAAA;cAAA,IAE/B,EACL;gBAAA;gBAAA;cAAA;cAAA,iCAKW,KAAA;YAAA;cAGA,QAAA,GAAA,EAAA;cAAA,iCAEJ,IAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CACX;IAAA;MAAA;IAAA;IAAA;EAAA;EACA,GAAA;IAAA,sEAAK,kBAAO,OACZ;MAAA;MAAA;QAAA;UAAA;YAAA;cACI,IAAI,CAAC,UAAA,EAA2C,8BAAA,EAAA;cAE1C,cAAA,GAAiB,EAAC;cAAA,0CAGI,UAC5B;YAAA;cAAA;gBAAA;gBAAA;cAAA;cADW,aAAA;cAED,SAAA,GAAY,UAAW,CAAA,aAAA,CAAA;cAAA,IAExB,SACL;gBAAA;gBAAA;cAAA;cAAA;YAAA;cAIA,cAAA,CAAe,IAAA,CAAK,aAAa,CAAA;cAAA;cAAA;YAAA;cAAA,4CAG1B,cAAgB,qBAAG,OAAO;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CACzC;IAAA;MAAA;IAAA;IAAA;EAAA;EACA,MAAA;IAAA,yEAAQ,kBAAO,OACf;MAAA;QAAA;UAAA;YAAA;cACI,IAAI,CAAC,UAAA,EAA2C,8BAAA,EAAA;cAAA,kCAEzC,OAAA,CAAQ,MAAO,CAAA,UAAC,CAAM;gBAAA,OAAA,EAAA,CAAA,IAAO,UAAW,CAAA;cAAA,EAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CACnD;IAAA;MAAA;IAAA;IAAA;EAAA;AACJ,CAAA;AAEAC,IAAAA,CAAAA,UAAAA,CAAI,GAAA,CAAI,wBAAwB,CAAA","sourcesContent":["import type { FormatDetectionParser } from '@pixi/assets';\nimport { settings, extensions as ext, ExtensionType } from '@pixi/core';\n\nimport type { CompressedTextureExtensionRef, CompressedTextureExtensions } from './compressedTextureExtensions';\n\nlet storedGl: WebGLRenderingContext;\nlet extensions: Partial<CompressedTextureExtensions>;\n\nfunction getCompressedTextureExtensions()\n{\n    extensions = {\n        s3tc: storedGl.getExtension('WEBGL_compressed_texture_s3tc'),\n        s3tc_sRGB: storedGl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n        etc: storedGl.getExtension('WEBGL_compressed_texture_etc'),\n        etc1: storedGl.getExtension('WEBGL_compressed_texture_etc1'),\n        pvrtc: storedGl.getExtension('WEBGL_compressed_texture_pvrtc')\n            || storedGl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n        atc: storedGl.getExtension('WEBGL_compressed_texture_atc'),\n        astc: storedGl.getExtension('WEBGL_compressed_texture_astc')\n    } as Partial<CompressedTextureExtensions>;\n}\n\nexport const detectCompressedTextures = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 2,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        const canvas = settings.ADAPTER.createCanvas();\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            // #if _DEBUG\n            console.warn('WebGL not available for compressed textures.');\n            // #endif\n\n            return false;\n        }\n\n        storedGl = gl;\n\n        return true;\n    },\n    add: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        const textureFormats = [];\n\n        // Assign all available compressed-texture formats\n        for (const extensionName in extensions)\n        {\n            const extension = extensions[extensionName as CompressedTextureExtensionRef];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            textureFormats.push(extensionName);\n        }\n\n        return [...textureFormats, ...formats];\n    },\n    remove: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        return formats.filter((f) => !(f in extensions));\n    },\n} as FormatDetectionParser;\n\next.add(detectCompressedTextures);\n"]},"metadata":{},"sourceType":"script"}