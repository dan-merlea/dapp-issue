{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar BlobResource = require('./BlobResource.js');\nvar _const = require('../const.js');\nvar CompressedTextureResource = /*#__PURE__*/function (_BlobResource$BlobRes) {\n  _inherits(CompressedTextureResource, _BlobResource$BlobRes);\n  var _super = _createSuper(CompressedTextureResource);\n  function CompressedTextureResource(source, options) {\n    var _this;\n    _classCallCheck(this, CompressedTextureResource);\n    _this = _super.call(this, source, options);\n    _this.format = options.format;\n    _this.levels = options.levels || 1;\n    _this._width = options.width;\n    _this._height = options.height;\n    _this._extension = CompressedTextureResource._formatToExtension(_this.format);\n    if (options.levelBuffers || _this.buffer) {\n      _this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : _this.buffer.uint8View, _this.format, _this.levels, 4, 4, _this.width, _this.height);\n    }\n    return _this;\n  }\n  _createClass(CompressedTextureResource, [{\n    key: \"upload\",\n    value: function upload(renderer, _texture, _glTexture) {\n      var gl = renderer.gl;\n      var extension = renderer.context.extensions[this._extension];\n      if (!extension) {\n        throw new Error(\"\".concat(this._extension, \" textures are not supported on the current machine\"));\n      }\n      if (!this._levelBuffers) {\n        return false;\n      }\n      for (var i = 0, j = this.levels; i < j; i++) {\n        var _this$_levelBuffers$i = this._levelBuffers[i],\n          levelID = _this$_levelBuffers$i.levelID,\n          levelWidth = _this$_levelBuffers$i.levelWidth,\n          levelHeight = _this$_levelBuffers$i.levelHeight,\n          levelBuffer = _this$_levelBuffers$i.levelBuffer;\n        gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);\n      }\n      return true;\n    }\n  }, {\n    key: \"onBlobLoaded\",\n    value: function onBlobLoaded() {\n      this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);\n    }\n  }], [{\n    key: \"_formatToExtension\",\n    value: function _formatToExtension(format) {\n      if (format >= 33776 && format <= 33779) {\n        return \"s3tc\";\n      } else if (format >= 37488 && format <= 37497) {\n        return \"etc\";\n      } else if (format >= 35840 && format <= 35843) {\n        return \"pvrtc\";\n      } else if (format >= 36196) {\n        return \"etc1\";\n      } else if (format >= 35986 && format <= 34798) {\n        return \"atc\";\n      }\n      throw new Error(\"Invalid (compressed) texture format given!\");\n    }\n  }, {\n    key: \"_createLevelBuffers\",\n    value: function _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {\n      var buffers = new Array(levels);\n      var offset = buffer.byteOffset;\n      var levelWidth = imageWidth;\n      var levelHeight = imageHeight;\n      var alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n      var alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n      var levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n      for (var i = 0; i < levels; i++) {\n        buffers[i] = {\n          levelID: i,\n          levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,\n          levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,\n          levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)\n        };\n        offset += levelSize;\n        levelWidth = levelWidth >> 1 || 1;\n        levelHeight = levelHeight >> 1 || 1;\n        alignedLevelWidth = levelWidth + blockWidth - 1 & ~(blockWidth - 1);\n        alignedLevelHeight = levelHeight + blockHeight - 1 & ~(blockHeight - 1);\n        levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n      }\n      return buffers;\n    }\n  }]);\n  return CompressedTextureResource;\n}(BlobResource.BlobResource);\nexports.CompressedTextureResource = CompressedTextureResource;","map":{"version":3,"sources":["../../src/resources/CompressedTextureResource.ts"],"names":["BlobResource","INTERNAL_FORMAT_TO_BYTES_PER_PIXEL"],"mappings":"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","sourcesContent":["import { BlobResource } from './BlobResource';\nimport { INTERNAL_FORMAT_TO_BYTES_PER_PIXEL } from '../const';\nimport type { Renderer, BaseTexture, GLTexture } from '@pixi/core';\n\nimport type { INTERNAL_FORMATS } from '../const';\n\n/**\n * Used in parseKTX\n * @ignore\n */\nexport type CompressedLevelBuffer = {\n    levelID: number,\n    levelWidth: number,\n    levelHeight: number,\n    levelBuffer: Uint8Array\n};\n\n/**\n * @ignore\n */\nexport interface ICompressedTextureResourceOptions\n{\n    format: INTERNAL_FORMATS;\n    width: number;\n    height: number;\n    levels?: number;\n    levelBuffers?: CompressedLevelBuffer[];\n}\n\n/**\n * Resource for compressed texture formats, as follows: S3TC/DXTn (& their sRGB formats), ATC, ASTC, ETC 1/2, PVRTC.\n *\n * Compressed textures improve performance when rendering is texture-bound. The texture data stays compressed in\n * graphics memory, increasing memory locality and speeding up texture fetches. These formats can also be used to store\n * more detail in the same amount of memory.\n *\n * For most developers, container file formats are a better abstraction instead of directly handling raw texture\n * data. PixiJS provides native support for the following texture file formats\n * (via {@link PIXI.loadBasis}, {@link PIXI.loadKTX}, and {@link PIXI.loadDDS}):\n *\n * **.dds** - the DirectDraw Surface file format stores DXTn (DXT-1,3,5) data. See {@link PIXI.parseDDS}\n * **.ktx** - the Khronos Texture Container file format supports storing all the supported WebGL compression formats.\n *  See {@link PIXI.parseKTX}.\n * **.basis** - the BASIS supercompressed file format stores texture data in an internal format that is transcoded\n *  to the compression format supported on the device at _runtime_. It also supports transcoding into a uncompressed\n *  format as a fallback; you must install the `@pixi/basis-loader`, `@pixi/basis-transcoder` packages separately to\n *  use these files. See {@link PIXI.BasisParser}.\n *\n * The loaders for the aforementioned formats use `CompressedTextureResource` internally. It is strongly suggested that\n * they be used instead.\n *\n * ## Working directly with CompressedTextureResource\n *\n * Since `CompressedTextureResource` inherits `BlobResource`, you can provide it a URL pointing to a file containing\n * the raw texture data (with no file headers!):\n * @example\n * import { CompressedTextureResource, INTERNAL_FORMATS } from '@pixi/compressed-textures';\n * import { BaseTexture, Texture, ALPHA_MODES } from 'pixi.js';\n *\n * // The resource backing the texture data for your textures.\n * // NOTE: You can also provide a ArrayBufferView instead of a URL. This is used when loading data from a container file\n * //   format such as KTX, DDS, or BASIS.\n * const compressedResource = new CompressedTextureResource('bunny.dxt5', {\n *     format: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n *     width: 256,\n *     height: 256,\n * });\n *\n * // You can create a base-texture to the cache, so that future `Texture`s can be created using the `Texture.from` API.\n * const baseTexture = new BaseTexture(compressedResource, { pmaMode: ALPHA_MODES.NPM });\n *\n * // Create a Texture to add to the TextureCache\n * const texture = new Texture(baseTexture);\n *\n * // Add baseTexture & texture to the global texture cache\n * BaseTexture.addToCache(baseTexture, 'bunny.dxt5');\n * Texture.addToCache(texture, 'bunny.dxt5');\n * @memberof PIXI\n */\nexport class CompressedTextureResource extends BlobResource\n{\n    /** The compression format */\n    public format: INTERNAL_FORMATS;\n    /**\n     * The number of mipmap levels stored in the resource buffer.\n     * @default 1\n     */\n    public levels: number;\n\n    // Easy access to the WebGL extension providing support for the compression format via ContextSystem\n    private _extension: 's3tc' | 's3tc_sRGB' | 'atc' | 'astc' | 'etc' | 'etc1' | 'pvrtc';\n    // Buffer views for each mipmap level in the main buffer\n    private _levelBuffers: CompressedLevelBuffer[];\n\n    /**\n     * @param source - the buffer/URL holding the compressed texture data\n     * @param options\n     * @param {PIXI.INTERNAL_FORMATS} options.format - the compression format\n     * @param {number} options.width - the image width in pixels.\n     * @param {number} options.height - the image height in pixels.\n     * @param {number} [options.level=1] - the mipmap levels stored in the compressed texture, including level 0.\n     * @param {number} [options.levelBuffers] - the buffers for each mipmap level. `CompressedTextureResource` can allows you\n     *      to pass `null` for `source`, for cases where each level is stored in non-contiguous memory.\n     */\n    constructor(source: string | Uint8Array | Uint32Array, options: ICompressedTextureResourceOptions)\n    {\n        super(source, options);\n\n        this.format = options.format;\n        this.levels = options.levels || 1;\n\n        this._width = options.width;\n        this._height = options.height;\n\n        this._extension = CompressedTextureResource._formatToExtension(this.format);\n\n        if (options.levelBuffers || this.buffer)\n        {\n            // ViewableBuffer doesn't support byteOffset :-( so allow source to be Uint8Array\n            this._levelBuffers = options.levelBuffers\n                || CompressedTextureResource._createLevelBuffers(\n                    source instanceof Uint8Array ? source : this.buffer.uint8View,\n                    this.format,\n                    this.levels,\n                    4, 4, // PVRTC has 8x4 blocks in 2bpp mode\n                    this.width,\n                    this.height);\n        }\n    }\n\n    /**\n     * @override\n     * @param renderer - A reference to the current renderer\n     * @param _texture - the texture\n     * @param _glTexture - texture instance for this webgl context\n     */\n    upload(renderer: Renderer, _texture: BaseTexture, _glTexture: GLTexture): boolean\n    {\n        const gl = renderer.gl;\n        const extension = renderer.context.extensions[this._extension];\n\n        if (!extension)\n        {\n            throw new Error(`${this._extension} textures are not supported on the current machine`);\n        }\n        if (!this._levelBuffers)\n        {\n            // Do not try to upload data before BlobResource loads, unless the levelBuffers were provided directly!\n            return false;\n        }\n\n        for (let i = 0, j = this.levels; i < j; i++)\n        {\n            const { levelID, levelWidth, levelHeight, levelBuffer } = this._levelBuffers[i];\n\n            gl.compressedTexImage2D(gl.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);\n        }\n\n        return true;\n    }\n\n    /** @protected */\n    protected onBlobLoaded(): void\n    {\n        this._levelBuffers = CompressedTextureResource._createLevelBuffers(\n            this.buffer.uint8View,\n            this.format,\n            this.levels,\n            4, 4, // PVRTC has 8x4 blocks in 2bpp mode\n            this.width,\n            this.height);\n    }\n\n    /**\n     * Returns the key (to ContextSystem#extensions) for the WebGL extension supporting the compression format\n     * @private\n     * @param format - the compression format to get the extension for.\n     */\n    private static _formatToExtension(format: INTERNAL_FORMATS):\n    's3tc' | 's3tc_sRGB' | 'atc' |\n    'astc' | 'etc' | 'etc1' | 'pvrtc'\n    {\n        if (format >= 0x83F0 && format <= 0x83F3)\n        {\n            return 's3tc';\n        }\n        else if (format >= 0x9270 && format <= 0x9279)\n        {\n            return 'etc';\n        }\n        else if (format >= 0x8C00 && format <= 0x8C03)\n        {\n            return 'pvrtc';\n        }\n        else if (format >= 0x8D64)\n        {\n            return 'etc1';\n        }\n        else if (format >= 0x8C92 && format <= 0x87EE)\n        {\n            return 'atc';\n        }\n\n        throw new Error('Invalid (compressed) texture format given!');\n    }\n\n    /**\n     * Pre-creates buffer views for each mipmap level\n     * @private\n     * @param buffer -\n     * @param format - compression formats\n     * @param levels - mipmap levels\n     * @param blockWidth -\n     * @param blockHeight -\n     * @param imageWidth - width of the image in pixels\n     * @param imageHeight - height of the image in pixels\n     */\n    private static _createLevelBuffers(\n        buffer: Uint8Array,\n        format: INTERNAL_FORMATS,\n        levels: number,\n        blockWidth: number,\n        blockHeight: number,\n        imageWidth: number,\n        imageHeight: number\n    ): CompressedLevelBuffer[]\n    {\n        // The byte-size of the first level buffer\n        const buffers = new Array<CompressedLevelBuffer>(levels);\n\n        let offset = buffer.byteOffset;\n\n        let levelWidth = imageWidth;\n        let levelHeight = imageHeight;\n        let alignedLevelWidth = (levelWidth + blockWidth - 1) & ~(blockWidth - 1);\n        let alignedLevelHeight = (levelHeight + blockHeight - 1) & ~(blockHeight - 1);\n\n        let levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n\n        for (let i = 0; i < levels; i++)\n        {\n            buffers[i] = {\n                levelID: i,\n                levelWidth: levels > 1 ? levelWidth : alignedLevelWidth,\n                levelHeight: levels > 1 ? levelHeight : alignedLevelHeight,\n                levelBuffer: new Uint8Array(buffer.buffer, offset, levelSize)\n            };\n\n            offset += levelSize;\n\n            // Calculate levelBuffer dimensions for next iteration\n            levelWidth = (levelWidth >> 1) || 1;\n            levelHeight = (levelHeight >> 1) || 1;\n            alignedLevelWidth = (levelWidth + blockWidth - 1) & ~(blockWidth - 1);\n            alignedLevelHeight = (levelHeight + blockHeight - 1) & ~(blockHeight - 1);\n            levelSize = alignedLevelWidth * alignedLevelHeight * INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];\n        }\n\n        return buffers;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}