{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NumericalBinaryCodec = void 0;\nvar typesystem_1 = require(\"../typesystem\");\nvar utils_1 = require(\"./utils\");\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nvar NumericalBinaryCodec = /*#__PURE__*/function () {\n  function NumericalBinaryCodec() {\n    _classCallCheck(this, NumericalBinaryCodec);\n  }\n  _createClass(NumericalBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var offset = 0;\n      var length = type.sizeInBytes;\n      if (!length) {\n        // Size of type is not known: arbitrary-size big integer.\n        // Therefore, we must read the length from the header.\n        offset = constants_1.SizeOfU32;\n        length = buffer.readUInt32BE(0);\n      }\n      var payload = buffer.slice(offset, offset + length);\n      var result = this.decodeTopLevel(payload, type);\n      var decodedLength = length + offset;\n      return [result, decodedLength];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var payload = utils_1.cloneBuffer(buffer);\n      var empty = buffer.length == 0;\n      if (empty) {\n        return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n      }\n      var isPositive = !type.withSign || utils_1.isMsbZero(payload);\n      if (isPositive) {\n        var _value = utils_1.bufferToBigInt(payload);\n        return new typesystem_1.NumericalValue(type, _value);\n      }\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n      utils_1.flipBufferBitsInPlace(payload);\n      var value = utils_1.bufferToBigInt(payload);\n      var negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n      var negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n      return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(primitive) {\n      if (primitive.sizeInBytes) {\n        return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n      }\n      // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n      var buffer = this.encodeTopLevel(primitive);\n      var length = Buffer.alloc(constants_1.SizeOfU32);\n      length.writeUInt32BE(buffer.length);\n      return Buffer.concat([length, buffer]);\n    }\n  }, {\n    key: \"encodeNestedFixedSize\",\n    value: function encodeNestedFixedSize(primitive, size) {\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(size, 0x00);\n      }\n      if (!primitive.withSign) {\n        var _buffer = utils_1.bigIntToBuffer(primitive.value);\n        var _paddingBytes = Buffer.alloc(size - _buffer.length, 0x00);\n        return Buffer.concat([_paddingBytes, _buffer]);\n      }\n      if (primitive.value.isPositive()) {\n        var _buffer2 = utils_1.bigIntToBuffer(primitive.value);\n        // Fix ambiguity if any\n        if (utils_1.isMsbOne(_buffer2)) {\n          _buffer2 = utils_1.prependByteToBuffer(_buffer2, 0x00);\n        }\n        var _paddingBytes2 = Buffer.alloc(size - _buffer2.length, 0x00);\n        return Buffer.concat([_paddingBytes2, _buffer2]);\n      }\n      // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer);\n      // Fix ambiguity if any\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n      var paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n      return Buffer.concat([paddingBytes, buffer]);\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(primitive) {\n      var withSign = primitive.withSign;\n      // Nothing or Zero:\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(0);\n      }\n      // I don't care about the sign:\n      if (!withSign) {\n        return utils_1.bigIntToBuffer(primitive.value);\n      }\n      return this.encodePrimitive(primitive);\n    }\n  }, {\n    key: \"encodePrimitive\",\n    value: function encodePrimitive(primitive) {\n      // Positive:\n      if (primitive.value.isPositive()) {\n        var _buffer3 = utils_1.bigIntToBuffer(primitive.value);\n        // Fix ambiguity if any\n        if (utils_1.isMsbOne(_buffer3)) {\n          _buffer3 = utils_1.prependByteToBuffer(_buffer3, 0x00);\n        }\n        return _buffer3;\n      }\n      // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer);\n      // Fix ambiguity if any\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n      return buffer;\n    }\n  }]);\n  return NumericalBinaryCodec;\n}();\nexports.NumericalBinaryCodec = NumericalBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/numerical.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NumericalBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"./utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nclass NumericalBinaryCodec {\n    decodeNested(buffer, type) {\n        let offset = 0;\n        let length = type.sizeInBytes;\n        if (!length) {\n            // Size of type is not known: arbitrary-size big integer.\n            // Therefore, we must read the length from the header.\n            offset = constants_1.SizeOfU32;\n            length = buffer.readUInt32BE(0);\n        }\n        let payload = buffer.slice(offset, offset + length);\n        let result = this.decodeTopLevel(payload, type);\n        let decodedLength = length + offset;\n        return [result, decodedLength];\n    }\n    decodeTopLevel(buffer, type) {\n        let payload = utils_1.cloneBuffer(buffer);\n        let empty = buffer.length == 0;\n        if (empty) {\n            return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n        }\n        let isPositive = !type.withSign || utils_1.isMsbZero(payload);\n        if (isPositive) {\n            let value = utils_1.bufferToBigInt(payload);\n            return new typesystem_1.NumericalValue(type, value);\n        }\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n        utils_1.flipBufferBitsInPlace(payload);\n        let value = utils_1.bufferToBigInt(payload);\n        let negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n        let negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n        return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n    encodeNested(primitive) {\n        if (primitive.sizeInBytes) {\n            return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n        }\n        // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n        let buffer = this.encodeTopLevel(primitive);\n        let length = Buffer.alloc(constants_1.SizeOfU32);\n        length.writeUInt32BE(buffer.length);\n        return Buffer.concat([length, buffer]);\n    }\n    encodeNestedFixedSize(primitive, size) {\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(size, 0x00);\n        }\n        if (!primitive.withSign) {\n            const buffer = utils_1.bigIntToBuffer(primitive.value);\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        const paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n        return Buffer.concat([paddingBytes, buffer]);\n    }\n    encodeTopLevel(primitive) {\n        let withSign = primitive.withSign;\n        // Nothing or Zero:\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(0);\n        }\n        // I don't care about the sign:\n        if (!withSign) {\n            return utils_1.bigIntToBuffer(primitive.value);\n        }\n        return this.encodePrimitive(primitive);\n    }\n    encodePrimitive(primitive) {\n        // Positive:\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            return buffer;\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        return buffer;\n    }\n}\nexports.NumericalBinaryCodec = NumericalBinaryCodec;\n//# sourceMappingURL=numerical.js.map"]},"metadata":{},"sourceType":"script"}