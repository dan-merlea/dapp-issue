{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _get = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/get.js\").default;\nvar _getPrototypeOf = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar ParticleBuffer = require('./ParticleBuffer.js');\nvar particles$1 = require('./particles.js');\nvar particles = require('./particles2.js');\nvar ParticleRenderer = /*#__PURE__*/function (_core$ObjectRenderer) {\n  _inherits(ParticleRenderer, _core$ObjectRenderer);\n  var _super = _createSuper(ParticleRenderer);\n  function ParticleRenderer(renderer) {\n    var _this;\n    _classCallCheck(this, ParticleRenderer);\n    _this = _super.call(this, renderer);\n    _this.shader = null;\n    _this.properties = null;\n    _this.tempMatrix = new core.Matrix();\n    _this.properties = [{\n      attributeName: \"aVertexPosition\",\n      size: 2,\n      uploadFunction: _this.uploadVertices,\n      offset: 0\n    }, {\n      attributeName: \"aPositionCoord\",\n      size: 2,\n      uploadFunction: _this.uploadPosition,\n      offset: 0\n    }, {\n      attributeName: \"aRotation\",\n      size: 1,\n      uploadFunction: _this.uploadRotation,\n      offset: 0\n    }, {\n      attributeName: \"aTextureCoord\",\n      size: 2,\n      uploadFunction: _this.uploadUvs,\n      offset: 0\n    }, {\n      attributeName: \"aColor\",\n      size: 1,\n      type: core.TYPES.UNSIGNED_BYTE,\n      uploadFunction: _this.uploadTint,\n      offset: 0\n    }];\n    _this.shader = core.Shader.from(particles[\"default\"], particles$1[\"default\"], {});\n    _this.state = core.State.for2d();\n    return _this;\n  }\n  _createClass(ParticleRenderer, [{\n    key: \"render\",\n    value: function render(container) {\n      var children = container.children;\n      var maxSize = container._maxSize;\n      var batchSize = container._batchSize;\n      var renderer = this.renderer;\n      var totalChildren = children.length;\n      if (totalChildren === 0) {\n        return;\n      } else if (totalChildren > maxSize && !container.autoResize) {\n        totalChildren = maxSize;\n      }\n      var buffers = container._buffers;\n      if (!buffers) {\n        buffers = container._buffers = this.generateBuffers(container);\n      }\n      var baseTexture = children[0]._texture.baseTexture;\n      var premultiplied = baseTexture.alphaMode > 0;\n      this.state.blendMode = core.utils.correctBlendMode(container.blendMode, premultiplied);\n      renderer.state.set(this.state);\n      var gl = renderer.gl;\n      var m = container.worldTransform.copyTo(this.tempMatrix);\n      m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n      this.shader.uniforms.translationMatrix = m.toArray(true);\n      this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, premultiplied);\n      this.shader.uniforms.uSampler = baseTexture;\n      this.renderer.shader.bind(this.shader);\n      var updateStatic = false;\n      for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n        var amount = totalChildren - i;\n        if (amount > batchSize) {\n          amount = batchSize;\n        }\n        if (j >= buffers.length) {\n          buffers.push(this._generateOneMoreBuffer(container));\n        }\n        var buffer = buffers[j];\n        buffer.uploadDynamic(children, i, amount);\n        var bid = container._bufferUpdateIDs[j] || 0;\n        updateStatic = updateStatic || buffer._updateID < bid;\n        if (updateStatic) {\n          buffer._updateID = container._updateID;\n          buffer.uploadStatic(children, i, amount);\n        }\n        renderer.geometry.bind(buffer.geometry);\n        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n      }\n    }\n  }, {\n    key: \"generateBuffers\",\n    value: function generateBuffers(container) {\n      var buffers = [];\n      var size = container._maxSize;\n      var batchSize = container._batchSize;\n      var dynamicPropertyFlags = container._properties;\n      for (var i = 0; i < size; i += batchSize) {\n        buffers.push(new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n      }\n      return buffers;\n    }\n  }, {\n    key: \"_generateOneMoreBuffer\",\n    value: function _generateOneMoreBuffer(container) {\n      var batchSize = container._batchSize;\n      var dynamicPropertyFlags = container._properties;\n      return new ParticleBuffer.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n    }\n  }, {\n    key: \"uploadVertices\",\n    value: function uploadVertices(children, startIndex, amount, array, stride, offset) {\n      var w0 = 0;\n      var w1 = 0;\n      var h0 = 0;\n      var h1 = 0;\n      for (var i = 0; i < amount; ++i) {\n        var sprite = children[startIndex + i];\n        var texture = sprite._texture;\n        var sx = sprite.scale.x;\n        var sy = sprite.scale.y;\n        var trim = texture.trim;\n        var orig = texture.orig;\n        if (trim) {\n          w1 = trim.x - sprite.anchor.x * orig.width;\n          w0 = w1 + trim.width;\n          h1 = trim.y - sprite.anchor.y * orig.height;\n          h0 = h1 + trim.height;\n        } else {\n          w0 = orig.width * (1 - sprite.anchor.x);\n          w1 = orig.width * -sprite.anchor.x;\n          h0 = orig.height * (1 - sprite.anchor.y);\n          h1 = orig.height * -sprite.anchor.y;\n        }\n        array[offset] = w1 * sx;\n        array[offset + 1] = h1 * sy;\n        array[offset + stride] = w0 * sx;\n        array[offset + stride + 1] = h1 * sy;\n        array[offset + stride * 2] = w0 * sx;\n        array[offset + stride * 2 + 1] = h0 * sy;\n        array[offset + stride * 3] = w1 * sx;\n        array[offset + stride * 3 + 1] = h0 * sy;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"uploadPosition\",\n    value: function uploadPosition(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; i++) {\n        var spritePosition = children[startIndex + i].position;\n        array[offset] = spritePosition.x;\n        array[offset + 1] = spritePosition.y;\n        array[offset + stride] = spritePosition.x;\n        array[offset + stride + 1] = spritePosition.y;\n        array[offset + stride * 2] = spritePosition.x;\n        array[offset + stride * 2 + 1] = spritePosition.y;\n        array[offset + stride * 3] = spritePosition.x;\n        array[offset + stride * 3 + 1] = spritePosition.y;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"uploadRotation\",\n    value: function uploadRotation(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; i++) {\n        var spriteRotation = children[startIndex + i].rotation;\n        array[offset] = spriteRotation;\n        array[offset + stride] = spriteRotation;\n        array[offset + stride * 2] = spriteRotation;\n        array[offset + stride * 3] = spriteRotation;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"uploadUvs\",\n    value: function uploadUvs(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; ++i) {\n        var textureUvs = children[startIndex + i]._texture._uvs;\n        if (textureUvs) {\n          array[offset] = textureUvs.x0;\n          array[offset + 1] = textureUvs.y0;\n          array[offset + stride] = textureUvs.x1;\n          array[offset + stride + 1] = textureUvs.y1;\n          array[offset + stride * 2] = textureUvs.x2;\n          array[offset + stride * 2 + 1] = textureUvs.y2;\n          array[offset + stride * 3] = textureUvs.x3;\n          array[offset + stride * 3 + 1] = textureUvs.y3;\n          offset += stride * 4;\n        } else {\n          array[offset] = 0;\n          array[offset + 1] = 0;\n          array[offset + stride] = 0;\n          array[offset + stride + 1] = 0;\n          array[offset + stride * 2] = 0;\n          array[offset + stride * 2 + 1] = 0;\n          array[offset + stride * 3] = 0;\n          array[offset + stride * 3 + 1] = 0;\n          offset += stride * 4;\n        }\n      }\n    }\n  }, {\n    key: \"uploadTint\",\n    value: function uploadTint(children, startIndex, amount, array, stride, offset) {\n      for (var i = 0; i < amount; ++i) {\n        var sprite = children[startIndex + i];\n        var premultiplied = sprite._texture.baseTexture.alphaMode > 0;\n        var alpha = sprite.alpha;\n        var argb = alpha < 1 && premultiplied ? core.utils.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n        array[offset] = argb;\n        array[offset + stride] = argb;\n        array[offset + stride * 2] = argb;\n        array[offset + stride * 3] = argb;\n        offset += stride * 4;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(ParticleRenderer.prototype), \"destroy\", this).call(this);\n      if (this.shader) {\n        this.shader.destroy();\n        this.shader = null;\n      }\n      this.tempMatrix = null;\n    }\n  }]);\n  return ParticleRenderer;\n}(core.ObjectRenderer);\nParticleRenderer.extension = {\n  name: \"particle\",\n  type: core.ExtensionType.RendererPlugin\n};\ncore.extensions.add(ParticleRenderer);\nexports.ParticleRenderer = ParticleRenderer;","map":{"version":3,"sources":["../src/ParticleRenderer.ts"],"names":["ObjectRenderer","ExtensionType","Matrix","TYPES","Shader","vertex","State","ParticleBuffer","utils","extensions"],"mappings":"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","sourcesContent":["import { TYPES, Matrix, extensions, ExtensionType, ObjectRenderer, Shader, State, utils } from '@pixi/core';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\n\nimport type { ParticleContainer } from './ParticleContainer';\nimport type { Renderer, ExtensionMetadata } from '@pixi/core';\nimport type { Sprite } from '@pixi/sprite';\n\nexport interface IParticleRendererProperty\n{\n    attributeName: string;\n    size: number;\n    type?: TYPES;\n    uploadFunction: (...params: any[]) => any;\n    offset: number;\n}\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof PIXI\n */\nexport class ParticleRenderer extends ObjectRenderer\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        name: 'particle',\n        type: ExtensionType.RendererPlugin,\n    };\n\n    /** The WebGL state in which this renderer will work. */\n    public readonly state: State;\n\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public shader: Shader;\n    public tempMatrix: Matrix;\n    public properties: IParticleRendererProperty[];\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        this.shader = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new Matrix();\n\n        this.properties = [\n            // verticesData\n            {\n                attributeName: 'aVertexPosition',\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attributeName: 'aPositionCoord',\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attributeName: 'aRotation',\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attributeName: 'aTextureCoord',\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attributeName: 'aColor',\n                size: 1,\n                type: TYPES.UNSIGNED_BYTE,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n\n        this.shader = Shader.from(vertex, fragment, {});\n        this.state = State.for2d();\n    }\n\n    /**\n     * Renders the particle container object.\n     * @param container - The container to render using this ParticleRenderer.\n     */\n    public render(container: ParticleContainer): void\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize && !container.autoResize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._buffers;\n\n        if (!buffers)\n        {\n            buffers = container._buffers = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n        const premultiplied = baseTexture.alphaMode > 0;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.state.blendMode = utils.correctBlendMode(container.blendMode, premultiplied);\n        renderer.state.set(this.state);\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copyTo(this.tempMatrix);\n\n        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);\n\n        this.shader.uniforms.translationMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = utils.premultiplyRgba(container.tintRgb,\n            container.worldAlpha, this.shader.uniforms.uColor, premultiplied);\n\n        this.shader.uniforms.uSampler = baseTexture;\n\n        this.renderer.shader.bind(this.shader);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.geometry.bind(buffer.geometry);\n            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The buffers\n     */\n    private generateBuffers(container: ParticleContainer): ParticleBuffer[]\n    {\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature.\n     * @param container - The container to render using this ParticleRenderer\n     * @returns - The generated buffer\n     */\n    private _generateOneMoreBuffer(container: ParticleContainer): ParticleBuffer\n    {\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the vertices.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their vertices uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadVertices(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the position.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their positions uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadPosition(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the rotation.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadRotation(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Uploads the UVs.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadUvs(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     * Uploads the tint.\n     * @param children - the array of sprites to render\n     * @param startIndex - the index to start from in the children array\n     * @param amount - the amount of children that will have their rotation uploaded\n     * @param array - The vertices to upload.\n     * @param stride - Stride to use for iteration.\n     * @param offset - Offset to start at.\n     */\n    public uploadTint(\n        children: Sprite[], startIndex: number, amount: number,\n        array: number[], stride: number, offset: number\n    ): void\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const premultiplied = sprite._texture.baseTexture.alphaMode > 0;\n            const alpha = sprite.alpha;\n\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && premultiplied\n                ? utils.premultiplyTint(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n\n            array[offset] = argb;\n            array[offset + stride] = argb;\n            array[offset + (stride * 2)] = argb;\n            array[offset + (stride * 3)] = argb;\n\n            offset += stride * 4;\n        }\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.tempMatrix = null;\n    }\n}\n\nextensions.add(ParticleRenderer);\n"]},"metadata":{},"sourceType":"script"}