{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar math = require('@pixi/math');\nvar extensions = require('@pixi/extensions');\nvar tempRect = new math.Rectangle();\nvar tempRect2 = new math.Rectangle();\nvar RenderTextureSystem = /*#__PURE__*/function () {\n  function RenderTextureSystem(renderer) {\n    _classCallCheck(this, RenderTextureSystem);\n    this.renderer = renderer;\n    this.defaultMaskStack = [];\n    this.current = null;\n    this.sourceFrame = new math.Rectangle();\n    this.destinationFrame = new math.Rectangle();\n    this.viewportFrame = new math.Rectangle();\n  }\n  _createClass(RenderTextureSystem, [{\n    key: \"bind\",\n    value: function bind() {\n      var renderTexture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var sourceFrame = arguments.length > 1 ? arguments[1] : undefined;\n      var destinationFrame = arguments.length > 2 ? arguments[2] : undefined;\n      var renderer = this.renderer;\n      this.current = renderTexture;\n      var baseTexture;\n      var framebuffer;\n      var resolution;\n      if (renderTexture) {\n        baseTexture = renderTexture.baseTexture;\n        resolution = baseTexture.resolution;\n        if (!sourceFrame) {\n          tempRect.width = renderTexture.frame.width;\n          tempRect.height = renderTexture.frame.height;\n          sourceFrame = tempRect;\n        }\n        if (!destinationFrame) {\n          tempRect2.x = renderTexture.frame.x;\n          tempRect2.y = renderTexture.frame.y;\n          tempRect2.width = sourceFrame.width;\n          tempRect2.height = sourceFrame.height;\n          destinationFrame = tempRect2;\n        }\n        framebuffer = baseTexture.framebuffer;\n      } else {\n        resolution = renderer.resolution;\n        if (!sourceFrame) {\n          tempRect.width = renderer._view.screen.width;\n          tempRect.height = renderer._view.screen.height;\n          sourceFrame = tempRect;\n        }\n        if (!destinationFrame) {\n          destinationFrame = tempRect;\n          destinationFrame.width = sourceFrame.width;\n          destinationFrame.height = sourceFrame.height;\n        }\n      }\n      var viewportFrame = this.viewportFrame;\n      viewportFrame.x = destinationFrame.x * resolution;\n      viewportFrame.y = destinationFrame.y * resolution;\n      viewportFrame.width = destinationFrame.width * resolution;\n      viewportFrame.height = destinationFrame.height * resolution;\n      if (!renderTexture) {\n        viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n      }\n      viewportFrame.ceil();\n      this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n      this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n      if (renderTexture) {\n        this.renderer.mask.setMaskStack(baseTexture.maskStack);\n      } else {\n        this.renderer.mask.setMaskStack(this.defaultMaskStack);\n      }\n      this.sourceFrame.copyFrom(sourceFrame);\n      this.destinationFrame.copyFrom(destinationFrame);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(clearColor, mask) {\n      if (this.current) {\n        clearColor = clearColor || this.current.baseTexture.clearColor;\n      } else {\n        clearColor = clearColor || this.renderer.background.colorRgba;\n      }\n      var destinationFrame = this.destinationFrame;\n      var baseFrame = this.current ? this.current.baseTexture : this.renderer._view.screen;\n      var clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n      if (clearMask) {\n        var _this$viewportFrame = this.viewportFrame,\n          x = _this$viewportFrame.x,\n          y = _this$viewportFrame.y,\n          width = _this$viewportFrame.width,\n          height = _this$viewportFrame.height;\n        x = Math.round(x);\n        y = Math.round(y);\n        width = Math.round(width);\n        height = Math.round(height);\n        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n        this.renderer.gl.scissor(x, y, width, height);\n      }\n      this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);\n      if (clearMask) {\n        this.renderer.scissor.pop();\n      }\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      this.bind(null);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.bind(null);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.renderer = null;\n    }\n  }]);\n  return RenderTextureSystem;\n}();\nRenderTextureSystem.extension = {\n  type: extensions.ExtensionType.RendererSystem,\n  name: \"renderTexture\"\n};\nextensions.extensions.add(RenderTextureSystem);\nexports.RenderTextureSystem = RenderTextureSystem;","map":{"version":3,"sources":["../../src/renderTexture/RenderTextureSystem.ts"],"names":["Rectangle","ExtensionType","extensions"],"mappings":"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","sourcesContent":["import { Rectangle } from '@pixi/math';\nimport type { BUFFER_BITS } from '@pixi/constants';\n\nimport type { ISystem } from '../system/ISystem';\nimport type { Renderer } from '../Renderer';\nimport type { RenderTexture } from './RenderTexture';\nimport type { BaseRenderTexture } from './BaseRenderTexture';\nimport type { MaskData } from '../mask/MaskData';\nimport type { ISize } from '@pixi/math';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport { extensions, ExtensionType } from '@pixi/extensions';\n\n// Temporary rectangle for assigned sourceFrame or destinationFrame\nconst tempRect = new Rectangle();\n\n// Temporary rectangle for renderTexture destinationFrame\nconst tempRect2 = new Rectangle();\n\n/* eslint-disable max-len */\n/**\n * System plugin to the renderer to manage render textures.\n *\n * Should be added after FramebufferSystem\n *\n * ### Frames\n *\n * The `RenderTextureSystem` holds a sourceFrame → destinationFrame projection. The following table explains the different\n * coordinate spaces used:\n *\n * | Frame                  | Description                                                      | Coordinate System                                       |\n * | ---------------------- | ---------------------------------------------------------------- | ------------------------------------------------------- |\n * | sourceFrame            | The rectangle inside of which display-objects are being rendered | **World Space**: The origin on the top-left             |\n * | destinationFrame       | The rectangle in the render-target (canvas or texture) into which contents should be rendered | If rendering to the canvas, this is in screen space and the origin is on the top-left. If rendering to a render-texture, this is in its base-texture's space with the origin on the bottom-left.  |\n * | viewportFrame          | The framebuffer viewport corresponding to the destination-frame  | **Window Coordinates**: The origin is always on the bottom-left. |\n * @memberof PIXI\n */\nexport class RenderTextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'renderTexture',\n    };\n\n    /* eslint-enable max-len */\n\n    /**\n     * List of masks for the {@link PIXI.StencilSystem}.\n     * @readonly\n     */\n    public defaultMaskStack: Array<MaskData>;\n\n    /**\n     * Render texture currently bound. {@code null} if rendering to the canvas.\n     * @readonly\n     */\n    public current: RenderTexture | null;\n\n    /**\n     * The source frame for the render-target's projection mapping.\n     *\n     * See {@link PIXI.ProjectionSystem#sourceFrame} for more details\n     */\n    public readonly sourceFrame: Rectangle;\n\n    /**\n     * The destination frame for the render-target's projection mapping.\n     *\n     * See {@link PIXI.Projection#destinationFrame} for more details.\n     */\n    public readonly destinationFrame: Rectangle;\n\n    /**\n     * The viewport frame for the render-target's viewport binding. This is equal to the destination-frame\n     * for render-textures, while it is y-flipped when rendering to the screen (i.e. its origin is always on\n     * the bottom-left).\n     */\n    public readonly viewportFrame: Rectangle;\n\n    private renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultMaskStack = [];\n        this.current = null;\n        this.sourceFrame = new Rectangle();\n        this.destinationFrame = new Rectangle();\n        this.viewportFrame = new Rectangle();\n    }\n\n    /**\n     * Bind the current render texture.\n     * @param renderTexture - RenderTexture to bind, by default its `null` - the screen.\n     * @param sourceFrame - Part of world that is mapped to the renderTexture.\n     * @param destinationFrame - Part of renderTexture, by default it has the same size as sourceFrame.\n     */\n    bind(renderTexture: RenderTexture = null, sourceFrame?: Rectangle, destinationFrame?: Rectangle): void\n    {\n        const renderer = this.renderer;\n\n        this.current = renderTexture;\n\n        let baseTexture: BaseRenderTexture;\n        let framebuffer;\n        let resolution;\n\n        if (renderTexture)\n        {\n            baseTexture = renderTexture.baseTexture as BaseRenderTexture;\n\n            resolution = baseTexture.resolution;\n\n            if (!sourceFrame)\n            {\n                tempRect.width = renderTexture.frame.width;\n                tempRect.height = renderTexture.frame.height;\n\n                sourceFrame = tempRect;\n            }\n\n            if (!destinationFrame)\n            {\n                tempRect2.x = renderTexture.frame.x;\n                tempRect2.y = renderTexture.frame.y;\n                tempRect2.width = sourceFrame.width;\n                tempRect2.height = sourceFrame.height;\n\n                destinationFrame = tempRect2;\n            }\n\n            framebuffer = baseTexture.framebuffer;\n        }\n        else\n        {\n            resolution = renderer.resolution;\n\n            if (!sourceFrame)\n            {\n                tempRect.width = renderer._view.screen.width;\n                tempRect.height = renderer._view.screen.height;\n\n                sourceFrame = tempRect;\n            }\n\n            if (!destinationFrame)\n            {\n                destinationFrame = tempRect;\n\n                destinationFrame.width = sourceFrame.width;\n                destinationFrame.height = sourceFrame.height;\n            }\n        }\n\n        const viewportFrame = this.viewportFrame;\n\n        viewportFrame.x = destinationFrame.x * resolution;\n        viewportFrame.y = destinationFrame.y * resolution;\n        viewportFrame.width = destinationFrame.width * resolution;\n        viewportFrame.height = destinationFrame.height * resolution;\n\n        if (!renderTexture)\n        {\n            viewportFrame.y = renderer.view.height - (viewportFrame.y + viewportFrame.height);\n        }\n\n        viewportFrame.ceil();\n\n        this.renderer.framebuffer.bind(framebuffer, viewportFrame);\n        this.renderer.projection.update(destinationFrame, sourceFrame, resolution, !framebuffer);\n\n        if (renderTexture)\n        {\n            this.renderer.mask.setMaskStack(baseTexture.maskStack);\n        }\n        else\n        {\n            this.renderer.mask.setMaskStack(this.defaultMaskStack);\n        }\n\n        this.sourceFrame.copyFrom(sourceFrame);\n        this.destinationFrame.copyFrom(destinationFrame);\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour.\n     * @param clearColor - The color as rgba, default to use the renderer backgroundColor\n     * @param [mask=BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH] - Bitwise OR of masks\n     *  that indicate the buffers to be cleared, by default COLOR and DEPTH buffers.\n     */\n    clear(clearColor?: number[], mask?: BUFFER_BITS): void\n    {\n        if (this.current)\n        {\n            clearColor = clearColor || (this.current.baseTexture as BaseRenderTexture).clearColor;\n        }\n        else\n        {\n            clearColor = clearColor || this.renderer.background.colorRgba;\n        }\n\n        const destinationFrame = this.destinationFrame;\n        const baseFrame: ISize = this.current ? this.current.baseTexture : this.renderer._view.screen;\n        const clearMask = destinationFrame.width !== baseFrame.width || destinationFrame.height !== baseFrame.height;\n\n        if (clearMask)\n        {\n            let { x, y, width, height } = this.viewportFrame;\n\n            x = Math.round(x);\n            y = Math.round(y);\n            width = Math.round(width);\n            height = Math.round(height);\n\n            // TODO: ScissorSystem should cache whether the scissor test is enabled or not.\n            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);\n            this.renderer.gl.scissor(x, y, width, height);\n        }\n\n        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3], mask);\n\n        if (clearMask)\n        {\n            // Restore the scissor box\n            this.renderer.scissor.pop();\n        }\n    }\n\n    resize(): void // screenWidth, screenHeight)\n    {\n        // resize the root only!\n        this.bind(null);\n    }\n\n    /** Resets render-texture state. */\n    reset(): void\n    {\n        this.bind(null);\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(RenderTextureSystem);\n"]},"metadata":{},"sourceType":"script"}