{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _defineProperty = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProviderV2 = void 0;\nvar sign_client_1 = __importDefault(require(\"@walletconnect/sign-client\"));\nvar utils_1 = require(\"@walletconnect/utils\");\nvar constants_1 = require(\"./constants\");\nvar operation_1 = require(\"./operation\");\nvar logger_1 = require(\"./logger\");\nvar primitives_1 = require(\"./primitives\");\nvar userAddress_1 = require(\"./userAddress\");\nvar WalletConnectProviderV2 = /*#__PURE__*/function () {\n  function WalletConnectProviderV2(onClientConnect, chainId, walletConnectV2Relay, walletConnectV2ProjectId) {\n    _classCallCheck(this, WalletConnectProviderV2);\n    this.chainId = \"\";\n    this.address = \"\";\n    this.signature = \"\";\n    this.isInitializing = false;\n    this.events = [];\n    this.methods = [];\n    this.onClientConnect = onClientConnect;\n    this.chainId = chainId;\n    this.walletConnectV2Relay = walletConnectV2Relay;\n    this.walletConnectV2ProjectId = walletConnectV2ProjectId;\n  }\n  /**\n   * Initiates WalletConnect client.\n   */\n  _createClass(WalletConnectProviderV2, [{\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var client;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return sign_client_1.default.init({\n                  relayUrl: this.walletConnectV2Relay,\n                  projectId: this.walletConnectV2ProjectId\n                });\n              case 3:\n                client = _context.sent;\n                this.walletConnector = client;\n                _context.next = 7;\n                return this.subscribeToEvents(client);\n              case 7:\n                _context.next = 9;\n                return this.checkPersistedState(client);\n              case 9:\n                _context.next = 14;\n                break;\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](0);\n                throw new Error(\"connect: WalletConnect is unable to init\");\n              case 14:\n                _context.prev = 14;\n                this.isInitializing = false;\n                return _context.finish(14);\n              case 17:\n                return _context.abrupt(\"return\", true);\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 11, 14, 17]]);\n      }));\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !!this.walletConnector;\n    }\n    /**\n     * Returns true if provider is initialized and a valid session is set\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var _this = this;\n      return new Promise(function (resolve, _) {\n        return resolve(Boolean(_this.isInitialized() && typeof _this.session !== \"undefined\"));\n      });\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(options) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var methods, chains, events, response;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context2.next = 3;\n                  break;\n                }\n                _context2.next = 3;\n                return this.init();\n              case 3:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context2.next = 5;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 5:\n                methods = [].concat(_toConsumableArray(Object.values(operation_1.Operation)), _toConsumableArray((_a = options === null || options === void 0 ? void 0 : options.methods) !== null && _a !== void 0 ? _a : []));\n                chains = [\"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId)];\n                events = (_b = options === null || options === void 0 ? void 0 : options.events) !== null && _b !== void 0 ? _b : [];\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this.walletConnector.connect({\n                  pairingTopic: options === null || options === void 0 ? void 0 : options.topic,\n                  requiredNamespaces: _defineProperty({}, constants_1.WALLETCONNECT_ELROND_NAMESPACE, {\n                    methods: methods,\n                    chains: chains,\n                    events: events\n                  })\n                });\n              case 11:\n                response = _context2.sent;\n                this.events = events;\n                this.methods = methods;\n                return _context2.abrupt(\"return\", response);\n              case 17:\n                _context2.prev = 17;\n                _context2.t0 = _context2[\"catch\"](8);\n                if (!(options === null || options === void 0 ? void 0 : options.topic)) {\n                  _context2.next = 26;\n                  break;\n                }\n                _context2.next = 22;\n                return this.logout({\n                  topic: options.topic\n                });\n              case 22:\n                logger_1.Logger.error(\"connect: WalletConnect is unable to connect to existing pairing\");\n                throw new Error(\"connect: WalletConnect is unable to connect to existing pairing\");\n              case 26:\n                logger_1.Logger.error(\"connect: WalletConnect is unable to connect\");\n                throw new Error(\"connect: WalletConnect is unable to connect\");\n              case 28:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 17]]);\n      }));\n    }\n  }, {\n    key: \"login\",\n    value: function login(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var session, address, _yield$this$walletCon, signature;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.isInitializing = true;\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context3.next = 4;\n                  break;\n                }\n                _context3.next = 4;\n                return this.connect();\n              case 4:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context3.next = 6;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 6:\n                if (!(typeof this.session !== \"undefined\")) {\n                  _context3.next = 9;\n                  break;\n                }\n                _context3.next = 9;\n                return this.logout();\n              case 9:\n                _context3.prev = 9;\n                if (!(options && options.approval)) {\n                  _context3.next = 29;\n                  break;\n                }\n                _context3.next = 13;\n                return options.approval();\n              case 13:\n                session = _context3.sent;\n                if (!options.token) {\n                  _context3.next = 26;\n                  break;\n                }\n                address = this.getAddressFromSession(session);\n                _context3.next = 18;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_LOGIN_TOKEN,\n                    params: {\n                      token: options.token,\n                      address: address\n                    }\n                  }\n                });\n              case 18:\n                _yield$this$walletCon = _context3.sent;\n                signature = _yield$this$walletCon.signature;\n                if (signature) {\n                  _context3.next = 23;\n                  break;\n                }\n                logger_1.Logger.error(\"login: WalletConnect could not sign login token\");\n                throw new Error(\"WalletConnect could not sign login token\");\n              case 23:\n                _context3.next = 25;\n                return this.onSessionConnected({\n                  session: session,\n                  signature: signature\n                });\n              case 25:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 26:\n                _context3.next = 28;\n                return this.onSessionConnected({\n                  session: session,\n                  signature: \"\"\n                });\n              case 28:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 29:\n                _context3.next = 35;\n                break;\n              case 31:\n                _context3.prev = 31;\n                _context3.t0 = _context3[\"catch\"](9);\n                logger_1.Logger.error(\"login: WalletConnect is unable to login\");\n                throw new Error(\"login: WalletConnect is unable to login\");\n              case 35:\n                _context3.prev = 35;\n                this.isInitializing = false;\n                return _context3.finish(35);\n              case 38:\n                return _context3.abrupt(\"return\", \"\");\n              case 39:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[9, 31, 35, 38]]);\n      }));\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n  }, {\n    key: \"logout\",\n    value: function logout(options) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var topic, newPairings;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context4.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"logout: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                _context4.prev = 3;\n                topic = (_a = options === null || options === void 0 ? void 0 : options.topic) !== null && _a !== void 0 ? _a : (_b = this.session) === null || _b === void 0 ? void 0 : _b.topic;\n                if (!topic) {\n                  _context4.next = 10;\n                  break;\n                }\n                _context4.next = 8;\n                return this.walletConnector.disconnect({\n                  topic: topic,\n                  reason: utils_1.getSdkError(\"USER_DISCONNECTED\")\n                });\n              case 8:\n                newPairings = this.walletConnector.pairing.getAll({\n                  active: true\n                }).filter(function (pairing) {\n                  return pairing.topic !== topic;\n                });\n                this.pairings = newPairings;\n              case 10:\n                _context4.next = 15;\n                break;\n              case 12:\n                _context4.prev = 12;\n                _context4.t0 = _context4[\"catch\"](3);\n                logger_1.Logger.error(\"logout: WalletConnect was unable to logout\");\n              case 15:\n                return _context4.abrupt(\"return\", true);\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 12]]);\n      }));\n    }\n    /**\n     * Fetches the WalletConnect address\n     */\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context5.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getAddress: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                return _context5.abrupt(\"return\", this.address);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Fetches the WalletConnect signature\n     */\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context6.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getSignature: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                return _context6.abrupt(\"return\", this.signature);\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Fetches the WalletConnect pairings\n     */\n  }, {\n    key: \"getPairings\",\n    value: function getPairings() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context7.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"getPairings: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                return _context7.abrupt(\"return\", (_a = this.pairings) !== null && _a !== void 0 ? _a : this.walletConnector.pairing.getAll({\n                  active: true\n                }));\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Signs a message and returns it signed\n     * @param message\n     */\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var address, _yield$this$walletCon2, signature;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context8.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signMessage: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                if (!(typeof this.session === \"undefined\")) {\n                  _context8.next = 6;\n                  break;\n                }\n                logger_1.Logger.error(\"signMessage: Session is not connected\");\n                throw new Error(\"Session is not connected\");\n              case 6:\n                _context8.next = 8;\n                return this.getAddress();\n              case 8:\n                address = _context8.sent;\n                _context8.next = 11;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_MESSAGE,\n                    params: {\n                      address: address,\n                      message: message.message.toString()\n                    }\n                  }\n                });\n              case 11:\n                _yield$this$walletCon2 = _context8.sent;\n                signature = _yield$this$walletCon2.signature;\n                if (signature) {\n                  _context8.next = 16;\n                  break;\n                }\n                logger_1.Logger.error(\"signMessage: WalletConnect could not sign the message\");\n                throw new Error(\"WalletConnect could not sign the message\");\n              case 16:\n                message.applySignature(new primitives_1.Signature(signature), userAddress_1.UserAddress.fromBech32(address));\n                return _context8.abrupt(\"return\", message);\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Signs a transaction and returns it signed\n     * @param transaction\n     */\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var address, sender, wcTransaction, _yield$this$walletCon3, signature;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context9.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                if (!(typeof this.session === \"undefined\")) {\n                  _context9.next = 6;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: Session is not connected\");\n                throw new Error(\"Session is not connected\");\n              case 6:\n                _context9.next = 8;\n                return this.getAddress();\n              case 8:\n                address = _context9.sent;\n                sender = new primitives_1.Address(address);\n                wcTransaction = transaction.toPlainObject(sender);\n                if (!(this.chainId !== transaction.getChainID().valueOf())) {\n                  _context9.next = 14;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: Transaction Chain Id different than Connection Chain Id\");\n                throw new Error(\"Transaction Chain Id different than Connection Chain Id\");\n              case 14:\n                _context9.next = 16;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_TRANSACTION,\n                    params: {\n                      transaction: wcTransaction\n                    }\n                  }\n                });\n              case 16:\n                _yield$this$walletCon3 = _context9.sent;\n                signature = _yield$this$walletCon3.signature;\n                if (signature) {\n                  _context9.next = 21;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransaction: WalletConnect could not sign the transaction\");\n                throw new Error(\"WalletConnect could not sign the transaction\");\n              case 21:\n                transaction.applySignature(primitives_1.Signature.fromHex(signature), userAddress_1.UserAddress.fromBech32(address));\n                return _context9.abrupt(\"return\", transaction);\n              case 23:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Signs an array of transactions and returns it signed\n     * @param transactions\n     */\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(transactions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _this2 = this;\n        var address, sender, wcTransactions, _yield$this$walletCon4, signatures, _iterator, _step, _step$value, index, transaction;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context10.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                if (!(typeof this.session === \"undefined\")) {\n                  _context10.next = 6;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: Session is not connected\");\n                throw new Error(\"Session is not connected\");\n              case 6:\n                _context10.next = 8;\n                return this.getAddress();\n              case 8:\n                address = _context10.sent;\n                sender = new primitives_1.Address(address);\n                wcTransactions = transactions.map(function (transaction) {\n                  if (_this2.chainId !== transaction.getChainID().valueOf()) {\n                    logger_1.Logger.error(\"signTransactions: Transaction Chain Id different than Connection Chain Id\");\n                    throw new Error(\"Transactions Chain Id different than Connection Chain Id\");\n                  }\n                  return transaction.toPlainObject(sender);\n                });\n                _context10.next = 13;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: {\n                    method: operation_1.Operation.SIGN_TRANSACTIONS,\n                    params: {\n                      transactions: wcTransactions\n                    }\n                  }\n                });\n              case 13:\n                _yield$this$walletCon4 = _context10.sent;\n                signatures = _yield$this$walletCon4.signatures;\n                if (!(!signatures || !Array.isArray(signatures))) {\n                  _context10.next = 18;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: WalletConnect could not sign the transactions\");\n                throw new Error(\"WalletConnect could not sign the transactions\");\n              case 18:\n                if (!(transactions.length !== signatures.length)) {\n                  _context10.next = 21;\n                  break;\n                }\n                logger_1.Logger.error(\"signTransactions: WalletConnect could not sign the transactions. Invalid signatures.\");\n                throw new Error(\"WalletConnect could not sign the transactions. Invalid signatures.\");\n              case 21:\n                _iterator = _createForOfIteratorHelper(transactions.entries());\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], transaction = _step$value[1];\n                    transaction.applySignature(primitives_1.Signature.fromHex(signatures[index].signature), userAddress_1.UserAddress.fromBech32(address));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n                return _context10.abrupt(\"return\", transactions);\n              case 24:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Sends a custom request\n     * @param request\n     */\n  }, {\n    key: \"sendCustomRequest\",\n    value: function sendCustomRequest(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _yield$this$walletCon5, response;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context11.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomRequest: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                if (!(typeof this.session === \"undefined\")) {\n                  _context11.next = 6;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomRequest: Session is not connected\");\n                throw new Error(\"Session is not connected\");\n              case 6:\n                if (!(options === null || options === void 0 ? void 0 : options.request)) {\n                  _context11.next = 15;\n                  break;\n                }\n                _context11.next = 9;\n                return this.walletConnector.request({\n                  chainId: \"\".concat(constants_1.WALLETCONNECT_ELROND_NAMESPACE, \":\").concat(this.chainId),\n                  topic: this.session.topic,\n                  request: options.request\n                });\n              case 9:\n                _yield$this$walletCon5 = _context11.sent;\n                response = _yield$this$walletCon5.response;\n                if (response) {\n                  _context11.next = 14;\n                  break;\n                }\n                logger_1.Logger.error(\"sendCustomRequest: WalletConnect could not send the custom request\");\n                throw new Error(\"WalletConnect could not send the custom request\");\n              case 14:\n                return _context11.abrupt(\"return\", response);\n              case 15:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n    /**\n     * Ping helper\n     */\n  }, {\n    key: \"ping\",\n    value: function ping() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context12.next = 3;\n                  break;\n                }\n                logger_1.Logger.error(\"ping: WalletConnect not initialised, call init() first\");\n                throw new Error(\"WalletConnect not initialised, call init() first\");\n              case 3:\n                if (!(typeof this.session === \"undefined\")) {\n                  _context12.next = 6;\n                  break;\n                }\n                logger_1.Logger.error(\"ping: Session is not connected\");\n                throw new Error(\"Session is not connected\");\n              case 6:\n                _context12.prev = 6;\n                _context12.next = 9;\n                return this.walletConnector.ping({\n                  topic: this.session.topic\n                });\n              case 9:\n                return _context12.abrupt(\"return\", true);\n              case 12:\n                _context12.prev = 12;\n                _context12.t0 = _context12[\"catch\"](6);\n                logger_1.Logger.error(\"ping: Ping failed\");\n                return _context12.abrupt(\"return\", false);\n              case 16:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[6, 12]]);\n      }));\n    }\n  }, {\n    key: \"loginAccount\",\n    value: function loginAccount(options) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var newPairings;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (options) {\n                  _context13.next = 2;\n                  break;\n                }\n                return _context13.abrupt(\"return\");\n              case 2:\n                if (!this.addressIsValid(options.address)) {\n                  _context13.next = 7;\n                  break;\n                }\n                this.address = options.address;\n                if (options.signature) {\n                  this.signature = options.signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return _context13.abrupt(\"return\");\n              case 7:\n                logger_1.Logger.error(\"WalletConnect invalid address \".concat(options.address));\n                if (!(((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) && this.walletConnector)) {\n                  _context13.next = 13;\n                  break;\n                }\n                _context13.next = 11;\n                return this.walletConnector.disconnect({\n                  topic: this.session.topic,\n                  reason: utils_1.getSdkError(\"USER_DISCONNECTED\")\n                });\n              case 11:\n                newPairings = this.walletConnector.pairing.getAll({\n                  active: true\n                });\n                this.pairings = newPairings;\n              case 13:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n  }, {\n    key: \"onSessionConnected\",\n    value: function onSessionConnected(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var address;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (options) {\n                  _context14.next = 2;\n                  break;\n                }\n                return _context14.abrupt(\"return\", \"\");\n              case 2:\n                this.session = options.session;\n                address = this.getAddressFromSession(options.session);\n                if (!address) {\n                  _context14.next = 7;\n                  break;\n                }\n                _context14.next = 7;\n                return this.loginAccount({\n                  address: address,\n                  signature: options.signature\n                });\n              case 7:\n                return _context14.abrupt(\"return\", \"\");\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n  }, {\n    key: \"handleTopicUpdateEvent\",\n    value: function handleTopicUpdateEvent(_ref) {\n      var topic = _ref.topic;\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context15.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                this.pairings = this.walletConnector.pairing.getAll({\n                  active: true\n                });\n                if (this.address && !this.isInitializing && (((_a = this === null || this === void 0 ? void 0 : this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic || this.pairings.length === 0)) {\n                  this.onClientConnect.onClientLogout();\n                }\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n    }\n  }, {\n    key: \"handleSessionEvents\",\n    value: function handleSessionEvents(_ref2) {\n      var topic = _ref2.topic,\n        params = _ref2.params;\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var event, eventData, session;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!(typeof this.walletConnector === \"undefined\")) {\n                  _context16.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                event = params.event;\n                if ((event === null || event === void 0 ? void 0 : event.name) && ((_a = this.session) === null || _a === void 0 ? void 0 : _a.topic) === topic) {\n                  eventData = event.data;\n                  session = this.walletConnector.session.get(topic);\n                  this.onClientConnect.onClientEvent(eventData);\n                }\n              case 4:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n  }, {\n    key: \"subscribeToEvents\",\n    value: function subscribeToEvents(client) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var _this3 = this;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!(typeof client === \"undefined\")) {\n                  _context17.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                client.on(\"session_update\", function (_ref3) {\n                  var topic = _ref3.topic,\n                    params = _ref3.params;\n                  var namespaces = params.namespaces;\n                  var _session = client.session.get(topic);\n                  var updatedSession = Object.assign(Object.assign({}, _session), {\n                    namespaces: namespaces\n                  });\n                  _this3.onSessionConnected({\n                    session: updatedSession\n                  });\n                });\n                client.on(\"session_event\", this.handleSessionEvents.bind(this));\n                client.on(\"session_expire\", this.handleTopicUpdateEvent.bind(this));\n                client.on(\"session_delete\", this.handleTopicUpdateEvent.bind(this));\n                client.on(\"pairing_expire\", this.handleTopicUpdateEvent.bind(this));\n                client.on(\"pairing_delete\", this.handleTopicUpdateEvent.bind(this));\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n  }, {\n    key: \"checkPersistedState\",\n    value: function checkPersistedState(client) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var lastKeyIndex, session;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!(typeof client === \"undefined\")) {\n                  _context18.next = 2;\n                  break;\n                }\n                throw new Error(\"WalletConnect is not initialized\");\n              case 2:\n                this.pairings = client.pairing.getAll({\n                  active: true\n                });\n                if (!(typeof this.session !== \"undefined\")) {\n                  _context18.next = 5;\n                  break;\n                }\n                return _context18.abrupt(\"return\");\n              case 5:\n                if (!(client.session.length && !this.address && !this.isInitializing)) {\n                  _context18.next = 11;\n                  break;\n                }\n                lastKeyIndex = client.session.keys.length - 1;\n                session = client.session.get(client.session.keys[lastKeyIndex]);\n                _context18.next = 10;\n                return this.onSessionConnected({\n                  session: session\n                });\n              case 10:\n                return _context18.abrupt(\"return\", session);\n              case 11:\n                return _context18.abrupt(\"return\");\n              case 12:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n    }\n  }, {\n    key: \"addressIsValid\",\n    value: function addressIsValid(destinationAddress) {\n      try {\n        var addr = userAddress_1.UserAddress.fromBech32(destinationAddress);\n        return !!addr;\n      } catch (_a) {\n        return false;\n      }\n    }\n  }, {\n    key: \"getAddressFromSession\",\n    value: function getAddressFromSession(session) {\n      var selectedNamespace = session.namespaces[constants_1.WALLETCONNECT_ELROND_NAMESPACE];\n      if (selectedNamespace && selectedNamespace.accounts) {\n        // Use only the first address in case of multiple provided addresses\n        var currentSession = selectedNamespace.accounts[0];\n        var _currentSession$split = currentSession.split(\":\"),\n          _currentSession$split2 = _slicedToArray(_currentSession$split, 3),\n          namespace = _currentSession$split2[0],\n          reference = _currentSession$split2[1],\n          address = _currentSession$split2[2];\n        return address;\n      }\n      return \"\";\n    }\n  }]);\n  return WalletConnectProviderV2;\n}();\nexports.WalletConnectProviderV2 = WalletConnectProviderV2;","map":null,"metadata":{},"sourceType":"script"}