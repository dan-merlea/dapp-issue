{"ast":null,"code":"import _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * A class used to parse Tiled maps from JSON.\n */\nexport var Map = /*#__PURE__*/function () {\n  // Constructor\n  function Map(data, fixedTileSize) {\n    var margin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var spacing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    _classCallCheck(this, Map);\n    this.margin = 0;\n    this.spacing = 0;\n    this.imageName = ''; // The image to slice up\n    this.tilesets = {};\n    this.collisions = [];\n    this.spawners = [];\n    this.layers = [];\n    if (!data) {\n      throw Error('Map does not exist');\n    }\n    this.mapWidthUnits = data.width;\n    this.mapHeightUnits = data.height;\n    this.fixedTileSize = fixedTileSize;\n    this.margin = margin;\n    this.spacing = spacing;\n    this.computeTileSets(data.tilesets);\n    this.computeCollisions(data.layers);\n    this.computeSpawners(data.layers);\n    this.computeLayers(data.layers);\n  }\n  // Methods\n  _createClass(Map, [{\n    key: \"computeTileSets\",\n    value: function computeTileSets(tilesets) {\n      var _this = this;\n      if (!tilesets || !tilesets.length) {\n        return;\n      }\n      // We only take the first tileset\n      var foundTileset = tilesets[0];\n      var offset = foundTileset.firstgid; // There is an offset needed to compute tileId in layers\n      this.imageName = foundTileset.image;\n      // Compute the position of each sprite into the image\n      var tileWidth = foundTileset.tilewidth;\n      var tileHeight = foundTileset.tileheight;\n      var imageWidthInUnits = foundTileset.imagewidth / tileWidth;\n      var col = 0;\n      var row = 0;\n      var x;\n      var y;\n      for (var i = 0; i < foundTileset.tilecount; i++) {\n        var tileId = i + offset;\n        x = col * (tileWidth + this.spacing) + this.margin;\n        y = row * (tileHeight + this.spacing) + this.margin;\n        this.tilesets[tileId] = {\n          tileId: tileId,\n          minX: x,\n          minY: y,\n          maxX: x + tileWidth,\n          maxY: y + tileHeight\n        };\n        col++;\n        if (col === imageWidthInUnits) {\n          col = 0;\n          row++;\n        }\n      }\n      // Compute special tiles\n      foundTileset.tiles.forEach(function (tile) {\n        var tileId = tile.id + offset;\n        // Compute animated tiles\n        if (tile.animation && tile.animation.length > 0) {\n          var animationId = tileId;\n          var foundTile = _this.tilesets[animationId];\n          if (foundTile) {\n            _this.tilesets[animationId].tileIds = tile.animation.map(function (frame) {\n              return frame.tileid + offset;\n            });\n          }\n        }\n        // Compute special tiles\n        if (tile.type) {\n          _this.tilesets[tileId].type = tile.type;\n        }\n      });\n    }\n  }, {\n    key: \"computeCollisions\",\n    value: function computeCollisions(layers) {\n      var foundLayer = layers.find(function (layer) {\n        return layer.name === 'collisions';\n      });\n      if (!foundLayer) {\n        console.log('ERROR: Could not find the collisions layer');\n        return;\n      }\n      this.collisions = this.parseLayer(foundLayer.data);\n    }\n  }, {\n    key: \"computeSpawners\",\n    value: function computeSpawners(layers) {\n      var foundLayer = layers.find(function (layer) {\n        return layer.name === 'spawners';\n      });\n      if (!foundLayer) {\n        return;\n      }\n      this.spawners = this.parseLayer(foundLayer.data);\n    }\n  }, {\n    key: \"computeLayers\",\n    value: function computeLayers(layers) {\n      var _this2 = this;\n      if (!layers || !layers.length) {\n        return;\n      }\n      layers.forEach(function (layer) {\n        _this2.layers.push({\n          name: layer.name,\n          tiles: _this2.parseLayer(layer.data)\n        });\n      });\n    }\n  }, {\n    key: \"parseLayer\",\n    value: function parseLayer(data) {\n      var _this3 = this;\n      if (!data || !data.length) {\n        return [];\n      }\n      var col = 0;\n      var row = 0;\n      var x = 0;\n      var y = 0;\n      var tileWidth = this.fixedTileSize;\n      var tileHeight = this.fixedTileSize;\n      var tiles = [];\n      data.forEach(function (tileId) {\n        if (tileId !== 0) {\n          var foundTile = _this3.tilesets[tileId];\n          x = col * tileWidth;\n          y = row * tileHeight;\n          // Set the tile\n          tiles.push(Object.assign({\n            tileId: tileId,\n            minX: x,\n            minY: y,\n            maxX: x + tileWidth,\n            maxY: y + tileHeight\n          }, foundTile.type && {\n            type: foundTile.type\n          }));\n        }\n        col++;\n        // Jump to new line\n        if (col === _this3.widthInUnits) {\n          col = 0;\n          row++;\n        }\n      });\n      return tiles;\n    }\n    // Getters\n  }, {\n    key: \"widthInUnits\",\n    get: function get() {\n      return this.mapWidthUnits;\n    }\n  }, {\n    key: \"heightInUnits\",\n    get: function get() {\n      return this.mapHeightUnits;\n    }\n  }, {\n    key: \"widthInPixels\",\n    get: function get() {\n      return this.mapWidthUnits * this.fixedTileSize;\n    }\n  }, {\n    key: \"heightInPixels\",\n    get: function get() {\n      return this.mapHeightUnits * this.fixedTileSize;\n    }\n  }]);\n  return Map;\n}();","map":{"version":3,"names":["Map","data","fixedTileSize","margin","spacing","imageName","tilesets","collisions","spawners","layers","Error","mapWidthUnits","width","mapHeightUnits","height","computeTileSets","computeCollisions","computeSpawners","computeLayers","length","foundTileset","offset","firstgid","image","tileWidth","tilewidth","tileHeight","tileheight","imageWidthInUnits","imagewidth","col","row","x","y","i","tilecount","tileId","minX","minY","maxX","maxY","tiles","forEach","tile","id","animation","animationId","foundTile","tileIds","map","frame","tileid","type","foundLayer","find","layer","name","console","log","parseLayer","push","Object","assign","widthInUnits"],"sources":["/Users/merlea/Development/Crypto/Krogan/kroganverse-com/packages/common/build/tiled/map.js"],"sourcesContent":["/**\n * A class used to parse Tiled maps from JSON.\n */\nexport class Map {\n    // Constructor\n    constructor(data, fixedTileSize, margin = 0, spacing = 0) {\n        this.margin = 0;\n        this.spacing = 0;\n        this.imageName = ''; // The image to slice up\n        this.tilesets = {};\n        this.collisions = [];\n        this.spawners = [];\n        this.layers = [];\n        if (!data) {\n            throw Error('Map does not exist');\n        }\n        this.mapWidthUnits = data.width;\n        this.mapHeightUnits = data.height;\n        this.fixedTileSize = fixedTileSize;\n        this.margin = margin;\n        this.spacing = spacing;\n        this.computeTileSets(data.tilesets);\n        this.computeCollisions(data.layers);\n        this.computeSpawners(data.layers);\n        this.computeLayers(data.layers);\n    }\n    // Methods\n    computeTileSets(tilesets) {\n        if (!tilesets || !tilesets.length) {\n            return;\n        }\n        // We only take the first tileset\n        const foundTileset = tilesets[0];\n        const offset = foundTileset.firstgid; // There is an offset needed to compute tileId in layers\n        this.imageName = foundTileset.image;\n        // Compute the position of each sprite into the image\n        const tileWidth = foundTileset.tilewidth;\n        const tileHeight = foundTileset.tileheight;\n        const imageWidthInUnits = foundTileset.imagewidth / tileWidth;\n        let col = 0;\n        let row = 0;\n        let x;\n        let y;\n        for (let i = 0; i < foundTileset.tilecount; i++) {\n            const tileId = i + offset;\n            x = col * (tileWidth + this.spacing) + this.margin;\n            y = row * (tileHeight + this.spacing) + this.margin;\n            this.tilesets[tileId] = {\n                tileId,\n                minX: x,\n                minY: y,\n                maxX: x + tileWidth,\n                maxY: y + tileHeight,\n            };\n            col++;\n            if (col === imageWidthInUnits) {\n                col = 0;\n                row++;\n            }\n        }\n        // Compute special tiles\n        foundTileset.tiles.forEach((tile) => {\n            const tileId = tile.id + offset;\n            // Compute animated tiles\n            if (tile.animation && tile.animation.length > 0) {\n                const animationId = tileId;\n                const foundTile = this.tilesets[animationId];\n                if (foundTile) {\n                    this.tilesets[animationId].tileIds = tile.animation.map((frame) => frame.tileid + offset);\n                }\n            }\n            // Compute special tiles\n            if (tile.type) {\n                this.tilesets[tileId].type = tile.type;\n            }\n        });\n    }\n    computeCollisions(layers) {\n        const foundLayer = layers.find((layer) => layer.name === 'collisions');\n        if (!foundLayer) {\n            console.log('ERROR: Could not find the collisions layer');\n            return;\n        }\n        this.collisions = this.parseLayer(foundLayer.data);\n    }\n    computeSpawners(layers) {\n        const foundLayer = layers.find((layer) => layer.name === 'spawners');\n        if (!foundLayer) {\n            return;\n        }\n        this.spawners = this.parseLayer(foundLayer.data);\n    }\n    computeLayers(layers) {\n        if (!layers || !layers.length) {\n            return;\n        }\n        layers.forEach((layer) => {\n            this.layers.push({\n                name: layer.name,\n                tiles: this.parseLayer(layer.data),\n            });\n        });\n    }\n    parseLayer(data) {\n        if (!data || !data.length) {\n            return [];\n        }\n        let col = 0;\n        let row = 0;\n        let x = 0;\n        let y = 0;\n        const tileWidth = this.fixedTileSize;\n        const tileHeight = this.fixedTileSize;\n        const tiles = [];\n        data.forEach((tileId) => {\n            if (tileId !== 0) {\n                const foundTile = this.tilesets[tileId];\n                x = col * tileWidth;\n                y = row * tileHeight;\n                // Set the tile\n                tiles.push(Object.assign({ tileId, minX: x, minY: y, maxX: x + tileWidth, maxY: y + tileHeight }, (foundTile.type && { type: foundTile.type })));\n            }\n            col++;\n            // Jump to new line\n            if (col === this.widthInUnits) {\n                col = 0;\n                row++;\n            }\n        });\n        return tiles;\n    }\n    // Getters\n    get widthInUnits() {\n        return this.mapWidthUnits;\n    }\n    get heightInUnits() {\n        return this.mapHeightUnits;\n    }\n    get widthInPixels() {\n        return this.mapWidthUnits * this.fixedTileSize;\n    }\n    get heightInPixels() {\n        return this.mapHeightUnits * this.fixedTileSize;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}