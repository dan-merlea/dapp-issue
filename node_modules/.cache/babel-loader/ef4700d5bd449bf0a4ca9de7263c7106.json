{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nvar codec_1 = require(\"./codec\");\nvar composite_1 = require(\"./typesystem/composite\");\nvar variadic_1 = require(\"./typesystem/variadic\");\nvar algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nvar Codec = new codec_1.BinaryCodec();\nvar ArgSerializer = /*#__PURE__*/function () {\n  function ArgSerializer() {\n    _classCallCheck(this, ArgSerializer);\n  }\n  _createClass(ArgSerializer, [{\n    key: \"stringToValues\",\n    value:\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    function stringToValues(joinedString, parameters) {\n      var buffers = this.stringToBuffers(joinedString);\n      var values = this.buffersToValues(buffers, parameters);\n      return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n  }, {\n    key: \"stringToBuffers\",\n    value: function stringToBuffers(joinedString) {\n      // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n      return joinedString.split(exports.ArgumentsSeparator).map(function (item) {\n        return Buffer.from(item, \"hex\");\n      });\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n  }, {\n    key: \"buffersToValues\",\n    value: function buffersToValues(buffers, parameters) {\n      // TODO: Refactor, split (function is quite complex).\n      buffers = buffers || [];\n      var values = [];\n      var bufferIndex = 0;\n      var numBuffers = buffers.length;\n      for (var i = 0; i < parameters.length; i++) {\n        var parameter = parameters[i];\n        var type = parameter.type;\n        var value = readValue(type);\n        values.push(value);\n      }\n      // This is a recursive function.\n      function readValue(type) {\n        // TODO: Use matchers.\n        if (type.hasExactClass(algebraic_1.OptionalType.ClassName)) {\n          var typedValue = readValue(type.getFirstTypeParameter());\n          return new algebraic_1.OptionalValue(type, typedValue);\n        } else if (type.hasExactClass(variadic_1.VariadicType.ClassName)) {\n          var typedValues = [];\n          while (!hasReachedTheEnd()) {\n            typedValues.push(readValue(type.getFirstTypeParameter()));\n          }\n          return new variadic_1.VariadicValue(type, typedValues);\n        } else if (type.hasExactClass(composite_1.CompositeType.ClassName)) {\n          var _typedValues = [];\n          var _iterator = _createForOfIteratorHelper(type.getTypeParameters()),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var typeParameter = _step.value;\n              _typedValues.push(readValue(typeParameter));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return new composite_1.CompositeValue(type, _typedValues);\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var _typedValue = decodeNextBuffer(type);\n          return _typedValue;\n        }\n      }\n      function decodeNextBuffer(type) {\n        if (hasReachedTheEnd()) {\n          return null;\n        }\n        var buffer = buffers[bufferIndex++];\n        var decodedValue = Codec.decodeTopLevel(buffer, type);\n        return decodedValue;\n      }\n      function hasReachedTheEnd() {\n        return bufferIndex >= numBuffers;\n      }\n      return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n  }, {\n    key: \"valuesToString\",\n    value: function valuesToString(values) {\n      var strings = this.valuesToStrings(values);\n      var argumentsString = strings.join(exports.ArgumentsSeparator);\n      var count = strings.length;\n      return {\n        argumentsString: argumentsString,\n        count: count\n      };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n  }, {\n    key: \"valuesToStrings\",\n    value: function valuesToStrings(values) {\n      var buffers = this.valuesToBuffers(values);\n      var strings = buffers.map(function (buffer) {\n        return buffer.toString(\"hex\");\n      });\n      return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n  }, {\n    key: \"valuesToBuffers\",\n    value: function valuesToBuffers(values) {\n      // TODO: Refactor, split (function is quite complex).\n      var buffers = [];\n      var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      function handleValue(value) {\n        // TODO: Use matchers.\n        if (value.hasExactClass(algebraic_1.OptionalValue.ClassName)) {\n          var valueAsOptional = value;\n          if (valueAsOptional.isSet()) {\n            handleValue(valueAsOptional.getTypedValue());\n          }\n        } else if (value.hasExactClass(variadic_1.VariadicValue.ClassName)) {\n          var valueAsVariadic = value;\n          var _iterator3 = _createForOfIteratorHelper(valueAsVariadic.getItems()),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var item = _step3.value;\n              handleValue(item);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else if (value.hasExactClass(composite_1.CompositeValue.ClassName)) {\n          var valueAsComposite = value;\n          var _iterator4 = _createForOfIteratorHelper(valueAsComposite.getItems()),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _item = _step4.value;\n              handleValue(_item);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var buffer = Codec.encodeTopLevel(value);\n          buffers.push(buffer);\n        }\n      }\n      return buffers;\n    }\n  }]);\n  return ArgSerializer;\n}();\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"mappings":"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","names":["exports","Codec","codec_1","ArgSerializer","joinedString","parameters","buffers","stringToBuffers","values","buffersToValues","split","map","Buffer","from","item","bufferIndex","numBuffers","length","i","parameter","type","value","readValue","push","hasExactClass","algebraic_1","ClassName","typedValue","getFirstTypeParameter","variadic_1","typedValues","hasReachedTheEnd","composite_1","getTypeParameters","typeParameter","decodeNextBuffer","buffer","decodedValue","decodeTopLevel","strings","valuesToStrings","argumentsString","join","count","valuesToBuffers","toString","handleValue","valueAsOptional","isSet","getTypedValue","valueAsVariadic","getItems","valueAsComposite","encodeTopLevel"],"sourceRoot":"","sources":["../../src/smartcontracts/argSerializer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}