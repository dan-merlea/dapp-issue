{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar core = require('@pixi/core');\nvar Bounds = require('./Bounds.js');\nvar DisplayObject = /*#__PURE__*/function (_core$utils$EventEmit) {\n  _inherits(DisplayObject, _core$utils$EventEmit);\n  var _super = _createSuper(DisplayObject);\n  function DisplayObject() {\n    var _this;\n    _classCallCheck(this, DisplayObject);\n    _this = _super.call(this);\n    _this.tempDisplayObjectParent = null;\n    _this.transform = new core.Transform();\n    _this.alpha = 1;\n    _this.visible = true;\n    _this.renderable = true;\n    _this.cullable = false;\n    _this.cullArea = null;\n    _this.parent = null;\n    _this.worldAlpha = 1;\n    _this._lastSortedIndex = 0;\n    _this._zIndex = 0;\n    _this.filterArea = null;\n    _this.filters = null;\n    _this._enabledFilters = null;\n    _this._bounds = new Bounds.Bounds();\n    _this._localBounds = null;\n    _this._boundsID = 0;\n    _this._boundsRect = null;\n    _this._localBoundsRect = null;\n    _this._mask = null;\n    _this._maskRefCount = 0;\n    _this._destroyed = false;\n    _this.isSprite = false;\n    _this.isMask = false;\n    return _this;\n  }\n  _createClass(DisplayObject, [{\n    key: \"destroyed\",\n    get: function get() {\n      return this._destroyed;\n    }\n  }, {\n    key: \"_recursivePostUpdateTransform\",\n    value: function _recursivePostUpdateTransform() {\n      if (this.parent) {\n        this.parent._recursivePostUpdateTransform();\n        this.transform.updateTransform(this.parent.transform);\n      } else {\n        this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n      }\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      this._boundsID++;\n      this.transform.updateTransform(this.parent.transform);\n      this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(skipUpdate, rect) {\n      if (!skipUpdate) {\n        if (!this.parent) {\n          this.parent = this._tempDisplayObjectParent;\n          this.updateTransform();\n          this.parent = null;\n        } else {\n          this._recursivePostUpdateTransform();\n          this.updateTransform();\n        }\n      }\n      if (this._bounds.updateID !== this._boundsID) {\n        this.calculateBounds();\n        this._bounds.updateID = this._boundsID;\n      }\n      if (!rect) {\n        if (!this._boundsRect) {\n          this._boundsRect = new core.Rectangle();\n        }\n        rect = this._boundsRect;\n      }\n      return this._bounds.getRectangle(rect);\n    }\n  }, {\n    key: \"getLocalBounds\",\n    value: function getLocalBounds(rect) {\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new core.Rectangle();\n        }\n        rect = this._localBoundsRect;\n      }\n      if (!this._localBounds) {\n        this._localBounds = new Bounds.Bounds();\n      }\n      var transformRef = this.transform;\n      var parentRef = this.parent;\n      this.parent = null;\n      this.transform = this._tempDisplayObjectParent.transform;\n      var worldBounds = this._bounds;\n      var worldBoundsID = this._boundsID;\n      this._bounds = this._localBounds;\n      var bounds = this.getBounds(false, rect);\n      this.parent = parentRef;\n      this.transform = transformRef;\n      this._bounds = worldBounds;\n      this._bounds.updateID += this._boundsID - worldBoundsID;\n      return bounds;\n    }\n  }, {\n    key: \"toGlobal\",\n    value: function toGlobal(position, point) {\n      var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!skipUpdate) {\n        this._recursivePostUpdateTransform();\n        if (!this.parent) {\n          this.parent = this._tempDisplayObjectParent;\n          this.displayObjectUpdateTransform();\n          this.parent = null;\n        } else {\n          this.displayObjectUpdateTransform();\n        }\n      }\n      return this.worldTransform.apply(position, point);\n    }\n  }, {\n    key: \"toLocal\",\n    value: function toLocal(position, from, point, skipUpdate) {\n      if (from) {\n        position = from.toGlobal(position, point, skipUpdate);\n      }\n      if (!skipUpdate) {\n        this._recursivePostUpdateTransform();\n        if (!this.parent) {\n          this.parent = this._tempDisplayObjectParent;\n          this.displayObjectUpdateTransform();\n          this.parent = null;\n        } else {\n          this.displayObjectUpdateTransform();\n        }\n      }\n      return this.worldTransform.applyInverse(position, point);\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(container) {\n      if (!container || !container.addChild) {\n        throw new Error(\"setParent: Argument must be a Container\");\n      }\n      container.addChild(this);\n      return container;\n    }\n  }, {\n    key: \"removeFromParent\",\n    value: function removeFromParent() {\n      var _this$parent;\n      (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.removeChild(this);\n    }\n  }, {\n    key: \"setTransform\",\n    value: function setTransform() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n      var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n      var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n      this.position.x = x;\n      this.position.y = y;\n      this.scale.x = !scaleX ? 1 : scaleX;\n      this.scale.y = !scaleY ? 1 : scaleY;\n      this.rotation = rotation;\n      this.skew.x = skewX;\n      this.skew.y = skewY;\n      this.pivot.x = pivotX;\n      this.pivot.y = pivotY;\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(_options) {\n      this.removeFromParent();\n      this._destroyed = true;\n      this.transform = null;\n      this.parent = null;\n      this._bounds = null;\n      this.mask = null;\n      this.cullArea = null;\n      this.filters = null;\n      this.filterArea = null;\n      this.hitArea = null;\n      this.interactive = false;\n      this.interactiveChildren = false;\n      this.emit(\"destroyed\");\n      this.removeAllListeners();\n    }\n  }, {\n    key: \"_tempDisplayObjectParent\",\n    get: function get() {\n      if (this.tempDisplayObjectParent === null) {\n        this.tempDisplayObjectParent = new TemporaryDisplayObject();\n      }\n      return this.tempDisplayObjectParent;\n    }\n  }, {\n    key: \"enableTempParent\",\n    value: function enableTempParent() {\n      var myParent = this.parent;\n      this.parent = this._tempDisplayObjectParent;\n      return myParent;\n    }\n  }, {\n    key: \"disableTempParent\",\n    value: function disableTempParent(cacheParent) {\n      this.parent = cacheParent;\n    }\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) {\n      this.transform.position.x = value;\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) {\n      this.transform.position.y = value;\n    }\n  }, {\n    key: \"worldTransform\",\n    get: function get() {\n      return this.transform.worldTransform;\n    }\n  }, {\n    key: \"localTransform\",\n    get: function get() {\n      return this.transform.localTransform;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this.transform.position;\n    },\n    set: function set(value) {\n      this.transform.position.copyFrom(value);\n    }\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return this.transform.scale;\n    },\n    set: function set(value) {\n      this.transform.scale.copyFrom(value);\n    }\n  }, {\n    key: \"pivot\",\n    get: function get() {\n      return this.transform.pivot;\n    },\n    set: function set(value) {\n      this.transform.pivot.copyFrom(value);\n    }\n  }, {\n    key: \"skew\",\n    get: function get() {\n      return this.transform.skew;\n    },\n    set: function set(value) {\n      this.transform.skew.copyFrom(value);\n    }\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this.transform.rotation;\n    },\n    set: function set(value) {\n      this.transform.rotation = value;\n    }\n  }, {\n    key: \"angle\",\n    get: function get() {\n      return this.transform.rotation * core.RAD_TO_DEG;\n    },\n    set: function set(value) {\n      this.transform.rotation = value * core.DEG_TO_RAD;\n    }\n  }, {\n    key: \"zIndex\",\n    get: function get() {\n      return this._zIndex;\n    },\n    set: function set(value) {\n      this._zIndex = value;\n      if (this.parent) {\n        this.parent.sortDirty = true;\n      }\n    }\n  }, {\n    key: \"worldVisible\",\n    get: function get() {\n      var item = this;\n      do {\n        if (!item.visible) {\n          return false;\n        }\n        item = item.parent;\n      } while (item);\n      return true;\n    }\n  }, {\n    key: \"mask\",\n    get: function get() {\n      return this._mask;\n    },\n    set: function set(value) {\n      if (this._mask === value) {\n        return;\n      }\n      if (this._mask) {\n        var maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n        if (maskObject) {\n          maskObject._maskRefCount--;\n          if (maskObject._maskRefCount === 0) {\n            maskObject.renderable = true;\n            maskObject.isMask = false;\n          }\n        }\n      }\n      this._mask = value;\n      if (this._mask) {\n        var _maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n        if (_maskObject) {\n          if (_maskObject._maskRefCount === 0) {\n            _maskObject.renderable = false;\n            _maskObject.isMask = true;\n          }\n          _maskObject._maskRefCount++;\n        }\n      }\n    }\n  }], [{\n    key: \"mixin\",\n    value: function mixin(source) {\n      var keys = Object.keys(source);\n      for (var i = 0; i < keys.length; ++i) {\n        var propertyName = keys[i];\n        Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));\n      }\n    }\n  }]);\n  return DisplayObject;\n}(core.utils.EventEmitter);\nvar TemporaryDisplayObject = /*#__PURE__*/function (_DisplayObject) {\n  _inherits(TemporaryDisplayObject, _DisplayObject);\n  var _super2 = _createSuper(TemporaryDisplayObject);\n  function TemporaryDisplayObject() {\n    var _this2;\n    _classCallCheck(this, TemporaryDisplayObject);\n    _this2 = _super2.apply(this, arguments);\n    _this2.sortDirty = null;\n    return _this2;\n  }\n  return _createClass(TemporaryDisplayObject);\n}(DisplayObject);\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\nexports.DisplayObject = DisplayObject;\nexports.TemporaryDisplayObject = TemporaryDisplayObject;","map":{"version":3,"sources":["../src/DisplayObject.ts"],"names":["utils","Transform","Bounds","Rectangle"],"mappings":"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","sourcesContent":["import { DEG_TO_RAD, RAD_TO_DEG, Rectangle, Transform, utils } from '@pixi/core';\nimport { Bounds } from './Bounds';\n\nimport type { Filter, IPointData, Matrix, MaskData, ObservablePoint, Point, Renderer } from '@pixi/core';\nimport type { Container } from './Container';\n\nexport interface IDestroyOptions\n{\n    children?: boolean;\n    texture?: boolean;\n    baseTexture?: boolean;\n}\n\nexport interface DisplayObjectEvents extends GlobalMixins.DisplayObjectEvents\n{\n    added: [Container];\n    childAdded: [DisplayObject, Container, number];\n    childRemoved: [DisplayObject, Container, number];\n    destroyed: [];\n    removed: [Container];\n    removedFrom: [DisplayObject, Container, number];\n}\n\nexport interface DisplayObject\n    extends Omit<GlobalMixins.DisplayObject, keyof utils.EventEmitter<DisplayObjectEvents>>,\n    utils.EventEmitter<DisplayObjectEvents> {}\n\n/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds()\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * It is recommended that applications use the `renderable` property for culling. See\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n * @memberof PIXI\n */\nexport abstract class DisplayObject extends utils.EventEmitter<DisplayObjectEvents>\n{\n    abstract sortDirty: boolean;\n\n    /** The display object container that contains this display object. */\n    public parent: Container;\n\n    /**\n     * The multiplied alpha of the displayObject.\n     * @readonly\n     */\n    public worldAlpha: number;\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing.\n     */\n    public transform: Transform;\n\n    /** The opacity of the object. */\n    public alpha: number;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.\n     */\n    public visible: boolean;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually.\n     */\n    public renderable: boolean;\n\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     */\n    public cullable: boolean;\n\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     */\n    public cullArea: Rectangle;\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     */\n    public filterArea: Rectangle;\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     */\n    public filters: Filter[] | null;\n\n    /** Used to fast check if a sprite is.. a sprite! */\n    public isSprite: boolean;\n\n    /** Does any other displayObject use this object as a mask? */\n    public isMask: boolean;\n\n    /**\n     * Which index in the children array the display component was before the previous zIndex sort.\n     * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.\n     * @protected\n     */\n    public _lastSortedIndex: number;\n\n    /**\n     * The original, cached mask of the object.\n     * @protected\n     */\n    public _mask: Container | MaskData;\n\n    /** The bounds object, this is used to calculate and store the bounds of the displayObject. */\n    public _bounds: Bounds;\n\n    /** Local bounds object, swapped with `_bounds` when using `getLocalBounds()`. */\n    public _localBounds: Bounds;\n\n    /**\n     * The zIndex of the displayObject.\n     * A higher value will mean it will be rendered on top of other displayObjects within the same container.\n     * @protected\n     */\n    protected _zIndex: number;\n\n    /**\n     * Currently enabled filters.\n     * @protected\n     */\n    protected _enabledFilters: Filter[];\n\n    /** Flags the cached bounds as dirty. */\n    protected _boundsID: number;\n\n    /** Cache of this display-object's bounds-rectangle. */\n    protected _boundsRect: Rectangle;\n\n    /** Cache of this display-object's local-bounds rectangle. */\n    protected _localBoundsRect: Rectangle;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    protected _destroyed: boolean;\n\n    /** The number of times this object is used as a mask by another object. */\n    private _maskRefCount: number;\n    private tempDisplayObjectParent: TemporaryDisplayObject;\n    public displayObjectUpdateTransform: () => void;\n\n    /**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     * @param source - The source of properties and methods to mix in.\n     */\n    static mixin(source: utils.Dict<any>): void\n    {\n        // in ES8/ES2017, this would be really easy:\n        // Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n\n        // get all the enumerable property keys\n        const keys = Object.keys(source);\n\n        // loop through properties\n        for (let i = 0; i < keys.length; ++i)\n        {\n            const propertyName = keys[i];\n\n            // Set the property using the property descriptor - this works for accessors and normal value properties\n            Object.defineProperty(\n                DisplayObject.prototype,\n                propertyName,\n                Object.getOwnPropertyDescriptor(source, propertyName)\n            );\n        }\n    }\n\n    constructor()\n    {\n        super();\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        this.transform = new Transform();\n        this.alpha = 1;\n        this.visible = true;\n        this.renderable = true;\n        this.cullable = false;\n        this.cullArea = null;\n\n        this.parent = null;\n        this.worldAlpha = 1;\n\n        this._lastSortedIndex = 0;\n        this._zIndex = 0;\n\n        this.filterArea = null;\n        this.filters = null;\n        this._enabledFilters = null;\n\n        this._bounds = new Bounds();\n        this._localBounds = null;\n        this._boundsID = 0;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n        this._mask = null;\n        this._maskRefCount = 0;\n        this._destroyed = false;\n\n        this.isSprite = false;\n        this.isMask = false;\n    }\n\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     * @instance\n     * @event added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     * @instance\n     * @event removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    /**\n     * Fired when this DisplayObject is destroyed. This event is emitted once\n     * destroy is finished.\n     * @instance\n     * @event destroyed\n     */\n\n    /** Readonly flag for destroyed display objects. */\n    get destroyed(): boolean\n    {\n        return this._destroyed;\n    }\n\n    /** Recalculates the bounds of the display object. */\n    abstract calculateBounds(): void;\n\n    abstract removeChild(child: DisplayObject): void;\n\n    /**\n     * Renders the object using the WebGL renderer.\n     * @param renderer - The renderer.\n     */\n    abstract render(renderer: Renderer): void;\n\n    /** Recursively updates transform of all objects from the root to this one internal function for toLocal() */\n    protected _recursivePostUpdateTransform(): void\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /** Updates the object transform for rendering. TODO - Optimization pass! */\n    updateTransform(): void\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n     *\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n     * its height increases.\n     *\n     * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n     * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n     *\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n     * calculation if needed.\n     *\n     * ```js\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n     * ```\n     *\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n     * details.\n     *\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n     * cases.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     */\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._bounds.updateID !== this._boundsID)\n        {\n            this.calculateBounds();\n            this._bounds.updateID = this._boundsID;\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @returns - The rectangular bounding area.\n     */\n    getLocalBounds(rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        if (!this._localBounds)\n        {\n            this._localBounds = new Bounds();\n        }\n\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        const worldBounds = this._bounds;\n        const worldBoundsID = this._boundsID;\n\n        this._bounds = this._localBounds;\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        this._bounds = worldBounds;\n        this._bounds.updateID += this._boundsID - worldBoundsID;// reflect side-effects\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     */\n    toGlobal<P extends IPointData = Point>(position: IPointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply<P>(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The DisplayObject to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     */\n    toLocal<P extends IPointData = Point>(position: IPointData, from?: DisplayObject, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent as Container;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject.\n     * @param container - The Container to add this DisplayObject to.\n     * @returns - The Container that this DisplayObject was added to.\n     */\n    setParent(container: Container): Container\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /** Remove the DisplayObject from its parent Container. If the DisplayObject has no parent, do nothing. */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     * @param x - The X position\n     * @param y - The Y position\n     * @param scaleX - The X scale value\n     * @param scaleY - The Y scale value\n     * @param rotation - The rotation\n     * @param skewX - The X skew value\n     * @param skewY - The Y skew value\n     * @param pivotX - The X pivot value\n     * @param pivotY - The Y pivot value\n     * @returns - The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0): this\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     * @param _options\n     */\n    destroy(_options?: IDestroyOptions | boolean): void\n    {\n        this.removeFromParent();\n\n        this._destroyed = true;\n        this.transform = null;\n\n        this.parent = null;\n        this._bounds = null;\n        this.mask = null;\n\n        this.cullArea = null;\n        this.filters = null;\n        this.filterArea = null;\n        this.hitArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this.emit('destroyed');\n        this.removeAllListeners();\n    }\n\n    /**\n     * @protected\n     * @member {PIXI.Container}\n     */\n    get _tempDisplayObjectParent(): TemporaryDisplayObject\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this.tempDisplayObjectParent = new TemporaryDisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root.\n     *\n     * ```js\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     * @returns - Current parent\n     */\n    enableTempParent(): Container\n    {\n        const myParent = this.parent;\n\n        this.parent = this._tempDisplayObjectParent as Container;\n\n        return myParent;\n    }\n\n    /**\n     * Pair method for `enableTempParent`\n     * @param cacheParent - Actual parent of element\n     */\n    disableTempParent(cacheParent: Container): void\n    {\n        this.parent = cacheParent;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this.position.x;\n    }\n\n    set x(value: number)\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this.position.y;\n    }\n\n    set y(value: number)\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform(): Matrix\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    get localTransform(): Matrix\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this.transform.position;\n    }\n\n    set position(value: IPointData)\n    {\n        this.transform.position.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value: IPointData)\n    {\n        this.transform.scale.copyFrom(value);\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value: IPointData)\n    {\n        this.transform.pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value: IPointData)\n    {\n        this.transform.skew.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value: number)\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.transform.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.transform.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The zIndex of the displayObject.\n     *\n     * If a container has the sortableChildren property set to true, children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see PIXI.Container#sortableChildren\n     */\n    get zIndex(): number\n    {\n        return this._zIndex;\n    }\n\n    set zIndex(value: number)\n    {\n        this._zIndex = value;\n        if (this.parent)\n        {\n            this.parent.sortDirty = true;\n        }\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     * @readonly\n     */\n    get worldVisible(): boolean\n    {\n        let item = this as DisplayObject;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @todo At the moment, CanvasRenderer doesn't support Sprite as mask.\n     */\n    get mask(): Container | MaskData | null\n    {\n        return this._mask;\n    }\n\n    set mask(value: Container | MaskData | null)\n    {\n        if (this._mask === value)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                maskObject._maskRefCount--;\n\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = true;\n                    maskObject.isMask = false;\n                }\n            }\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            const maskObject = ((this._mask as MaskData).isMaskData\n                ? (this._mask as MaskData).maskObject : this._mask) as Container;\n\n            if (maskObject)\n            {\n                if (maskObject._maskRefCount === 0)\n                {\n                    maskObject.renderable = false;\n                    maskObject.isMask = true;\n                }\n\n                maskObject._maskRefCount++;\n            }\n        }\n    }\n}\n\n/**\n * @private\n */\nexport class TemporaryDisplayObject extends DisplayObject\n{\n    calculateBounds: () => null;\n    removeChild: (child: DisplayObject) => null;\n    render: (renderer: Renderer) => null;\n    sortDirty: boolean = null;\n}\n\n/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n"]},"metadata":{},"sourceType":"script"}