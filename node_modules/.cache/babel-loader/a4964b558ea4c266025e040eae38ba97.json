{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prependByteToBuffer = exports.flipBufferBitsInPlace = exports.getHexMagnitudeOfBigInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.cloneBuffer = exports.isMsbZero = exports.isMsbOne = void 0;\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar utils_codec_1 = require(\"../../utils.codec\");\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 1.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\nfunction isMsbOne(buffer) {\n  var byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var byte = buffer[byteIndex];\n  var bit = byte >> 7;\n  var isSet = bit == 1;\n  return isSet;\n}\nexports.isMsbOne = isMsbOne;\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 0.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\nfunction isMsbZero(buffer) {\n  var byteIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return !isMsbOne(buffer, byteIndex);\n}\nexports.isMsbZero = isMsbZero;\nfunction cloneBuffer(buffer) {\n  var clone = Buffer.alloc(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\nfunction bufferToBigInt(buffer) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.\n  var hex = buffer.toString(\"hex\");\n  return new bignumber_js_1.default(\"0x\".concat(hex), 16);\n}\nexports.bufferToBigInt = bufferToBigInt;\nfunction bigIntToBuffer(value) {\n  // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.\n  var hex = getHexMagnitudeOfBigInt(value);\n  return Buffer.from(hex, \"hex\");\n}\nexports.bigIntToBuffer = bigIntToBuffer;\nfunction getHexMagnitudeOfBigInt(value) {\n  if (!value) {\n    return \"\";\n  }\n  if (value.isNegative()) {\n    value = value.multipliedBy(new bignumber_js_1.default(-1));\n  }\n  return utils_codec_1.numberToPaddedHex(value);\n}\nexports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;\nfunction flipBufferBitsInPlace(buffer) {\n  for (var i = 0; i < buffer.length; i++) {\n    buffer[i] = ~buffer[i];\n  }\n}\nexports.flipBufferBitsInPlace = flipBufferBitsInPlace;\nfunction prependByteToBuffer(buffer, byte) {\n  return Buffer.concat([Buffer.from([byte]), buffer]);\n}\nexports.prependByteToBuffer = prependByteToBuffer;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/utils.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,IAAA,cAAA,GAAA,eAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA;;;;AAIG;AACH,SAAgB,QAAQ,CAAC,MAAc,EAAuB;EAAA,IAArB,SAAA,uEAAoB,CAAC;EAC1D,IAAI,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC;EAC5B,IAAI,GAAG,GAAG,IAAI,IAAI,CAAC;EACnB,IAAI,KAAK,GAAG,GAAG,IAAI,CAAC;EACpB,OAAO,KAAK;AAChB;AALA,OAAA,CAAA,QAAA,GAAA,QAAA;AAOA;;;;AAIG;AACH,SAAgB,SAAS,CAAC,MAAc,EAAuB;EAAA,IAArB,SAAA,uEAAoB,CAAC;EAC3D,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,SAAS,CAAC;AACvC;AAFA,OAAA,CAAA,SAAA,GAAA,SAAA;AAIA,SAAgB,WAAW,CAAC,MAAc,EAAA;EACtC,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC;EACvC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;EAClB,OAAO,KAAK;AAChB;AAJA,OAAA,CAAA,WAAA,GAAA,WAAA;AAMA,SAAgB,cAAc,CAAC,MAAc,EAAA;EACzC;EACA,IAAI,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC;EAChC,OAAO,IAAI,cAAA,CAAA,OAAS,aAAM,GAAG,GAAI,EAAE,CAAC;AACxC;AAJA,OAAA,CAAA,cAAA,GAAA,cAAA;AAMA,SAAgB,cAAc,CAAC,KAAgB,EAAA;EAC3C;EACA,IAAI,GAAG,GAAG,uBAAuB,CAAC,KAAK,CAAC;EACxC,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC;AAClC;AAJA,OAAA,CAAA,cAAA,GAAA,cAAA;AAMA,SAAgB,uBAAuB,CAAC,KAAgB,EAAA;EACpD,IAAI,CAAC,KAAK,EAAE;IACR,OAAO,EAAE;EACZ;EAED,IAAI,KAAK,CAAC,UAAU,EAAE,EAAE;IACpB,KAAK,GAAG,KAAK,CAAC,YAAY,CAAC,IAAI,cAAA,CAAA,OAAS,CAAC,CAAC,CAAC,CAAC,CAAC;EAChD;EAED,OAAO,aAAA,CAAA,iBAAiB,CAAC,KAAK,CAAC;AACnC;AAVA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAYA,SAAgB,qBAAqB,CAAC,MAAc,EAAA;EAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACpC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;EACzB;AACL;AAJA,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAMA,SAAgB,mBAAmB,CAAC,MAAc,EAAE,IAAY,EAAA;EAC5D,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AACvD;AAFA,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prependByteToBuffer = exports.flipBufferBitsInPlace = exports.getHexMagnitudeOfBigInt = exports.bigIntToBuffer = exports.bufferToBigInt = exports.cloneBuffer = exports.isMsbZero = exports.isMsbOne = void 0;\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst utils_codec_1 = require(\"../../utils.codec\");\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 1.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\nfunction isMsbOne(buffer, byteIndex = 0) {\n    let byte = buffer[byteIndex];\n    let bit = byte >> 7;\n    let isSet = bit == 1;\n    return isSet;\n}\nexports.isMsbOne = isMsbOne;\n/**\n * Returns whether the most significant bit of a given byte (within a buffer) is 0.\n * @param buffer the buffer to test\n * @param byteIndex the index of the byte to test\n */\nfunction isMsbZero(buffer, byteIndex = 0) {\n    return !isMsbOne(buffer, byteIndex);\n}\nexports.isMsbZero = isMsbZero;\nfunction cloneBuffer(buffer) {\n    let clone = Buffer.alloc(buffer.length);\n    buffer.copy(clone);\n    return clone;\n}\nexports.cloneBuffer = cloneBuffer;\nfunction bufferToBigInt(buffer) {\n    // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size Buffer to BigInt conversion.\n    let hex = buffer.toString(\"hex\");\n    return new bignumber_js_1.default(`0x${hex}`, 16);\n}\nexports.bufferToBigInt = bufferToBigInt;\nfunction bigIntToBuffer(value) {\n    // Currently, in JavaScript, this is the feasible way to achieve reliable, arbitrary-size BigInt to Buffer conversion.\n    let hex = getHexMagnitudeOfBigInt(value);\n    return Buffer.from(hex, \"hex\");\n}\nexports.bigIntToBuffer = bigIntToBuffer;\nfunction getHexMagnitudeOfBigInt(value) {\n    if (!value) {\n        return \"\";\n    }\n    if (value.isNegative()) {\n        value = value.multipliedBy(new bignumber_js_1.default(-1));\n    }\n    return utils_codec_1.numberToPaddedHex(value);\n}\nexports.getHexMagnitudeOfBigInt = getHexMagnitudeOfBigInt;\nfunction flipBufferBitsInPlace(buffer) {\n    for (let i = 0; i < buffer.length; i++) {\n        buffer[i] = ~buffer[i];\n    }\n}\nexports.flipBufferBitsInPlace = flipBufferBitsInPlace;\nfunction prependByteToBuffer(buffer, byte) {\n    return Buffer.concat([Buffer.from([byte]), buffer]);\n}\nexports.prependByteToBuffer = prependByteToBuffer;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}