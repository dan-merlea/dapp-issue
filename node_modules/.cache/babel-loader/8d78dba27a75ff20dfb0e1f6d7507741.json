{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar Attribute = require('./Attribute.js');\nvar Buffer = require('./Buffer.js');\nvar interleaveTypedArrays = require('./utils/interleaveTypedArrays.js');\nvar utils = require('@pixi/utils');\nvar runner = require('@pixi/runner');\nvar constants = require('@pixi/constants');\nvar byteSizeMap = {\n  5126: 4,\n  5123: 2,\n  5121: 1\n};\nvar UID = 0;\nvar map = {\n  Float32Array: Float32Array,\n  Uint32Array: Uint32Array,\n  Int32Array: Int32Array,\n  Uint8Array: Uint8Array,\n  Uint16Array: Uint16Array\n};\nvar Geometry = /*#__PURE__*/function () {\n  function Geometry() {\n    var buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Geometry);\n    this.buffers = buffers;\n    this.indexBuffer = null;\n    this.attributes = attributes;\n    this.glVertexArrayObjects = {};\n    this.id = UID++;\n    this.instanced = false;\n    this.instanceCount = 1;\n    this.disposeRunner = new runner.Runner(\"disposeGeometry\");\n    this.refCount = 0;\n  }\n  _createClass(Geometry, [{\n    key: \"addAttribute\",\n    value: function addAttribute(id, buffer) {\n      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var type = arguments.length > 4 ? arguments[4] : undefined;\n      var stride = arguments.length > 5 ? arguments[5] : undefined;\n      var start = arguments.length > 6 ? arguments[6] : undefined;\n      var instance = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      if (!buffer) {\n        throw new Error(\"You must pass a buffer when creating an attribute\");\n      }\n      if (!(buffer instanceof Buffer.Buffer)) {\n        if (buffer instanceof Array) {\n          buffer = new Float32Array(buffer);\n        }\n        buffer = new Buffer.Buffer(buffer);\n      }\n      var ids = id.split(\"|\");\n      if (ids.length > 1) {\n        for (var i = 0; i < ids.length; i++) {\n          this.addAttribute(ids[i], buffer, size, normalized, type);\n        }\n        return this;\n      }\n      var bufferIndex = this.buffers.indexOf(buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(buffer);\n        bufferIndex = this.buffers.length - 1;\n      }\n      this.attributes[id] = new Attribute.Attribute(bufferIndex, size, normalized, type, stride, start, instance);\n      this.instanced = this.instanced || instance;\n      return this;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(id) {\n      return this.attributes[id];\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(id) {\n      return this.buffers[this.getAttribute(id).buffer];\n    }\n  }, {\n    key: \"addIndex\",\n    value: function addIndex(buffer) {\n      if (!(buffer instanceof Buffer.Buffer)) {\n        if (buffer instanceof Array) {\n          buffer = new Uint16Array(buffer);\n        }\n        buffer = new Buffer.Buffer(buffer);\n      }\n      buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      this.indexBuffer = buffer;\n      if (!this.buffers.includes(buffer)) {\n        this.buffers.push(buffer);\n      }\n      return this;\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex() {\n      return this.indexBuffer;\n    }\n  }, {\n    key: \"interleave\",\n    value: function interleave() {\n      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this;\n      var arrays = [];\n      var sizes = [];\n      var interleavedBuffer = new Buffer.Buffer();\n      var i;\n      for (i in this.attributes) {\n        var attribute = this.attributes[i];\n        var buffer = this.buffers[attribute.buffer];\n        arrays.push(buffer.data);\n        sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);\n        attribute.buffer = 0;\n      }\n      interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes);\n      for (i = 0; i < this.buffers.length; i++) {\n        if (this.buffers[i] !== this.indexBuffer) {\n          this.buffers[i].destroy();\n        }\n      }\n      this.buffers = [interleavedBuffer];\n      if (this.indexBuffer) {\n        this.buffers.push(this.indexBuffer);\n      }\n      return this;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      for (var i in this.attributes) {\n        var attribute = this.attributes[i];\n        var buffer = this.buffers[attribute.buffer];\n        return buffer.data.length / (attribute.stride / 4 || attribute.size);\n      }\n      return 0;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.disposeRunner.emit(this, false);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.dispose();\n      this.buffers = null;\n      this.indexBuffer = null;\n      this.attributes = null;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var geometry = new Geometry();\n      for (var i = 0; i < this.buffers.length; i++) {\n        geometry.buffers[i] = new Buffer.Buffer(this.buffers[i].data.slice(0));\n      }\n      for (var _i in this.attributes) {\n        var attrib = this.attributes[_i];\n        geometry.attributes[_i] = new Attribute.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);\n      }\n      if (this.indexBuffer) {\n        geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n        geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n      }\n      return geometry;\n    }\n  }], [{\n    key: \"merge\",\n    value: function merge(geometries) {\n      var geometryOut = new Geometry();\n      var arrays = [];\n      var sizes = [];\n      var offsets = [];\n      var geometry;\n      for (var i = 0; i < geometries.length; i++) {\n        geometry = geometries[i];\n        for (var j = 0; j < geometry.buffers.length; j++) {\n          sizes[j] = sizes[j] || 0;\n          sizes[j] += geometry.buffers[j].data.length;\n          offsets[j] = 0;\n        }\n      }\n      for (var _i2 = 0; _i2 < geometry.buffers.length; _i2++) {\n        arrays[_i2] = new map[utils.getBufferType(geometry.buffers[_i2].data)](sizes[_i2]);\n        geometryOut.buffers[_i2] = new Buffer.Buffer(arrays[_i2]);\n      }\n      for (var _i3 = 0; _i3 < geometries.length; _i3++) {\n        geometry = geometries[_i3];\n        for (var _j = 0; _j < geometry.buffers.length; _j++) {\n          arrays[_j].set(geometry.buffers[_j].data, offsets[_j]);\n          offsets[_j] += geometry.buffers[_j].data.length;\n        }\n      }\n      geometryOut.attributes = geometry.attributes;\n      if (geometry.indexBuffer) {\n        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n        geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        var offset = 0;\n        var stride = 0;\n        var offset2 = 0;\n        var bufferIndexToCount = 0;\n        for (var _i4 = 0; _i4 < geometry.buffers.length; _i4++) {\n          if (geometry.buffers[_i4] !== geometry.indexBuffer) {\n            bufferIndexToCount = _i4;\n            break;\n          }\n        }\n        for (var _i5 in geometry.attributes) {\n          var attribute = geometry.attributes[_i5];\n          if ((attribute.buffer | 0) === bufferIndexToCount) {\n            stride += attribute.size * byteSizeMap[attribute.type] / 4;\n          }\n        }\n        for (var _i6 = 0; _i6 < geometries.length; _i6++) {\n          var indexBufferData = geometries[_i6].indexBuffer.data;\n          for (var _j2 = 0; _j2 < indexBufferData.length; _j2++) {\n            geometryOut.indexBuffer.data[_j2 + offset2] += offset;\n          }\n          offset += geometries[_i6].buffers[bufferIndexToCount].data.length / stride;\n          offset2 += indexBufferData.length;\n        }\n      }\n      return geometryOut;\n    }\n  }]);\n  return Geometry;\n}();\nexports.Geometry = Geometry;","map":{"version":3,"sources":["../../src/geometry/Geometry.ts"],"names":["Runner","Buffer","Attribute","BUFFER_TYPE","interleaveTypedArrays","getBufferType"],"mappings":";;;;;;;;;;;;;AAWA,IAAM,WAAA,GAAuC;EAAE,IAAA,EAAM,CAAA;EAAG,IAAM,EAAA,CAAA;EAAG,IAAA,EAAM;AAAE,CAAA;AACzE,IAAI,GAAM,GAAA,CAAA;AAGV,IAAM,GAAiB,GAAA;EACnB,YAAA,EAAA,YAAA;EACA,WAAA,EAAA,WAAA;EACA,UAAA,EAAA,UAAA;EACA,UAAA,EAAA,UAAA;EACA,WAAA,EAAA;AACJ,CAAA;AAAA,IAqBa,QACb;EA6BI,oBACA;IAAA,IADY,OAAyB,uEAAA,EAAI;IAAA,IAAA,UAAA,uEAAyC,CAAA,CAClF;IAAA;IACI,IAAA,CAAK,OAAU,GAAA,OAAA;IAEf,IAAA,CAAK,WAAc,GAAA,IAAA;IAEnB,IAAA,CAAK,UAAa,GAAA,UAAA;IAElB,IAAA,CAAK,oBAAA,GAAuB,CAAA,CAAC;IAE7B,IAAA,CAAK,EAAK,GAAA,GAAA,EAAA;IAEV,IAAA,CAAK,SAAY,GAAA,KAAA;IACjB,IAAA,CAAK,aAAgB,GAAA,CAAA;IAEhB,IAAA,CAAA,aAAA,GAAgB,IAAIA,MAAAA,CAAAA,MAAAA,CAAO,iBAAiB,CAAA;IACjD,IAAA,CAAK,QAAW,GAAA,CAAA;EAAA;EACpB;IAAA;IAAA,OAgBA,sBAAa,EAAY,EAAA,MAAA,EAEzB;MAAA,IAFsF,IAAO,uEAAA,CAAA;MAAA,IAAG,UAAa,uEAAA,KAAA;MAAA,IACzG,IAAc;MAAA,IAAA,MAAA;MAAA,IAAiB,KAAgB;MAAA,IAAA,QAAA,uEAAW,KAC9D;MACI,IAAI,CAAC,MACL,EAAA;QACU,MAAA,IAAI,KAAA,CAAM,mDAAmD,CAAA;MAAA;MAInE,IAAA,EAAA,MAAA,YAAoBC,MAAAA,CAAAA,MACxB,CAAA,EAAA;QAEI,IAAI,MAAA,YAAkB,KACtB,EAAA;UACa,MAAA,GAAA,IAAI,YAAA,CAAa,MAAM,CAAA;QAAA;QAG3B,MAAA,GAAA,IAAIA,MAAAA,CAAAA,MAAAA,CAAO,MAAM,CAAA;MAAA;MAGxB,IAAA,GAAA,GAAM,EAAG,CAAA,KAAA,CAAM,GAAG,CAAA;MAEpB,IAAA,GAAA,CAAI,MAAA,GAAS,CACjB,EAAA;QACI,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,GAAA,CAAI,MAAA,EAAQ,CAChC,EAAA,EAAA;UACI,IAAA,CAAK,YAAA,CAAa,GAAI,CAAA,CAAA,CAAA,EAAI,MAAQ,EAAA,IAAA,EAAM,UAAA,EAAY,IAAI,CAAA;QAAA;QAGrD,OAAA,IAAA;MAAA;MAGX,IAAI,WAAc,GAAA,IAAA,CAAK,OAAQ,CAAA,OAAA,CAAQ,MAAM,CAAA;MAE7C,IAAI,WAAA,KAAgB,CACpB,CAAA,EAAA;QACS,IAAA,CAAA,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAA;QACV,WAAA,GAAA,IAAA,CAAK,OAAA,CAAQ,MAAS,GAAA,CAAA;MAAA;MAGnC,IAAA,CAAA,UAAA,CAAW,EAAM,CAAA,GAAA,IAAIC,SAAAA,CAAAA,SAAU,CAAA,WAAA,EAAa,IAAA,EAAM,UAAY,EAAA,IAAA,EAAM,MAAQ,EAAA,KAAA,EAAO,QAAQ,CAAA;MAG3F,IAAA,CAAA,SAAA,GAAY,IAAA,CAAK,SAAa,IAAA,QAAA;MAE5B,OAAA,IAAA;IAAA;EACX;IAAA;IAAA,OAOA,sBAAa,EACb,EAAA;MACI,OAAO,IAAA,CAAK,UAAW,CAAA,EAAA,CAAA;IAAA;EAC3B;IAAA;IAAA,OAOA,mBAAU,EACV,EAAA;MACI,OAAO,IAAK,CAAA,OAAA,CAAQ,IAAK,CAAA,YAAA,CAAa,EAAE,CAAE,CAAA,MAAA,CAAA;IAAA;EAC9C;IAAA;IAAA,OASA,kBAAS,MACT,EAAA;MACQ,IAAA,EAAA,MAAA,YAAoBD,MAAAA,CAAAA,MACxB,CAAA,EAAA;QAEI,IAAI,MAAA,YAAkB,KACtB,EAAA;UACa,MAAA,GAAA,IAAI,WAAA,CAAY,MAAM,CAAA;QAAA;QAG1B,MAAA,GAAA,IAAIA,MAAAA,CAAAA,MAAAA,CAAO,MAAM,CAAA;MAAA;MAG9B,MAAA,CAAO,IAAA,GAAOE,SAAAA,CAAAA,WAAY,CAAA,oBAAA;MAE1B,IAAA,CAAK,WAAc,GAAA,MAAA;MAEnB,IAAI,CAAC,IAAA,CAAK,OAAQ,CAAA,QAAA,CAAS,MAAM,CACjC,EAAA;QACS,IAAA,CAAA,OAAA,CAAQ,IAAA,CAAK,MAAM,CAAA;MAAA;MAGrB,OAAA,IAAA;IAAA;EACX;IAAA;IAAA,OAMA,oBACA;MACI,OAAO,IAAK,CAAA,WAAA;IAAA;EAChB;IAAA;IAAA,OAOA,sBACA;MAEQ,IAAA,IAAA,CAAK,OAAA,CAAQ,MAAW,KAAA,CAAA,IAAM,IAAA,CAAK,OAAQ,CAAA,MAAA,KAAW,CAAA,IAAK,IAAK,CAAA,WAAA,EAAqB,OAAA,IAAA;MAGzF,IAAM,MAAA,GAAS,EAAC;MAChB,IAAM,KAAA,GAAQ,EAAC;MACT,IAAA,iBAAA,GAAoB,IAAIF,MAAAA,CAAAA,MAAO,EAAA;MACjC,IAAA,CAAA;MAEC,KAAA,CAAA,IAAK,IAAA,CAAK,UACf,EAAA;QACU,IAAA,SAAA,GAAY,IAAA,CAAK,UAAW,CAAA,CAAA,CAAA;QAE5B,IAAA,MAAA,GAAS,IAAK,CAAA,OAAA,CAAQ,SAAU,CAAA,MAAA,CAAA;QAE/B,MAAA,CAAA,IAAA,CAAK,MAAA,CAAO,IAAI,CAAA;QAEvB,KAAA,CAAM,IAAA,CAAM,SAAU,CAAA,IAAA,GAAO,WAAY,CAAA,SAAA,CAAU,IAAA,CAAA,GAAS,CAAC,CAAA;QAE7D,SAAA,CAAU,MAAS,GAAA,CAAA;MAAA;MAGL,iBAAA,CAAA,IAAA,GAAOG,qBAAAA,CAAAA,qBAAsB,CAAA,MAAA,EAAQ,KAAK,CAAA;MAE5D,KAAK,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,OAAA,CAAQ,MAAA,EAAQ,CACrC,EAAA,EAAA;QACI,IAAI,IAAK,CAAA,OAAA,CAAQ,CAAO,CAAA,KAAA,IAAA,CAAK,WAC7B,EAAA;UACS,IAAA,CAAA,OAAA,CAAQ,CAAA,CAAA,CAAG,OAAQ,EAAA;QAAA;MAC5B;MAGC,IAAA,CAAA,OAAA,GAAU,CAAC,iBAAiB,CAAA;MAEjC,IAAI,IAAA,CAAK,WACT,EAAA;QACS,IAAA,CAAA,OAAA,CAAQ,IAAK,CAAA,IAAA,CAAK,WAAW,CAAA;MAAA;MAG/B,OAAA,IAAA;IAAA;EACX;IAAA;IAAA,OAGA,mBACA;MACe,KAAA,IAAA,CAAA,IAAK,IAAA,CAAK,UACrB,EAAA;QACU,IAAA,SAAA,GAAY,IAAA,CAAK,UAAW,CAAA,CAAA,CAAA;QAC5B,IAAA,MAAA,GAAS,IAAK,CAAA,OAAA,CAAQ,SAAU,CAAA,MAAA,CAAA;QAEtC,OAAQ,MAAA,CAAO,IAAa,CAAA,MAAA,IAAqB,SAAA,CAAA,MAAA,GAAS,CAAA,IAAM,SAAU,CAAA,IAAA,CAAA;MAAA;MAGvE,OAAA,CAAA;IAAA;EACX;IAAA;IAAA,OAGA,mBACA;MACS,IAAA,CAAA,aAAA,CAAc,IAAK,CAAA,IAAA,EAAM,KAAK,CAAA;IAAA;EACvC;IAAA;IAAA,OAGA,mBACA;MACI,IAAA,CAAK,OAAQ,EAAA;MAEb,IAAA,CAAK,OAAU,GAAA,IAAA;MACf,IAAA,CAAK,WAAc,GAAA,IAAA;MACnB,IAAA,CAAK,UAAa,GAAA,IAAA;IAAA;EACtB;IAAA;IAAA,OAMA,iBACA;MACU,IAAA,QAAA,GAAW,IAAI,QAAS,EAAA;MAE9B,KAAA,IAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,OAAA,CAAQ,MAAA,EAAQ,CACzC,EAAA,EAAA;QACa,QAAA,CAAA,OAAA,CAAQ,CAAK,CAAA,GAAA,IAAIH,MAAAA,CAAAA,MAAO,CAAA,IAAA,CAAK,OAAA,CAAQ,CAAG,CAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA;MAAA;MAGvD,KAAA,IAAA,EAAA,IAAK,IAAA,CAAK,UACrB,EAAA;QACU,IAAA,MAAA,GAAS,IAAA,CAAK,UAAW,CAAA,EAAA,CAAA;QAE/B,QAAA,CAAS,UAAA,CAAW,EAAK,CAAA,GAAA,IAAIC,SAAAA,CAAAA,SACzB,CAAA,MAAA,CAAO,MAAA,EACP,MAAO,CAAA,IAAA,EACP,MAAO,CAAA,UAAA,EACP,MAAA,CAAO,IACP,EAAA,MAAA,CAAO,MAAA,EACP,MAAO,CAAA,KAAA,EACP,MAAA,CAAO,QACX,CAAA;MAAA;MAGJ,IAAI,IAAA,CAAK,WACT,EAAA;QACI,QAAA,CAAS,WAAA,GAAc,QAAS,CAAA,OAAA,CAAQ,IAAA,CAAK,OAAQ,CAAA,OAAA,CAAQ,IAAA,CAAK,WAAW,CAAA,CAAA;QACpE,QAAA,CAAA,WAAA,CAAY,IAAA,GAAOC,SAAAA,CAAAA,WAAY,CAAA,oBAAA;MAAA;MAGrC,OAAA,QAAA;IAAA;EACX;IAAA;IAAA,OASA,eAAa,UACb,EAAA;MAIU,IAAA,WAAA,GAAc,IAAI,QAAS,EAAA;MAEjC,IAAM,MAAA,GAAS,EAAC;MAChB,IAAM,KAAA,GAAuB,EAAC;MAC9B,IAAM,OAAA,GAAU,EAAC;MAEb,IAAA,QAAA;MAGJ,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,CAAW,MAAA,EAAQ,CACvC,EAAA,EAAA;QACI,QAAA,GAAW,UAAW,CAAA,CAAA,CAAA;QAEtB,KAAA,IAAS,CAAA,GAAI,CAAG,EAAA,CAAA,GAAI,QAAS,CAAA,OAAA,CAAQ,MAAA,EAAQ,CAC7C,EAAA,EAAA;UACU,KAAA,CAAA,CAAA,CAAA,GAAK,KAAA,CAAM,CAAM,CAAA,IAAA,CAAA;UACvB,KAAA,CAAM,CAAM,CAAA,IAAA,QAAA,CAAS,OAAQ,CAAA,CAAA,CAAA,CAAG,IAAK,CAAA,MAAA;UACrC,OAAA,CAAQ,CAAK,CAAA,GAAA,CAAA;QAAA;MACjB;MAIJ,KAAA,IAAS,GAAA,GAAI,CAAG,EAAA,GAAA,GAAI,QAAS,CAAA,OAAA,CAAQ,MAAA,EAAQ,GAC7C,EAAA,EAAA;QAEW,MAAA,CAAA,GAAA,CAAA,GAAK,IAAI,GAAA,CAAIE,KAAAA,CAAAA,aAAc,CAAA,QAAA,CAAS,OAAA,CAAQ,GAAG,CAAA,CAAA,IAAI,CAAG,CAAA,CAAA,KAAA,CAAM,GAAE,CAAA,CAAA;QACrE,WAAA,CAAY,OAAQ,CAAA,GAAA,CAAA,GAAK,IAAIJ,MAAAA,CAAAA,MAAAA,CAAO,MAAA,CAAO,GAAE,CAAA,CAAA;MAAA;MAIjD,KAAA,IAAS,GAAI,GAAA,CAAA,EAAG,GAAI,GAAA,UAAA,CAAW,MAAA,EAAQ,GACvC,EAAA,EAAA;QACI,QAAA,GAAW,UAAW,CAAA,GAAA,CAAA;QAEtB,KAAA,IAAS,EAAA,GAAI,CAAG,EAAA,EAAA,GAAI,QAAS,CAAA,OAAA,CAAQ,MAAA,EAAQ,EAC7C,EAAA,EAAA;UACI,MAAA,CAAO,EAAA,CAAA,CAAG,GAAI,CAAA,QAAA,CAAS,OAAA,CAAQ,EAAG,CAAA,CAAA,IAAA,EAAM,OAAA,CAAQ,EAAE,CAAA,CAAA;UAClD,OAAA,CAAQ,EAAM,CAAA,IAAA,QAAA,CAAS,OAAQ,CAAA,EAAA,CAAA,CAAG,IAAK,CAAA,MAAA;QAAA;MAC3C;MAGJ,WAAA,CAAY,UAAA,GAAa,QAAS,CAAA,UAAA;MAElC,IAAI,QAAA,CAAS,WACb,EAAA;QACI,WAAA,CAAY,WAAA,GAAc,WAAY,CAAA,OAAA,CAAQ,QAAA,CAAS,OAAQ,CAAA,OAAA,CAAQ,QAAA,CAAS,WAAW,CAAA,CAAA;QAC/E,WAAA,CAAA,WAAA,CAAY,IAAA,GAAOE,SAAAA,CAAAA,WAAY,CAAA,oBAAA;QAE3C,IAAI,MAAS,GAAA,CAAA;QACb,IAAI,MAAS,GAAA,CAAA;QACb,IAAI,OAAU,GAAA,CAAA;QACd,IAAI,kBAAqB,GAAA,CAAA;QAGzB,KAAA,IAAS,GAAA,GAAI,CAAG,EAAA,GAAA,GAAI,QAAS,CAAA,OAAA,CAAQ,MAAA,EAAQ,GAC7C,EAAA,EAAA;UACI,IAAI,QAAS,CAAA,OAAA,CAAQ,GAAO,CAAA,KAAA,QAAA,CAAS,WACrC,EAAA;YACyB,kBAAA,GAAA,GAAA;YACrB;UAAA;QACJ;QAIO,KAAA,IAAA,GAAA,IAAK,QAAA,CAAS,UACzB,EAAA;UACU,IAAA,SAAA,GAAY,QAAA,CAAS,UAAW,CAAA,GAAA,CAAA;UAEjC,IAAA,CAAA,SAAA,CAAU,MAAS,GAAA,CAAA,MAAO,kBAC/B,EAAA;YACI,MAAA,IAAY,SAAU,CAAA,IAAA,GAAO,WAAY,CAAA,SAAA,CAAU,IAAS,CAAA,GAAA,CAAA;UAAA;QAChE;QAIJ,KAAA,IAAS,GAAI,GAAA,CAAA,EAAG,GAAI,GAAA,UAAA,CAAW,MAAA,EAAQ,GACvC,EAAA,EAAA;UACU,IAAA,eAAA,GAAkB,UAAW,CAAA,GAAA,CAAA,CAAG,WAAY,CAAA,IAAA;UAElD,KAAA,IAAS,GAAI,GAAA,CAAA,EAAG,GAAI,GAAA,eAAA,CAAgB,MAAA,EAAQ,GAC5C,EAAA,EAAA;YACgB,WAAA,CAAA,WAAA,CAAY,IAAK,CAAA,GAAA,GAAI,OAAY,CAAA,IAAA,MAAA;UAAA;UAGjD,MAAA,IAAU,UAAW,CAAA,GAAA,CAAA,CAAG,OAAQ,CAAA,kBAAA,CAAA,CAAoB,IAAA,CAAK,MAAU,GAAA,MAAA;UACnE,OAAA,IAAW,eAAgB,CAAA,MAAA;QAAA;MAC/B;MAGG,OAAA,WAAA;IAAA;EACX;EAAA;AAAA","sourcesContent":["import { Attribute } from './Attribute';\nimport { Buffer } from './Buffer';\nimport { interleaveTypedArrays } from './utils/interleaveTypedArrays';\nimport { getBufferType } from '@pixi/utils';\nimport { Runner } from '@pixi/runner';\n\nimport type { TYPES } from '@pixi/constants';\nimport { BUFFER_TYPE } from '@pixi/constants';\nimport type { IArrayBuffer } from './Buffer';\nimport type { Dict } from '@pixi/utils';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\nlet UID = 0;\n\n/* eslint-disable object-shorthand */\nconst map: Dict<any> = {\n    Float32Array: Float32Array,\n    Uint32Array: Uint32Array,\n    Int32Array: Int32Array,\n    Uint8Array: Uint8Array,\n    Uint16Array: Uint16Array,\n};\n\n/* eslint-disable max-len */\n\n/**\n * The Geometry represents a model. It consists of two components:\n * - GeometryStyle - The structure of the model such as the attributes layout\n * - GeometryData - the data of the model - this consists of buffers.\n * This can include anything from positions, uvs, normals, colors etc.\n *\n * Geometry can be defined without passing in a style or data if required (thats how I prefer!)\n * @example\n * import { Geometry } from 'pixi.js';\n *\n * const geometry = new Geometry();\n *\n * geometry.addAttribute('positions', [0, 0, 100, 0, 100, 100, 0, 100], 2);\n * geometry.addAttribute('uvs', [0, 0, 1, 0, 1, 1, 0, 1], 2);\n * geometry.addIndex([0, 1, 2, 1, 3, 2]);\n * @memberof PIXI\n */\nexport class Geometry\n{\n    public buffers: Array<Buffer>;\n    public indexBuffer: Buffer;\n    public attributes: {[key: string]: Attribute};\n    public id: number;\n\n    /** Whether the geometry is instanced. */\n    public instanced: boolean;\n\n    /**\n     * Number of instances in this geometry, pass it to `GeometrySystem.draw()`.\n     * @default 1\n     */\n    public instanceCount: number;\n\n    /**\n     * A map of renderer IDs to webgl VAOs\n     * @type {object}\n     */\n    glVertexArrayObjects: {[key: number]: {[key: string]: WebGLVertexArrayObject}};\n    disposeRunner: Runner;\n\n    /** Count of existing (not destroyed) meshes that reference this geometry. */\n    refCount: number;\n\n    /**\n     * @param buffers - An array of buffers. optional.\n     * @param attributes - Of the geometry, optional structure of the attributes layout\n     */\n    constructor(buffers: Array<Buffer> = [], attributes: {[key: string]: Attribute} = {})\n    {\n        this.buffers = buffers;\n\n        this.indexBuffer = null;\n\n        this.attributes = attributes;\n\n        this.glVertexArrayObjects = {};\n\n        this.id = UID++;\n\n        this.instanced = false;\n        this.instanceCount = 1;\n\n        this.disposeRunner = new Runner('disposeGeometry');\n        this.refCount = 0;\n    }\n\n    /**\n     *\n     * Adds an attribute to the geometry\n     * Note: `stride` and `start` should be `undefined` if you dont know them, not 0!\n     * @param id - the name of the attribute (matching up to a shader)\n     * @param {PIXI.Buffer|number[]} buffer - the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.\n     * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n     * @param normalized - should the data be normalized.\n     * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {PIXI.TYPES} to see the ones available\n     * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n     * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n     * @param instance - Instancing flag\n     * @returns - Returns self, useful for chaining.\n     */\n    addAttribute(id: string, buffer: Buffer | Float32Array | Uint32Array | Array<number>, size = 0, normalized = false,\n        type?: TYPES, stride?: number, start?: number, instance = false): this\n    {\n        if (!buffer)\n        {\n            throw new Error('You must pass a buffer when creating an attribute');\n        }\n\n        // check if this is a buffer!\n        if (!(buffer instanceof Buffer))\n        {\n            // its an array!\n            if (buffer instanceof Array)\n            {\n                buffer = new Float32Array(buffer);\n            }\n\n            buffer = new Buffer(buffer);\n        }\n\n        const ids = id.split('|');\n\n        if (ids.length > 1)\n        {\n            for (let i = 0; i < ids.length; i++)\n            {\n                this.addAttribute(ids[i], buffer, size, normalized, type);\n            }\n\n            return this;\n        }\n\n        let bufferIndex = this.buffers.indexOf(buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(buffer);\n            bufferIndex = this.buffers.length - 1;\n        }\n\n        this.attributes[id] = new Attribute(bufferIndex, size, normalized, type, stride, start, instance);\n\n        // assuming that if there is instanced data then this will be drawn with instancing!\n        this.instanced = this.instanced || instance;\n\n        return this;\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    getBuffer(id: string): Buffer\n    {\n        return this.buffers[this.getAttribute(id).buffer];\n    }\n\n    /**\n     *\n     * Adds an index buffer to the geometry\n     * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.\n     * @param {PIXI.Buffer|number[]} [buffer] - The buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.\n     * @returns - Returns self, useful for chaining.\n     */\n    addIndex(buffer?: Buffer | IArrayBuffer | number[]): Geometry\n    {\n        if (!(buffer instanceof Buffer))\n        {\n            // its an array!\n            if (buffer instanceof Array)\n            {\n                buffer = new Uint16Array(buffer);\n            }\n\n            buffer = new Buffer(buffer);\n        }\n\n        buffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n\n        this.indexBuffer = buffer;\n\n        if (!this.buffers.includes(buffer))\n        {\n            this.buffers.push(buffer);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * This function modifies the structure so that all current attributes become interleaved into a single buffer\n     * This can be useful if your model remains static as it offers a little performance boost\n     * @returns - Returns self, useful for chaining.\n     */\n    interleave(): Geometry\n    {\n        // a simple check to see if buffers are already interleaved..\n        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) return this;\n\n        // assume already that no buffers are interleaved\n        const arrays = [];\n        const sizes = [];\n        const interleavedBuffer = new Buffer();\n        let i;\n\n        for (i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n\n            const buffer = this.buffers[attribute.buffer];\n\n            arrays.push(buffer.data);\n\n            sizes.push((attribute.size * byteSizeMap[attribute.type]) / 4);\n\n            attribute.buffer = 0;\n        }\n\n        interleavedBuffer.data = interleaveTypedArrays(arrays, sizes);\n\n        for (i = 0; i < this.buffers.length; i++)\n        {\n            if (this.buffers[i] !== this.indexBuffer)\n            {\n                this.buffers[i].destroy();\n            }\n        }\n\n        this.buffers = [interleavedBuffer];\n\n        if (this.indexBuffer)\n        {\n            this.buffers.push(this.indexBuffer);\n        }\n\n        return this;\n    }\n\n    /** Get the size of the geometries, in vertices. */\n    getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = this.buffers[attribute.buffer];\n\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /** Disposes WebGL resources that are connected to this geometry. */\n    dispose(): void\n    {\n        this.disposeRunner.emit(this, false);\n    }\n\n    /** Destroys the geometry. */\n    destroy(): void\n    {\n        this.dispose();\n\n        this.buffers = null;\n        this.indexBuffer = null;\n        this.attributes = null;\n    }\n\n    /**\n     * Returns a clone of the geometry.\n     * @returns - A new clone of this geometry.\n     */\n    clone(): Geometry\n    {\n        const geometry = new Geometry();\n\n        for (let i = 0; i < this.buffers.length; i++)\n        {\n            geometry.buffers[i] = new Buffer(this.buffers[i].data.slice(0));\n        }\n\n        for (const i in this.attributes)\n        {\n            const attrib = this.attributes[i];\n\n            geometry.attributes[i] = new Attribute(\n                attrib.buffer,\n                attrib.size,\n                attrib.normalized,\n                attrib.type,\n                attrib.stride,\n                attrib.start,\n                attrib.instance\n            );\n        }\n\n        if (this.indexBuffer)\n        {\n            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];\n            geometry.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n\n        return geometry;\n    }\n\n    /**\n     * Merges an array of geometries into a new single one.\n     *\n     * Geometry attribute styles must match for this operation to work.\n     * @param geometries - array of geometries to merge\n     * @returns - Shiny new geometry!\n     */\n    static merge(geometries: Array<Geometry>): Geometry\n    {\n        // todo add a geometry check!\n        // also a size check.. cant be too big!]\n\n        const geometryOut = new Geometry();\n\n        const arrays = [];\n        const sizes: Array<number> = [];\n        const offsets = [];\n\n        let geometry;\n\n        // pass one.. get sizes..\n        for (let i = 0; i < geometries.length; i++)\n        {\n            geometry = geometries[i];\n\n            for (let j = 0; j < geometry.buffers.length; j++)\n            {\n                sizes[j] = sizes[j] || 0;\n                sizes[j] += geometry.buffers[j].data.length;\n                offsets[j] = 0;\n            }\n        }\n\n        // build the correct size arrays..\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            // TODO types!\n            arrays[i] = new map[getBufferType(geometry.buffers[i].data)](sizes[i]);\n            geometryOut.buffers[i] = new Buffer(arrays[i]);\n        }\n\n        // pass to set data..\n        for (let i = 0; i < geometries.length; i++)\n        {\n            geometry = geometries[i];\n\n            for (let j = 0; j < geometry.buffers.length; j++)\n            {\n                arrays[j].set(geometry.buffers[j].data, offsets[j]);\n                offsets[j] += geometry.buffers[j].data.length;\n            }\n        }\n\n        geometryOut.attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];\n            geometryOut.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n\n            let offset = 0;\n            let stride = 0;\n            let offset2 = 0;\n            let bufferIndexToCount = 0;\n\n            // get a buffer\n            for (let i = 0; i < geometry.buffers.length; i++)\n            {\n                if (geometry.buffers[i] !== geometry.indexBuffer)\n                {\n                    bufferIndexToCount = i;\n                    break;\n                }\n            }\n\n            // figure out the stride of one buffer..\n            for (const i in geometry.attributes)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.buffer | 0) === bufferIndexToCount)\n                {\n                    stride += ((attribute.size * byteSizeMap[attribute.type]) / 4);\n                }\n            }\n\n            // time to off set all indexes..\n            for (let i = 0; i < geometries.length; i++)\n            {\n                const indexBufferData = geometries[i].indexBuffer.data;\n\n                for (let j = 0; j < indexBufferData.length; j++)\n                {\n                    geometryOut.indexBuffer.data[j + offset2] += offset;\n                }\n\n                offset += geometries[i].buffers[bufferIndexToCount].data.length / (stride);\n                offset2 += indexBufferData.length;\n            }\n        }\n\n        return geometryOut;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}