{"ast":null,"code":"import _objectSpread from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar ExtensionType = /* @__PURE__ */function (ExtensionType2) {\n  ExtensionType2[\"Renderer\"] = \"renderer\";\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"RendererSystem\"] = \"renderer-webgl-system\";\n  ExtensionType2[\"RendererPlugin\"] = \"renderer-webgl-plugin\";\n  ExtensionType2[\"CanvasRendererSystem\"] = \"renderer-canvas-system\";\n  ExtensionType2[\"CanvasRendererPlugin\"] = \"renderer-canvas-plugin\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  return ExtensionType2;\n}(ExtensionType || {});\nvar normalizeExtension = function normalizeExtension(ext) {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    var metadata = typeof ext.extension !== \"object\" ? {\n      type: ext.extension\n    } : ext.extension;\n    ext = _objectSpread(_objectSpread({}, metadata), {}, {\n      ref: ext\n    });\n  }\n  if (typeof ext === \"object\") {\n    ext = _objectSpread({}, ext);\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nvar extensions = {\n  _addHandlers: {},\n  _removeHandlers: {},\n  _queue: {},\n  remove: function remove() {\n    var _this = this;\n    for (var _len = arguments.length, extensions2 = new Array(_len), _key = 0; _key < _len; _key++) {\n      extensions2[_key] = arguments[_key];\n    }\n    extensions2.map(normalizeExtension).forEach(function (ext) {\n      ext.type.forEach(function (type) {\n        var _this$_removeHandlers, _this$_removeHandlers2;\n        return (_this$_removeHandlers = (_this$_removeHandlers2 = _this._removeHandlers)[type]) === null || _this$_removeHandlers === void 0 ? void 0 : _this$_removeHandlers.call(_this$_removeHandlers2, ext);\n      });\n    });\n    return this;\n  },\n  add: function add() {\n    var _this2 = this;\n    for (var _len2 = arguments.length, extensions2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      extensions2[_key2] = arguments[_key2];\n    }\n    extensions2.map(normalizeExtension).forEach(function (ext) {\n      ext.type.forEach(function (type) {\n        var handlers = _this2._addHandlers;\n        var queue = _this2._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type].push(ext);\n        } else {\n          handlers[type](ext);\n        }\n      });\n    });\n    return this;\n  },\n  handle: function handle(type, onAdd, onRemove) {\n    var addHandlers = this._addHandlers;\n    var removeHandlers = this._removeHandlers;\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    var queue = this._queue;\n    if (queue[type]) {\n      queue[type].forEach(function (ext) {\n        return onAdd(ext);\n      });\n      delete queue[type];\n    }\n    return this;\n  },\n  handleByMap: function handleByMap(type, map) {\n    return this.handle(type, function (extension) {\n      map[extension.name] = extension.ref;\n    }, function (extension) {\n      delete map[extension.name];\n    });\n  },\n  handleByList: function handleByList(type, list) {\n    return this.handle(type, function (extension) {\n      list.push(extension.ref);\n      list.sort(function (a, b) {\n        var _b$priority, _a$priority;\n        return ((_b$priority = b.priority) !== null && _b$priority !== void 0 ? _b$priority : -1) - ((_a$priority = a.priority) !== null && _a$priority !== void 0 ? _a$priority : -1);\n      });\n    }, function (extension) {\n      var index = list.indexOf(extension.ref);\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    });\n  }\n};\nexport { ExtensionType, extensions };","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Collection of valid extension types.\n * @memberof PIXI\n * @property {string} Application - Application plugins\n * @property {string} RendererPlugin - Plugins for Renderer\n * @property {string} CanvasRendererPlugin - Plugins for CanvasRenderer\n * @property {string} Loader - Plugins to use with Loader\n * @property {string} LoadParser - Parsers for Assets loader.\n * @property {string} ResolveParser - Parsers for Assets resolvers.\n * @property {string} CacheParser - Parsers for Assets cache.\n */\nenum ExtensionType\n// eslint-disable-next-line @typescript-eslint/indent\n{\n    Renderer = 'renderer',\n    Application = 'application',\n    RendererSystem = 'renderer-webgl-system',\n    RendererPlugin = 'renderer-webgl-plugin',\n    CanvasRendererSystem = 'renderer-canvas-system',\n    CanvasRendererPlugin = 'renderer-canvas-plugin',\n    Asset = 'asset',\n    LoadParser = 'load-parser',\n    ResolveParser = 'resolve-parser',\n    CacheParser = 'cache-parser',\n    DetectionParser = 'detection-parser',\n}\n\ninterface ExtensionMetadataDetails\n{\n    type: ExtensionType | ExtensionType[];\n    name?: string;\n    priority?: number;\n}\n\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof PIXI\n */\ninterface ExtensionFormatLoose\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Strict extension format that is used internally for registrations.\n * @memberof PIXI\n */\ninterface ExtensionFormat extends ExtensionFormatLoose\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: ExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormatLoose | any): ExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n * @memberof PIXI\n * @namespace extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Record<ExtensionType, ExtensionHandler>,\n\n    /** @ignore */\n    _removeHandlers: {} as Record<ExtensionType, ExtensionHandler>,\n\n    /** @ignore */\n    _queue: {} as Record<ExtensionType, ExtensionFormat[]>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {PIXI.extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormatLoose | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {PIXI.extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormatLoose | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type].push(ext);\n                }\n                else\n                {\n                    handlers[type](ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.\n     * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.\n     * @returns {PIXI.extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type].forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {PIXI.extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                map[extension.name] = extension.ref;\n            },\n            (extension) =>\n            {\n                delete map[extension.name];\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @returns {PIXI.extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[])\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                list.push(extension.ref);\n                list.sort((a, b) => (b.priority ?? -1) - (a.priority ?? -1));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionFormatLoose,\n    ExtensionFormat,\n};\n"]},"metadata":{},"sourceType":"module"}