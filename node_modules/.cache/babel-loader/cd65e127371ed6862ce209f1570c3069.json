{"ast":null,"code":"/*!\n * @pixi/prepare - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar settings = require('@pixi/settings');\nvar core = require('@pixi/core');\nvar graphics = require('@pixi/graphics');\nvar ticker = require('@pixi/ticker');\nvar display = require('@pixi/display');\nvar text = require('@pixi/text');\nvar utils = require('@pixi/utils');\n\n/**\n * Default number of uploads per frame using prepare plugin.\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\nsettings.settings.UPLOADS_PER_FRAME = 4;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/**\n * CountLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of items per frame.\n * @memberof PIXI\n */\nvar CountLimiter = /** @class */function () {\n  /**\n   * @param maxItemsPerFrame - The maximum number of items that can be prepared each frame.\n   */\n  function CountLimiter(maxItemsPerFrame) {\n    this.maxItemsPerFrame = maxItemsPerFrame;\n    this.itemsLeft = 0;\n  }\n  /** Resets any counting properties to start fresh on a new frame. */\n  CountLimiter.prototype.beginFrame = function () {\n    this.itemsLeft = this.maxItemsPerFrame;\n  };\n  /**\n   * Checks to see if another item can be uploaded. This should only be called once per item.\n   * @returns If the item is allowed to be uploaded.\n   */\n  CountLimiter.prototype.allowedToUpload = function () {\n    return this.itemsLeft-- > 0;\n  };\n  return CountLimiter;\n}();\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue) {\n  var result = false;\n  // Objects with multiple textures\n  if (item && item._textures && item._textures.length) {\n    for (var i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof core.Texture) {\n        var baseTexture = item._textures[i].baseTexture;\n        if (queue.indexOf(baseTexture) === -1) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n  return result;\n}\n/**\n * Built-in hook to find BaseTextures from Texture.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue) {\n  if (item.baseTexture instanceof core.BaseTexture) {\n    var texture = item.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to find textures from objects.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof core.Texture) {\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n * @private\n * @param _helper - Not used by this upload handler\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction drawText(_helper, item) {\n  if (item instanceof text.Text) {\n    // updating text will return early if it is not dirty\n    item.updateText(true);\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n * @private\n * @param _helper - Not used by this upload handler\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction calculateTextStyle(_helper, item) {\n  if (item instanceof text.TextStyle) {\n    var font = item.toFontString();\n    text.TextMetrics.measureFont(font);\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to find Text objects.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns if a PIXI.Text object was found.\n */\nfunction findText(item, queue) {\n  if (item instanceof text.Text) {\n    // push the text style to prepare it - this can be really expensive\n    if (queue.indexOf(item.style) === -1) {\n      queue.push(item.style);\n    }\n    // also push the text object so that we can render it (to canvas/texture) if needed\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    // also push the Text's texture for upload to GPU\n    var texture = item._texture.baseTexture;\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to find TextStyle objects.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns If a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue) {\n  if (item instanceof text.TextStyle) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * The prepare manager provides functionality to upload content to the GPU.\n *\n * BasePrepare handles basic queuing functionality and is extended by\n * {@link PIXI.Prepare} and {@link PIXI.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n * @example\n * // Create a sprite\n * const sprite = PIXI.Sprite.from('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n * @abstract\n * @memberof PIXI\n */\nvar BasePrepare = /** @class */function () {\n  /**\n   * @param {PIXI.AbstractRenderer} renderer - A reference to the current renderer\n   */\n  function BasePrepare(renderer) {\n    var _this = this;\n    this.limiter = new CountLimiter(settings.settings.UPLOADS_PER_FRAME);\n    this.renderer = renderer;\n    this.uploadHookHelper = null;\n    this.queue = [];\n    this.addHooks = [];\n    this.uploadHooks = [];\n    this.completes = [];\n    this.ticking = false;\n    this.delayedTick = function () {\n      // unlikely, but in case we were destroyed between tick() and delayedTick()\n      if (!_this.queue) {\n        return;\n      }\n      _this.prepareItems();\n    };\n    // hooks to find the correct texture\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture);\n    // upload hooks\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  /** @ignore */\n  BasePrepare.prototype.upload = function (item, done) {\n    var _this = this;\n    if (typeof item === 'function') {\n      done = item;\n      item = null;\n    }\n    if (done) {\n      utils.deprecation('6.5.0', 'BasePrepare.upload callback is deprecated, use the return Promise instead.');\n    }\n    return new Promise(function (resolve) {\n      // If a display object, search for items\n      // that we could upload\n      if (item) {\n        _this.add(item);\n      }\n      // TODO: remove done callback and just use resolve\n      var complete = function complete() {\n        done === null || done === void 0 ? void 0 : done();\n        resolve();\n      };\n      // Get the items for upload from the display\n      if (_this.queue.length) {\n        _this.completes.push(complete);\n        if (!_this.ticking) {\n          _this.ticking = true;\n          ticker.Ticker.system.addOnce(_this.tick, _this, ticker.UPDATE_PRIORITY.UTILITY);\n        }\n      } else {\n        complete();\n      }\n    });\n  };\n  /**\n   * Handle tick update\n   * @private\n   */\n  BasePrepare.prototype.tick = function () {\n    setTimeout(this.delayedTick, 0);\n  };\n  /**\n   * Actually prepare items. This is handled outside of the tick because it will take a while\n   * and we do NOT want to block the current animation frame from rendering.\n   * @private\n   */\n  BasePrepare.prototype.prepareItems = function () {\n    this.limiter.beginFrame();\n    // Upload the graphics\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      var item = this.queue[0];\n      var uploaded = false;\n      if (item && !item._destroyed) {\n        for (var i = 0, len = this.uploadHooks.length; i < len; i++) {\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    }\n    // We're finished\n    if (!this.queue.length) {\n      this.ticking = false;\n      var completes = this.completes.slice(0);\n      this.completes.length = 0;\n      for (var i = 0, len = completes.length; i < len; i++) {\n        completes[i]();\n      }\n    } else {\n      // if we are not finished, on the next rAF do this again\n      ticker.Ticker.system.addOnce(this.tick, this, ticker.UPDATE_PRIORITY.UTILITY);\n    }\n  };\n  /**\n   * Adds hooks for finding items.\n   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n   *          function must return `true` if it was able to add item to the queue.\n   * @returns Instance of plugin for chaining.\n   */\n  BasePrepare.prototype.registerFindHook = function (addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n    return this;\n  };\n  /**\n   * Adds hooks for uploading items.\n   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n   *          function must return `true` if it was able to handle upload of item.\n   * @returns Instance of plugin for chaining.\n   */\n  BasePrepare.prototype.registerUploadHook = function (uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n    return this;\n  };\n  /**\n   * Manually add an item to the uploading queue.\n   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n   *        add to the queue\n   * @returns Instance of plugin for chaining.\n   */\n  BasePrepare.prototype.add = function (item) {\n    // Add additional hooks for finding elements on special\n    // types of objects that\n    for (var i = 0, len = this.addHooks.length; i < len; i++) {\n      if (this.addHooks[i](item, this.queue)) {\n        break;\n      }\n    }\n    // Get children recursively\n    if (item instanceof display.Container) {\n      for (var i = item.children.length - 1; i >= 0; i--) {\n        this.add(item.children[i]);\n      }\n    }\n    return this;\n  };\n  /** Destroys the plugin, don't use after this. */\n  BasePrepare.prototype.destroy = function () {\n    if (this.ticking) {\n      ticker.Ticker.system.remove(this.tick, this);\n    }\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  };\n  return BasePrepare;\n}();\n\n/**\n * Built-in hook to upload PIXI.Texture objects to the GPU.\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadBaseTextures(renderer, item) {\n  if (item instanceof core.BaseTexture) {\n    // if the texture already has a GL texture, then the texture has been prepared or rendered\n    // before now. If the texture changed, then the changer should be calling texture.update() which\n    // reuploads the texture without need for preparing it again\n    if (!item._glTextures[renderer.CONTEXT_UID]) {\n      renderer.texture.bind(item);\n    }\n    return true;\n  }\n  return false;\n}\n/**\n * Built-in hook to upload PIXI.Graphics to the GPU.\n * @private\n * @param renderer - instance of the webgl renderer\n * @param item - Item to check\n * @returns If item was uploaded.\n */\nfunction uploadGraphics(renderer, item) {\n  if (!(item instanceof graphics.Graphics)) {\n    return false;\n  }\n  var geometry = item.geometry;\n  // update dirty graphics to get batches\n  item.finishPoly();\n  geometry.updateBatches();\n  var batches = geometry.batches;\n  // upload all textures found in styles\n  for (var i = 0; i < batches.length; i++) {\n    var texture = batches[i].style.texture;\n    if (texture) {\n      uploadBaseTextures(renderer, texture.baseTexture);\n    }\n  }\n  // if its not batchable - update vao for particular shader\n  if (!geometry.batchable) {\n    renderer.geometry.bind(geometry, item._resolveDirectShader(renderer));\n  }\n  return true;\n}\n/**\n * Built-in hook to find graphics.\n * @private\n * @param item - Display object to check\n * @param queue - Collection of items to upload\n * @returns if a PIXI.Graphics object was found.\n */\nfunction findGraphics(item, queue) {\n  if (item instanceof graphics.Graphics) {\n    queue.push(item);\n    return true;\n  }\n  return false;\n}\n/**\n * The prepare plugin provides renderer-specific plugins for pre-rendering DisplayObjects. These plugins are useful for\n * asynchronously preparing and uploading to the GPU assets, textures, graphics waiting to be displayed.\n *\n * Do not instantiate this plugin directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new application\n * const app = new PIXI.Application();\n * document.body.appendChild(app.view);\n *\n * // Don't start rendering right away\n * app.stop();\n *\n * // create a display object\n * const rect = new PIXI.Graphics()\n *     .beginFill(0x00ff00)\n *     .drawRect(40, 40, 200, 200);\n *\n * // Add to the stage\n * app.stage.addChild(rect);\n *\n * // Don't start rendering until the graphic is uploaded to the GPU\n * app.renderer.plugins.prepare.upload(app.stage, () => {\n *     app.start();\n * });\n * @memberof PIXI\n */\nvar Prepare = /** @class */function (_super) {\n  __extends(Prepare, _super);\n  /**\n   * @param {PIXI.Renderer} renderer - A reference to the current renderer\n   */\n  function Prepare(renderer) {\n    var _this = _super.call(this, renderer) || this;\n    _this.uploadHookHelper = _this.renderer;\n    // Add textures and graphics to upload\n    _this.registerFindHook(findGraphics);\n    _this.registerUploadHook(uploadBaseTextures);\n    _this.registerUploadHook(uploadGraphics);\n    return _this;\n  }\n  /** @ignore */\n  Prepare.extension = {\n    name: 'prepare',\n    type: core.ExtensionType.RendererPlugin\n  };\n  return Prepare;\n}(BasePrepare);\n\n/**\n * TimeLimiter limits the number of items handled by a {@link PIXI.BasePrepare} to a specified\n * number of milliseconds per frame.\n * @memberof PIXI\n */\nvar TimeLimiter = /** @class */function () {\n  /** @param maxMilliseconds - The maximum milliseconds that can be spent preparing items each frame. */\n  function TimeLimiter(maxMilliseconds) {\n    this.maxMilliseconds = maxMilliseconds;\n    this.frameStart = 0;\n  }\n  /** Resets any counting properties to start fresh on a new frame. */\n  TimeLimiter.prototype.beginFrame = function () {\n    this.frameStart = Date.now();\n  };\n  /**\n   * Checks to see if another item can be uploaded. This should only be called once per item.\n   * @returns - If the item is allowed to be uploaded.\n   */\n  TimeLimiter.prototype.allowedToUpload = function () {\n    return Date.now() - this.frameStart < this.maxMilliseconds;\n  };\n  return TimeLimiter;\n}();\nexports.BasePrepare = BasePrepare;\nexports.CountLimiter = CountLimiter;\nexports.Prepare = Prepare;\nexports.TimeLimiter = TimeLimiter;","map":null,"metadata":{},"sourceType":"script"}