{"ast":null,"code":"import _regeneratorRuntime from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { utils } from '@pixi/core';\nimport '../utils/index.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nvar Loader = /*#__PURE__*/function () {\n  function Loader() {\n    _classCallCheck(this, Loader);\n    this._parsers = [];\n    this.promiseCache = {};\n  }\n  _createClass(Loader, [{\n    key: \"reset\",\n    value: function reset() {\n      this.promiseCache = {};\n    }\n  }, {\n    key: \"_getLoadPromiseAndParser\",\n    value: function _getLoadPromiseAndParser(url, data) {\n      var _this = this;\n      var result = {\n        promise: null,\n        parser: null\n      };\n      result.promise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var asset, i, _parser$test, parser, _i, _parser, _parser$testParse;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                asset = null;\n                i = 0;\n              case 2:\n                if (!(i < _this.parsers.length)) {\n                  _context.next = 13;\n                  break;\n                }\n                parser = _this.parsers[i];\n                if (!(parser.load && (_parser$test = parser.test) !== null && _parser$test !== void 0 && _parser$test.call(parser, url, data, _this))) {\n                  _context.next = 10;\n                  break;\n                }\n                _context.next = 7;\n                return parser.load(url, data, _this);\n              case 7:\n                asset = _context.sent;\n                result.parser = parser;\n                return _context.abrupt(\"break\", 13);\n              case 10:\n                i++;\n                _context.next = 2;\n                break;\n              case 13:\n                if (result.parser) {\n                  _context.next = 15;\n                  break;\n                }\n                return _context.abrupt(\"return\", null);\n              case 15:\n                _i = 0;\n              case 16:\n                if (!(_i < _this.parsers.length)) {\n                  _context.next = 35;\n                  break;\n                }\n                _parser = _this.parsers[_i];\n                if (!_parser.parse) {\n                  _context.next = 32;\n                  break;\n                }\n                _context.t0 = _parser.parse;\n                if (!_context.t0) {\n                  _context.next = 24;\n                  break;\n                }\n                _context.next = 23;\n                return (_parser$testParse = _parser.testParse) === null || _parser$testParse === void 0 ? void 0 : _parser$testParse.call(_parser, asset, data, _this);\n              case 23:\n                _context.t0 = _context.sent;\n              case 24:\n                if (!_context.t0) {\n                  _context.next = 32;\n                  break;\n                }\n                _context.next = 27;\n                return _parser.parse(asset, data, _this);\n              case 27:\n                _context.t1 = _context.sent;\n                if (_context.t1) {\n                  _context.next = 30;\n                  break;\n                }\n                _context.t1 = asset;\n              case 30:\n                asset = _context.t1;\n                result.parser = _parser;\n              case 32:\n                _i++;\n                _context.next = 16;\n                break;\n              case 35:\n                return _context.abrupt(\"return\", asset);\n              case 36:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n      return result;\n    }\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(assetsToLoadIn, onProgress) {\n        var _this2 = this;\n        var count, assets, singleAsset, assetsToLoad, total, promises;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                count = 0;\n                assets = {};\n                singleAsset = isSingleItem(assetsToLoadIn);\n                assetsToLoad = convertToList(assetsToLoadIn, function (item) {\n                  return {\n                    src: item\n                  };\n                });\n                total = assetsToLoad.length;\n                promises = assetsToLoad.map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(asset) {\n                    var url;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            url = utils.path.toAbsolute(asset.src);\n                            if (assets[asset.src]) {\n                              _context2.next = 15;\n                              break;\n                            }\n                            _context2.prev = 2;\n                            if (!_this2.promiseCache[url]) {\n                              _this2.promiseCache[url] = _this2._getLoadPromiseAndParser(url, asset);\n                            }\n                            _context2.next = 6;\n                            return _this2.promiseCache[url].promise;\n                          case 6:\n                            assets[asset.src] = _context2.sent;\n                            if (onProgress) onProgress(++count / total);\n                            _context2.next = 15;\n                            break;\n                          case 10:\n                            _context2.prev = 10;\n                            _context2.t0 = _context2[\"catch\"](2);\n                            delete _this2.promiseCache[url];\n                            delete assets[asset.src];\n                            throw new Error(\"[Loader.load] Failed to load \".concat(url, \".\\n\").concat(_context2.t0));\n                          case 15:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, null, [[2, 10]]);\n                  }));\n                  return function (_x3) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n                _context3.next = 8;\n                return Promise.all(promises);\n              case 8:\n                return _context3.abrupt(\"return\", singleAsset ? assets[assetsToLoad[0].src] : assets);\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function load(_x, _x2) {\n        return _load.apply(this, arguments);\n      }\n      return load;\n    }()\n  }, {\n    key: \"unload\",\n    value: function () {\n      var _unload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(assetsToUnloadIn) {\n        var _this3 = this;\n        var assetsToUnload, promises;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                assetsToUnload = convertToList(assetsToUnloadIn, function (item) {\n                  return {\n                    src: item\n                  };\n                });\n                promises = assetsToUnload.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(asset) {\n                    var url, loadPromise, _loadPromise$parser, _loadPromise$parser$u, loadedAsset;\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            url = utils.path.toAbsolute(asset.src);\n                            loadPromise = _this3.promiseCache[url];\n                            if (!loadPromise) {\n                              _context4.next = 8;\n                              break;\n                            }\n                            _context4.next = 5;\n                            return loadPromise.promise;\n                          case 5:\n                            loadedAsset = _context4.sent;\n                            (_loadPromise$parser = loadPromise.parser) === null || _loadPromise$parser === void 0 ? void 0 : (_loadPromise$parser$u = _loadPromise$parser.unload) === null || _loadPromise$parser$u === void 0 ? void 0 : _loadPromise$parser$u.call(_loadPromise$parser, loadedAsset, asset, _this3);\n                            delete _this3.promiseCache[url];\n                          case 8:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n                  return function (_x5) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n                _context5.next = 4;\n                return Promise.all(promises);\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      function unload(_x4) {\n        return _unload.apply(this, arguments);\n      }\n      return unload;\n    }()\n  }, {\n    key: \"parsers\",\n    get: function get() {\n      return this._parsers;\n    }\n  }]);\n  return Loader;\n}();\nexport { Loader };","map":{"version":3,"sources":["../../src/loader/Loader.ts"],"names":[],"mappings":"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","sourcesContent":["import { utils } from '@pixi/core';\nimport { convertToList, isSingleItem } from '../utils';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser, LoadAsset } from './types';\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @memberof PIXI\n * @class AssetLoader\n */\nexport class Loader\n{\n    private _parsers: LoaderParser[] = [];\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: LoadAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.load && parser.test?.(url, data, this))\n                {\n                    asset = await parser.load(url, data, this);\n                    result.parser = parser;\n\n                    break;\n                }\n            }\n\n            if (!result.parser)\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`);\n                // #endif\n\n                return null;\n            }\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - a function that gets called when the progress changes\n     */\n    public async load(\n        assetsToLoadIn: string | string[] | LoadAsset | LoadAsset[],\n        onProgress?: (progress: number) => void,\n    ): Promise<{[key: string]: any} | any>\n    {\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<LoadAsset>(assetsToLoadIn, (item) => ({\n            src: item,\n        }));\n\n        const total = assetsToLoad.length;\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            if (!assets[asset.src])\n            {\n                try\n                {\n                    if (!this.promiseCache[url])\n                    {\n                        this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                    }\n\n                    assets[asset.src] = await this.promiseCache[url].promise;\n\n                    // Only progress if nothing goes wrong\n                    if (onProgress) onProgress(++count / total);\n                }\n                catch (e)\n                {\n                    // Delete eventually registered file and promises from internal cache\n                    // so they can be eligible for another loading attempt\n                    delete this.promiseCache[url];\n                    delete assets[asset.src];\n\n                    // Stop further execution\n                    throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n                }\n            }\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | LoadAsset | LoadAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<LoadAsset>(assetsToUnloadIn, (item) => ({\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: LoadAsset) =>\n        {\n            const url = utils.path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                loadPromise.parser?.unload?.(loadedAsset, asset, this);\n\n                delete this.promiseCache[url];\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** All loader parsers registered */\n    public get parsers(): LoaderParser[]\n    {\n        return this._parsers;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}