{"ast":null,"code":"var backslash = require('backslash');\nmodule.exports = {\n  validate: validate,\n  parse: parse\n};\n\n/**\n * Validates a json string.\n * Errors are returned\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {String} error. undefined if no error\n */\nfunction validate(jsonString, allowDuplicatedKeys) {\n  var error;\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n  if (typeof jsonString !== 'string') {\n    error = 'Input must be a string';\n  } else {\n    try {\n      // Try to find a value starting from index 0\n      _findValue(jsonString, 0, allowDuplicatedKeys, false);\n    } catch (e) {\n      error = e.message;\n    }\n  }\n  return error;\n}\n\n/**\n * Parses a json. Errors are thrown if any\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {Object}\n */\nfunction parse(jsonString, allowDuplicatedKeys) {\n  if (typeof jsonString !== 'string') {\n    throw new Error('Input must be a string');\n  }\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n\n  // Try to find a value starting from index 0\n  var value = _findValue(jsonString, 0, allowDuplicatedKeys, true);\n  return value.value;\n}\n\n/**\n * Find the comma separator, ], } or end of file\n * @param {String} str - original json string\n * @param {Number} startInd - starting index\n * @returns {{start: Number, end: Number, value: String}} value: the separator found\n * @private\n */\nfunction _findSeparator(str, startInd) {\n  var len = str.length;\n  var sepStartInd = startInd;\n  var sepEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ',') {\n      sepEndInd = i;\n      break;\n    } else if (ch === ']' || ch === '}') {\n      sepEndInd = i - 1;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting end of expression or separator');\n    }\n  }\n  var value;\n  if (sepEndInd === undefined) {\n    sepEndInd = len;\n    value = str[sepEndInd];\n  } else {\n    value = str[sepEndInd];\n    sepEndInd++;\n  }\n  return {\n    start: sepStartInd,\n    end: sepEndInd,\n    value: value\n  };\n}\n\n/**\n * Find the semi-colon separator ':'\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number}}\n * @private\n */\nfunction _findSemiColonSeparator(str, startInd) {\n  var len = str.length;\n  var semiColStartInd = startInd;\n  var semiColEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ':') {\n      semiColEndInd = i;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting \\':\\'');\n    }\n  }\n  if (semiColEndInd === undefined) {\n    throw _syntaxError(str, i, 'expecting \\':\\'');\n  }\n  semiColEndInd++;\n  return {\n    start: semiColStartInd,\n    end: semiColEndInd\n  };\n}\n\n/**\n * Find a value it can be number, array, object, strings or boolean\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not\n * @returns {{value: *, start: Number, end: Number}}\n * @private\n */\nfunction _findValue(str, startInd, allowDuplicatedKeys, parse) {\n  var len = str.length;\n  var valueStartInd;\n  var valueEndInd;\n  var isArray = false;\n  var isObject = false;\n  var isString = false;\n  var isNumber = false;\n  var dotFound = false;\n  var whiteSpaceInNumber = false;\n  var value;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (valueStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch === '[') {\n          isArray = true;\n        } else if (ch === '{') {\n          isObject = true;\n        } else if (ch === '\"') {\n          isString = true;\n        } else if (_isTrueFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = true;\n          break;\n        } else if (_isFalseFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 4;\n          valueEndInd = i;\n          value = false;\n          break;\n        } else if (_isNullFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = null;\n          break;\n        } else if (_isNumber(ch)) {\n          isNumber = true;\n        } else if (ch === '-') {\n          isNumber = true;\n        } else {\n          throw _syntaxError(str, i, '');\n        }\n        valueStartInd = i;\n      }\n    } else {\n      if (isArray) {\n        var arr = _findArray(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = arr.end;\n        value = arr.value;\n        break;\n      } else if (isObject) {\n        var obj = _findObject(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = obj.end;\n        value = obj.value;\n        break;\n      } else if (isString && ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        valueEndInd = i;\n        value = backslash(str.substring(valueStartInd + 1, valueEndInd));\n        break;\n      } else if (isNumber) {\n        if (_isWhiteSpace(ch)) {\n          whiteSpaceInNumber = true;\n        } else if (ch === ',' || ch === ']' || ch === '}') {\n          value = parseFloat(str.substring(valueStartInd, valueEndInd), 10);\n          valueEndInd = i - 1;\n          break;\n        } else if (_isNumber(ch) && !whiteSpaceInNumber) {\n          continue;\n        } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {\n          dotFound = true;\n        } else {\n          throw _syntaxError(str, i, 'expecting number');\n        }\n      }\n    }\n  }\n  if (valueEndInd === undefined) {\n    if (isNumber) {\n      value = parseFloat(str.substring(valueStartInd, i), 10);\n      valueEndInd = i - 1;\n    } else {\n      throw _syntaxError(str, i, 'unclosed statement');\n    }\n  }\n  valueEndInd++;\n  return {\n    value: value,\n    start: valueStartInd,\n    end: valueEndInd\n  };\n}\n\n/**\n * Find a key in an object\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: String}}\n * @private\n */\nfunction _findKey(str, startInd) {\n  var len = str.length;\n  var keyStartInd;\n  var keyEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (keyStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch !== '\"') {\n          throw _syntaxError(str, i, 'expecting String');\n        }\n        keyStartInd = i;\n      }\n    } else {\n      if (ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        keyEndInd = i;\n        break;\n      }\n    }\n  }\n  if (keyEndInd === undefined) {\n    throw _syntaxError(str, len, 'expecting String');\n  }\n  var value = backslash(str.substring(keyStartInd + 1, keyEndInd));\n  if (value === '') {\n    throw _syntaxError(str, keyStartInd, 'empty string');\n  }\n  keyEndInd++;\n  return {\n    start: keyStartInd,\n    end: keyEndInd,\n    value: value\n  };\n}\n\n/**\n * Find an object by identifying the key, ':' separator and value\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys\n * @returns {{start: Number, end: Number, value: Object}}\n * @private\n */\nfunction _findObject(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var obj = {};\n  var keys = [];\n  var values = [];\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n  if (str[j] === '}') {\n    return {\n      start: startInd,\n      end: j,\n      value: obj\n    };\n  }\n  while (sepValue === ',') {\n    var key = _findKey(str, i);\n    var semi = _findSemiColonSeparator(str, key.end);\n    var value = _findValue(str, semi.end, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n    if (!allowDuplicatedKeys) {\n      if (keys.indexOf(key.value) !== -1) {\n        key.value = key.value + '1';\n        // throw _syntaxError(str, key.end, 'duplicated keys \"' + key.value + '\"');\n      }\n    }\n\n    keys.push(key.value);\n    values.push(value.value);\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  if (parse) {\n    var indx = 0;\n    for (indx = 0; indx < keys.length; indx++) {\n      obj[keys[indx]] = values[indx];\n    }\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: obj\n  };\n}\n\n/**\n * Going backward from an index, determine if there are even number\n * of consecutive backslashes in the string\n * @param {String} str - original json string\n * @param {Number} endInd\n * @returns {Boolean}\n * @private\n */\nfunction _hasEvenNumberOfBackSlash(str, endInd) {\n  var i = endInd;\n  var count = 0;\n  while (i > -1 && str[i] === '\\\\') {\n    count++;\n    i--;\n  }\n  return count % 2 === 0;\n}\n\n/**\n * Find an array by identifying values separated by ',' separator\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: Array}}\n * @private\n */\nfunction _findArray(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var arr = [];\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n  if (str[j] === ']') {\n    return {\n      start: startInd,\n      end: j,\n      value: arr\n    };\n  }\n  while (sepValue === ',') {\n    var value = _findValue(str, i, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n    if (parse) {\n      arr.push(value.value);\n    }\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: arr\n  };\n}\n\n/**\n * Determine if the string is 'true' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isTrueFromIndex(str, ind) {\n  return str.substr(ind, 4) === 'true';\n}\n\n/**\n * Determine if the string is 'false' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isFalseFromIndex(str, ind) {\n  return str.substr(ind, 5) === 'false';\n}\n\n/**\n * Determine if the string is 'null' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isNullFromIndex(str, ind) {\n  return str.substr(ind, 4) === 'null';\n}\nvar white = new RegExp(/^\\s$/);\n/**\n * Determine if this character is a white space\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isWhiteSpace(ch) {\n  return white.test(ch);\n}\nvar numberReg = new RegExp(/^\\d$/);\n/**\n * Determine if this character is a numeric character\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isNumber(ch) {\n  return numberReg.test(ch);\n}\n\n/**\n * Generate syntax error\n * @param {String} str - original json string\n * @param {Number} index - index in which the error was detected\n * @param {String} reason\n * @returns {Error}\n * @private\n */\nfunction _syntaxError(str, index, reason) {\n  var regionLen = 10;\n  var regionStr;\n  if (str.length < index + regionLen) {\n    regionStr = str.substr(_normalizeNegativeNumber(str.length - regionLen), str.length);\n  } else if (index - regionLen / 2 < 0) {\n    regionStr = str.substr(0, regionLen);\n  } else {\n    regionStr = str.substr(_normalizeNegativeNumber(index - regionLen / 2), regionLen);\n  }\n  var message;\n  if (reason) {\n    message = 'Syntax error: ' + reason + ' near ' + regionStr;\n  } else {\n    message = 'Syntax error near ' + regionStr;\n  }\n  return new Error(message);\n}\n\n/**\n * Return 0 if number is negative, the original number otherwise\n * @param {Number} num\n * @returns {Number}\n * @private\n */\nfunction _normalizeNegativeNumber(num) {\n  return num < 0 ? 0 : num;\n}","map":{"version":3,"names":["backslash","require","module","exports","validate","parse","jsonString","allowDuplicatedKeys","error","_findValue","e","message","Error","value","_findSeparator","str","startInd","len","length","sepStartInd","sepEndInd","i","ch","_isWhiteSpace","_syntaxError","undefined","start","end","_findSemiColonSeparator","semiColStartInd","semiColEndInd","valueStartInd","valueEndInd","isArray","isObject","isString","isNumber","dotFound","whiteSpaceInNumber","_isTrueFromIndex","_isFalseFromIndex","_isNullFromIndex","_isNumber","arr","_findArray","obj","_findObject","_hasEvenNumberOfBackSlash","substring","parseFloat","_findKey","keyStartInd","keyEndInd","sepValue","keys","values","j","key","semi","sepIndex","indexOf","push","indx","endInd","count","ind","substr","white","RegExp","test","numberReg","index","reason","regionLen","regionStr","_normalizeNegativeNumber","num"],"sources":["/Users/merlea/Development/Crypto/Krogan/dapp-issue/node_modules/json-duplicate-key-handle/index.js"],"sourcesContent":["var backslash = require('backslash');\nmodule.exports = {\n  validate: validate,\n  parse: parse\n};\n\n/**\n * Validates a json string.\n * Errors are returned\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {String} error. undefined if no error\n */\nfunction validate(jsonString, allowDuplicatedKeys) {\n  var error;\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n  if (typeof jsonString !== 'string') {\n    error = 'Input must be a string';\n  } else {\n    try {\n      // Try to find a value starting from index 0\n      _findValue(jsonString, 0, allowDuplicatedKeys, false);\n    } catch(e) {\n      error = e.message;\n    }\n  }\n  return error;\n}\n\n/**\n * Parses a json. Errors are thrown if any\n * @param jsonString\n * @param allowDuplicatedKeys\n * @returns {Object}\n */\nfunction parse(jsonString, allowDuplicatedKeys) {\n  if (typeof jsonString !== 'string') {\n    throw new Error('Input must be a string');\n  }\n\n  allowDuplicatedKeys = allowDuplicatedKeys || false;\n\n  // Try to find a value starting from index 0\n  var value = _findValue(jsonString, 0, allowDuplicatedKeys, true);\n  return value.value;\n}\n\n/**\n * Find the comma separator, ], } or end of file\n * @param {String} str - original json string\n * @param {Number} startInd - starting index\n * @returns {{start: Number, end: Number, value: String}} value: the separator found\n * @private\n */\nfunction _findSeparator(str, startInd) {\n  var len = str.length;\n  var sepStartInd = startInd;\n  var sepEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ',') {\n      sepEndInd = i;\n      break;\n    } else if ( ch === ']' || ch === '}') {\n      sepEndInd = i - 1;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting end of expression or separator');\n    }\n  }\n\n  var value;\n  if (sepEndInd === undefined) {\n    sepEndInd = len;\n    value = str[sepEndInd];\n  } else {\n    value = str[sepEndInd];\n    sepEndInd++;\n  }\n  return {\n    start: sepStartInd,\n    end: sepEndInd,\n    value: value\n  };\n}\n\n/**\n * Find the semi-colon separator ':'\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number}}\n * @private\n */\nfunction _findSemiColonSeparator(str, startInd) {\n  var len = str.length;\n  var semiColStartInd = startInd;\n  var semiColEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (ch === ':') {\n      semiColEndInd = i;\n      break;\n    } else if (!_isWhiteSpace(ch)) {\n      throw _syntaxError(str, i, 'expecting \\':\\'');\n    }\n  }\n  if (semiColEndInd === undefined) {\n    throw _syntaxError(str, i, 'expecting \\':\\'');\n  }\n  semiColEndInd++;\n  return {\n    start: semiColStartInd,\n    end: semiColEndInd\n  };\n}\n\n/**\n * Find a value it can be number, array, object, strings or boolean\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys - allow duplicated keys in objects or not\n * @returns {{value: *, start: Number, end: Number}}\n * @private\n */\nfunction _findValue(str, startInd, allowDuplicatedKeys, parse) {\n  var len = str.length;\n  var valueStartInd;\n  var valueEndInd;\n  var isArray = false;\n  var isObject = false;\n  var isString = false;\n  var isNumber = false;\n  var dotFound = false;\n  var whiteSpaceInNumber = false;\n  var value;\n\n  for (var i = startInd; i < len; i++) {\n\n    var ch = str[i];\n    if (valueStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch === '[') {\n          isArray = true;\n        } else if (ch === '{') {\n          isObject = true;\n        } else if (ch === '\"') {\n          isString = true;\n        } else if (_isTrueFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = true;\n          break;\n        } else if (_isFalseFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 4;\n          valueEndInd = i;\n          value = false;\n          break;\n        } else if (_isNullFromIndex(str, i)) {\n          valueStartInd = i;\n          i = i + 3;\n          valueEndInd = i;\n          value = null;\n          break;\n        } else if (_isNumber(ch)) {\n          isNumber = true;\n        } else if (ch === '-') {\n          isNumber = true;\n        } else {\n          throw _syntaxError(str, i, '');\n        }\n        valueStartInd = i;\n      }\n    } else {\n      if (isArray) {\n        var arr = _findArray(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = arr.end;\n        value = arr.value;\n        break;\n      } else if (isObject) {\n        var obj = _findObject(str, i, allowDuplicatedKeys, parse);\n        valueEndInd = obj.end;\n        value = obj.value;\n        break;\n      } else if (isString && ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        valueEndInd = i;\n        value = backslash(str.substring(valueStartInd + 1, valueEndInd));\n        break;\n      } else if (isNumber) {\n        if(_isWhiteSpace(ch)) {\n          whiteSpaceInNumber = true;\n        } else if (ch === ',' || ch === ']' || ch === '}') {\n          value = parseFloat(str.substring(valueStartInd, valueEndInd), 10);\n          valueEndInd = i - 1;\n          break;\n        } else if (_isNumber(ch) && !whiteSpaceInNumber) {\n          continue;\n        } else if (ch === '.' && !dotFound && !whiteSpaceInNumber) {\n          dotFound = true;\n        } else {\n          throw _syntaxError(str, i, 'expecting number');\n        }\n      }\n    }\n  }\n\n  if (valueEndInd === undefined) {\n    if (isNumber) {\n      value = parseFloat(str.substring(valueStartInd, i), 10);\n      valueEndInd = i - 1;\n    } else {\n      throw _syntaxError(str, i, 'unclosed statement');\n    }\n  }\n  valueEndInd++;\n  return {\n    value: value,\n    start: valueStartInd,\n    end: valueEndInd\n  };\n}\n\n/**\n * Find a key in an object\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: String}}\n * @private\n */\nfunction _findKey(str, startInd) {\n  var len = str.length;\n  var keyStartInd;\n  var keyEndInd;\n  for (var i = startInd; i < len; i++) {\n    var ch = str[i];\n    if (keyStartInd === undefined) {\n      if (!_isWhiteSpace(ch)) {\n        if (ch !== '\"') {\n          throw _syntaxError(str, i, 'expecting String');\n        }\n        keyStartInd = i;\n      }\n    } else {\n      if (ch === '\"' && _hasEvenNumberOfBackSlash(str, i - 1)) {\n        keyEndInd = i;\n        break;\n      }\n    }\n  }\n\n  if (keyEndInd === undefined) {\n    throw _syntaxError(str, len, 'expecting String');\n  }\n\n  var value = backslash(str.substring(keyStartInd + 1, keyEndInd));\n  if (value === '') {\n    throw _syntaxError(str, keyStartInd, 'empty string');\n  }\n  keyEndInd++;\n  return {\n    start: keyStartInd,\n    end: keyEndInd,\n    value: value\n  };\n}\n\n/**\n * Find an object by identifying the key, ':' separator and value\n * @param {String} str - original json string\n * @param {Number} startInd\n * @param {Boolean} allowDuplicatedKeys\n * @returns {{start: Number, end: Number, value: Object}}\n * @private\n */\nfunction _findObject(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var obj = {};\n  var keys = [];\n  var values = [];\n\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === '}') {\n    return {\n      start: startInd,\n      end: j,\n      value: obj\n    };\n  }\n\n  while (sepValue === ',') {\n    var key = _findKey(str, i);\n    var semi = _findSemiColonSeparator(str, key.end);\n    var value = _findValue(str, semi.end, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (!allowDuplicatedKeys) {\n      if(keys.indexOf(key.value) !== -1) {\n        key.value = key.value + '1';\n        // throw _syntaxError(str, key.end, 'duplicated keys \"' + key.value + '\"');\n      }\n    }\n    keys.push(key.value);\n    values.push(value.value);\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n\n  if (parse) {\n    var indx = 0;\n    for(indx = 0; indx < keys.length; indx++) {\n      obj[keys[indx]] = values[indx];\n    }\n  }\n\n  return {\n    start: startInd,\n    end: i,\n    value: obj\n  };\n}\n\n/**\n * Going backward from an index, determine if there are even number\n * of consecutive backslashes in the string\n * @param {String} str - original json string\n * @param {Number} endInd\n * @returns {Boolean}\n * @private\n */\nfunction _hasEvenNumberOfBackSlash(str, endInd) {\n  var i = endInd;\n  var count = 0;\n  while(i > -1 && str[i] === '\\\\') {\n    count++;\n    i--;\n  }\n  return (count % 2) === 0;\n}\n\n/**\n * Find an array by identifying values separated by ',' separator\n * @param {String} str - original json string\n * @param {Number} startInd\n * @returns {{start: Number, end: Number, value: Array}}\n * @private\n */\nfunction _findArray(str, startInd, allowDuplicatedKeys, parse) {\n  var i = startInd;\n  var sepValue = ',';\n  var arr = [];\n\n  var j = startInd;\n  while (_isWhiteSpace(str[j])) {\n    j++;\n  }\n\n  if (str[j] === ']') {\n    return {\n      start: startInd,\n      end: j,\n      value: arr\n    };\n  }\n\n  while (sepValue === ',') {\n    var value = _findValue(str, i, allowDuplicatedKeys, parse);\n    var sepIndex = _findSeparator(str, value.end);\n\n    if (parse) {\n      arr.push(value.value);\n    }\n    i = sepIndex.end;\n    sepValue = sepIndex.value;\n  }\n  return {\n    start: startInd,\n    end: i,\n    value: arr\n  };\n}\n\n/**\n * Determine if the string is 'true' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isTrueFromIndex(str, ind) {\n  return (str.substr(ind, 4) === 'true');\n}\n\n/**\n * Determine if the string is 'false' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isFalseFromIndex(str, ind) {\n  return (str.substr(ind, 5) === 'false');\n}\n\n/**\n * Determine if the string is 'null' from specified index\n * @param {String} str - original json string\n * @param {Number} ind\n * @returns {Boolean}\n * @private\n */\nfunction _isNullFromIndex(str, ind) {\n  return (str.substr(ind, 4) === 'null');\n}\n\nvar white = new RegExp(/^\\s$/);\n/**\n * Determine if this character is a white space\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isWhiteSpace(ch){\n  return white.test(ch);\n}\n\nvar numberReg = new RegExp(/^\\d$/);\n/**\n * Determine if this character is a numeric character\n * @param {String} ch - single character string\n * @returns {Boolean}\n * @private\n */\nfunction _isNumber(ch) {\n  return numberReg.test(ch);\n}\n\n/**\n * Generate syntax error\n * @param {String} str - original json string\n * @param {Number} index - index in which the error was detected\n * @param {String} reason\n * @returns {Error}\n * @private\n */\nfunction _syntaxError(str, index, reason) {\n  var regionLen = 10;\n\n  var regionStr;\n  if (str.length < index + regionLen) {\n    regionStr = str.substr(_normalizeNegativeNumber(str.length - regionLen), str.length);\n  } else if (index - (regionLen/2) < 0) {\n    regionStr = str.substr(0, regionLen);\n  } else {\n    regionStr = str.substr(_normalizeNegativeNumber(index - (regionLen/2)), regionLen);\n  }\n\n  var message;\n  if (reason) {\n    message = 'Syntax error: ' + reason + ' near ' + regionStr;\n  } else {\n    message = 'Syntax error near ' + regionStr;\n  }\n  return new Error(message);\n}\n\n/**\n * Return 0 if number is negative, the original number otherwise\n * @param {Number} num\n * @returns {Number}\n * @private\n */\nfunction _normalizeNegativeNumber(num) {\n  return (num < 0) ? 0 : num;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}