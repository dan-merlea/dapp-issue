{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _toConsumableArray = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/merlea/Development/Crypto/Krogan/kroganverse-com/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\nvar reflection_1 = require(\"../../reflection\");\nvar utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\nvar Type = /*#__PURE__*/function () {\n  function Type(name) {\n    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n    _classCallCheck(this, Type);\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n  _createClass(Type, [{\n    key: \"getName\",\n    value: function getName() {\n      return this.name;\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return Type.ClassName;\n    }\n  }, {\n    key: \"getClassHierarchy\",\n    value: function getClassHierarchy() {\n      var prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, function (prototype) {\n        return prototype.belongsToTypesystem;\n      });\n      var classNames = prototypes.map(function (prototype) {\n        return prototype.getClassName();\n      }).reverse();\n      return classNames;\n    }\n    /**\n     * Gets the fully qualified name of the type, to allow for better (efficient and non-ambiguous) type comparison within erdjs' typesystem.\n     */\n  }, {\n    key: \"getFullyQualifiedName\",\n    value: function getFullyQualifiedName() {\n      var joinedTypeParameters = this.getTypeParameters().map(function (type) {\n        return type.getFullyQualifiedName();\n      }).join(\", \");\n      return this.isGenericType() ? \"erdjs:types:\".concat(this.getName(), \"<\").concat(joinedTypeParameters, \">\") : \"erdjs:types:\".concat(this.getName());\n    }\n  }, {\n    key: \"hasExactClass\",\n    value: function hasExactClass(className) {\n      return this.getClassName() == className;\n    }\n  }, {\n    key: \"hasClassOrSuperclass\",\n    value: function hasClassOrSuperclass(className) {\n      var hierarchy = this.getClassHierarchy();\n      return hierarchy.includes(className);\n    }\n  }, {\n    key: \"getTypeParameters\",\n    value: function getTypeParameters() {\n      return this.typeParameters;\n    }\n  }, {\n    key: \"isGenericType\",\n    value: function isGenericType() {\n      return this.typeParameters.length > 0;\n    }\n  }, {\n    key: \"getFirstTypeParameter\",\n    value: function getFirstTypeParameter() {\n      utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n      return this.typeParameters[0];\n    }\n    /**\n     * Generates type expressions similar to elrond-wasm-rs.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var typeParameters = this.getTypeParameters().map(function (type) {\n        return type.toString();\n      }).join(\", \");\n      var typeParametersExpression = typeParameters ? \"<\".concat(typeParameters, \">\") : \"\";\n      return \"\".concat(this.name).concat(typeParametersExpression);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return Type.equals(this, other);\n    }\n  }, {\n    key: \"differs\",\n    value: function differs(other) {\n      return !this.equals(other);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.name;\n    }\n    /**\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n     *\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n     * For example, Option<u32> is assignable from Option<?>.\n     * For more details, see the implementation of {@link OptionType} and @{@link OptionalType}.\n     *\n     * Also see:\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n     */\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(other) {\n      var invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), other.getTypeParameters());\n      if (!invariantTypeParameters) {\n        return false;\n      }\n      var fullyQualifiedNameOfThis = this.getFullyQualifiedName();\n      var fullyQualifiedNamesInHierarchyOfOther = Type.getFullyQualifiedNamesInHierarchy(other);\n      if (fullyQualifiedNamesInHierarchyOfOther.includes(fullyQualifiedNameOfThis)) {\n        return true;\n      }\n      return other.hasClassOrSuperclass(this.getClassName());\n    }\n  }, {\n    key: \"getNamesOfDependencies\",\n    value: function getNamesOfDependencies() {\n      var dependencies = [];\n      var _iterator = _createForOfIteratorHelper(this.typeParameters),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var type = _step.value;\n          dependencies.push(type.getName());\n          dependencies.push.apply(dependencies, _toConsumableArray(type.getNamesOfDependencies()));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return _toConsumableArray(new Set(dependencies));\n    }\n    /**\n     * Converts the account to a pretty, plain JavaScript object.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        typeParameters: this.typeParameters.map(function (item) {\n          return item.toJSON();\n        })\n      };\n    }\n  }, {\n    key: \"getCardinality\",\n    value: function getCardinality() {\n      return this.cardinality;\n    }\n    /**\n     * A special marker for types within erdjs' typesystem.\n     */\n  }, {\n    key: \"belongsToTypesystem\",\n    value: function belongsToTypesystem() {}\n  }], [{\n    key: \"equals\",\n    value: function equals(a, b) {\n      return a.getFullyQualifiedName() == b.getFullyQualifiedName();\n    }\n  }, {\n    key: \"equalsMany\",\n    value: function equalsMany(a, b) {\n      return a.every(function (type, i) {\n        return type.equals(b[i]);\n      });\n    }\n  }, {\n    key: \"isAssignableFromMany\",\n    value: function isAssignableFromMany(a, b) {\n      return a.every(function (type, i) {\n        return type.isAssignableFrom(b[i]);\n      });\n    }\n  }, {\n    key: \"getFullyQualifiedNamesInHierarchy\",\n    value: function getFullyQualifiedNamesInHierarchy(type) {\n      var prototypes = reflection_1.getJavascriptPrototypesInHierarchy(type, function (prototype) {\n        return prototype.belongsToTypesystem;\n      });\n      var fullyQualifiedNames = prototypes.map(function (prototype) {\n        return prototype.getFullyQualifiedName.call(type);\n      });\n      return fullyQualifiedNames;\n    }\n  }]);\n  return Type;\n}();\nexports.Type = Type;\nType.ClassName = \"Type\";\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\nvar TypeCardinality = /*#__PURE__*/function () {\n  function TypeCardinality(lowerBound, upperBound) {\n    _classCallCheck(this, TypeCardinality);\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n  _createClass(TypeCardinality, [{\n    key: \"isSingular\",\n    value: function isSingular() {\n      return this.lowerBound == 1 && this.upperBound == 1;\n    }\n  }, {\n    key: \"isSingularOrNone\",\n    value: function isSingularOrNone() {\n      return this.lowerBound == 0 && this.upperBound == 1;\n    }\n  }, {\n    key: \"isComposite\",\n    value: function isComposite() {\n      return this.upperBound != 1;\n    }\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.lowerBound == this.upperBound;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.lowerBound;\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      return this.upperBound || TypeCardinality.MaxCardinality;\n    }\n  }], [{\n    key: \"fixed\",\n    value: function fixed(value) {\n      return new TypeCardinality(value, value);\n    }\n  }, {\n    key: \"variable\",\n    value: function variable(value) {\n      return new TypeCardinality(0, value);\n    }\n  }]);\n  return TypeCardinality;\n}();\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\nTypeCardinality.MaxCardinality = 4096;\nvar PrimitiveType = /*#__PURE__*/function (_Type) {\n  _inherits(PrimitiveType, _Type);\n  var _super = _createSuper(PrimitiveType);\n  function PrimitiveType(name) {\n    _classCallCheck(this, PrimitiveType);\n    return _super.call(this, name);\n  }\n  _createClass(PrimitiveType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return PrimitiveType.ClassName;\n    }\n  }]);\n  return PrimitiveType;\n}(Type);\nexports.PrimitiveType = PrimitiveType;\nPrimitiveType.ClassName = \"PrimitiveType\";\nvar CustomType = /*#__PURE__*/function (_Type2) {\n  _inherits(CustomType, _Type2);\n  var _super2 = _createSuper(CustomType);\n  function CustomType() {\n    _classCallCheck(this, CustomType);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(CustomType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return CustomType.ClassName;\n    }\n  }]);\n  return CustomType;\n}(Type);\nexports.CustomType = CustomType;\nCustomType.ClassName = \"CustomType\";\nvar TypedValue = /*#__PURE__*/function () {\n  function TypedValue(type) {\n    _classCallCheck(this, TypedValue);\n    this.type = type;\n  }\n  _createClass(TypedValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return TypedValue.ClassName;\n    }\n  }, {\n    key: \"getClassHierarchy\",\n    value: function getClassHierarchy() {\n      var prototypes = reflection_1.getJavascriptPrototypesInHierarchy(this, function (prototype) {\n        return prototype.belongsToTypesystem;\n      });\n      var classNames = prototypes.map(function (prototype) {\n        return prototype.getClassName();\n      }).reverse();\n      return classNames;\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this.type;\n    }\n  }, {\n    key: \"hasExactClass\",\n    value: function hasExactClass(className) {\n      return this.getClassName() == className;\n    }\n  }, {\n    key: \"hasClassOrSuperclass\",\n    value: function hasClassOrSuperclass(className) {\n      var hierarchy = this.getClassHierarchy();\n      return hierarchy.includes(className);\n    }\n    /**\n     * A special marker for values within erdjs' typesystem.\n     */\n  }, {\n    key: \"belongsToTypesystem\",\n    value: function belongsToTypesystem() {}\n  }]);\n  return TypedValue;\n}();\nexports.TypedValue = TypedValue;\nTypedValue.ClassName = \"TypedValue\";\nvar PrimitiveValue = /*#__PURE__*/function (_TypedValue) {\n  _inherits(PrimitiveValue, _TypedValue);\n  var _super3 = _createSuper(PrimitiveValue);\n  function PrimitiveValue(type) {\n    _classCallCheck(this, PrimitiveValue);\n    return _super3.call(this, type);\n  }\n  _createClass(PrimitiveValue, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return PrimitiveValue.ClassName;\n    }\n  }]);\n  return PrimitiveValue;\n}(TypedValue);\nexports.PrimitiveValue = PrimitiveValue;\nPrimitiveValue.ClassName = \"PrimitiveValue\";\nfunction isTyped(value) {\n  return value.belongsToTypesystem !== undefined;\n}\nexports.isTyped = isTyped;\nvar TypePlaceholder = /*#__PURE__*/function (_Type3) {\n  _inherits(TypePlaceholder, _Type3);\n  var _super4 = _createSuper(TypePlaceholder);\n  function TypePlaceholder() {\n    _classCallCheck(this, TypePlaceholder);\n    return _super4.call(this, \"...\");\n  }\n  _createClass(TypePlaceholder, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return TypePlaceholder.ClassName;\n    }\n  }]);\n  return TypePlaceholder;\n}(Type);\nexports.TypePlaceholder = TypePlaceholder;\nTypePlaceholder.ClassName = \"TypePlaceholder\";\nvar NullType = /*#__PURE__*/function (_Type4) {\n  _inherits(NullType, _Type4);\n  var _super5 = _createSuper(NullType);\n  function NullType() {\n    _classCallCheck(this, NullType);\n    return _super5.call(this, \"?\");\n  }\n  _createClass(NullType, [{\n    key: \"getClassName\",\n    value: function getClassName() {\n      return NullType.ClassName;\n    }\n  }]);\n  return NullType;\n}(Type);\nexports.NullType = NullType;\nNullType.ClassName = \"NullType\";","map":null,"metadata":{},"sourceType":"script"}